<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Adobe&reg; Flash&reg; Platform용 ActionScript&reg; 3.0 참조 설명서"><meta name="lang" content="ko-kr"><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"><link rel="stylesheet" href="asfilter.css" type="text/css"><link rel="stylesheet" href="ion.css" type="text/css"><title>명령문, 키워드 및 지시문 - Adobe ActionScript&reg; 3 (AS3 ) API 참조 설명서</title>
		<link rel="stylesheet" href="filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="filter_new.css" type="text/css">
			
		<script src="jquery.js" type="text/javascript"></script>
		<script src="s_chl_code.js" type="text/javascript"></script>
		<script src="jquery.zclip.js" type="text/javascript"></script>
		<script src="jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="cookies.js" type="text/javascript"></script>
		<script src="asdoc.js" type="text/javascript"></script>
		<script src="iscroll.js" type="text/javascript"></script>
		<script src="AC_OETags.js" type="text/javascript"></script>
		<script src="omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "런타임";
			var productsLabel = "제품";
			var noneLabel = "없음";
			var qsearchBoxLabel = "빠른 검색";
			var qsearchText = "찾을 수 없는 용어";
			var ajaxErrorMsg="페이지 불러오기 오류";
			var ajaxErrorTryMsg="다시 시도";
			var ajaxLoadingMsg="불러오는 중";
			var cancelMsg = "취소";
			var classesText = "클래스";
			var strJiveReply = "이 질문은 다음 문서에 대응하여 제출되었습니다. "
			var showFilters = "필터 표시";
			var hideFilters = "필터 숨기기";
			
		
			var baseRef = "./";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform용 ActionScript<sup>&reg;</sup> 3.0 참조 설명서<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="index.html"> 홈 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="statements.html#top" style="display:">패키지 및 클래스 목록 표시</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="statements.html#top" style="display:none">패키지 및 클래스 목록 숨기기</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="package-summary.html"> 패키지 </a>&nbsp;|&nbsp;
												<a target="_self" href="class-summary.html"> 클래스 </a>&nbsp;|&nbsp;
												<a target="_self" href="whatsnew.html"> 새로운 내용 </a>&nbsp;|&nbsp;
												<a target="_self" href="all-index-Symbols.html"> 색인 </a>&nbsp;|&nbsp;
												<a target="_self" href="appendixes.html"> 부록 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">영어로 표시되는 이유</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ko_KR/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('./')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('./')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="help.js"></script>
						<script language="javascript" type="text/javascript" src="asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>필터:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="statements.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">&nbsp;</a><br>
								<h1 id="classProductName">명령문, 키워드 및 지시문&nbsp;</h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="statements.html#propertySummary" style="display:none"> 속성 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 속성 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 생성자 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="statements.html#methodSummary" style="display:none"> 메서드 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="statements.html#constantSummary" style="display:none"> 전역 상수 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="statements.html#eventSummary" style="display:none"> 이벤트 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="statements.html#styleSummary" style="display:none"> 스타일 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="statements.html#SkinPartSummary" style="display:none"> 스킨 파트 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="statements.html#SkinStateSummary" style="display:none"> 스킨 상태 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="statements.html#effectSummary" style="display:none"> 효과 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="statements.html#constantSummary" style="display:none"> 상수 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="statements.html#methodSummary" style="display:none"> 전역 함수 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="statements.html#methodSummary" style="display:none">함수</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="statements.html#interfaceSummary" style="display:none"> 인터페이스 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="statements.html#classSummary" style="display:none"> 클래스 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="statements.html#includeExamplesSummary" style="display:none"> 예제 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="statements.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								클래스
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><p>명령문은 런타임에 액션을 수행하거나 지정하는 언어 요소입니다. 예를 들어, <code>return</code> 문은 실행 함수에 대한 결과 값을 반환합니다. <code>if</code> 문은 다음으로 수행해야 할 액션을 결정하는 조건을 평가합니다. <code>switch</code> 문은 ActionScript 명령문의 분기 구조를 만듭니다. 
		<p>특성 키워드는 정의의 의미를 변경하며 클래스, 변수, 함수 및 네임스페이스 정의에 적용할 수 있습니다. 정의 키워드는 변수, 함수, 클래스 및 인터페이스와 같은 항목을 정의하는 데 사용됩니다. 기본 표현식 키워드는 리터럴 값을 나타냅니다. 예약어 목록을 보려면 <a href="http://www.adobe.com/go/learn_as3_reservedwords_kr" >ActionScript 3.0 학습</a>.</p> 
		<p>지시문은 명령문과 정의를 포함하며 컴파일 타임 또는 런타임에 영향을 미칠 수 있습니다. 다음 표에서 명령문이나 정의가 아닌 지시문은 지시문으로 레이블되어 있습니다.</p>
		</p><br><a name="statementSummary"></a><table cellspacing="0" cellpadding="3" class="summaryTable"><tr><th>&nbsp;</th><th colspan="2">특성 키워드</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#dynamic">dynamic</a></td><td class="summaryTableLastCol">클래스의 인스턴스가 런타임에 추가되는 동적 속성을 가질 수 있도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#final">final</a></td><td class="summaryTableLastCol">메서드 재정의 또는 클래스 확장을 수행할 수 없도록 지정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#internal">internal</a></td><td class="summaryTableLastCol">클래스, 변수, 상수 또는 함수를 동일한 패키지 내의 모든 호출자에서 사용할 수 있도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#native">native</a></td><td class="summaryTableLastCol">함수 또는 메서드가 Flash Player에 의해 기본 코드로 구현되도록 지정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#override">override</a></td><td class="summaryTableLastCol">메서드가 상속된 메서드를 대체하도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#private">private</a></td><td class="summaryTableLastCol">변수, 상수, 메서드 또는 네임스페이스를 정의하는 클래스에서만 변수, 상수, 메서드 또는 네임스페이스를 사용할 수 있도록 지정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#protected">protected</a></td><td class="summaryTableLastCol">변수, 상수, 메서드 또는 네임스페이스를 정의하는 클래스 또는 해당 클래스의 하위 클래스에서만 변수, 상수, 메서드 또는 네임스페이스를 사용할 수 있도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#public">public</a></td><td class="summaryTableLastCol">모든 호출자가 클래스, 변수, 상수 또는 메서드를 사용할 수 있도록 지정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#static">static</a></td><td class="summaryTableLastCol">변수, 상수 또는 메서드가 클래스의 인스턴스가 아니라 클래스에 속한 것으로 지정합니다.</td></tr><tr><th>&nbsp;</th><th colspan="2"> 네임스페이스 </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#AS3">AS3</a></td><td class="summaryTableLastCol">프로토타입 속성 대신 고정된 속성인 기본 ActionScript 클래스의 메서드와 속성을 정의합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#flash_proxy">flash_proxy</a></td><td class="summaryTableLastCol">Proxy 클래스의 메서드를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#object_proxy">object_proxy</a></td><td class="summaryTableLastCol">ObjectProxy 클래스의 메서드를 정의합니다.</td></tr><tr><th>&nbsp;</th><th colspan="2">기본 표현식 키워드</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#false">false</a></td><td class="summaryTableLastCol">false를 나타내는 부울 값입니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#null">null</a></td><td class="summaryTableLastCol">데이터가 제공되지 않은 경우 변수에 지정하거나 함수에서 반환할 수 있는 특수한 값입니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#this">this</a></td><td class="summaryTableLastCol">메서드의 포함 객체에 대한 참조입니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#true">true</a></td><td class="summaryTableLastCol">true를 나타내는 부울 값입니다.</td></tr><tr><th>&nbsp;</th><th colspan="2">명령문</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#break">break</a></td><td class="summaryTableLastCol">루프(<code>for</code>, <code>for..in</code>, <code>for each..in</code>, <code>do..while</code> 또는 <code>while</code>) 내에 나타나거나 <code>switch</code> 문 내의 특정 case와 연관된 명령문 블록 내에 나타납니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#case">case</a></td><td class="summaryTableLastCol"><code>switch</code> 문의 이동 대상을 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#continue">continue</a></td><td class="summaryTableLastCol">가장 안쪽의 루프에 남아 있는 명령문을 모두 건너뛰고 제어가 정상적으로 루프의 끝에 전달된 것처럼 루프의 다음 반복을 시작합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default">default</a></td><td class="summaryTableLastCol"><code>switch</code> 문에 대한 기본 case를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#do..while">do..while</a></td><td class="summaryTableLastCol">조건을 처음 평가하기 전에 명령문이 한 번 실행된다는 점을 제외하고는 <code>while</code> 루프와 유사합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#else">else</a></td><td class="summaryTableLastCol"><code>if</code> 문의 조건이 <code>false</code>를 반환하는 경우 실행할 명령문을 지정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for">for</a></td><td class="summaryTableLastCol"><code>init</code>(초기화) 표현식을 한 번 평가한 다음 루핑 시퀀스를 시작합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for..in">for..in</a></td><td class="summaryTableLastCol">객체의 동적 속성이나 배열 요소를 반복 실행하고 각 속성이나 요소에 대해 <code>statement</code>를 실행합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for_each..in">for each..in</a></td><td class="summaryTableLastCol">컬렉션의 항목을 반복하고 각 항목에 대해 <code>statement</code>를 실행합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#if">if</a></td><td class="summaryTableLastCol">조건을 평가하여 다음에 실행할 명령문을 결정합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#label">label</a></td><td class="summaryTableLastCol">명령문을 <code>break</code> 또는 <code>continue</code>로 참조할 수 있는 식별자와 연결합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#return">return</a></td><td class="summaryTableLastCol">실행 시에 호출하는 함수에 즉시 반환됩니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#super">super</a></td><td class="summaryTableLastCol">메서드나 생성자의 수퍼 클래스 또는 부모 버전을 호출합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#switch">switch</a></td><td class="summaryTableLastCol">표현식의 값에 따라 여러 명령문 중 하나에 제어가 전달됩니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#throw">throw</a></td><td class="summaryTableLastCol"><code>catch</code> 코드 블록이 처리할 수 있거나 <em>catch</em>할 수 있는 오류를 생성하거나 <em>throw</em>합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#try..catch..finally">try..catch..finally</a></td><td class="summaryTableLastCol">오류가 발생할 수 있는 코드 블록을 포함하고 오류에 대응합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#while">while</a></td><td class="summaryTableLastCol">조건을 평가하고 조건이 <code>true</code>로 평가되면 하나 이상의 명령문을 실행한 후 루프로 돌아가서 조건을 다시 평가합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#with">with</a></td><td class="summaryTableLastCol">명령문을 실행하는 데 사용할 기본 객체를 만듭니다. 이 객체를 사용하면 작성해야 하는 코드의 양을 줄일 수 있습니다.</td></tr><tr><th>&nbsp;</th><th colspan="2">정의 키워드</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#..._(rest)_parameter">... (rest) parameter</a></td><td class="summaryTableLastCol">함수가 쉼표로 구분된 인수를 무제한으로 받도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#class">class</a></td><td class="summaryTableLastCol">사용자가 정의한 메서드와 속성을 공유하는 객체를 인스턴스화하는 데 사용할 수 있는 클래스를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#const">const</a></td><td class="summaryTableLastCol">값을 한 번만 대입할 수 있는 변수인 상수를 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#extends">extends</a></td><td class="summaryTableLastCol">다른 클래스의 하위 클래스인 클래스를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#function">function</a></td><td class="summaryTableLastCol">특정 작업을 수행하기 위해 정의하는 일련의 명령문을 구성합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#get">get</a></td><td class="summaryTableLastCol">속성처럼 읽을 수 있는 메서드인 getter를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#implements">implements</a></td><td class="summaryTableLastCol">클래스가 하나 이상의 인터페이스를 구현하도록 지정합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#interface">interface</a></td><td class="summaryTableLastCol">인터페이스를 정의합니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#namespace">namespace</a></td><td class="summaryTableLastCol">정의의 가시성을 제어할 수 있습니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#package">package</a></td><td class="summaryTableLastCol">다른 스크립트에서 가져올 수 있도록 코드를 여러 그룹으로 분할해서 구성할 수 있습니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#set">set</a></td><td class="summaryTableLastCol">공용 인터페이스에 속성으로 표시되는 메서드인 setter를 정의합니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#var">var</a></td><td class="summaryTableLastCol">변수를 지정합니다.</td></tr><tr><th>&nbsp;</th><th colspan="2">지시문</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default_xml_namespace">default xml namespace</a></td><td class="summaryTableLastCol">
			<code>default xml namespace</code> 지시문은 XML 객체에 사용할 기본 네임스페이스를 설정합니다.
			</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#import">import</a></td><td class="summaryTableLastCol">외부적으로 정의된 클래스 및 패키지를 코드에서 사용할 수 있도록 만듭니다.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#include">include</a></td><td class="summaryTableLastCol">지정된 파일의 내용을 포함합니다. 파일 내의 명령은 호출하는 스크립트의 일부인 것처럼 사용됩니다.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#use_namespace">use namespace</a></td><td class="summaryTableLastCol">지정된 네임스페이스가 열려 있는 네임스페이스 세트에 추가되도록 합니다.</td></tr></table><div class="detailSectionHeader">명령문, 키워드 및 지시문 세부 정보</div><a name="..._(rest)_parameter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">... (rest) parameter</td><td class="detailHeaderType">정의 키워드</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName(parameter0, parameter1, ...rest){ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>함수가 쉼표로 구분된 인수를 무제한으로 받도록 지정합니다. 인수 목록은 함수 본문 어디에서나 사용할 수 있는 배열이 됩니다. 이 배열의 이름은 매개 변수 선언의 <code>...</code> 문자 뒤에 지정됩니다. 매개 변수는 예약어가 아닌 어떤 이름이나 가질 수 있습니다. 
			<p>다른 매개 변수와 함께 사용할 경우 <code>...</code> (rest) 매개 변수 선언은 마지막 매개 변수로 지정해야 합니다. <code>...</code> (rest) 매개 변수 배열은 함수에 전달된 인수의 수가 다른 매개 변수의 수를 초과하는 경우에만 채워집니다.</p> 
			<p>쉼표로 구분된 인수 목록의 각 인수는 배열의 요소에 배치됩니다. Array 클래스의 인스턴스를 전달하면 전체 배열이 <code>...</code> (rest) 매개 변수 배열의 단일 요소에 배치됩니다.</p>
			<p>이 매개 변수를 사용하면 <code>arguments</code> 객체를 사용할 수 없습니다. <code>...</code> (rest) 매개 변수는 <code>arguments</code> 배열 및 <code>arguments.length</code> 속성과 동일한 기능을 제공하지만 <code>arguments.callee</code>와 유사한 기능은 제공하지 않습니다. <code>...</code> (rest) 매개 변수를 사용하기 전에는 <code>arguments.callee</code>를 사용해야 할 일이 있는지 확인합니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rest</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 함수에 전달된 인수 배열의 이름을 나타내는 식별자입니다. 매개 변수는 키워드가 아닌 어떤 이름이나 가질 수 있으므로 매개 변수의 이름을 rest로 지정하지 않아도 됩니다. ... (rest) 매개 변수의 데이터 유형을 Array로 지정할 수 있습니다. 그러나 이렇게 하면 매개 변수가 Array 클래스의 인스턴스와 동일하지 않은 쉼표로 구분된 값 목록을 받기 때문에 혼동될 수 있습니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 ...(rest) 매개 변수를 서로 다른 두 함수에서 사용합니다. 첫 번째 함수인 traceParams에서는 간단하게 rest 배열의 각 인수에 대해 trace() 함수를 호출합니다. 두 번째 함수인 average()에서는 인수 목록을 받아서 평균을 반환합니다. 또한 두 번째 함수에서는 매개 변수에 대해 args라는 다른 이름을 사용합니다.
<div class="listing"><pre>
package {
	import flash.display.MovieClip;
	
	public class RestParamExample extends MovieClip {
		public function RestParamExample() {
			traceParams(100, 130, "two"); // 100,130,two
			trace(average(4, 7, 13));     // 8
		}
	}
}


function traceParams(... rest) {
 	trace(rest);
 }
 
function average(... args) : Number{
	var sum:Number = 0;
	for (var i:uint = 0; i < args.length; i++) {
		sum += args[i];
	}
	return (sum / args.length);
}
</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments 객체</a></div></div><a name="AS3"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">AS3</td><td class="detailHeaderType"> 네임스페이스 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>프로토타입 속성 대신 고정된 속성인 기본 ActionScript 클래스의 메서드와 속성을 정의합니다. "-as3" 컴파일러 옵션을 <code>true</code>로 설정하면(Flex Builder 2의 기본 설정) AS3 네임스페이스가 모든 기본 클래스에 대해 자동으로 열립니다. 즉, 기본 클래스의 인스턴스는 클래스의 프로토타입 객체에 연결된 것과 동일한 속성 및 메서드 대신 고정된 속성 및 메서드를 사용합니다. 고정된 속성을 사용하면 일반적으로 성능이 향상되지만 ECMAScript 버전 3 언어 사양(ECMA-262)과의 호환성 비용이 늘어납니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="Object.html" target="">Object 클래스</a></div></div><a name="break"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">break</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>break [label]</code></p></p></td></tr></table><p></p><p><p>루프(<code>for</code>, <code>for..in</code>, <code>for each..in</code>, <code>do..while</code> 또는 <code>while</code>) 내에 나타나거나 <code>switch</code> 문 내의 특정 case와 연관된 명령문 블록 내에 나타납니다. <code>break</code> 문을 루프에서 사용하면 루프 본문의 나머지를 건너뛰고 루핑 액션을 중단한 후 루프 문 다음의 명령문을 실행합니다. <code>break</code> 문을 <code>switch</code>에서 사용하면 해당 <code>case</code> 블록에서 명령문의 나머지를 건너뛰고 포함 <code>switch</code> 문 다음의 첫 번째 명령문으로 이동합니다. 
			<p>중첩 루프에서 <code>break</code> 문은 즉시 루프의 나머지만을 건너뛰고 일련의 전체 중첩 루프에서 빠져 나오지 않습니다. 전체 중첩 루프에서 벗어나려면 <code>label</code> 또는 <code>try..catch..finally</code>를 사용합니다.</p>
			<p><code>break</code> 문은 레이블이 지정된 외부 명령문과 일치해야 하는 선택적 레이블을 가질 수 있습니다. 외부 명령문의 레이블과 일치하지 않는 레이블을 사용하면 구문 오류가 발생합니다. 레이블이 지정된 <code>break</code> 문은 여러 레벨의 중첩 루프 명령문, <code>switch</code> 문 또는 <code>block</code> 문을 빠져 나올 때 사용할 수 있습니다. <code>label</code> 문에 대한 항목을 예로 들어 보겠습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 명령문과 연결된 레이블의 이름입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 break 문을 사용하여 무한 루프에서 빠져 나옵니다. 
<div class="listing"><pre>
var i:int = 0;
while (true) { 
	trace(i); 
	if (i >= 10) { 
		break; // this will terminate/exit the loop 
	} 
	i++; 
} 
/*
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10*/</pre></div>  
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="case"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">case</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>case jumpTarget: statements</pre></p></td></tr></table><p></p><p><p><code>switch</code> 문의 이동 대상을 정의합니다. <code>jumpTarget</code> 매개 변수가 완전 항등(<code>===</code>)을 사용하는 <code>switch</code> 문의 <code>expression</code> 매개 변수와 동일하면 Flash Player는 <code>break</code> 문 또는<code>switch</code> 문의 끝을 만날 때까지 <code>statements</code> 매개 변수에서 명령문을 실행합니다. <p><code>switch</code> 문 외부에서 <code>case</code> 문을 사용하면 오류가 발생하고 스크립트가 컴파일되지 않습니다.</p> 
			<p></p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">jumpTarget</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 모든 표현식입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; jumpTarget이 switch 문의 조건 표현식과 일치할 때 실행할 명령문입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 switch 문 thisMonth의 이동 대상을 정의합니다. thisMonth가 case 문의 표현식과 같으면 명령문이 실행됩니다. 
<div class="listing"><pre>
var thisMonth:int = new Date().getMonth(); 
switch (thisMonth) { 
	case 0 : 
		trace("January"); 
		break; 
	case 1 : 
		trace("February"); 
		break; 
	case 5 : 
	case 6 : 
	case 7 : 
		trace("Some summer month"); 
		break; 
	case 8 : 
		trace("September"); 
		break; 
	default : 
		trace("some other month"); 
}</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#switch" target="">switch</a></div></div><a name="class"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">class</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>[dynamic] [public | internal] [final] class className [ extends superClass ] [ implements interfaceName[, interfaceName... ] ] { 
	// class definition here
}</pre>
			</p></td></tr></table><p></p><p><p>사용자가 정의한 메서드와 속성을 공유하는 객체를 인스턴스화하는 데 사용할 수 있는 클래스를 정의합니다. 예를 들어, 청구서 추적 시스템을 개발하는 경우 각 송장에 포함해야 할 모든 메서드와 속성을 정의하는 Invoice 클래스를 만들 수 있습니다. 그런 다음 <code>new Invoice()</code> 명령을 사용하여 Invoice 객체를 만듭니다. 
			<p>각 ActionScript 소스 파일에는 다른 소스 파일 또는 스크립트에서 액세스할 수 있는 클래스를 하나만 포함할 수 있습니다. 외부에서 액세스할 수 있는 클래스는 공용 또는 내부 클래스이며 반드시 패키지 문 내부에 정의해야 합니다. 동일한 파일에 다른 클래스를 포함하는 경우 이러한 클래스는 패키지 문의 외부 즉, 파일의 끝에 배치해야 합니다. </p>
			<p>외부에서 액세스할 수 있는 클래스의 이름은 해당 클래스가 포함된 ActionScript 소스 파일의 이름과 일치해야 합니다. 소스 파일의 이름은 파일 확장명 .as가 추가된 클래스 이름이어야 합니다. 예를 들어, 클래스 이름을 Student로 지정하면 이 클래스를 정의하는 파일의 이름은 Student.as로 지정해야 합니다.</p> 
			<p>클래스 정의를 중첩할 수 없습니다. 즉, 클래스 정의 내에 다른 클래스를 정의할 수 없습니다.</p> 
			<p>클래스의 새 인스턴스가 만들어질 때마다 실행되는 생성자 메서드를 정의할 수 있습니다. 생성자 메서드의 이름은 클래스의 이름과 일치해야 합니다. 생성자 메서드를 정의하지 않으면 기본 생성자가 자동으로 만들어집니다.</p>
			<p>객체가 런타임에 동적 속성을 추가하거나 액세스할 수 있음을 나타내려면 class 문 앞에 <code>dynamic</code> 키워드를 지정합니다. 클래스가 인터페이스를 구현함을 선언하려면 <code>implements</code> 키워드를 사용합니다. 클래스의 하위 클래스를 만들려면 <code>extends</code> 키워드를 사용합니다. 클래스는 하나의 클래스만 확장할 수 있지만 여러 인터페이스를 구현할 수 있습니다. <code>implements</code>와 <code>extends</code>를 한 명령문에 사용할 수 있습니다. 다음 예제에서는 <code>implements</code> 및 <code>extends</code> 키워드의 일반적인 사용법을 보여 줍니다.</p> 
<div class="listing"><pre>class C implements Interface_i, Interface_j // OK 
class C extends Class_d implements Interface_i, Interface_j // OK 
class C extends Class_d, Class_e // not OK </pre></div> 

			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 정규화된 클래스 이름입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 Plant라는 클래스를 생성합니다. Plant 생성자는 두 개의 매개 변수를 사용합니다. 
<div class="listing"><pre>// Filename Plant.as 
package {
  public class Plant { 
	// Define property names and types 
	private var _leafType:String; 
	private var _bloomSeason:String; 
	// Following line is constructor 
	// because it has the same name as the class 
	public function Plant(param_leafType:String, param_bloomSeason:String) { 
		// Assign passed values to properties when new Plant object is created 
		_leafType = param_leafType; 
		_bloomSeason = param_bloomSeason; 
	} 
	// Create methods to return property values, because best practice 
	// recommends against directly referencing a property of a class 
	public function get leafType():String { 
		return _leafType; 
	} 
	public function get bloomSeason():String { 
		return _bloomSeason; 
	} 
  }
}</pre></div> 
스크립트에서 new 연산자를 사용하여 Plant 객체를 만듭니다.
<div class="listing"><pre>
var pineTree:Plant = new Plant("Evergreen", "N/A"); 
// Confirm parameters were passed correctly 
trace(pineTree.leafType); 
trace(pineTree.bloomSeason); </pre></div> 
			
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#dynamic" target="">dynamic</a><br/><a href="statements.html#extends" target="">extends</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="const"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">const</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>const identifier = value </pre></p></td></tr></table><p></p><p><p>값을 한 번만 대입할 수 있는 변수인 상수를 지정합니다.  
			<p>데이터 유형 앞에 콜론(:) 문자를 추가하면 상수를 고정 유형으로 지정할 수 있습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">identifier</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 상수에 대한 식별자입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 한 개의 상수에 값을 두 번 이상 대입할 때 오류가 발생함을 보여 줍니다.
<div class="listing"><pre>
const MIN_AGE:int = 21;
MIN_AGE = 18; // error</pre></div>
다음 예제에서는 상수가 배열인 경우 Array.push()를 포함한 Array 클래스 메서드를 호출할 수 있음을 보여 줍니다. 그러나 새 배열 리터럴을 대입할 수는 없습니다. 
<div class="listing"><pre>
const product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); // array operations are allowed
product_array = ["Other"];  // assignment is an error
trace(product_array); 
</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#var" target="">var</a></div></div><a name="continue"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">continue</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>continue [label]</pre></p></td></tr></table><p></p><p><p>가장 안쪽의 루프에 남아 있는 명령문을 모두 전달하고 제어가 루프의 끝까지 정상적으로 전달된 것처럼 루프의 다음 반복을 시작합니다. <code>continue</code> 문은 루프 외부에는 적용되지 않습니다. 중첩 루프에서 선택적 <code>label</code> 매개 변수를 사용하여 가장 안쪽의 루프를 제외한 모든 루프를 건너뜁니다.
			<p><code>continue</code> 문은 레이블이 지정된 외부 명령문과 일치해야 하는 선택적 레이블을 가질 수 있습니다. 외부 명령문의 레이블과 일치하지 않는 레이블을 사용하면 구문 오류가 발생합니다. 레이블이 지정된 <code>continue</code> 문을 사용하여 여러 레벨의 중첩 루프 명령문을 건너뛸 수 있습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 while 루프에서는 continue 문을 사용하여 3의 배수를 만날 때마다 루프 본문의 나머지를 건너뛴 다음, 조건이 테스트되는 루프 맨 위로 이동합니다. 
<div class="listing"><pre>
var i:int = 0; 
while (i < 10) { 
	if (i % 3 == 0) { 
		i++; 
		continue; 
	} 
	trace(i); 
	i++; 
}</pre></div> 
for 루프에서도 continue 문을 사용하여 루프 본문의 나머지를 건너뛸 수 있습니다. 다음 예제에서는 i % 3이 0과 같은 경우 trace(i) 문이 생략됩니다. 
<div class="listing"><pre> 
for (var i:int = 0; i < 10; i++) { 
	if (i % 3 == 0) { 
		continue; 
	} 
	trace(i); 
}</pre></div> 

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="default"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>default: statements </pre></p></td></tr></table><p></p><p><p><code>switch</code> 문에 대한 기본 case를 정의합니다. <code>switch</code> 문의 <code>expression</code> 매개 변수가 strict equality[<code>===</code>] 연산을 사용할 경우 해당 <code>switch</code> 문의 <code>case</code> 키워드를 따르는 <code>expression</code> 매개 변수와 하나도 동일하지 않으면 명령문이 실행됩니다. 
			<p><code>switch</code> 문에서는 <code>default</code> case 문이 필요하지 않습니다. <code>default</code> case 문을 목록의 마지막에 배치할 필요도 없습니다. <code>switch</code> 문 외부에서 <code>default</code> 문을 사용하면 오류가 발생하고 스크립트가 컴파일되지 않습니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 모든 명령문입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 요일이 일요일이나 토요일인 경우 case 문이 하나도 적용되지 않고 default 문이 실행됩니다. 
<div class="listing"><pre>
var dayOfWeek:int = new Date().getDay(); 
switch (dayOfWeek) { 
	case 1 : 
		trace("Monday"); 
		break; 
	case 2 : 
		trace("Tuesday"); 
		break; 
	case 3 : 
		trace("Wednesday"); 
		break; 
	case 4 : 
		trace("Thursday"); 
		break; 
	case 5 : 
		trace("Friday"); 
		break; 
	default : 
		trace("Weekend"); 
}</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#switch" target="">switch</a></div></div><a name="default_xml_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default xml namespace</td><td class="detailHeaderType">지시문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>default xml namespace = ns</code></p></p></td></tr></table><p></p><p><p>
			<code>default xml namespace</code> 지시문은 XML 객체에 사용할 기본 네임스페이스를 설정합니다. 
			
			<p><code>default xml namespace</code>를 설정하지 않은 경우 기본 네임스페이스는 이름이 지정되지 않은 네임스페이스(빈 문자열로 설정된 URI 포함)입니다. <code>default xml namespace</code> 선언의 범위는 변수의 범위와 마찬가지로 함수 블록 내입니다.
			</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 default xml namespace의 범위가 함수 블록임을 보여 줍니다.
			<div class="listing"><pre>var nsDefault1:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault1;
	    
var x1:XML = <test1 />;
trace("x1 ns: " + x1.namespace());
			
scopeCheck();	

var x2:XML = <test2 />;
trace("x2 ns: " + x2.namespace());
		
function scopeCheck(): void {
	
	var x3:XML = <test3 />;
	trace("x3 ns: " + x3.namespace());
				
	var nsDefault2:Namespace = new Namespace("http://schemas.xmlsoap.org/soap/envelope/");
	default xml namespace = nsDefault2;
		    
	var x4:XML = <test4 />;
	trace("x4 ns: " + x4.namespace());

}</pre></div>
			
			이 예제의 trace() 출력은 다음과 같습니다.
			
			x1 ns: http://www.example.com/namespaces/
x3 ns: 
x4 ns: http://schemas.xmlsoap.org/soap/envelope/
x2 ns: http://www.example.com/namespaces/



다음 예제에서는 default xml namespace를 사용하여 기본 네임스페이스를 대입합니다. 두 번째 XML 객체(x2)는 x2가 자체 기본 네임스페이스를 정의하므로 이 설정을 사용하지 않습니다. 
<div class="listing"><pre>
var nsDefault:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault;
            
var x1:XML = <test1 />;

trace(x1.namespace());
	// http://www.example.com/namespaces/

var x2:XML = <test2 xmlns = "http://www.w3.org/1999/XSL/Transform/" />;
trace(x2.namespace());
	// http://www.w3.org/1999/XSL/Transform/

var x3:XML = <test3 xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" />;
trace(x3.namespace());
	// http://www.example.com/namespaces/
</pre></div>  
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#namespace" target="">namespace</a><br/><a href="Namespace.html" target="">Namespace 클래스</a><br/><a href="statements.html#use_namespace" target="">use namespace</a><br/><a href="XML.html" target="">XML</a></div></div><a name="do..while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">do..while</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>do { statement(s) } while (condition)</pre></p></td></tr></table><p></p><p><p>조건을 처음 평가하기 전에 명령문이 한 번 실행된다는 점을 제외하고는 <code>while</code> 루프와 유사합니다. 그 후에 명령문은 조건이 <code>true</code>로 평가된 경우에만 실행됩니다. <p><code>do..while</code> 루프를 사용하면 루프 내의 코드가 한 번 이상 실행됩니다. <code>while</code> 루프를 실행할 명령문의 복사본을 <code>while</code> 루프가 시작되기 전에 배치하여도 같은 결과를 얻을 수 있지만 대부분의 프로그래머는 <code>do..while</code> 루프가 더 읽기 쉽다고 생각합니다.</p> 
			<p>조건이 항상 <code>true</code>로 평가되면 <code>do..while</code> 루프는 무한 루프입니다. 무한 루프 상태가 되면 Flash Player에 문제가 발생하여 경고 메시지가 나타나거나 플레이어에서 충돌이 발생할 수 있습니다. 루핑할 횟수를 아는 경우에는 가능하면 <code>for</code> 루프를 사용합니다. <code>for</code> 루프는 읽고 디버깅하기 쉽지만 모든 상황에서 <code>do..while</code> 루프를 대체할 수 있는 것은 아닙니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 평가할 조건입니다. 코드의 do 블록 내에 있는 명령문은 condition 매개 변수가 true로 평가되어야 실행됩니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 do..while 루프를 사용하여 조건이 true인지 평가하고 myVar이 5 이상이 될 때까지 myVar을 추적합니다. myVar이 5 이상이 되면 루프가 끝납니다. 
<div class="listing"><pre>
var myVar:Number = 0; 
do { 
	trace(myVar); 
	myVar++; 
} 
while (myVar < 5); 
/*
0 
1 
2 
3 
4
*/</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="dynamic"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dynamic</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>dynamic class className { // class definition here }</pre></p></td></tr></table><p></p><p><p>클래스의 인스턴스가 런타임에 추가되는 동적 속성을 가질 수 있도록 지정합니다. 클래스에서 <code>dynamic</code> 특성을 사용하는 경우 런타임에 속성을 해당 클래스의 인스턴스에 추가할 수 있습니다. <code>dynamic</code>으로 표시되지 않은 클래스는 속성을 클래스의 인스턴스에 추가할 수 없는 <em>봉인된</em> 클래스로 간주됩니다.
			<p>동적 클래스가 아닌 봉인된 클래스의 경우 클래스 인스턴스에 속성을 가져오거나 설정하려고 하면 오류가 발생합니다. 컴파일러를 Strict 모드로 설정하고 데이터 유형을 지정한 경우 인스턴스를 만들 때 봉인된 객체에 속성을 추가하려고 시도하면 컴파일러 오류가 발생하며, 컴파일러 오류가 발생하지 않은 경우에는 런타임 오류가 발생합니다.</p> 
			<p><code>dynamic</code> 특성은 하위 클래스에 상속되지 않습니다. 동적 클래스를 확장한 경우에는 <code>dynamic</code> 특성을 사용하여 하위 클래스를 선언해야만 하위 클래스가 동적 클래스가 됩니다.</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 이후 예제에서 사용할 Expando라는 동적 클래스와 Sealed라는 봉인된 클래스를 만듭니다.
<div class="listing"><pre>
package {

	dynamic class Expando  {
	}
	
	class Sealed {
	}
}
</pre></div>
다음 코드는 Expando 클래스의 인스턴스를 만들고, 이 인스턴스에 속성을 추가할 수 있음을 보여 줍니다.
<div class="listing"><pre>
var myExpando:Expando = new Expando();
myExpando.prop1 = "new";
trace(myExpando.prop1); // new
</pre></div>
다음 코드는 Sealed 클래스의 인스턴스를 만들고, 속성을 추가할 때 오류가 발생한다는 것을 보여 줍니다.
<div class="listing"><pre>
var mySealed:Sealed = new Sealed();
mySealed.prop1 = "newer"; // error
</pre></div>
		

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a></div></div><a name="else"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">else</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) { 
	// statement(s)
} 
else {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p><code>if</code> 문의 조건이 <code>false</code>를 반환하는 경우 실행할 명령문을 지정합니다. 명령문을 하나만 실행할 경우에는 <code>else</code> 문이 실행할 명령문을 둘러싸는 중괄호(<code>{}</code>)가 필요하지 않습니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; true 또는 false로 평가되는 표현식입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 else 조건을 사용하여 age_txt 변수가 18보다 큰지 또는 작은지 확인합니다. 
<div class="listing"><pre>
if (age_txt.text>=18) { 
	trace("welcome, user"); 
} 
else { 
	trace("sorry, junior"); 
	userObject.minor = true; 
	userObject.accessAllowed = false;
}</pre></div> 
다음 예제에서는 else 문 뒤에 오는 명령문이 하나뿐이기 때문에 중괄호({})가 필요하지 않습니다.
<div class="listing"><pre>
if (age_txt.text>18) { 
	trace("welcome, user");
} 
else trace("sorry, junior");</pre></div>
다음 예제에서는 if 및 else 문의 조합을 사용하여 score_txt를 지정된 값과 비교합니다. 
<div class="listing"><pre>

if (score_txt.text>90) { 
	trace("A"); 
} 
else if (score_txt.text>75) { 
	trace("B"); 
} 
else if (score_txt.text>60) { 
	trace("C"); 
} 
else { 
	trace("F"); 
}</pre></div><p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#if" target="">if</a></div></div><a name="extends"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">extends</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>class className extends otherClassName {}
interface interfaceName extends otherInterfaceName {} </pre> </p></td></tr></table><p></p><p><p>다른 클래스의 하위 클래스인 클래스를 정의합니다. 하위 클래스는 수퍼 클래스에 정의된 모든 메서드, 속성 및 함수 등을 상속 받습니다. <code>final</code>로 표시된 클래스는 확장할 수 없습니다.
			<p>또한 <code>extends</code> 키워드를 사용하여 인터페이스를 확장할 수 있습니다. 다른 인터페이스를 확장하는 인터페이스는 원본 인터페이스의 모든 메서드 선언을 포함합니다.</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 정의할 클래스의 이름입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 Car 클래스가 Vehicle 클래스를 확장하여 Car 클래스의 모든 메서드, 속성 및 함수가 상속됩니다. 스크립트가 Car 객체를 인스턴스화하면 Car 클래스의 메서드와 Vehicle 클래스의 메서드를 모두 사용할 수 있습니다. 
			다음 예제에서는 Vehicle 클래스를 정의하는 Vehicle.as 파일의 내용을 보여 줍니다.  
<div class="listing"><pre>
package {
	class Vehicle { 
	    var numDoors:Number; 
	    var color:String; 
	    public function Vehicle(param_numDoors:Number = 2, param_color:String = null) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	    } 
	    public function start():void { 
	        trace("[Vehicle] start"); 
	    } 
	    public function stop():void { 
	        trace("[Vehicle] stop"); 
	    } 
	    public function reverse():void { 
	        trace("[Vehicle] reverse"); 
	    } 
	}	
}</pre></div> 
다음 예제에서는 같은 디렉토리에 있는 두 번째 ActionScript 파일(Car.as)을 보여 줍니다. 이 클래스는 Vehicle 클래스를 확장하여 세 가지 방식으로 변경합니다. 우선 Car 클래스는 car 객체가 정품 크기의 예비 타이어를 가지고 있는지 추적할 fullSizeSpare 변수를 추가합니다. 그런 다음, 차량의 도난 방지 경보 장치를 활성화하는 새로운 메서드인 activateCarAlarm()을 추가합니다. 마지막으로 stop() 함수를 재정의하여 Car 클래스가 멈추려 할 때는 잠금 방지 제동 시스템을 사용한다는 사실을 추가합니다.
<div class="listing"><pre>
package {

	public class Car extends Vehicle { 
	    var fullSizeSpare:Boolean; 
	    public function Car(param_numDoors:Number, param_color:String, param_fullSizeSpare:Boolean) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	        fullSizeSpare = param_fullSizeSpare; 
	    } 
	    public function activateCarAlarm():void { 
	        trace("[Car] activateCarAlarm"); 
	    } 
	    public override function stop():void { 
	        trace("[Car] stop with antilock brakes"); 
	    } 
	}
}</pre></div> 
다음 예제에서는 Car 객체를 인스턴스화하고 Vehicle 클래스에서 정의된 start() 메서드를 호출한 다음 Car 클래스에 의해 재정의된 stop() 메서드를 호출하고 마지막으로 Car 클래스에서 activateCarAlarm() 메서드를 호출합니다.
<div class="listing"><pre>var myNewCar:Car = new Car(2, "Red", true); 
myNewCar.start(); // [Vehicle] start 
myNewCar.stop(); // [Car] stop with anti-lock brakes 
myNewCar.activateCarAlarm(); // [Car] activateCarAlarm</pre></div> 
또한 super 문을 사용하여 Vehicle 클래스의 하위 클래스를 작성할 수 있으며, 이 하위 클래스를 사용하여 수퍼 클래스의 생성자에 액세스할 수 있습니다. 다음 예제에서는 역시 같은 디렉토리에서 세 번째 ActionScript 파일인 Truck.as 파일을 보여 줍니다. Truck 클래스는 생성자와 재정의된 reverse() 메서드에서 super를 사용합니다. 
<div class="listing"><pre>
package {
	class Truck extends Vehicle {
		var numWheels:Number;
		public function Truck(param_numDoors:Number, param_color:String, param_numWheels:Number) { 
			super(param_numDoors, param_color); 
			numWheels = param_numWheels; 
		} 
		public override function reverse():void { 
			beep();
			super.reverse();
		} 
		public function beep():void { 
			trace("[Truck] make beeping sound"); 
		} 
	}
}</pre></div> 
다음 예제에서는 Truck 객체를 인스턴스화하고 Truck 클래스에 의해 재정의된 reverse() 메서드를 호출한 다음 Vehicle 클래스에서 정의된 stop() 메서드를 호출합니다.  
<div class="listing"><pre>var myTruck:Truck = new Truck(2, "White", 18); 
myTruck.reverse(); // [Truck] make beeping sound [Vehicle] reverse 
myTruck.stop(); // [Vehicle] stop</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#interface" target="">interface</a></div></div><a name="false"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">false</td><td class="detailHeaderType">기본 표현식 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>false</pre></p></td></tr></table><p></p><p><p>false를 나타내는 부울 값입니다. 부울 값은 <code>true</code> 또는 <code>false</code>이며, <code>false</code>의 반대는 <code>true</code>입니다.
			<p>자동 데이터 유형 지정 기능이 <code>false</code>를 숫자로 변환하면 <code>0</code>이 됩니다. <code>false</code>를 문자열로 변환하면 <code>"false"</code>가 됩니다.</p>
			<p><b>중요:</b> 문자열 <code>"false"</code>는 부울 값 <code>true</code>로 변환됩니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 자동 데이터 유형 지정 기능이 false를 숫자 및 문자열로 변환하는 방법을 보여 줍니다.
<div class="listing"><pre>
var bool1:Boolean = Boolean(false);

// converts it to the number 0
trace(1 + bool1); // outputs 1

// converts it to a string
trace("String: " + bool1); // outputs String: false
</pre></div>
다음 예제에서는 문자열 "false"가 부울 값 true로 변환되는 것을 보여 줍니다.
<div class="listing"><pre>
trace(Boolean("false")); // true

if ("false") {
	trace("condition expression evaluated to true");
}
else {
	trace("condition expression evaluated to false");
}
// condition expression evaluated to true
</pre></div>

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="Boolean.html" target="">Boolean 클래스</a><br/><a href="statements.html#true" target="">true</a></div></div><a name="final"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">final</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
final function methodName() { 
	// your statements here 
}
final class className {}</pre> </p></td></tr></table><p></p><p><p>메서드 재정의 또는 클래스 확장을 수행할 수 없도록 지정합니다. <code>final</code>로 표시된 메서드를 재정의하거나 클래스를 확장하려고 시도하면 오류가 발생합니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; 재정의할 수 없는 메서드 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 확장할 수 없는 클래스 이름입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#override" target="">override</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="flash_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">flash_proxy</td><td class="detailHeaderType"> 네임스페이스 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Proxy 클래스의 메서드를 정의합니다. Proxy 하위 클래스에 Proxy 클래스 메서드와 일치하는 인스턴스 메서드 이름이 포함된 경우 발생할 수 있는 이름 충돌을 피하기 위해 Proxy 클래스 메서드는 자체 네임스페이스에 있습니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="flash/utils/Proxy.html" target="">Proxy 클래스</a></div></div><a name="for"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for ([init]; [condition]; [next]) { 
	// statement(s)
}</pre>
			</p></td></tr></table><p></p><p><p><code>init</code>(초기화) 표현식을 한 번 평가한 다음 루핑 시퀀스를 시작합니다. 루핑 시퀀스는 <code>condition</code> 표현식을 평가하여 시작합니다. <code>condition</code> 표현식이 <code>true</code>로 평가되면 <code>statement</code>가 실행되고 <code>next</code>가 평가됩니다. 그런 다음 <code>condition</code> 표현식을 평가하여 루핑 시퀀스가 다시 시작됩니다. 
			<p>명령문을 하나만 실행할 경우에는 <code>for</code> 문이 실행할 명령문 블록을 둘러싸는 중괄호(<code>{}</code>)가 필요하지 않습니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">init</span></code> &mdash; 루핑 시퀀스를 시작하기 전에 평가할 선택적 표현식, 즉 일반적으로 대입 표현식입니다. var 문에서도 이 매개 변수를 사용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">condition</span></code> &mdash; 루핑 시퀀스를 시작하기 전에 평가할 선택적 표현식, 즉 일반적으로 비교 표현식입니다. 표현식이 true로 평가되면 for 문과 연결된 명령문이 실행됩니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">next</span></code> &mdash; 루핑 시퀀스 이후에 평가할 선택적 표현식 즉, 일반적으로 증가 또는 감소 표현식입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 for를 사용하여 배열에 요소를 추가합니다. 
<div class="listing"><pre>
var my_array:Array = new Array(); 
for (var i:Number = 0; i < 10; i++) { 
	my_array[i] = (i + 5) * 10;  
} 
trace(my_array); // 50,60,70,80,90,100,110,120,130,140 </pre></div> 
다음 예제에서는 for를 사용하여 같은 액션을 반복적으로 수행합니다. 이 코드에서 for 루프는 1부터 100까지의 숫자를 추가합니다. 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) { 
	sum += i; 
} 
trace(sum); // 5050</pre></div> 
다음 예제에서는 실행될 명령문이 하나뿐이어서 중괄호({})가 필요하지 않습니다. 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) 
	sum += i; 
trace(sum); // 5050</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="operators.html#increment" target="">++ (increment)</a></div></div><a name="for..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for..in</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>for (variableIterant:String in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>객체의 동적 속성이나 배열 요소를 반복 실행하고 각 속성이나 요소에 대해 <code>statement</code>를 실행합니다. 객체 속성 간에 특정한 순서가 있는 것은 아니므로 속성은 임의의 순서에 따라 나타날 수 있습니다. 클래스에 정의된 변수 및 메서드와 같이 고정된 속성은 <code>for..in</code> 문으로 열거되지 않습니다. 고정된 속성 목록을 얻으려면 flash.utils 패키지에 있는 <code>describeType()</code> 함수를 사용합니다.
			 
			 
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a href="String.html">String</a></code> &mdash; 객체의 각 속성이나 배열 요소를 참조하면서 반복 실행되는 변수의 이름입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 for..in을 사용하여 객체의 속성을 반복 실행합니다. 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var prop in myObject) { 
	trace("myObject."+prop+" = "+myObject[prop]); 
} 
/*
myObject.firstName = Tara 
myObject.age = 27 
myObject.city = San Francisco
*/</pre></div> 
다음 예제에서는 typeof 연산자를 for..in 문과 함께 사용하여 특정 유형의 자식을 반복 실행합니다. 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var name in myObject) { 
	if (typeof (myObject[name]) == "string") { 
		trace("I have a string property named "+name); 
	} 
}
/*
I have a string property named city
I have a string property named firstName
*/
</pre></div> 
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="flash/utils/package.html#describeType()" target="">describeType()</a></div></div><a name="for_each..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for each..in</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for each (variableIterant in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>컬렉션의 항목을 반복하고 각 항목에 대해 <code>statement</code>를 실행합니다. E4X 언어 확장의 일부로 도입된 <code>for each..in</code> 문은 XML 객체뿐만 아니라 객체 및 배열에 대해서도 사용할 수 있습니다. <code>for each..in</code> 문은 객체의 속성 중 고정된 속성은 제외하고 동적 속성만 반복합니다. 고정된 속성은 클래스 정의의 일부로 정의된 속성입니다. <code>for each..in</code> 문을 사용자 정의 클래스의 인스턴스와 함께 사용하려면 <code>dynamic</code> 특성을 사용하여 클래스를 선언해야 합니다. 
			<p><code>for..in</code> 문과 달리 <code>for each..in</code> 문은 속성 이름 대신 객체의 속성 값을 반복합니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 컬렉션의 항목을 참조하면서 반복 실행되는 변수의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; 반복할 컬렉션의 이름입니다. 컬렉션은 XML 객체, 일반 객체 또는 배열일 수 있습니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 for each..in을 사용하여 객체의 속성 값을 반복 실행합니다. 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	trace(item); 
} 
/*
Tara
27
San Francisco
*/</pre></div> 
다음 예제에서는 for each..in을 사용하여 배열 요소를 반복 실행합니다. 
<div class="listing"><pre>
var myArray:Array = new Array("one", "two", "three"); 
for each(var item in myArray) 
	trace(item); 
/*
one
two
three
*/</pre></div> 
다음 예제에서는 is 연산자를 for each..in 문과 함께 사용하여 특정 유형의 자식을 반복 실행합니다. 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	if (item is String) {  
		trace("I have a string property with value " + item); 
	} 
}

/*
I have a string property with value Tara
I have a string property with value San Francisco
*/
</pre></div> 

다음 예제에서는 for each..in을 사용하여 XMLList 객체(doc.p)의 속성을 반복 실행합니다.

<div class="listing"><pre>
var doc:XML = 
		<body>
			<p>Hello</p>
			<p>Hola</p>
			<hr />
			<p>Bonjour</p>
		</body>;
for each (var item in doc.p) {
	trace(item);
}

/*
Hello
Hola
Bonjour
*/
</pre></div>
			<p></p></div><a name="function"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">function</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} 
var functionName:Function = function ([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>특정 작업을 수행하기 위해 정의하는 일련의 명령문을 구성합니다. 특정 위치에서 함수를 정의하거나 SWF 파일 내의 다른 스크립트에서 함수를 <em>호출</em>할 수 있습니다. 함수를 정의할 때 해당 함수의 매개 변수도 지정할 수 있습니다. 매개 변수는 함수가 적용되는 값에 대한 자리 표시자입니다. 다른 상황에서 함수를 다시 사용할 수 있도록 함수를 호출할 때마다 함수에 다른 매개 변수를 전달할 수 있습니다. 
			<p>함수의 <code>statement(s)</code> 블록에서 <code>return</code> 문을 사용하여 함수가 값을 생성하거나 <em>반환</em>하도록 할 수 있습니다.</p> 
			<p>구문 1: <code>function</code> 키워드를 사용하여 지정된 함수 이름, 매개 변수 및 명령문을 가진 함수를 정의할 수 있습니다. 스크립트에서 함수를 호출하면 함수 정의의 명령문이 실행됩니다. 전방 참조가 허용되므로 동일한 스크립트 내에서 함수를 호출한 다음 해당 함수를 선언할 수 있습니다. 함수 정의는 동일한 함수의 이전 정의를 모두 대체합니다. 명령문을 사용할 수 있는 곳이면 어느 곳에서나 이 구문을 사용할 수 있습니다. </p> 
			<p>구문 2: <code>function</code>을 사용하여 익명 함수를 만들고 해당 함수에 대한 참조를 반환할 수도 있습니다. 이 구문은 표현식에 사용되며 특히 객체에 메서드를 설치하는 데 유용합니다.</p> 
			<p>추가 기능을 사용하려면 함수 정의에서 <code>arguments</code> 객체를 사용하면 됩니다. <code>arguments</code> 객체는 일반적으로 매개 변수의 변수 번호를 승인하는 함수를 만들고 익명의 순환 함수를 만드는 데 사용됩니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; 새 함수의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 반환값의 데이터 유형입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 제곱 값을 반환하는 sqr 함수를 정의합니다. 
<div class="listing"><pre>function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
} 
var yNum:Number = sqr(3); 
trace(yNum); // 9</pre></div> 
함수를 정의하고 동일한 스크립트에서 이 함수를 사용하는 경우 함수의 정의는 함수가 사용된 후에 나타날 수 있습니다. 
<div class="listing"><pre>var yNum:Number = sqr(3); 
trace(yNum); // 9 
function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
}</pre></div> 

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments 객체</a><br/><a href="statements.html#return" target="">return</a></div></div><a name="get"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">get</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function get property() : returnType{ 
	// your statements here 
}</pre> </p></td></tr></table><p></p><p><p>속성처럼 읽을 수 있는 메서드인 getter를 정의합니다. getter는 <code>var</code> 또는 <code>const</code> 키워드로 선언된 속성 값을 반환하는 특수 함수입니다. 다른 메서드와 달리 getter는 괄호(<code>()</code>) 없이 호출되므로 변수처럼 보입니다.
			<p>getter를 사용하면 전용 속성에 대한 공용 인터페이스를 만들어서 정보 은폐 원칙을 적용할 수 있습니다. 정보 은폐 기술을 사용하면 전용 속성의 기본 구현이 변경되더라도 공용 인터페이스를 그대로 유지할 수 있습니다.</p>
			<p>또한 <code>var</code> 또는 <code>const</code>로 선언된 속성은 하위 클래스에서 재정의할 수 없는 반면 getter는 하위 클래스에서 재정의할 수 있습니다.</p>
			<p>getter와 setter를 결합하여 읽기/쓰기 속성을 만들 수 있습니다. 읽기 전용 속성을 만들려면 해당 setter는 만들지 않고 getter만 만듭니다. 쓰기 전용 속성을 만들려면 해당 getter는 만들지 않고 setter만 만듭니다.</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; get이 액세스하는 속성의 식별자이며, 이 값은 해당 set 명령에 사용된 값과 동일해야 합니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 반환값의 데이터 유형입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 Team 클래스를 정의합니다. Team 클래스에는 클래스 내에서 속성을 가져오거나 설정하는 데 사용할 수 있는 getter/setter 메서드가 포함되어 있습니다. 
<div class="listing"><pre>
package {
	public class Team { 
		var teamName:String; 
		var teamCode:String; 
		var teamPlayers:Array = new Array(); 
		public function Team(param_name:String, param_code:String) { 
			teamName = param_name; 
			teamCode = param_code; 
		} 
		public function get name():String { 
			return teamName; 
		} 
		public function set name(param_name:String):void { 
			teamName = param_name; 
		}
	} 
}</pre></div>
스크립트에 다음 코드를 입력합니다. 
<div class="listing"><pre>
var giants:Team = new Team("San Fran", "SFO"); 
trace(giants.name); 
giants.name = "San Francisco"; 
trace(giants.name); 
/*
San Fran San Francisco */</pre></div> 
giants.name을 추적할 경우 getter 메서드를 사용하여 속성 값을 반환합니다.
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#set" target="">set</a></div></div><a name="if"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">if</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>조건을 평가하여 다음에 실행할 명령문을 결정합니다. 조건이 <code>true</code>이면 중괄호(<code>{}</code>) 안에서 조건 뒤에 있는 명령문이 실행됩니다. 조건이 <code>false</code>이면 중괄호 안의 명령문을 건너뛰고 중괄호 다음의 명령문이 실행됩니다. <code>if</code> 문을 <code>else</code> 문과 함께 사용하면 스크립트에 분기 논리를 만들 수 있습니다. 
			<p>명령문을 하나만 실행할 경우에는 <code>if</code> 문이 실행할 명령문을 둘러싸는 중괄호(<code>{}</code>)가 필요하지 않습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; true 또는 false로 평가되는 표현식입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#else" target="">else</a></div></div><a name="implements"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">implements</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>myClass implements interface01 [, interface02 , ...] </pre> </p></td></tr></table><p></p><p><p>클래스가 하나 이상의 인터페이스를 구현하도록 지정합니다. 클래스가 인터페이스를 구현할 때 클래스는 인터페이스에 선언된 모든 메서드를 정의해야 합니다. 인터페이스를 구현한 클래스의 모든 인스턴스는 인터페이스에 정의된 데이터 유형의 멤버로 간주됩니다. 결과적으로 <code>is</code> 연산자는 클래스 인스턴스가 첫 번째 피연산자이고 인터페이스가 두 번째 피연산자일 때 <code>true</code>를 반환하며, 인터페이스에 정의된 데이터 유형과의 강제 형 변환이 수행됩니다.
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#interface" target="">interface</a></div></div><a name="import"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">import</td><td class="detailHeaderType">지시문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>import packageName.className 
import packageName.*</pre> </p></td></tr></table><p></p><p><p>외부적으로 정의된 클래스 및 패키지를 코드에서 사용할 수 있도록 만듭니다. 예를 들어, flash.display.Sprite 클래스를 스크립트에서 사용하려면 해당 클래스를 가져와야 합니다. 이 요구 사항은 이전 버전의 ActionScript에서 달라진 것입니다. 이전 버전에서는 <code>import</code> 지시문이 선택 사항이었습니다.
			<p><code>import</code> 지시문을 사용한 후에는 클래스 이름만 포함되거나 패키지 이름이 포함된 전체 클래스 이름을 사용할 수 있습니다.</p>
<div class="listing"><pre> 
import flash.display.Sprite; 

// name of class only
var mySprite:Sprite = new Sprite();

// full class name
var mySprite:flash.display.Sprite = new flash.display.Sprite();
</pre></div> 
<p>액세스하려는 패키지에 여러 개의 클래스가 있으면 다음 예제에서처럼 해당 파일을 모두 하나의 명령문으로 가져올 수 있습니다.</p>
<div class="listing"><pre>import flash.display.*;</pre></div>
<p><code>import</code> 지시문은 가져온 패키지의 최상위에 있는 클래스, 함수 및 변수만을 가져옵니다. 중첩 패키지는 명시적으로 가져와야 합니다.</p>
<p>클래스를 가져왔지만 스크립트에서 사용하지 않는 경우 클래스는 SWF 파일의 일부로 내보내지지 않습니다. 따라서 대규모의 패키지를 가져올 때 SWF 파일의 크기를 걱정할 필요가 없습니다. 클래스와 관련된 바이트코드는 해당 클래스가 실제로 사용되는 경우에만 SWF 파일에 포함됩니다. 필요하지 않은 클래스를 가져오게 되면 이름이 충돌할 가능성이 높아지는 단점이 있습니다.</p> 
 
<pre>
// On Frame 1 of a FLA: 
import adobe.example.*; 
var myFoo:foo = new foo();</pre> 
 

			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 별개의 클래스 파일에서 정의한 패키지의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 별개의 클래스 파일에서 정의한 클래스의 이름입니다.</td></tr></table></div><a name="include"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">include</td><td class="detailHeaderType">지시문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>include "[path]filename.as"</pre></p></td></tr></table><p></p><p><p>지정된 파일의 내용을 포함합니다. 파일 내의 명령은 호출하는 스크립트의 일부인 것처럼 사용됩니다. <code>include</code> 지시문은 컴파일 타임에 호출됩니다. 그러므로 포함된 파일을 변경하게 되면 변경한 파일을 저장한 후 이 파일을 사용하는 SWF 파일을 다시 컴파일해야 합니다.
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="interface"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">interface</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre> interface InterfaceName [extends InterfaceName ] {}</pre> </p></td></tr></table><p></p><p><p>인터페이스를 정의합니다. 인터페이스는 해당 인터페이스를 구현하는 클래스에 의해 정의되어야 하는 일련의 메서드를 정의하는 데이터 유형입니다.
			<p> 인터페이스는 클래스와 유사하지만 다음과 같은 중요한 차이가 있습니다.</p> 
			<ul> 
			  <li>인터페이스에는 구현되지 않은 메서드 선언만 포함됩니다. 따라서 인터페이스를 구현하는 모든 클래스는 인터페이스에 선언된 각각의 메서드를 구현해야 합니다.</li> 
			  <li>인터페이스 메서드 정의는 <code>public</code> 또는 <code>private</code>와 같은 특성을 가질 수 없지만 구현된 메서드는 해당 인터페이스를 구현하는 클래스의 정의에서 <code>public</code>으로 표시되어야 합니다.</li> 
			  <li>인터페이스에서 <code>extends</code> 문을 사용하거나 클래스에서 <code>implements</code> 문을 사용하여 여러 인터페이스를 상속할 수 있습니다.</li> 
			</ul>
			<p>ActionScript 2.0과는 달리 ActionScript 3.0에서는 getter 및 setter 메서드를 인터페이스 정의에 사용할 수 있습니다.</p>
			
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#implements" target="">implements</a></div></div><a name="internal"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">internal</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
[internal] var varName
[internal] const kName
[internal] function functionName()  { 
	// your statements here 
}
[internal] class className{
	// your statements here 
}
[internal] namespace nsName
</pre> </p></td></tr></table><p></p><p><p>클래스, 변수, 상수 또는 함수를 동일한 패키지 내의 모든 호출자에서 사용할 수 있도록 지정합니다. 클래스, 속성 및 메서드는 기본적으로 <code>internal</code> 네임스페이스에 속합니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; internal로 지정할 클래스의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; internal로 지정할 변수의 이름입니다. 변수가 클래스에 속해 있는지 여부와 상관없이 internal 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; internal로 지정할 상수의 이름입니다. 상수가 클래스에 속해 있는지 여부와 상관없이 internal 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; internal로 지정할 함수 또는 메서드의 이름입니다. 함수가 클래스에 속해 있는지 여부와 상관없이 internal 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; internal로 지정할 네임스페이스의 이름입니다. 네임스페이스가 클래스에 속해 있는지 여부와 상관없이 internal 특성을 적용할 수 있습니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#package" target="">package</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="label"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">label</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>label: statement
label: {
    statements
}</pre></p></td></tr></table><p></p><p><p>명령문을 <code>break</code> 또는 <code>continue</code>로 참조할 수 있는 식별자와 연결합니다. 중첩 루프에서 레이블을 참조하지 않는 <code>break</code> 또는 <code>continue</code> 명령문은 즉시 루프의 나머지 부분만을 건너뛸 수 있으며 전체 루프를 건너뛰지는 않습니다. 그러나 전체 루프를 정의하는 명령문에 연결된 레이블이 있는 경우 <code>break</code> 또는 <code>continue</code> 문은 해당 레이블을 참조하여 전체 루프를 건너뛸 수 있습니다.
			<p>또한 레이블을 사용하여 블록 명령문을 빠져 나올 수 있습니다. 블록 명령문이 루프의 일부가 아닌 경우에는 레이블을 참조하지 않는 <code>break</code> 문을 블록 명령문 내에 배치할 수 없습니다. 블록 명령문에 연결된 레이블이 있는 경우에는 해당 레이블을 참조하는 <code>break</code> 문을 블록 명령문 내에 배치할 수 있습니다.</p>		
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 명령문과 연결할 유효한 식별자입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 레이블과 연결할 명령문입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 중첩 루프에서 레이블을 사용하여 전체 루프에서 빠져 나오는 방법을 보여 줍니다. 이 코드에서는 중첩 루프를 사용하여 0부터 99까지의 숫자 목록을 생성합니다. break 문은 횟수가 80에 도달하기 전까지 발생합니다. break 문이 outerLoop 레이블을 사용하지 않는 경우 코드는 즉시 루프의 나머지 부분만을 건너뛴 다음 90부터 99까지의 숫자를 출력합니다. 그러나 이 예제에서는 outerLoop 레이블이 사용되므로 break 문은 전체 루프의 나머지 부분을 건너뛰며 79가 마지막으로 출력됩니다.
<div class="listing"><pre>
outerLoop: for (var i:int = 0; i < 10; i++) {
	for (var j:int = 0; j < 10; j++) {
		if ( (i == 8) && (j == 0)) {
			break outerLoop;
		}
		trace(10 * i + j);
	}
}
/*
1
2
...
79
*/
</pre></div>
다음 예제에서는 레이블을 블록 명령문과 함께 사용하는 방법을 보여 줍니다. 다음 예제에서는 break 문이 블록의 마지막 명령문을 건너뛰도록 블록 명령문에 foo라는 레이블이 지정됩니다.
<div class="listing"><pre>
foo: {
	trace("a");
	break foo;
	trace("b");
}
// a
</pre></div>

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a></div></div><a name="namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">namespace</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>namespace name [= uri]</pre> </p></td></tr></table><p></p><p><p>정의의 가시성을 제어할 수 있습니다. 미리 정의된 네임스페이스에는 <code>public</code>, <code>private</code>, <code>protected</code> 및 <code>internal</code>이 포함됩니다. 
			<p>다음 단계에서는 네임스페이스를 만들고, 적용하고, 참조하는 방법을 보여 줍니다.</p>
			<ul>
			  <li>먼저 <code>namespace</code> 키워드를 사용하여 사용자 정의 네임스페이스를 정의합니다. 예를 들어, <code>namespace version1</code> 코드는 <code>version1</code>이라는 네임스페이스를 만듭니다.</li>
			  <li>그런 다음 속성 또는 메서드 선언에 있는 사용자 정의 네임스페이스를 사용하여 속성 또는 메서드에 네임스페이스를 적용합니다. 예를 들어, <code>version1 myProperty:String</code> 코드는 <code>version1</code> 네임스페이스에 속한 <code>myProperty</code>라는 속성을 만듭니다.</li>
			  <li>그런 다음 <code>use</code> 키워드를 사용하거나 네임스페이스 형식으로 식별자를 접두어로 사용하여 네임스페이스를 참조합니다. 예를 들어 <code>use namespace version1;</code> 코드는 이후 행에 대한 <code>version1</code> 네임스페이스를 참조하고, <code>version1::myProperty</code> 코드는 <code>myProperty</code> 속성에 대한 <code>version1</code> 네임스페이스를 참조합니다.</li>
			</ul>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 유효한 식별자가 될 수 있는 네임스페이스의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">uri</span>:<a href="String.html">String</a></code> &mdash; 네임스페이스의 URI(Uniform Resource Identifier)입니다. 이 매개 변수는 선택적입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#package" target="">package</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="native"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">native</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
native function functionName();
class className { 
	native function methodName();
}</pre> </p></td></tr></table><p></p><p><p>함수 또는 메서드가 Flash Player에 의해 기본 코드로 구현되도록 지정합니다. Flash Player는 내부적으로 <code>native</code> 키워드를 사용하여 ActionScript API(Application Programming Interface)에서 함수 및 메서드를 선언합니다. 이 키워드는 사용자의 코드에 사용할 수 없습니다. &nbsp;			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="null"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">null</td><td class="detailHeaderType">기본 표현식 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>null</pre></p></td></tr></table><p></p><p><p>데이터가 제공되지 않은 경우 변수에 지정하거나 함수에서 반환할 수 있는 특수한 값입니다. <code>null</code>을 사용하여 누락된 값이나 정의된 데이터 유형이 없는 값을 나타낼 수 있습니다.
				<p> <code>null</code> 값과 특수 값 <code>undefined</code>를 혼동해서는 안 됩니다. equality 연산자(<code>==</code>)를 사용하여 <code>null</code>과 <code>undefined</code>를 비교하면 동일한 것으로 나타납니다. 그러나 strict equality(<code>===</code>)를 사용하여 <code>null</code>과 <code>undefined</code>를 비교하면 이들은 같지 않은 것으로 나타납니다.</p> 
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 인덱스가 지정된 배열에서 처음 여섯 개의 값을 확인하고 값이 설정되지 않은 경우(값 == null인 경우) 메시지를 출력합니다.
<div class="listing"><pre>

var testArray:Array = new Array();
testArray[0] = "fee";
testArray[1] = "fi";
testArray[4] = "foo";

for (i = 0; i < 6; i++) {
    if (testArray[i] == null) {
        trace("testArray[" + i + "] == null");
    }
}

/* 
testArray[2] == null
testArray[3] == null
testArray[5] == null
*/
</pre></div>	

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="package.html#undefined" target="">undefined</a></div></div><a name="object_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">object_proxy</td><td class="detailHeaderType"> 네임스페이스 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>ObjectProxy 클래스의 메서드를 정의합니다. Proxy 하위 클래스에 Proxy 클래스 메서드와 일치하는 인스턴스 메서드 이름이 포함된 경우 발생할 수 있는 이름 충돌을 피하기 위해 ObjectProxy 클래스 메서드는 자체 네임스페이스에 있습니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="override"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">override</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
override function name() { 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>메서드가 상속된 메서드를 대체하도록 지정합니다. 상속된 메서드를 재정의하려면 <code>override</code> 특성을 사용하고, 이름, 클래스 속성 특성, 매개 변수의 수 및 유형, 반환 유형이 정확히 일치하는지 확인해야 합니다. <code>override</code> 특성을 사용하지 않고 메서드를 재정의하려고 하면 오류가 발생합니다. 마찬가지로 <code>override</code> 특성을 사용할 때 메서드에 일치하는 상속된 메서드가 없으면 오류가 발생합니다.
			<p>다음과 같은 항목에 대해서는 <code>override</code> 특성을 사용할 수 없습니다.</p>
			<ul>
			  <li>변수</li>
			  <li>상수</li>
			  <li>정적 메서드</li>
			  <li>상속되지 않은 메서드</li>
			  <li>인터페이스 메서드를 구현한 메서드</li>
			  <li>수퍼 클래스에서 <code>final</code>로 표시된 상속된 메서드</li>
			</ul>
			<p><code>var</code> 또는 <code>const</code>로 선언된 속성을 재정의할 수는 없지만 기본 클래스 속성을 getter-setter로 만들고 <code>get</code> 및 <code>set</code>을 사용하여 정의된 메서드를 재정의하여 비슷한 기능을 얻을 수 있습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Function.html">Function</a></code> &mdash; 재정의할 메서드 이름입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#final" target="">final</a><br/><a href="statements.html#get" target="">get</a><br/><a href="statements.html#set" target="">set</a></div></div><a name="package"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">package</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
package packageName {
    class someClassName { 
    } 
}</pre> </p></td></tr></table><p></p><p><p>다른 스크립트에서 가져올 수 있도록 코드를 여러 그룹으로 분할해서 구성할 수 있습니다. <code>package</code> 키워드를 사용하여 클래스가 패키지의 멤버임을 나타내야 합니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 패키지 이름입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a><br/><a href="statements.html#class" target="">class</a></div></div><a name="private"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">private</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	private var varName;
	private const kName;
	private function methodName() { 
		// your statements here 
	}
	private namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>변수, 상수 또는 메서드를 선언하거나 정의하는 클래스에서만 변수, 상수 또는 메서드를 사용할 수 있도록 지정합니다. ActionScript 2.0과 달리 ActionScript 3.0에서는 <code>private</code>가 더 이상 하위 클래스에 대한 액세스를 제공하지 않습니다. 게다가 <code>private</code>는 컴파일 타임 및 런타임에서의 액세스를 제한합니다. 기본적으로 변수 또는 함수는 동일한 패키지의 모든 호출자에서 사용할 수 있습니다. 변수나 함수에 대한 액세스를 제한하고자 할 때 이 키워드를 사용합니다. 
			<p>이 키워드는 클래스 정의에만 사용할 수 있으며 인터페이스 정의에는 사용할 수 없습니다. <code>private</code>는 클래스 또는 다른 패키지 레벨 정의에 적용할 수 없습니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; private로 지정할 변수의 이름입니다. 변수가 클래스 내에 있을 때만 private 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; private로 지정할 상수의 이름입니다. 상수가 클래스 내에 있을 때만 private 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; private로 지정할 메서드의 이름입니다. 메서드가 클래스 내에 있을 때만 private 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; private로 지정할 네임스페이스의 이름입니다. 네임스페이스가 클래스 내에 있을 때만 private 특성을 적용할 수 있습니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 private 키워드를 사용하여 클래스 내에서 특정 속성을 숨기는 방법을 보여 줍니다. 
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  public var beta:String = "visible everywhere"; 
}
	
class B extends A {
  function B() {
    alpha = "Access attempt from subclass"; // error
  }
}
</pre></div> 
alpha는 전용 변수이므로 A 클래스의 외부에서 액세스할 수 없습니다. 하위 클래스 B 또한 A 클래스의 외부이므로 이 변수에 액세스할 수 없습니다. 전용 변수에 액세스하려고 시도하면 오류가 발생합니다.
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="protected"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">protected</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	protected var varName;
	protected const kName;
	protected function methodName() { 
		// your statements here 
	}
	protected namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>변수, 상수, 메서드 또는 네임스페이스를 정의하는 클래스 또는 해당 클래스의 하위 클래스에서만 변수, 상수, 메서드 또는 네임스페이스를 사용할 수 있도록 지정합니다. ActionScript 3.0의 <code>protected</code> 정의는 ActionScript 2.0 버전의 <code>private</code> 정의와 비슷하지만 <code>protected</code>가 컴파일 타임 및 런타임에서의 액세스를 제한한다는 점이 다릅니다. 기본적으로 변수 또는 함수는 동일한 패키지의 모든 호출자에서 사용할 수 있습니다. 변수나 함수에 대한 액세스를 제한하고자 할 때 이 키워드를 사용합니다.  
				<p>이 키워드는 클래스 정의에만 사용할 수 있으며 인터페이스 정의에는 사용할 수 없습니다. <code>private</code>는 클래스 또는 다른 패키지 레벨 정의에 적용할 수 없습니다.</p>
				<p>ActionScript 3.0의 <code>protected</code> 정의는 Java 프로그래밍 언어의 <code>protected</code> 정의보다 제한적입니다. ActionScript 3.0 <code>protected</code>는 하위 클래스에 대한 액세스를 엄격하게 제한하는 반면 Java <code>protected</code>는 동일한 패키지 내의 모든 클래스에 대한 액세스를 허용합니다. 예를 들어, <code>Base</code>라는 클래스에 <code>protected</code>로 표시된 속성이 들어 있는 경우 ActionScript 3.0에서는 Base를 확장한 클래스만 protected 속성에 액세스할 수 있습니다. Java에서는 Base의 하위 클래스가 아니더라도 Base와 동일한 패키지에 있는 모든 클래스에서 protected 속성에 액세스할 수 있습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; protected로 지정할 변수의 이름입니다. 변수가 클래스 내에 있을 때만 protected 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; protected로 지정할 상수의 이름입니다. 상수가 클래스 내에 있을 때만 protected 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; protected로 지정할 메서드의 이름입니다. 메서드가 클래스 내에 있을 때만 protected 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; protected로 지정할 네임스페이스의 이름입니다. 네임스페이스가 클래스 내에 있을 때만 protected 특성을 적용할 수 있습니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 클래스 A에서 protected 클래스 변수를 만들고 클래스 B가 클래스 A의 하위 클래스이므로 클래스 B의 변수에 액세스할 수 있음을 보여 줍니다.
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  protected var beta:String = "visible inside class A and its subclasses"; 
}
	
class B extends A {
  public function B() {
    beta = "Access attempt from subclass succeeded";
    trace(beta);  // Access attempt from subclass succeeded
  }
}
</pre></div>
			
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="public"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">public</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
public var varName
public const kName
public function functionName()  { 
	// your statements here 
}
public class className {
	// your statements here 
}
public namespace nsName
</pre> </p></td></tr></table><p></p><p><p>모든 호출자가 클래스, 변수, 상수 또는 메서드를 사용할 수 있도록 지정합니다. 클래스, 변수 및 메서드는 기본적으로 내부 항목이므로 현재 패키지 내에서만 볼 수 있습니다. 클래스, 변수 또는 메서드를 모든 호출자에 표시하려면 <code>public</code> 특성을 사용해야 합니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; public으로 지정할 클래스의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; public으로 지정할 변수의 이름입니다. 변수가 클래스에 속해 있는지 여부와 상관없이 public 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; public으로 지정할 상수의 이름입니다. 상수가 클래스에 속해 있는지 여부와 상관없이 public 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; public으로 지정할 함수 또는 메서드의 이름입니다. 함수가 클래스에 속해 있는지 여부와 상관없이 public 특성을 적용할 수 있습니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; public으로 지정할 네임스페이스의 이름입니다. 네임스페이스가 클래스에 속해 있는지 여부와 상관없이 public 특성을 적용할 수 있습니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 클래스 파일에서 공용 변수를 사용하는 방법을 보여 줍니다. 
<div class="listing"><pre>class User { 
	public var age:Number; 
	public var fname:String; 
} // end of class User definition
 
var jimmy:User = new User(); 
jimmy.age = 27; 
jimmy.fname = "jimmy";
trace(jimmy.age, jimmy.fname); // 27 jimmy</pre></div> 
User 클래스의 공용 변수 중 하나를 전용 변수로 변경하는 경우 User 클래스 외부에서 해당 변수에 액세스하려고 하면 컴파일 타임 오류가 발생합니다. 

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a></div></div><a name="return"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">return</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function functionName () {
	return [expression]
}</pre></p></td></tr></table><p></p><p><p>실행 시에 호출하는 함수에 즉시 반환됩니다. <code>return</code> 문 뒤에 표현식이 있는 경우에는 해당 표현식이 평가되고 결과가 반환됩니다. 
			<p>함수 정의에 반환 유형이 들어 있는 경우 <code>return</code> 문은 표현식 뒤에 있어야 합니다. 반환 유형이 지정되지 않은 채로 <code>return</code> 문이 단독으로 사용된 경우에는 <code>undefined</code>가 반환됩니다.</p>
			<p>여러 값을 반환할 수는 없습니다. 반환값을 여러 개 지정하면 마지막 값만 반환됩니다. 다음 예제에서는 <code>c</code>가 반환됩니다.</p> <pre>return a, b, c ;</pre> <p>여러 값을 반환해야 하는 경우에는 대신 배열이나 객체를 사용합니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 함수의 값으로 평가하고 반환할 표현식입니다. 이 매개 변수는 선택적입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 sum() 함수의 본문에서 return 문을 사용하여 세 매개 변수의 추가된 값을 반환합니다. 다음 코드 행에서는 sum()을 호출하여 반환값을 변수 newValue에 할당합니다. 
<div class="listing"><pre>function sum(a:Number, b:Number, c:Number):Number { 
	return (a + b + c); 
} 
var newValue:Number = sum(4, 32, 78); 
trace(newValue); // 114</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#function" target="">function</a></div></div><a name="set"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">set</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function set property(newValue:*) : void{ 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>공용 인터페이스에 속성으로 표시되는 메서드인 setter를 정의합니다. setter는 <code>var</code> 키워드로 선언된 속성 값을 설정하는 특수 메서드입니다. 다른 메서드와는 달리 setter는 괄호(<code>()</code>) 없이 호출되므로 변수처럼 보입니다.
			<p>setter를 사용하면 전용 속성에 대한 공용 인터페이스를 만들어서 정보 은폐 원칙을 적용할 수 있습니다. 정보 은폐 기술을 사용하면 전용 속성의 기본 구현이 변경되더라도 공용 인터페이스를 그대로 유지할 수 있습니다.</p>
			<p>또한 setter를 사용하면 하위 클래스에서 재정의할 수 있는 반면 <code>var</code>로 선언된 속성은 하위 클래스에서 재정의할 수 없습니다.</p>
			<p>setter의 반환 유형은 <code>void</code>이거나 지정되지 않아야 합니다.</p>
			<p>setter와 getter를 결합하여 읽기/쓰기 속성을 만들 수 있습니다. 읽기 전용 속성을 만들려면 해당 setter는 만들지 않고 getter만 만듭니다. 쓰기 전용 속성을 만들려면 해당 getter는 만들지 않고 setter만 만듭니다.</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; set이 수정하는 속성의 식별자이며, 이 값은 해당 get 명령에 사용된 값과 동일해야 합니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">newValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 대입할 새 값입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 getter-setter를 정의하여 age라는 읽기/쓰기 속성을 만듭니다.
<div class="listing"><pre>
package {
	class User { 
	    private var userAge:Number; 
	    
	    public function get age():Number {
	    	return userAge;
	    }
	    
	    public function set age(x:Number):void {
	    	userAge = x;	
	    }
	} 
} 
</pre></div>
스크립트에 다음 코드를 입력합니다.
<div class="listing"><pre>
var myUser:User = new User();
myUser.age = 25;
trace(myUser.age); // 25
</pre></div>
			
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#get" target="">get</a></div></div><a name="static"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">static</td><td class="detailHeaderType">특성 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>class someClassName{ 
	static var varName; 
	static const kName;
	static function methodName() { 
		// your statements here
	} 
}</pre> </p></td></tr></table><p></p><p><p>변수, 상수 또는 메서드가 클래스의 인스턴스가 아니라 클래스에 속한 것으로 지정합니다.
			<p>정적 클래스 멤버에 액세스하려면 인스턴스 이름 대신 클래스 이름을 사용합니다. 예를 들어, Date 클래스에는 다음 구문을 사용해서 호출할 수 있는 <code>parse()</code>라는 정적 메서드가 있습니다.</p>
			<div class="listing"><pre>Date.parse()</pre></div>
			<p><code>parse()</code> 메서드는 Date 클래스의 인스턴스에서 호출할 수 없습니다. 예를 들어, 다음 코드에서는 오류가 발생합니다.</p>
			<div class="listing"><pre>var myDate:Date = new Date();
            myDate.parse("Jan 01 00:00:00 2006"); // error</pre></div>
			<p><code>static</code>은 클래스 정의에만 사용할 수 있으며 인터페이스 정의에는 사용할 수 없습니다.</p>
			<p>정적 클래스 멤버는 상속되지 않습니다. Java 또는 C++에서처럼 하위 클래스의 이름을 사용하여 정적 클래스 멤버를 참조할 수 없습니다. 그러나 다음 예제를 참조하십시오.</p>
			<p>정적 메서드 내에서는 <code>super</code> 문이나 <code>this</code> 키워드를 사용할 수 없습니다.</p>
			
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; static으로 지정할 변수의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; static으로 지정할 상수의 이름입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; static으로 지정할 메서드의 이름입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 static 키워드를 사용하여 이제까지 생성된 클래스 인스턴스의 수를 추적하는 카운터를 만드는 방법을 보여 줍니다. numInstances 변수는 정적 변수이기 때문에 인스턴스마다 생성되는 것이 아니라 클래스 전체에 대해 한 번만 생성됩니다. Users.as라는 ActionScript 파일을 새로 만들고 다음과 같은 코드를 입력합니다. 
<div class="listing"><pre>class Users { 
	private static var numInstances:Number = 0; 
	function Users() { 
		numInstances++; 
	} 
	static function get instances():Number { 
		return numInstances; 
	} 
}</pre></div> 
스크립트에 다음 코드를 입력합니다.
<div class="listing"><pre>
trace(Users.instances); 
var user1:Users = new Users(); 
trace(Users.instances); 
var user2:Users = new Users(); 
trace(Users.instances); 
</pre></div>
다음 예제에서는 Users 클래스를 확장하여 정적 변수 및 메서드가 상속되지 않아도 하위 클래스에서 참조될 수 있음을 보여 줍니다.
<div class="listing"><pre>
class PowerUsers extends Users{
    function PowerUsers() {
        instances++;  // unqualified reference to static property Users.instances is legal
    }
}

trace(PowerUsers.instances); // error, cannot access static property using PowerUsers class
</pre></div>

			<p></p></div><a name="super"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">super</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>super([arg1, ..., argN])
super.method([arg1, ..., argN])</pre></p></td></tr></table><p></p><p><p>메서드나 생성자의 수퍼 클래스 또는 부모 버전을 호출합니다. 클래스 생성자 본문 내에서 사용되는 <code>super()</code> 문은 생성자의 수퍼 클래스 버전을 호출합니다. 수퍼 클래스 생성자를 호출할 경우에는 올바른 개수의 인수가 있어야 합니다. 수퍼 클래스 생성자는 명시적으로 호출하지 않더라도 항상 호출됩니다. 명시적으로 호출하지 않은 경우에는 인수가 없는 호출이 하위 클래스 생성자 본문의 첫 번째 명령문 앞에 자동으로 삽입됩니다. 즉 하위 클래스에서 생성자 함수를 정의하고 수퍼 클래스 생성자가 하나 이상의 인수를 받는 경우에는 올바른 수의 인수를 가지고 수퍼 클래스 생성자를 명시적으로 호출해야 하며, 그렇지 않은 경우 오류가 발생합니다. 그러나 수퍼 클래스 생성자 호출은 하위 클래스 생성자의 첫 번째 명령문이 아니어도 됩니다. ActionScript 2.0에서는 첫 번째 명령문이어야 했습니다.
			<p>인스턴스 메서드의 본문에서 <code>super</code>를 dot(.) 연산자와 함께 사용하여 수퍼 클래스 버전의 메서드를 호출하고 <code>(arg1 ... argN)</code> 인수를 선택적으로 수퍼 클래스 메서드에 전달할 수 있습니다. 이 방법은 수퍼 클래스 메서드에 비헤이비어를 추가할 뿐만 아니라 수퍼 클래스 메서드를 호출하여 원래 비헤이비어를 수행하는 하위 클래스 메서드를 만드는 데 유용합니다.</p>
			<p><code>super</code> 문은 정적 멤버에서 사용할 수 없습니다.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">method</span>:<a href="Function.html">Function</a></code> &mdash; 수퍼 클래스에서 호출할 메서드입니다.</td></tr><tr><td width="20px"></td><td><code><span class="label">argN</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 메서드의 수퍼 클래스 버전 또는 수퍼 클래스의 생성자 함수에 전달되는 선택적 매개 변수입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="switch"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">switch</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>
switch (expression) {
	caseClause: 
	[defaultClause:] 
}</pre></p></td></tr></table><p></p><p><p>표현식의 값에 따라 여러 명령문 중 하나에 제어가 전달됩니다. 모든 <code>switch</code> 문에는 표현식과 일치하는 <code>case</code> 문이 없을 때 실행되는 기본 case가 있어야 합니다. 각 <code>case</code> 문에는 다음 case로 진행하는 것을 방지하기 위한 <code>break</code> 문이 들어 있어야 합니다. case 문이 조건 통과되면 다음 <code>case</code> 문이 테스트 표현식과 일치하지 않더라도 해당 case 문의 코드가 실행됩니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 모든 표현식입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 default case가 실행되는 switch 문을 정의합니다.

<div class="listing"><pre>

var switchExpression:int = 3;
		
switch (switchExpression) {
	case 0:
		trace(0);
		break;
	case 1:
		trace(1);
		break;
	case 2:
		trace(2);
		break;
	default:
		trace("Not 0, 1, or 2");
}

// Not 0, 1, or 2
</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="operators.html#strict_equality" target="">=== (strict equality)</a><br/><a href="statements.html#case" target="">case</a><br/><a href="statements.html#default" target="">default</a></div></div><a name="this"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">this</td><td class="detailHeaderType">기본 표현식 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>this</pre></p></td></tr></table><p></p><p><p>메서드의 포함 객체에 대한 참조입니다. 스크립트가 실행되면 <code>this</code> 키워드는 스크립트를 포함한 객체를 참조합니다. 메서드 본문 내에서 <code>this</code> 키워드는 호출된 메서드를 포함한 클래스 인스턴스를 참조합니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>동적 클래스에 정의된 함수를 호출하려면 this를 사용하여 적절한 범위에서 함수를 호출해야 합니다.
<div class="listing"><pre>
// incorrect version of Simple.as
/*
dynamic class Simple {
    function callfunc() {
        func();
    }
}
*/
// correct version of Simple.as
dynamic class Simple {
    function callfunc() {
        this.func();
    }
}
</pre></div>
스크립트에 다음 코드를 추가합니다.
<div class="listing"><pre>
var simpleObj:Simple = new Simple();
simpleObj.func = function() {
	trace("hello there");
}
simpleObj.callfunc();
</pre></div>
앞의 코드는 callfunc() 메서드에서 this를 사용할 때 작동합니다. 그러나 위 예제에서 주석 처리했던 잘못된 버전의 Simple.as를 사용할 경우 구문 오류가 발생합니다.

			
			<p></p></div><a name="throw"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">throw</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>throw expression </pre></p></td></tr></table><p></p><p><p><code>catch</code> 코드 블록이 처리할 수 있거나 <em>catch</em>할 수 있는 오류를 생성하거나 <em>throw</em>합니다. <code>catch</code> 블록으로 예외를 catch할 수 없으면 throw된 값의 문자열 표시가 출력 패널로 전송됩니다. <code>catch</code> 또는 <code>finally</code> 블록으로 예외를 catch할 수 없으면 throw된 값의 문자열 표시가 로그 파일로 전송됩니다. <p>일반적으로 Error 클래스 또는 하위 클래스의 인스턴스를 throw합니다. 자세한 내용은 예제 단원을 참조하십시오.</p></p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; ActionScript 표현식 또는 객체입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>이 예제에서 checkEmail()이라는 함수는 전달된 문자열이 올바른 전자 메일 주소 형식인지 확인합니다. 문자열에 @ 심볼이 없으면 함수에서 오류가 throw됩니다. 
<div class="listing"><pre>function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new Error("Invalid email address"); 
	} 
} 
checkEmail("someuser_theirdomain.com");</pre></div> 
그런 후 다음 코드는 try 코드 블록 내에서 동일한 함수인 checkEmail() 함수를 호출합니다. 전자 메일 문자열에 유효한 전자 메일 주소가 들어 있지 않으면 trace 문에서 오류 메시지를 출력합니다.
<div class="listing"><pre>
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e); 
}
// Error: Invalid email address.</pre></div> 
다음 예제에서는 Error 클래스의 하위 클래스가 throw됩니다. 이 하위 클래스의 인스턴스를 throw하기 위해 checkEmail() 함수를 수정합니다.
<div class="listing"><pre>
// Define Error subclass InvalidEmailError 
class InvalidEmailAddress extends Error { 
    public function InvalidEmailAddress() {
    	message = "Invalid email address."; 
    }
}
</pre></div> 
스크립트에 다음 코드를 입력합니다.
<div class="listing"><pre>
import InvalidEmailAddress; 
function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new InvalidEmailAddress(); 
	} 
} 
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e);
}
// Error: Invalid email address.</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="Error.html" target="">Error 클래스</a><br/><a href="statements.html#try..catch..finally" target="">try..catch..finally</a></div></div><a name="true"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">true</td><td class="detailHeaderType">기본 표현식 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>true</pre></p></td></tr></table><p></p><p><p>true를 나타내는 부울 값입니다. 부울 값은 <code>true</code> 또는 <code>false</code>이며, <code>true</code>의 반대는 <code>false</code>입니다. 자동 데이터 유형 지정 기능이 <code>true</code>를 숫자로 변환하면 1이 됩니다. <code>true</code>를 문자열로 변환하면 <code>"true"</code>가 됩니다.
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 if 문에서 true를 사용하는 방법을 보여 줍니다.
<div class="listing"><pre>

var shouldExecute:Boolean;
// ...
// code that sets shouldExecute to either true or false goes here
// shouldExecute is set to true for this example:

shouldExecute = true;

if (shouldExecute == true) {
    trace("your statements here");
}

// true is also implied, so the if statement could also be written:
// if (shouldExecute) {
//         trace("your statements here");
// }</pre></div>
다음 예제에서는 자동 데이터 유형 지정 기능이 true를 숫자 1로 변환하는 방법을 보여 줍니다.
<div class="listing"><pre>

var myNum:Number;
myNum = 1 + true;
trace(myNum); // 2</pre></div>

			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="Boolean.html" target="">Boolean 클래스</a><br/><a href="statements.html#false" target="">false</a></div></div><a name="try..catch..finally"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">try..catch..finally</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>try { 
    // try block 
} finally { 
    // finally block  
} 

try { 
    // try block 
} catch(error[:ErrorType1]) {
    // catch block 
} [catch(error[:ErrorTypeN]) { 
    // catch block 
}] [finally {
    // finally block 
}]</pre></p></td></tr></table><p></p><p><p>오류가 발생할 수 있는 코드 블록을 포함하고 오류에 대응합니다. <code>try..catch..finally</code> 문을 사용하여 구현되는 예외 처리는 ActionScript 3.0의 런타임 오류 조건을 처리하는 기본 메커니즘입니다. 런타임 오류가 발생하면 예외가 throw되어 정상적인 실행이 중지되고 <code>Error</code> 유형의 특수 객체가 만들어집니다. 그런 다음 사용할 수 있는 첫 번째 <code>catch</code> 블록에 오류 객체가 전달 또는 <em>throw</em>됩니다. 사용할 수 있는 <code>catch</code> 블록이 없는 경우에는 예외가 catch되지 않는 예외인 것으로 간주됩니다. catch되지 않는 예외가 발생하면 스크립트가 종료됩니다.
			<p>코드에서 <code>throw</code> 문을 사용하여 예외를 명시적으로 throw할 수 있습니다. 아무 값이나 throw할 수 있지만 유연성이 좋고 Flash Player의 동작과 일치하는 객체를 throw하는 것이 좋습니다.</p>
			<p>예외가 Flash Player에서 throw되었는지, 사용자 코드에서 throw되었는지 상관없이 예외를 catch하려면 예외를 throw하는 코드를 <code>try</code> 블록에 배치합니다. <code>try</code> 블록 내의 코드가 예외를 throw하면 <code>catch</code> 블록(있는 경우)에 제어가 전달된 다음 <code>finally</code> 블록(있는 경우)으로 전달됩니다. <code>finally</code> 블록은 예외가 throw되었는지 여부에 관계없이 항상 실행됩니다. <code>try</code> 블록 내의 코드가 예외를 throw하지 않은 경우, 즉 <code>try</code> 블록이 정상적으로 완료된 경우에는 <code>catch</code> 블록 내의 코드가 무시되지만 <code>finally</code> 블록 내의 코드는 실행됩니다. <code>finally</code> 블록은 <code>try</code> 블록이 <code>return</code> 문을 사용하여 종료된 경우에도 실행됩니다. </p>
			<p><code>try</code> 블록 다음에는 <code>catch</code> 블록이나 <code>finally</code> 블록 또는 둘 모두가 와야 합니다. 단일 <code>try</code> 블록에는 여러 <code>catch</code> 블록이 포함될 수 있지만 <code>finally</code> 블록은 하나만 포함됩니다. <code>try</code> 블록은 무제한 중첩될 수 있습니다.</p> 
			<p><code>catch</code> 핸들러에 지정된 <code>error</code> 매개 변수는 <code>e</code>, <code>theException</code> 또는 <code>x</code>와 같은 간단한 식별자여야 합니다. 매개 변수의 유형도 지정할 수 있습니다. 여러 <code>catch</code> 블록을 사용할 때 유형 지정된 매개 변수를 사용하면 단일 <code>try</code> 블록에서 throw된 여러 유형의 오류 객체를 catch할 수 있습니다.</p> 
			<p>throw된 예외가 객체인 경우 throw된 객체가 특정 유형의 하위 클래스이면 유형이 일치하게 됩니다. 특정 유형의 오류가 throw되면 해당 오류를 처리하는 <code>catch</code> 블록이 실행됩니다. 지정된 유형이 아닌 예외가 throw되면 <code>catch</code> 블록이 실행되지 않고 예외는 자동으로 <code>try</code> 블록 밖으로 throw되어 일치하는 <code>catch</code> 핸들러로 이동합니다. </p> 
			<p>오류가 함수 내에서 throw되고 함수에 <code>catch</code> 핸들러가 없으면 Flash Player는 <code>catch</code> 블록이 발견될 때까지 해당 함수는 물론 호출자 함수도 종료합니다. 이러한 과정에서 <code>finally</code> 핸들러는 모든 단계에서 호출됩니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">error</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; throw 문에서 throw된 표현식으로, 주로 Error 클래스 또는 해당 하위 클래스 중 하나의 인스턴스입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 try..catch 문을 보여 줍니다. try 블록 내의 코드에 유효하지 않은 연산이 들어 있습니다. sprite는 자신을 자식으로 추가할 수 없습니다. 따라서 Flash Player가 예외를 throw하고, ArgumentError 유형의 객체를 해당 catch 블록에 전달합니다.
<div class="listing"><pre>
import flash.display.Sprite;

var spr:Sprite = new Sprite();
try {
	spr.addChild(spr);
}
catch (e:ArgumentError) {
	trace (e); // ArgumentError: Error #2024: An object may not be added as a child of itself.
}
</pre></div> 
다음 예제에서 RecordSetException 및 MalformedRecord 객체는 Error 클래스의 하위 클래스입니다.  
<div class="listing"><pre>
class RecordSetException extends Error { 
	public function RecordSetException () {
		message = "Record set exception occurred."; 
	}
}

class MalformedRecord extends Error { 
	public function MalformedRecord {
		message = "Malformed record exception occurred."; 
	}
}</pre></div> 

RecordSet 클래스의 sortRows() 메서드 내에서 발생한 예외의 유형에 따라 미리 정의된 오류 객체 중 하나가 throw됩니다. 다음 예제에서는 이 코드가 어떤 식으로 실행되는지 보여 줍니다. 
<div class="listing"><pre>
class RecordSet { 
	public function sortRows() { 
		var returnVal:Number = randomNum(); 
		if (returnVal == 1) { 
			throw new RecordSetException(); 
		} 
		else if (returnVal == 2) { 
			throw new MalformedRecord(); 
		} 
	}
	public function randomNum():Number { 
		return Math.round(Math.random() * 10) % 3; 
	}
}</pre></div> 
마지막으로 다음 코드에서는 RecordSet 클래스 인스턴스의 sortRows() 메서드를 호출합니다. 이 코드는 sortRows()에 의해 throw된 각 유형의 오류 객체에 대한 catch 블록을 정의합니다.
<div class="listing"><pre>import RecordSet; 
var myRecordSet:RecordSet = new RecordSet();
try { 
	myRecordSet.sortRows(); 
	trace("everything is fine"); 
} 
catch (e:RecordSetException) { 
	trace(e.toString()); 
} 
catch (e:MalformedRecord) { 
	trace(e.toString()); 
}</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="Error.html" target="">Error 클래스</a><br/><a href="statements.html#throw" target="">throw</a></div></div><a name="use_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">use namespace</td><td class="detailHeaderType">지시문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>use namespace ns1[, ns2, ...nsN]</pre></p></td></tr></table><p></p><p><p>지정된 네임스페이스가 열려 있는 네임스페이스 세트에 추가되도록 합니다. 지정된 네임스페이스는 현재 코드 블록이 종료될 때 열려 있는 네임스페이스 세트에서 제거됩니다. <code>use namespace</code> 지시문은 프로그램의 최상위 수준, 즉 패키지 정의 또는 클래스 정의에 나타날 수 있습니다.</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">nsN</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 열려 있는 네임스페이스 세트에 추가할 하나 이상의 네임스페이스입니다.</td></tr></table><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#default_xml_namespace" target="">default xml namespace</a><br/><a href="statements.html#namespace" target="">namespace</a><br/><a href="XML.html" target="">XML 클래스</a></div></div><a name="var"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">var</td><td class="detailHeaderType">정의 키워드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>var variableName [= value1][...,variableNameN[=valueN]] </pre></p></td></tr></table><p></p><p><p>변수를 지정합니다. 함수 내에서 변수를 선언하면 로컬 변수가 됩니다. 로컬 변수는 함수에 대해 정의되며 함수 호출이 끝나면 만료됩니다. 
			 
			<p>다른 객체의 범위에 있는 변수는 로컬 변수로 선언할 수 없습니다.</p> 
<pre>my_array.length = 25; // ok 
var my_array.length = 25; // syntax error </pre> 
			<p>데이터 유형 앞에 콜론 문자를 추가하면 데이터 유형을 변수에 대입할 수 있습니다.</p>
			<p>각각의 선언을 쉼표로 구분하면 여러 변수를 하나의 명령문에서 선언할 수 있습니다. 단, 이와 같은 구문은 코드의 명확성을 떨어뜨릴 수 있습니다.</p>
			<pre>var first:String = "Bart", middle:String = "J.", last:String = "Bartleby";</pre>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 식별자입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 ActionScript에서는 제품 이름 배열을 새로 만듭니다. Array.push는 배열의 끝에 요소를 하나 추가합니다. 
<div class="listing"><pre>
var product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); 
trace(product_array); 
// Studio,Dreamweaver,Flash,ColdFusion,Contribute,Breeze,Flex</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#const" target="">const</a></div></div><a name="while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">while</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>while (condition) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>조건을 평가하고 조건이 <code>true</code>로 평가되면 하나 이상의 명령문을 실행한 후 루프로 돌아가서 조건을 다시 평가합니다. 조건이 <code>false</code>로 평가되면 명령문이 생략되고 루프가 종료됩니다. 
			<p><code>while</code> 문은 다음과 같은 일련의 단계를 수행합니다. 1~4단계까지의 각 반복을 루프 <em>반복</em>이라고 합니다. 다음 단계와 같이 반복을 시작할 때마다 조건을 테스트합니다.</p> 
			<ol> 
				<li><code>condition</code> 표현식이 평가됩니다.</li> 
				<li><code>condition</code>이 <code>true</code> 또는 부울 값 <code>true</code>로 변환되는 값(예: 0이 아닌 숫자)으로 평가되면 3단계로 이동합니다. 그렇지 않으면 <code>while</code> 문이 완료되고 <code>while</code> 루프 이후의 다음 명령문에서 실행이 재개됩니다.</li> 
				<li>명령문 블록 <code>statement(s)</code>를 실행합니다. <code>continue</code> 문이 나타나면 나머지 명령문을 건너뛰고 1단계로 이동합니다. <code>break</code> 문이 나타나면 <code>while</code> 문이 완료되고 <code>while</code> 루프 이후의 다음 명령문에서 실행이 재개됩니다.</li> 
				<li>1단계로 이동합니다.</li> 
			</ol> 
			<p>일반적으로 반복은 카운터 변수가 지정된 값보다 작을 때 액션을 수행하기 위해 사용됩니다. 각 루프가 끝나면 지정된 값이 될 때까지 카운터가 증가합니다. 이때 <code>condition</code>은 더 이상 <code>true</code>가 아니며 루프가 끝납니다.</p> 
			<p>명령문을 하나만 실행할 경우에는 <code>while</code> 문이 실행할 명령문을 둘러싸는 중괄호(<code>{}</code>)가 필요하지 않습니다.</p>
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; true 또는 false로 평가되는 표현식입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 while 문을 사용하여 표현식을 테스트합니다. i 값이 20보다 작으면 i 값이 추적됩니다. 조건이 더 이상 true가 아니면 루프가 종료됩니다. 
<div class="listing"><pre>
var i:Number = 0; 
while (i < 20) { 
	trace(i); 
	i += 3; 
}
/*
0 
3 
6 
9 
12
15 
18
*/</pre></div>
			<p></p><p><span class="label"> 관련 API 요소 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#do..while" target="">do..while</a></div></div><a name="with"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">with</td><td class="detailHeaderType">명령문</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">구문</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>with (object:Object) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>명령문을 실행하는 데 사용할 기본 객체를 만듭니다. 이 객체를 사용하면 작성해야 하는 코드의 양을 줄일 수 있습니다.
			<p><code>object</code> 매개 변수는 <code>statement(s)</code> 매개 변수의 속성, 변수 및 함수를 읽는 컨텍스트가 됩니다. 예를 들어, <code>object</code>가 <code>my_array</code>이고 지정된 두 개의 속성이 <code>length</code> 및 <code>concat</code>이면 이러한 속성은 자동으로 <code>my_array.length</code> 및 <code>my_array.concat</code>로 판독됩니다. 다른 예로, <code>object</code>가 <code>state.california</code>이면 <code>with</code> 문 내의 액션 또는 명령문은 <code>california</code> 인스턴스 내에서 호출됩니다.</p> 
			<p><code>statement(s)</code> 매개 변수에서 식별자 값을 찾기 위해 ActionScript는 <code>object</code>가 지정한 범위 체인이 시작되는 곳에서 시작하고 특정 순서대로 범위 체인의 각 수준에서 식별자를 검색합니다. </p> 
			<p>식별자를 확인하기 위해 <code>with</code> 문에서 사용하는 범위 체인은 다음 목록의 첫 항목에서 시작하여 마지막 항목까지 계속됩니다.</p> 
			<ul> 
				<li>가장 안쪽에 있는 <code>with</code> 문의 <code>object</code> 매개 변수에 지정된 객체</li> 
				<li>가장 바깥쪽에 있는 <code>with</code> 문의 <code>object</code> 매개 변수에 지정된 객체</li> 
				<li>Activation 객체(함수에서 호출되는 로컬 변수를 갖고 있는 함수를 스크립트에서 호출할 때 자동으로 만들어지는 임시 객체)</li> 
				<li>현재 실행 중인 스크립트가 포함된 객체</li> 
				<li>전역 객체(Math와 String 같은 내장 객체)</li> 
			</ul> 
			<p><code>with</code> 문 안에서 변수를 설정하려면 변수가 <code>with</code> 문 외부에 선언되어 있거나 변수를 활성화할 타임라인의 전체 경로를 입력해야 합니다. 변수를 선언하지 않고 <code>with</code> 문에 설정하면 <code>with</code> 문은 범위 체인에 따라 값을 찾습니다. 변수가 아직 없으면 <code>with</code> 문이 호출된 타임라인에 새 값이 설정됩니다.</p> 
			</p></p><p></p><span class="label">매개 변수</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; ActionScript 객체 또는 동영상 클립의 인스턴스입니다.</td></tr></table><br/><span class="label">예제</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span><br/>다음 예제에서는 someOther_mc 인스턴스의 _x 속성과 _y 속성을 설정한 후 someOther_mc에 프레임 3으로 이동한 후 중지하도록 지시합니다. 
with (someOther_mc) { 
	_x = 50; 
	_y = 100; 
	gotoAndStop(3); 
} 
다음 코드 예제에서는 with 문을 사용하지 않고 앞의 코드를 작성하는 방법을 보여 줍니다. 
someOther_mc._x = 50; 
someOther_mc._y = 100; 
someOther_mc.gotoAndStop(3); 
with 문은 범위 체인 목록에 있는 여러 항목을 동시에 액세스할 때 유용합니다. 다음 예제에서는 내장 Math 객체가 범위 체인의 맨 앞에 옵니다. Math를 기본 객체로 설정하면 cos, sin, PI 식별자가 각각 Math.cos, Math.sin, Math.PI로 확인됩니다. a, x, y 및 r 식별자는 Math 객체의 메서드나 속성은 아니지만 polar() 함수의 객체 활성화 범위 내에 존재하기 때문에 해당 로컬 변수로 확인됩니다. 
<div class="listing"><pre>function polar(r:Number):void { 
	var a:Number, x:Number, y:Number; 
	with (Math) { 
		a = PI * pow(r, 2); 
		x = r * cos(PI); 
		y = r * sin(PI / 2); 
	} 
	trace("area = " + a); 
	trace("x = " + x); 
	trace("y = " + y); 
} polar(3);
/* 
area = 28.2743338823081 
x = -3 
y = 3
*/</pre></div>
			<p></p></div><p></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:35 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ko_KR/legalnotices/index.html">법적 고지 사항</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">온라인 개인 정보 보호 정책</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">영어로 표시되는 이유</span>
				</div>
				<div class="white_content_body">
					<b>ActionScript 3.0 참조 설명서의 내용이 영어로 나타납니다.</b><br><br>
					ActionScript 3.0 참조 설명서 중 일부는 전체 언어로 번역되지 않았습니다. 언어 요소가 번역되지 않은 경우 영어로 나타납니다. 예를 들어 ga.controls.HelpBox 클래스는 어떤 언어로도 번역되지 않았습니다. 그러므로 한국어 버전의 참조 설명서에서 ga.controls.HelpBox 클래스는 영어로 나타납니다.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:35 PM Z  -->
