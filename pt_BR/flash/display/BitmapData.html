<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Referência do ActionScript&reg; 3.0 para Adobe&reg; Flash&reg; Platform"><meta name="lang" content="pt-br"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Referência da API Adobe ActionScript&reg; 3 (AS3  )</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Runtimes";
			var productsLabel = "Produtos";
			var noneLabel = "Nenhum";
			var qsearchBoxLabel = "Pesquisa rápida";
			var qsearchText = "Termo não encontrado";
			var ajaxErrorMsg="Erro ao carregar a página";
			var ajaxErrorTryMsg="Tentar novamente";
			var ajaxLoadingMsg="Ainda carregando";
			var cancelMsg = "Cancelar";
			var classesText = "Classes";
			var strJiveReply = "Esta pergunta foi publicada em resposta ao seguinte artigo: "
			var showFilters = "Mostrar filtros";
			var hideFilters = "Ocultar filtros";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Referência do ActionScript<sup>&reg;</sup> 3.0 para Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Início </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">Exibir listas de Pacotes e Classes</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">Ocultar listas de Pacotes e Classes</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Pacotes </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Classes </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Novidades </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Índice </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Apêndices </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Por que inglês?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/pt_BR/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filtros:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Recuperando dados do servidor...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Recuperando dados do servidor...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> Propriedades </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Propriedades </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Construtor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> Métodos </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> Constantes globais </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> Eventos </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> Estilos </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> Partes da capa </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> Estados da capa </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> Efeitos </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> Constantes </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> Funções globais </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">Funções</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> Interfaces </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> Classes </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> Exemplos </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Classes
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Pacote</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">Classe</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">Herança</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">Implementações</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 A classe BitmapData permite trabalhar com os dados (pixels) de um objeto <span>Bitmap</span>. Você pode usar os métodos da classe BitmapData para criar imagens bitmap transparentes ou opacas arbitrariamente dimensionadas e manipulá-las de várias maneiras em tempo de execução. <span>Você também pode acessar o BitmapData para uma imagem bitmap carregada com a classe <code>flash.display.Loader</code>.</span> 
 
               <p>Essa classe permite separar operações de renderização de bitmap das rotinas internas de atualização da exibição do Flash Player. Ao manipular diretamente um objeto BitmapData, você pode criar imagens complexas sem fica sujeito à sobrecarga por quadro do redesenho constante do conteúdo a partir de dados vetoriais.</p>
 
               <p>Os métodos da classe BitmapData oferecem suporte a efeitos que não estão disponíveis por meio dos filtros disponíveis a objetos de exibição não bitmap.</p>
 
               <p>Um objeto BitmapData contém uma matriz de dados de pixel. Esses dados podem representar um bitmap totalmente opaco ou um bitmap transparente que contém dados de canais alfa. Qualquer um desses tipos de objeto BitmapData é armazenado como um buffer de inteiros de 32 bits. Cada inteiro de 32 bits determina as propriedades de um único pixel no bitmap.</p>
 
               <p>Cada inteiro de 32 bits é uma combinação de quatro valores de canal de 8 bits (de 0 a 255) que descrevem a transparência de alfa e os valores de vermelho, verde e azul (ARGB) do pixel. (Para valores ARGB, o byte mais significativo representa o valor do canal alfa, seguido de vermelho, verde e azul.)</p>
 
               <p>Os quatro canais (alfa, vermelho, verde e azul) são representados como números usados com o método <code>BitmapData.copyChannel()</code> ou as propriedades <code>DisplacementMapFilter.componentX</code> e <code>DisplacementMapFilter.componentY</code> e esses números são representados pelas seguintes constantes na classe BitmapDataChannel:</p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>Você pode anexar objetos BitmapData a um objeto Bitmap usando a propriedade <code>bitmapData</code> do objeto Bitmap.</p>
 
               <p>Um objeto BitmapData pode ser usado para preencher um objeto Graphics usando o método <code>Graphics.beginBitmapFill()</code>.</p>
 
               <p>No tempo de execução do AIR, as classes DockIcon, Icon, InteractiveIcon e SystemTrayIcon incluem cada uma propriedade <code>bitmaps</code> que está em uma matriz de objetos BitmapData que definem as imagens de bitmap de um ícone.</p>
 
               <p>No AIR 1.5 e no Flash Player 10, o tamanho máximo de um objeto BitmapData é de 8.191 pixels de largura ou de altura, e o número total de pixels não pode exceder 16.777.215 pixels. (Dessa forma, caso um objeto BitmapData tenha 8.191 pixels de largura, ele só pode ter 2.048 pixels de altura.) No Flash Player 9 e anteriores e no AIR 1.1 e anteriores, a limitação é de 2.880 de altura e de 2.880 pixels de largura.</p>
 
               <p>A partir do AIR 3 e Flash player 11, os limites de tamanho para um objeto BitmapData foram removidos. O tamanho máximo de um bitmap agora depende do sistema operacional.</p>
 
               <p>As chamadas a qualquer método ou propriedade de um objeto BitmapData lançarão um erro ArgumentError se o objeto BitmapData for inválido (por exemplo, se tiver <code>altura == 0</code> e <code>largura == 0</code>) ou se tiver sido descartado via dispose(). </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">Veja os exemplos</a></p><p><span class="classHeaderTableLabel">Elementos da API relacionados</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Propriedades públicas</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ocultar propriedades públicas herdadas</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Mostrar propriedades públicas herdadas</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Propriedade</th><th>Definido por</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Uma referência ao objeto de classe ou à função de construtor de uma determinada ocorrência de objeto.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[somente leitura] 
     A altura da imagem bitmap, em pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[somente leitura] 
     O retângulo que define o tamanho e a localização da imagem bitmap.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[somente leitura] 
     Define se a imagem bitmap oferece suporte à transparência por pixel.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[somente leitura] 
     A largura da imagem bitmap, em pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Métodos públicos </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ocultar métodos públicos herdados</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Mostrar métodos públicos herdados</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Método</th><th>Definido por</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     Cria um objeto BitmapData com uma largura e altura especificadas.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Usa uma imagem de origem e um objeto de filtro e gera a imagem filtrada.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     Retorna um novo objeto BitmapData que é clone da ocorrência original com uma cópia exata do bitmap contido.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ajusta os valores de cor em uma área especificada de uma imagem bitmap usando um objeto ColorTransform.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     Compara dois objetos BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Transfere dados de um canal de outro objeto BitmapData ou do objeto BitmapData atual para um canal do objeto BitmapData atual.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Fornece uma rotina rápida para executar a manipulação de pixels entre imagens sem estiramento, giro ou efeitos de cor.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Preenche uma matriz de bytes com base em uma região retangular dos dados de pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Libera a memória usada para armazenar o objeto BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Desenha o objeto de exibição original na imagem bitmap, usando o renderizador de vetores do tempo de execução do Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Desenha o objeto de exibição original na imagem bitmap, usando o renderizador de vetores do tempo de execução do Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Compacta este objeto BitmapData usando o algoritmo de compactação selecionado e retorna um novo objeto ByteArray.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Preenche uma área retangular de pixels com uma cor ARGB especificada.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Realiza uma operação de preenchimento em uma imagem, começando em uma coordenada (x, y) e preenchendo com uma certa cor.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Determina o retângulo de destino afetado pela chamada do método applyFilter(), considerando um objeto BitmapData, um retângulo de origem e um objeto de filtro.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Determina uma região retangular que delimita totalmente todos os pixels de uma cor especificada dentro da imagem bitmap (se o parâmetro localizarCor estiver definido como "true") ou que delimita totalmente todos os pixels que não incluem a cor especificada (se o parâmetro localizarCor estiver definido como "false").</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Retorna um inteiro que representa um valor de pixel RGB a partir do objeto BitmapData em um ponto específico (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Retorna um valor de cor ARGB que contém dados de canais alfa e dados RGB.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Gera uma matriz de bytes a partir de uma região retangular dos dados de pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     Gera uma matriz de vetores a partir de uma região retangular dos dados de pixel.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Indica se um objeto tem uma propriedade especificada definida.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     Calcula um histograma de número binário de valor 256 de um objeto BitmapData. </div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     Realiza a detecção de ocorrências em nível de pixels entre uma imagem bitmap e um ponto, um retângulo ou outra imagem bitmap.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Indica se uma ocorrência da classe Object está na cadeia de protótipos do objeto especificado como o parâmetro.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Bloqueia uma imagem de forma que qualquer objeto que faça referência ao objeto BitmapData, como objetos Bitmap, não seja atualizado quando esse objeto BitmapData for alterado.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Realiza a mesclagem por canal a partir de uma imagem de origem para uma imagem de destino.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Preenche uma imagem com pixels que representam ruído aleatório.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Remapeia os valores dos canais de cor em uma imagem que possui até quatro matrizes de dados de paleta de cores, uma para cada canal.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Gera uma imagem de ruído Perlin.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     Realiza uma operação de dissolver pixels a partir de uma imagem de origem para uma imagem de destino ou usando a mesma imagem.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Indica se a propriedade especificada existe e é enumerável.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Rola uma imagem em uma certa quantidade de pixels (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Define um único pixel de um objeto BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Define os valores de cor e transparência alfa de um único pixel de um objeto BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Converte uma matriz de bytes em uma região retangular de dados de pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Define a disponibilidade de uma propriedade dinâmica para operações de repetição.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Converte um Vector em uma região retangular de dados de pixels.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Testa valores de pixels em uma imagem com base em um limite especificado e define os pixels aprovados no texto como novos valores de cor.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Retorna a representação da string deste objeto, formatado segundo as convenções específicas para a localidade.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Retorna a representação de string do objeto especificado.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Desbloqueia uma imagem de forma que qualquer objeto que faça referência ao objeto BitmapData, como objetos Bitmap, seja atualizado quando esse objeto BitmapData for alterado.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Retorna o valor primitivo do objeto especificado.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Detalhes da propriedade</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">propriedade</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[somente leitura] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     A altura da imagem bitmap, em pixels.
     
     </p><br/><br/><span class="label"> Implementação </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">propriedade</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[somente leitura] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     O retângulo que define o tamanho e a localização da imagem bitmap. As partes superior e esquerda do retângulo são 0; a largura e a altura são iguais à largura e à altura em pixels do objeto BitmapData.
     
     </p><br/><br/><span class="label"> Implementação </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">propriedade</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[somente leitura] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Define se a imagem bitmap oferece suporte à transparência por pixel. Você pode definir esse valor apenas ao construir um objeto BitmapData transmitindo <code>true</code> para o parâmetro <code>transparente</code> do construtor. Em seguida, depois de criar um objeto BitmapData, você poderá verificar se ele oferece suporte à transparência por pixel determinando se o valor da propriedade <code>transparent</code> é <code>true</code>.
     
     
     </p><br/><br/><span class="label"> Implementação </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">propriedade</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[somente leitura] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     A largura da imagem bitmap, em pixels.
     
     </p><br/><br/><span class="label"> Implementação </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">Detalhes do construtor</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Construtor</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     Cria um objeto BitmapData com uma largura e altura especificadas. Se você especificar um valor para o parâmetro <code>fillColor</code>, cada pixel no bitmap será definido como essa cor.
     
     <p>Por padrão, o bitmap é criado como transparente, a não ser que você transmita o valor <code>false</code> para o parâmetro <code>transparent</code>. Depois de criar um bitmap opaco, não é possível alterá-lo para um bitmap transparente. Cada pixel em um bitmap opaco usa apenas 24 bits de informações de canais de cor. Se você definir o bitmap como transparente, cada pixel usará 32 bits de informações de canais de cor, incluindo um canal de transparência alfa.</p>
     
     <p>No AIR 1.5 e no Flash Player 10, o tamanho máximo de um objeto BitmapData é de 8.191 pixels de largura ou de altura, e o número total de pixels não pode exceder 16.777.215 pixels. (Dessa forma, caso um objeto BitmapData tenha 8.191 pixels de largura, ele só pode ter 2.048 pixels de altura.) No Flash Player 9 e anteriores e no AIR 1.1 e anteriores, a limitação é de 2.880 pixels de altura e de 2.880 pixels de largura. Se você especificar um valor de altura ou largura maior do que 2.880, uma nova ocorrência não será criada.</p>
     
     </p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; A largura da imagem bitmap, em pixels.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; A altura da imagem bitmap, em pixels.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Especifica se a imagem bitmap oferece suporte à transparência por pixel. O valor padrão é <code>true</code> (transparente). Para criar um bitmap totalmente transparente, defina o valor do parâmetro <code>transparent</code> como <code>true</code> e o valor do parâmetro <code>fillColor</code> como 0x00000000 (ou 0). Definir a propriedade <code>transparent</code> como <code>false</code> pode resultar em melhorias secundárias no desempenho de renderização. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; Um valor de cor ARGB de 32 bits usado para preencher a área da imagem bitmap. O valor padrão é 0xFFFFFFFF (branco sólido).
     
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; largura e/ou altura excede as dimensões máximas.
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Detalhes do método</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Usa uma imagem de origem e um objeto de filtro e gera a imagem filtrada.
     
     <p>Esse método depende do comportamento de objetos de filtro embutidos, que determinam o retângulo de destino que é afetado por um retângulo de origem de entrada.</p>
     
     <p>Após a aplicação de um filtro, a imagem resultante pode ser maior do que a imagem de entrada. Por exemplo, se você uma classe BlurFilter para aplicar desfoque a um retângulo de origem de (50,50,100,100) e um ponto de destino de (10,10), a área que será alterada na imagem de destino será maior do que (10,10,60,60) por causa do desfoque. Isso acontece internamente durante a chamada <code>applyFilter()</code>.</p>
     
     <p>Se o parâmetro <code>retOrigem</code> do parâmetro <code>dadosBitmapOrigem</code> for uma região interior, como (50,50,100,100) em uma imagem de 200 x 200, o filtro usará os pixels de origem fora do parâmetro <code>retOrigem</code> para gerar o retângulo de destino.</p>
     
     <p>Se o objeto BitmapData e o objeto especificado como o parâmetro <code>sourceBitmapData</code> forem o mesmo objeto, o aplicativo usará uma cópia temporária do objeto para realizar a filtragem. Para obter o melhor desempenho, evite essa situação.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência à ocorrência atual de BitmapData.

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O ponto na imagem de destino (a ocorrência atual de BitmapData) que corresponde ao canto superior esquerdo do retângulo de origem.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; O objeto de filtro que você usa para realizar a operação de filtragem. Cada tipo de filtro tem certos requisitos, como os seguintes:
     
     <ul><li><b>BlurFilter</b> &mdash; esse filtro pode usar imagens de origem e destino que são opacas ou transparentes. Se os formatos das imagens não corresponderem, a cópia da imagem de origem feita durante a filtragem corresponderá ao formato da imagem de destino.</li><li><b>BevelFilter, DropShadowFilter, GlowFilter</b> &mdash; a imagem de destino desses filtros deve ser uma imagem transparente. Chamar DropShadowFilter ou GlowFilter cria uma imagem que contém os dados de canais alfa da sombra projetada ou do brilho. Isso não cria uma sombra projetada na imagem de destino. Se você usar qualquer um desses filtros com uma imagem de destino opaca, uma exceção será lançada.</li><li><b>ConvolutionFilter</b> &mdash; esse filtro pode usar imagens de origem e destino que são opacas ou transparentes.</li><li><b>ColorMatrixFilter</b> &mdash; esse filtro pode usar imagens de origem e destino que são opacas ou transparentes.</li><li><b>DisplacementMapFilter</b> &mdash; esse filtro pode usar imagens de origem e destino que são opacas ou transparentes, mas os formatos dessas imagens devem ser idênticos.</li></ul>
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem, pontoDest ou filtro são "null".
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; A transparência dos objetos BitmapData não é compatível com a operação de filtro.
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como aplicar um filtro de desfoque a uma ocorrência de BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Retorna um novo objeto BitmapData que é clone da ocorrência original com uma cópia exata do bitmap contido.
     
     </p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; Um novo objeto BitmapData é idêntico ao original.
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como clonar uma ocorrência de BitmapData e mostra que, quando a ocorrência de BitmapData clonada é modificada, o original permanece inalterado:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ajusta os valores de cor em uma área especificada de uma imagem bitmap usando um objeto <code>ColorTransform</code>. Se o retângulo corresponder aos limites da imagem bitmap, esse método transformará os valores de cor da imagem inteira.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um objeto Rectangle que define a área da imagem na qual o objeto ColorTransform é aplicado.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; Um objeto ColorTransform que descreve os valores de transformação de cor a serem aplicados.
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro ret ou transformaçãoCor é "null".
      
      </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como aplicar uma transformação de cor à metade esquerda (retângulo) de um objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     Compara dois objetos BitmapData. Se dois objetos BitmapData tiverem as mesmas dimensões (largura e altura), o método retornará um novo objeto BitmapData, no qual cada pixel é a "diferença" entre os pixels nos dois objetos de origem:
     
     <ul><li>Se dois pixels forem iguais, o pixel de diferença será 0x00000000. </li><li>Se dois pixels tiverem valores RGB diferentes (ignorando o valor alfa), o pixel de diferença será 0xRRGGBB, em que RR/GG/BB são os valores de diferença individuais entre os canais de vermelho, verde e azul (o valor de pixel no objeto de origem menos o valor de pixel no objeto <code>otherBitmapData</code>). Diferenças de canais alfa são ignoradas nesse caso. </li><li>Se apenas o valor do canal alfa for diferente, o valor do pixel será 0x<i>ZZ</i>FFFFFF, em que <i>ZZ</i> é a diferença nos valores alfa (o valor alfa no objeto de origem menos o valor alfa no objeto <code>otherBitmapData</code>).</li></ul>
     
     <p>Por exemplo, considere os dois objetos BitmapData a seguir:</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>Observação:</b> As cores usadas para preencher os dois objetos BitmapData têm valores RGB um pouco diferentes (0xFF0000 e 0xFFAA00). O resultado do método <code>compare()</code> é um novo objeto BitmapData com cada pixel mostrando a diferença nos valores RGB entre os dois bitmaps.</p>
     
     <p>Considere os dois objetos BitmapData a seguir, nos quais as cores RGB são as mesmas, mas os valores alfa são diferentes:</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p>O resultado do método <code>compare()</code> é um novo objeto BitmapData com cada pixel mostrando a diferença nos valores alfa entre os dois bitmaps.</p>
     
     <p>Se os objetos BitmapData forem equivalentes (com as mesmas largura e altura e valores de pixels idênticos), o método retornará o número 0.</p>
     
     <p>Se as larguras dos objetos BitmapData não forem iguais, o método retornará o número -3. </p>
     
     <p>Se as alturas dos objetos BitmapData não forem iguais, mas as larguras forem as mesmas, o método retornará o número -4.</p>
     
     <p>O exemplo a seguir compara dois objetos Bitmap com larguras diferentes (50 e 60):</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; O objeto BitmapData a ser comparado com o objeto BitmapData de origem.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; Se dois objetos BitmapData tiverem as mesmas dimensões (largura e altura), o método retornará um novo objeto BitmapData que tem a diferença entre os dois objetos (consulte a discussão principal). Se os objetos BitmapData forem equivalentes, o método retornará o número 0. Se as larguras dos objetos BitmapData não forem iguais, o método retornará o número -3. Se as alturas dos objetos BitmapData não forem iguais, o método retornará o número -4. 
     
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro outrosDadosBitmap é "null".
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra o valor de um pixel no objeto BitmapData resultante da comparação de dois objetos BitmapData com as mesmas dimensões:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Transfere dados de um canal de outro objeto BitmapData ou do objeto BitmapData atual para um canal do objeto BitmapData atual. Todos os dados nos outros canais do objeto BitmapData são preservados.
     
     <p>O valor do canal de origem e o valor do canal de destino podem ser um dos seguintes: </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência ao objeto BitmapData atual.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; O objeto Rectangle de origem. Para copiar apenas os dados de canal de uma área menor no bitmap, especifique um retângulo de origem que seja menor do que o tamanho geral do objeto BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O objeto Point de destino que representa o canto superior esquerdo da área retangular na qual os novos dados de canal são inseridos. Para copiar apenas os dados de canal de uma área para uma área diferente na imagem de destino, especifique um ponto diferente de (0,0).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; O canal de origem. Use um valor da classe BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; O canal de destino. Use um valor da classe BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem ou pontoDest são "null".
      
      </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como copiar o canal de vermelho em um objeto BitmapData para o seu próprio canal de azul em uma região de 20 x 20 pixels:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Fornece uma rotina rápida para executar a manipulação de pixels entre imagens sem estiramento, giro ou efeitos de cor. Esse método copia uma área retangular de uma imagem de origem em uma área retangular com o mesmo tamanho no ponto de destino do objeto BitmapData de destino.
     
     <p>Se você incluir os parâmetros <code>alfaBitmap</code> e <code>pontoAlfa</code>, poderá usar uma imagem secundária como origem alfa para a imagem de origem. Se a imagem de origem tiver dados alfa, ambos os conjuntos de dados alfa serão usados para compor pixels da imagem de origem para a imagem de destino. O parâmetro <code>pontoAlfa</code> é o ponto na imagem alfa que corresponde ao canto superior esquerdo do retângulo de origem. Nenhum dos pixels fora da interseção da imagem de origem e da imagem alfa é copiado para a imagem de destino.</p>
     
     <p>A propriedade <code>mergeAlpha</code> controla se o canal alfa é o não usado quando uma imagem transparente é copiada em outra imagem transparente. Para copiar pixels com os dados de canal alfa, defina a propriedade <code>mergeAlpha</code> como <code>true</code>. Por padrão, a propriedade <code>mergeAlpha</code> é <code>false</code>.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a partir da qual copiar os pixels. A imagem de origem pode ser uma ocorrência diferente de BitmapData diferente ou pode fazer referência à ocorrência atual de BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O objeto de destino que representa o canto superior esquerdo da área retangular na qual os novos pixels são inseridos.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; Uma origem de objeto BitmapData alfa secundária.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; O ponto na origem do objeto BitmapData alfa que corresponde ao canto superior esquerdo do parâmetro <code>retOrigem</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Para usar o canal alfa, defina o valor como <code>true</code>. Para copiar pixels sem canal alfa, defina o valor como <code>false</code>.
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem ou pontoDest são "null".
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como copiar pixels de uma região de 20 x 20 pixels em um objeto BitmapData para outro objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     Preenche uma matriz de bytes com base em uma região retangular dos dados de pixels. Iniciando-se do índice da <code>posição</code> do ByteArray, este método escreve um inteiro sem sinal (um valor de pixel não multiplicado de 32 bits) para cada pixel em uma matriz de bytes. Se for necessário, o tamanho da matriz de bytes é aumentada para o número necessário de bytes para armazenar todos os dados de pixels.
           
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Uma área retangular no objeto BitmapData atual
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; o destino do objeto ByteArray
     
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; se o argumento <code>rect</code> for <code>null</code> ou o argumento de <code>dados</code> for <code>null</code> 
     
	 </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Libera a memória usada para armazenar o objeto BitmapData. 
     
     <p>Quando o método <code>dispose()</code> é chamado em uma imagem, a largura e a altura dessa imagem são definidas como 0. Todas as chamadas subsequentes a métodos ou propriedades dessa ocorrência de BitmapData falharão e uma exceção será lançada. </p>
     <p><code>BitmapData.dispose()</code> libera a memória ocupada pelos dados de reais do bitmap, imediatamente (um bitmap pode consumir até 64 Mb da memória). Depois de usar <code>BitmapData.dispose()</code>, o objeto de BitmapData não é mais utilizável e o tempo de execução de Flash lança uma exceção se você chamar funções no objeto BitmapData. No entanto, <code>BitmapData.dispose()</code> não faz a coleta do lixo do objeto BitmapData (aproximadamente 128 bytes); a memória ocupada pelo objeto BitmapData real é liberada no momento em que o objeto de BitmapData é reunido pelo coletor de lixo.</p>
     
     </p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra o efeito de chamar um método de um objeto BitmapData após uma chamada ao método <code>dispose()</code> (uma exceção é lançada):
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Desenha o objeto de exibição <code>source</code> na imagem bitmap, usando o renderizador de vetores do tempo de execução do Flash. Você pode especificar o parâmetro <code>matrix</code>, <code>transformaçãoCor</code>, <code>modoMesclagem</code> e um parâmetro <code>retCorte</code> de destino para controlar como é feita a renderização. Opcionalmente, é possível especificar se o bitmap deve ser suavizado quando dimensionado (isso apenas funcionará se o objeto de origem for um objeto BitmapData).
     
     <p><b>Nota: </b>O método <code>drawWithQuality()</code> funciona exatamente como o método <code>draw()</code>, mas em vez de usar a propriedade <code>Stage.quality</code> para determinar a qualidade da renderização de vetor, você especifica o parâmetro <code>quality</code> para o método <code>drawWithQuality()</code>.</p>
      
     <p>Esse método corresponde diretamente a como os objetos são desenhados com o renderizador de vetores padrão para objetos na interface da ferramenta de autoria.</p>
     
     <p>O objeto de exibição de origem não usa nenhuma de suas transformações aplicadas para essa chamada. Ele é tratado como existente na biblioteca ou no arquivo, sem transformação de matriz, transformação de cor e modo de mesclagem. Para desenhar um objeto de exibição (como um clipe de filme) usando suas próprias propriedades de transformação, você pode copiar a propriedade <code>transform</code> do objeto para a propriedade <code>transform</code> do objeto Bitmap que usa o objeto BitmapData.</p>
     
     <p>Este método é suportado pelo RTMP no <span>Flash Player 9.0.115.0 e posterior e no </span> Adobe AIR. Você pode controlar o acesso a fluxos no Flash Media Server em um script do lado do servidor. Para obter mais informações, consulte as propriedades <code>Client.audioSampleAccess</code> e <code>Client.videoSampleAccess</code> na <a href="http://www.adobe.com/go/learn_flash_ss_as_br" target="external"> <i>Referência de lado do servidor do ActionScript para Adobe Flash Media Server</i></a>.</p>
     
     <p>Se o objeto source e (no caso de um objeto Sprite ou MovieClip) todos os seus objetos filhos não são provenientes do mesmo domínio do chamador ou não estão em um conteúdo acessível ao chamador depois que ele chamar o método<code>Security.allowDomain()</code>, uma chamada para o <code>draw()</code> lança uma exceção de SecurityError. Esta restrição não se aplica ao conteúdo do AIR na área de segurança do aplicativo.</p>
     
     <p>Também há restrições quanto ao uso de uma imagem bitmap carregada como <code>source</code>. Uma chamada para o método <code>draw()</code> é bem-sucedida caso a imagem carregada esteja no mesmo domínio do chamador. Além disso, um arquivo de política em vários domínios no servidor da imagem pode conceder a permissão ao domínio do conteúdo SWF que chama o método <code>draw()</code>. Nesse caso, você deve definir a propriedade <code>checkPolicyFile</code> de um objeto LoaderContext, além de usar esse objeto como o parâmetro <code>context</code> durante a chamada do método <code>load()</code> do objeto Loader usado para carregar a imagem. Essas restrições não se aplicam ao conteúdo do AIR na área de segurança do aplicativo.</p>
     
     <p>No Windows, o método <code>draw()</code> não pode capturar o conteúdo SWF incorporado em uma página HTML <span> em um objeto HTMLLoader no Adobe AIR</span>.</p>
     
     <p>O método <code>draw()</code> não pode capturar conteúdo PDF<span> no Adobe AIR</span>. Ele também não pode capturar ou incorporar conteúdo SWF em HTML em que o atributo <code>wmode</code> é definido como <code>"window"</code> <span>no Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; O objeto de exibição ou o objeto BitmapData a ser desenhado para o objeto BitmapData. (As classes DisplayObject e BitmapData implementam a interface IBitmapDrawable.)
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto Matrix usado para dimensionar, girar ou converter as coordenadas do bitmap. Se você não quiser aplicar uma transformação de matriz à imagem, defina esse parâmetro como uma matriz de identidade, criada com o construtor <code>new Matrix()</code> padrão, ou transmita um valor <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto ColorTransform que você usa para ajustar os valores de cor do bitmap. Se nenhum objeto for fornecido, as cores da imagem bitmap não serão transformadas. Se você precisar transmitir esse parâmetro, mas não quiser transformar a imagem, defina-o para um objeto ColorTransform criado com o construtor <code>new ColorTransform()</code> padrão.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Um valor de string, da classe flash.display.BlendMode, especificando o modo de mesclagem a ser aplicado ao bitmap resultante. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto Rectangle que define a área do objeto de origem a ser desenhado. Se você não fornecer esse valor, nenhum corte ocorrerá e o objeto de origem inteiro será desenhado.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Um valor booliano que determina se um objeto BitmapData é suavizado quando dimensionado ou girado, devido a um dimensionamento ou giro no parâmetro <code>matrix</code>. O parâmetro <code>suavização</code> apenas será aplicável se o parâmetro <code>origem</code> for um objeto BitmapData. Com o parâmetro <code>suavização</code> definido como <code>false</code>, a imagem BitmapData dimensionada ou girada pode aparecer pixelizada ou irregular. Por exemplo, as duas imagens a seguir usam o mesmo objeto BitmapData para o parâmetro <code>origem</code>, mas o parâmetro <code>suavização</code> está definido como <code>true</code> à esquerda e como <code>false</code> à direita:
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Duas imagens: a esquerda com suavização e a direita sem suavização."></img></p>
     
     <p>Desenhar um bitmap com o parâmetro <code>suavização</code> definido como <code>true</code> demora mais do que fazer o mesmo com o parâmetro <code>suavização</code> definido como <code>false</code>.</p>
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; O parâmetro <code>origem</code> não é um objeto BitmapData ou DisplayObject.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; O objeto <code>source</code> e (no caso de um objeto Sprite ou MovieClip) todos os respectivos objetos-filho não são provenientes do mesmo domínio do chamador ou não estão em um conteúdo acessível ao chamador depois que ele chamar o método <code>Security.allowDomain()</code>. Esta restrição não se aplica ao conteúdo do AIR na área de segurança do aplicativo.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; A origem é nula ou não é um objeto IBitmapDrawable válido.
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como desenhar um objeto TextField em um objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Desenha o objeto de exibição <code>source</code> na imagem bitmap, usando o renderizador de vetores do tempo de execução do Flash. Você pode especificar o parâmetro <code>matrix</code>, <code>transformaçãoCor</code>, <code>modoMesclagem</code> e um parâmetro <code>retCorte</code> de destino para controlar como é feita a renderização. Opcionalmente, é possível especificar se o bitmap deve ser suavizado quando dimensionado (isso apenas funcionará se o objeto de origem for um objeto BitmapData).
     
     <p><b>Nota: </b>O método <code>drawWithQuality()</code> funciona exatamente como o método <code>draw()</code>, mas em vez de usar a propriedade <code>Stage.quality</code> para determinar a qualidade da renderização de vetor, você especifica o parâmetro <code>quality</code> para o método <code>drawWithQuality()</code>.</p>
      
     <p>Esse método corresponde diretamente a como os objetos são desenhados com o renderizador de vetores padrão para objetos na interface da ferramenta de autoria.</p>
     
     <p>O objeto de exibição de origem não usa nenhuma de suas transformações aplicadas para essa chamada. Ele é tratado como existente na biblioteca ou no arquivo, sem transformação de matriz, transformação de cor e modo de mesclagem. Para desenhar um objeto de exibição (como um clipe de filme) usando suas próprias propriedades de transformação, você pode copiar a propriedade <code>transform</code> do objeto para a propriedade <code>transform</code> do objeto Bitmap que usa o objeto BitmapData.</p>
     
     <p>Este método é suportado pelo RTMP no <span>Flash Player 9.0.115.0 e posterior e no </span> Adobe AIR. Você pode controlar o acesso a fluxos no Flash Media Server em um script do lado do servidor. Para obter mais informações, consulte as propriedades <code>Client.audioSampleAccess</code> e <code>Client.videoSampleAccess</code> na <a href="http://www.adobe.com/go/documentation_br" target="external"> <i>Referência de lado do servidor do ActionScript para Adobe Flash Media Server</i></a>.</p>
     
     <p>Se o objeto de origem e (no caso de um objeto Sprite ou MovieClip) todos os seus objetos filhos não são provenientes do mesmo domínio do chamador ou não estão em um conteúdo acessível ao chamador depois que ele chamar o método<code>Security.allowDomain()</code>, uma chamada para o <code>drawWithQuality()</code> lança uma exceção de SecurityError. Esta restrição não se aplica ao conteúdo do AIR na área de segurança do aplicativo.</p>
     
     <p>Também há restrições quanto ao uso de uma imagem bitmap carregada como <code>source</code>. Uma chamada para o método <code>drawWithQuality()</code> será bem-sucedida caso a imagem carregada esteja no mesmo domínio do chamador. Além disso, um arquivo de política em vários domínios no servidor da imagem pode conceder a permissão ao domínio do conteúdo SWF que chama o método <code>drawWithQuality()</code>. Nesse caso, você deve definir a propriedade <code>checkPolicyFile</code> de um objeto LoaderContext, além de usar esse objeto como o parâmetro <code>context</code> durante a chamada do método <code>load()</code> do objeto Loader usado para carregar a imagem. Essas restrições não se aplicam ao conteúdo do AIR na área de segurança do aplicativo.</p>
     
     <p>No Windows, o método <code>drawWithQuality()</code> não pode capturar o conteúdo SWF incorporado em uma página HTML <span> em um objeto HTMLLoader no Adobe AIR</span>.</p>
     
     <p>O método <code>drawWithQuality()</code> não pode capturar conteúdo PDF<span> no Adobe AIR</span>. Ele também não pode capturar ou incorporar conteúdo SWF em HTML em que o atributo <code>wmode</code> é definido como <code>"window"</code> <span>no Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; O objeto de exibição ou o objeto BitmapData a ser desenhado para o objeto BitmapData. (As classes DisplayObject e BitmapData implementam a interface IBitmapDrawable.)
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto Matrix usado para dimensionar, girar ou converter as coordenadas do bitmap. Se você não quiser aplicar uma transformação de matriz à imagem, defina esse parâmetro como uma matriz de identidade, criada com o construtor <code>new Matrix()</code> padrão, ou transmita um valor <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto ColorTransform que você usa para ajustar os valores de cor do bitmap. Se nenhum objeto for fornecido, as cores da imagem bitmap não serão transformadas. Se você precisar transmitir esse parâmetro, mas não quiser transformar a imagem, defina-o para um objeto ColorTransform criado com o construtor <code>new ColorTransform()</code> padrão.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Um valor de string, da classe flash.display.BlendMode, especificando o modo de mesclagem a ser aplicado ao bitmap resultante. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Um objeto Rectangle que define a área do objeto de origem a ser desenhado. Se você não fornecer esse valor, nenhum corte ocorrerá e o objeto de origem inteiro será desenhado.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Um valor booliano que determina se um objeto BitmapData é suavizado quando dimensionado ou girado, devido a um dimensionamento ou giro no parâmetro <code>matrix</code>. O parâmetro <code>suavização</code> apenas será aplicável se o parâmetro <code>origem</code> for um objeto BitmapData. Com o parâmetro <code>suavização</code> definido como <code>false</code>, a imagem BitmapData dimensionada ou girada pode aparecer pixelizada ou irregular. Por exemplo, as duas imagens a seguir usam o mesmo objeto BitmapData para o parâmetro <code>origem</code>, mas o parâmetro <code>suavização</code> está definido como <code>true</code> à esquerda e como <code>false</code> à direita:
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Duas imagens: a esquerda com suavização e a direita sem suavização."></img></p>
     
     <p>Desenhar um bitmap com o parâmetro <code>suavização</code> definido como <code>true</code> demora mais do que fazer o mesmo com o parâmetro <code>suavização</code> definido como <code>false</code>.</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Algum de um dos valores de StageQuality. Seleciona a qualidade de suavização de borada a ser usada ao desenhar gráficos de vetor. 
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; O parâmetro <code>origem</code> não é um objeto BitmapData ou DisplayObject.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; O objeto <code>source</code> e (no caso de um objeto Sprite ou MovieClip) todos os respectivos objetos-filho não são provenientes do mesmo domínio do chamador ou não estão em um conteúdo acessível ao chamador depois que ele chamar o método <code>Security.allowDomain()</code>. Esta restrição não se aplica ao conteúdo do AIR na área de segurança do aplicativo.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; A origem é nula ou não é um objeto IBitmapDrawable válido.
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como desenhar um objeto TextField em um objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Compacta este objeto BitmapData usando o algoritmo de compactação selecionado e retorna um novo objeto ByteArray. Como alternativa, grava os dados resultantes na ByteArray especificada. O argumento <code>compressor</code> especifica o algoritmo de codificação e pode ser PNGEncoderOptions, JPEGEncoderOptions, ou JPEGXREncoderOptions.
     
     <p>O exemplo a seguir compacta um objeto de BitmapData usando JPEGEncoderOptions:</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; A área do objeto BitmapData a ser compactada.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; O tipo de compactador a ser usado. Os valores válidos são: <code>flash.display.PNGEncoderOptions</code>, <code>flash.display.JPEGEncoderOptions</code> e <code>flash.display.JPEGXREncoderOptions</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; A ByteArray de saída para manter a imagem codificada.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Uma ByteArray que contém a imagem codificada.
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Preenche uma área retangular de pixels com uma cor ARGB especificada.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; A área retangular a ser preenchida.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; O valor de cor ARGB que preenche a área. As cores ARGB são frequentemente especificadas em formato hexadecimal; por exemplo, 0xFF336699.
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro ret é "null".
      
      </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como preencher uma região retangular de um objeto BitmapData com azul:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Realiza uma operação de preenchimento em uma imagem, começando em uma coordenada (<i>x</i>, <i>y</i>) e preenchendo com uma certa cor. O método <code>floodFill()</code> é semelhante à ferramenta lata de tinta em vários programas de pintura. A cor é uma cor ARGB que contém informações alfa e informações de cores.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A coordenada <i>x</i> da imagem.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A coordenada <i>y</i> da imagem.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; A cor ARGB a ser usada como preenchimento.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como preencher com vermelho uma região de um objeto BitmapData, ou seja, a região ao redor do pixel definido pelo ponto <code>(10, 10)</code>, no qual todas as cores correspondem à cor nesse ponto.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Determina o retângulo de destino afetado pela chamada do método <code>applyFilter()</code>, considerando um objeto BitmapData, um retângulo de origem e um objeto de filtro.
     
     <p>Por exemplo, um filtro de desfoque normalmente afeta uma área maior do que o tamanho da imagem original. Uma imagem de 100 x 200 pixels que está sendo filtrada por uma ocorrência de BlurFilter padrão, em que <code>blurX = blurY = 4</code> gera um retângulo de destino de <code>(-2,-2,104,204)</code>. O método <code>generateFilterRect()</code> permite descobrir o tamanho desse retângulo de destino com antecedência, para que você possa dimensionar a imagem de destino apropriadamente antes de realizar uma operação de filtro.</p>
     
     <p>Alguns filtros cortam seu retângulo de destino com base no tamanho da imagem de origem. Por exemplo, um filtro <code>DropShadow</code> interno não gera um resultado maior do que sua imagem de origem. Nessa API, o objeto BitmapData é usado como os limites de origem e não o parâmetro <code>ret</code> de origem.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; O objeto de filtro que você usa para calcular o retângulo de destino.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo de destino calculado com o uso de imagem, do parâmetro <code>retOrigem</code> e de um filtro.
     
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro retOrigem ou filtro é "null".
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra como você pode usar o método <code>generateFilterRect()</code> para determinar a área retangular que o resultado de um filtro de desfoque ocupará. Os resultados do método <code>generateFilterRect()</code> são processados pela função <code>trace()</code>:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> Observe que o método <code>generateFilterRect()</code> não aplica o filtro. Chame o método <code>applyFilter()</code> para aplicar o filtro. 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Determina uma região retangular que delimita totalmente todos os pixels de uma cor especificada dentro da imagem bitmap (se o parâmetro <code>localizarCor</code> estiver definido como <code>true</code>) ou que delimita totalmente todos os pixels que não incluem a cor especificada (se o parâmetro <code>localizarCor</code> estiver definido como <code>false</code>). 
     
     <p>Por exemplo, se você tiver uma imagem de origem e quiser determinar o retângulo da imagem que contém um canal alfa diferente de zero, transmita <code>{máscara: 0xFF000000, cor: 0x00000000}</code> como parâmetros. Se o parâmetro <code>localizarCor</code> estiver definido como <code>true</code>, a imagem inteira será pesquisada quanto aos limites de pixels para os quais <code>(valor e máscara) == cor</code> (em que <code>value</code> é o valor de cor do pixel). Se o parâmetro <code>localizarCor</code> estiver definido como <code>false</code>, a imagem inteira será pesquisada quanto aos limites de pixels para os quais <code>(valor e máscara) != cor</code> (em que <code>value</code> é o valor de cor do pixel). Para determinar o espaço em branco em torno de uma imagem, passe o <code>{mask: 0xFFFFFFFF, cor: 0xFFFFFFFF}</code> para localizar os limites de pixels não brancos.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor hexadecimal que especifica os bits da cor ARGB a ser considerada. O valor da cor é combinado ao seu valor hexadecimal, usando o operador <code>&</code> (AND bit a bit).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor hexadecimal que especifica a cor ARGB a ser correspondida (se <code>localizarCor</code> estiver definido como <code>true</code>) ou <i>não</i> (se <code>localizarCor</code> estiver definido como <code>false</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Se o valor estiver definido como <code>true</code>, retornará os limites de um valor de cor em uma imagem. Se o valor estiver definido como <code>false</code>, retornará os limites dos pontos em que essa cor não existe em uma imagem. 
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; A região da imagem que é a cor especificada. 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData com vermelho na metade superior de seus pixels. Em seguida, chama o método <code>getColorBoundsRect()</code> para determinar o retângulo no qual os pixels são vermelhos (0xFF0000) e então chama o mesmo método para determinar o retângulo no qual os pixels não são vermelhos (definindo o parâmetro <code>localizarCor</code> como <code>false</code>:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Retorna um inteiro que representa um valor de pixel RGB a partir do objeto BitmapData em um ponto específico (<i>x</i>, <i>y</i>). O método <code>getPixel()</code> retorna um valor de pixel não multiplicado. Nenhuma informação de alfa é retornada.
     
     <p>Todos os pixels em um objeto BitmapData são armazenados como valores de cor não multiplicados. Um pixel de imagem pré-multiplicado que tem os valores dos canais de cores de vermelho, verde e azul já multiplicados pelos dados alfa. Por exemplo, se o valor de alfa for 0, os valores para os canais RGB também serão 0, independentemente dos valores não multiplicados. Essa perda de dados poderá causar alguns problemas quando você realizar operações. Todos os métodos BitmapData usam e retornam valores não multiplicados. A representação de pixels internos é convertida de pré-multiplicada em não multiplicada antes de ser retornada como um valor. Durante uma operação de definição, o valor de pixel é pré-multiplicado antes de o pixel de imagem bruto ser definido.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>x</i> do pixel.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>y</i> do pixel.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Um número que representa um valor de pixel RGB. Se as coordenadas (<i>x</i>, <i>y</i>) estiverem fora dos limites da imagem, o método retornará 0. 
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData preenchido com vermelho e, em seguida, usa o método <code>getPixel()</code> para determinar o valor de cor no pixel superior esquerdo:
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Retorna um valor de cor ARGB que contém dados de canais alfa e dados RGB. Esse método é semelhante ao método <code>getPixel()</code>, que retorna uma cor RGB sem dados de canais alfa.
     
     <p>Todos os pixels em um objeto BitmapData são armazenados como valores de cor não multiplicados. Um pixel de imagem pré-multiplicado que tem os valores dos canais de cores de vermelho, verde e azul já multiplicados pelos dados alfa. Por exemplo, se o valor de alfa for 0, os valores para os canais RGB também serão 0, independentemente dos valores não multiplicados. Essa perda de dados poderá causar alguns problemas quando você realizar operações. Todos os métodos BitmapData usam e retornam valores não multiplicados. A representação de pixels internos é convertida de pré-multiplicada em não multiplicada antes de ser retornada como um valor. Durante uma operação de definição, o valor de pixel é pré-multiplicado antes de o pixel de imagem bruto ser definido.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>x</i> do pixel.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>y</i> do pixel.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Um número que representa um valor de pixel ARGB. Se as coordenadas (<i>x</i>, <i>y</i>) estiverem fora dos limites da imagem, 0 será retornado.
     
     </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData preenchido com uma cor, usa o método <code>getPixel32()</code> para determinar o valor da cor no pixel superior esquerdo e, em seguida, determina os valores hexadecimais para cada componente de cor (alfa, vermelho, verde e azul):
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gera uma matriz de bytes a partir de uma região retangular dos dados de pixels. Grava um inteiro não sem sinal (um valor de pixel não multiplicado de 32 bits) para cada pixel na matriz de bytes.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Uma área retangular no objeto BitmapData atual.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Um ByteArray representando os pixels no Retângulo especificado.
     
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro ret é "null".
      
      </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData preenchido com pixels de ruído aleatório e usa o método <code>getPixels()</code> para preencher um objeto ByteArray com os valores de pixel do objeto BitmapData
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gera uma matriz de vetores a partir de uma região retangular dos dados de pixel. Retorna um objeto Vector de inteiros não assinados (um valor de pixel não multiplicado de 32 bits) para o retângulo especificado.
     
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Uma área retangular no objeto BitmapData atual.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Vector representa determinado Rectangle.
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro ret é "null".
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Calcula um histograma de número binário de valor 256 de um objeto BitmapData. Esse método retorna um objeto Vector contendo quatro ocorrências de Vector.&lt;Number> (quatro objetos Vector que contêm objetos Number). As quatro ocorrências de Vector representam os componentes vermelho, verde, azul e alfa, respectivamente. Cada ocorrência de Vector contém 256 valores que representam a contagem de preenchimento do valor de componente individual, de 0 a 255.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; A área do objeto BitmapData a ser usada.
      
      </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Realiza a detecção de ocorrências em nível de pixels entre uma imagem bitmap e um ponto, um retângulo ou outra imagem bitmap. Uma ocorrência é definida como uma sobreposição de um ponto ou retângulo sobre um pixel opaco, ou dois pixels opacos de sobreposição. Nenhuma operação de estiramento, giro ou outra transformação de qualquer objeto será considerada quando o teste de ocorrência for realizado. 
     
     <p>Se uma imagem for opaca, ela será considerada um retângulo totalmente opaco para esse método. Ambas as imagens devem ser transparentes para realizar um teste de ocorrência em nível de pixels que considere a transparência. Quando você testa duas imagens transparentes, os parâmetros de limite de alfa controlam quais valores de canais alfa, de 0 a 255, são considerados opacos.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  Uma posição do canto superior esquerdo da imagem BitmapData em um espaço de coordenadas arbitrário. O mesmo espaço de coordenadas é usado na definição do parâmetro <code>secondPointBitmap</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; O valor de canal alfa mais baixo considerado opaco para esse teste de ocorrência.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Um objeto Rectangle, Point, Bitmap ou BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Um ponto que define uma localização de pixel no segundo objeto BitmapData. Use esse parâmetro apenas quando o valor de <code>secondObject</code> for um objeto BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; O valor de canal alfa mais baixo considerado opaco no segundo objeto BitmapData. Use esse parâmetro apenas quando o valor de <code>secondObject</code> for um objeto BitmapData e quando ambos os objetos BitmapData forem transparentes.
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; Um valor de <code>true</code> se ocorrer uma ocorrência; caso contrário, <code>false</code>.
        
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; O parâmetro <code>secondObject</code> não é um objeto Point, Rectangle, Bitmap ou BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro primeiroPonto é "null".
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData que apenas é opaco em uma região retangular (20, 20, 40, 40) e chama o método <code>hitTest()</code> com um objeto Point como o <code>secondObject</code>. Na primeira chamada, o objeto Point define o canto superior esquerdo do objeto BitmapData, que não é opaco, e, na segunda chamada, o objeto Point define o centro do objeto BitmapData, que é opaco.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Bloqueia uma imagem de forma que qualquer objeto que faça referência ao objeto BitmapData, como objetos Bitmap, não seja atualizado quando esse objeto BitmapData for alterado. Para melhorar o desempenho, use esse método junto com o método <code>unlock()</code> antes e depois de várias chamadas ao método <code>setPixel()</code> ou <code>setPixel32()</code>.
     
     </p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData com base na propriedade <code>bitmapData</code> de um objeto Bitmap, <code>picture</code>. Em seguida, ele chama o método <code>lock()</code> antes de chamar uma função personalizada complicada, <code>complexTransformation()</code>, que modifica o objeto BitmapData. (O objeto <code>picture</code> e a função <code>complexTransformation()</code> não são definidas neste exemplo.) Mesmo que a função <code>complexTransformation()</code> atualize a propriedade <code>bitmapData</code> do objeto <code>picture</code>, as alterações apenas serão refletidas quando o código chamar o método <code>unlock()</code> no objeto <code>bitmapData</code>:
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Realiza a mesclagem por canal a partir de uma imagem de origem para uma imagem de destino. Para cada canal e cada pixel, um novo valor é calculado com base nos valores de canal dos pixels de origem e destino. Por exemplo, no canal de vermelho, o novo valor é calculado da seguinte maneira (em que <code>redSrc</code> é o valor do canal de vermelho para um pixel na imagem de origem e <code>redDest</code> é o valor do canal de vermelho no pixel correspondente da imagem de destino): 
     <p>
     <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p>Os valores de <code>redMultiplier</code>, <code>greenMultiplier</code>, <code>blueMultiplier</code> e <code>alphaMultiplier</code> são os multiplicadores usados para cada canal de cor. Use um valor hexadecimal que varia de <code>0</code> a <code>0x100</code> (256), em que <code>0</code> especifica que o valor total a partir do destino é usado no resultado, <code>0x100</code> especifica que o valor total a partir da origem é usado e os números intermediários especificam que uma mesclagem é usada (como <code>0x80</code> para 50%).</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência ao objeto BitmapData atual.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O ponto na imagem de destino (a ocorrência atual de BitmapData) que corresponde ao canto superior esquerdo do retângulo de origem.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor uint hexadecimal pelo qual multiplicar o valor do canal de vermelho. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor uint hexadecimal pelo qual multiplicar o valor do canal de verde. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor uint hexadecimal pelo qual multiplicar o valor do canal de azul.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Um valor uint hexadecimal pelo qual multiplicar o valor da transparência alfa.
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem ou pontoDest são "null".
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria dois objetos BitmapData. Ambos têm 100 x 80 pixels de tamanho. O primeiro é preenchido com verde e o segundo, com vermelho. O código chama o método <code>merge()</code>, mesclando os pixels do segundo BitmapData no primeiro objeto BitmapData, mas apenas em uma área retangular especificada:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Preenche uma imagem com pixels que representam ruído aleatório.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; O número base aleatório a ser usado. Se você mantiver todos os outros parâmetros iguais, poderá gerar diferentes resultados pseudoaleatórios variando o valor base aleatório. A função de ruído é uma função de mapeamento e não uma função real de geração de números aleatórios. Sendo assim, ela cria os mesmos resultados todas as vezes a partir da mesma base aleatória.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; O valor mais baixo a ser gerado para cada canal (0 a 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; O valor mais alto a ser gerado para cada canal (0 a 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; Um número que pode ser uma combinação de qualquer dos quatro valores de canais de cor (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> e <code>BitmapDataChannel.ALPHA</code>). É possível usar o operador OR lógico (<code>|</code>) para combinar valores de canal. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Um valor booliano. Se o valor for <code>true</code>, uma imagem em tons de cinza será criada ao definir todos os canais de cor como o mesmo valor. A seleção do canal alfa não é afetada pela definição desse parâmetro como <code>true</code>. 
     
     </td></tr></table></p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria dois objetos BitmapData e chama o método <code>noise()</code> em ambos: Entretanto, o parâmetro <code>tonscinza</code> está definido como <code>false</code> para a chamada ao método <code>noise()</code> do primeiro objeto e está definido como <code>true</code> para a chamada ao método <code>noise()</code> do segundo objeto:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Remapeia os valores dos canais de cor em uma imagem que possui até quatro matrizes de dados de paleta de cores, uma para cada canal. 
     
     <p>O tempo de execução do Flash usa as etapas a seguir para gerar a imagem resultante:</p>
     
     <ol><li>Após o cálculo dos valores de vermelho, verde, azul e alfa, eles são somados com o uso da aritmética padrão de inteiros de 32 bits. </li><li>Os valores dos canais de vermelho, verde, azul e alfa de cada pixel são extraídos em valores separados de 0 a 255. Esses valores são usados para procurar novos valores de cores na matriz apropriada: <code>redArray</code>, <code>greenArray</code>, <code>blueArray</code> e <code>alphaArray</code>. Cada uma dessas quatro matrizes deve conter 256 valores. </li><li>Após a recuperação de todos os quatro novos valores de canal, eles serão combinados em um valor ARGB padrão que é aplicado ao pixel.</li></ol>
     
     <p>Efeitos entre canais podem ser suportados com esse método. Cada matriz de entrada pode conter valores completos de 32 bits e não haverá deslocamentos quando os valores forem somados. Essa rotina não oferece suporte à fixação por canal. </p>
     
     <p>Se nenhuma matriz for especificada para um canal, o canal de cor será copiado da imagem de origem para a imagem de destino.</p>
     
     <p>Você pode usar esse método para uma variedade de efeitos, como mapeamento geral de paletas (usando um canal e convertendo-o em uma imagem colorida falsa). Esse método também pode ser usado para vários algoritmos avançados de manipulação de cores, como gama, curvas, níveis e quantização.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência à ocorrência atual de BitmapData.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O ponto na imagem de destino (o objeto BitmapData atual) que corresponde ao canto superior esquerdo do retângulo de origem.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Se <code>redArray</code> não for <code>null</code>, <code>red = redArray[source red value] else red = source rect value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Se <code>greenArray</code> não for <code>null</code>, <code>green = greenArray[source green value] else green = source green value.</code>
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Se <code>blueArray</code> não for <code>null</code>, <code>blue = blueArray[source blue value] else blue = source blue value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Se <code>alphaArray</code> não for <code>null</code>, <code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>.
     
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem ou pontoDest são "null".
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData verde com um quadrado centralizado vermelho e usa o método <code>paletteMap()</code> para alternar o vermelho com o verde na metade retangular inferior do objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Gera uma imagem de ruído Perlin.
     
     <p>O algoritmo de geração de ruído Perlin interpola e combina funções individuais de ruído aleatório (chamadas de oitavas) em uma única função que gera ruído aleatório com aparência mais natural. Como oitavas musicais, cada função de oitava é duas vezes a frequência da anterior. O ruído Perlin foi descrito como uma "soma fractal de ruído" porque combina vários conjuntos de dados de ruído com diferentes camadas de detalhe.</p>
     
     <p>Você pode usar funções de ruído Perlin para simular paisagens e fenômenos naturais, como fibras de madeira, nuvens e cadeias de montanha. Na maioria dos casos, a saída de uma função de ruído Perlin não é exibida diretamente, mas é usada para melhorar outras imagens e lhes dar variações pseudoaleatórias.</p>
     
     <p>Funções de ruído aleatório digital simples frequentemente produzem imagens com pontos ásperos contrastantes. Em geral, esse tipo de contraste áspero não é encontrado em essência. O algoritmo de ruído Perlin mescla várias funções de ruído que operam em diferentes níveis de detalhes. Esse algoritmo resulta em variações menores entre os valores de pixels vizinhos.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; A frequência a ser usada na direção <i>x</i>. Por exemplo, para gerar um ruído dimensionado para uma imagem de 64 x 128, transmita 64 para o valor <code>baseX</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; A frequência a ser usada na direção <i>y</i>. Por exemplo, para gerar um ruído dimensionado para uma imagem de 64 x 128, transmita 128 para o valor <code>baseY</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; Número de oitavas ou funções de ruído individuais a serem combinadas para criar esse ruído. Números maiores de oitavas criam imagens com mais detalhes. Números maiores de oitavas também exigem mais tempo de processamento.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; O número base aleatório a ser usado. Se você mantiver todos os outros parâmetros iguais, poderá gerar diferentes resultados pseudoaleatórios variando o valor base aleatório. A função de ruído Perlin é uma função de mapeamento e não uma função real de geração de números aleatórios. Sendo assim, ela cria os mesmos resultados todas as vezes a partir da mesma base aleatória.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Um valor booliano. Se o valor for <code>true</code>, o método tentará suavizar as bordas de transição da imagem para criar texturas contínuas para colocação lado a lado como um preenchimento de gradiente.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Um valor booliano. Se o valor for <code>true</code>, o método gerará ruído fractal; caso contrário, gerará turbulência. Uma imagem com turbulência tem descontinuidades visíveis no gradiente que podem fazer com que ela aproxime melhor os efeitos visuais mais nítidos, como chamas e ondas do mar.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  Um número que pode ser uma combinação de qualquer dos quatro valores de canais de cor (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> e <code>BitmapDataChannel.ALPHA</code>). É possível usar o operador OR lógico (<code>|</code>) para combinar valores de canal.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Um valor booliano. Se o valor for <code>true</code>, uma imagem em tons de cinza será criada ao definir cada um dos canais de cor de vermelho, verde e azul como valores idênticos. O valor do canal alfa não será afetado se esse valor for definido como <code>true</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Uma matriz de pontos que correspondem a deslocamentos <i>x</i> e <i>y</i> para cada oitava. Ao manipular os valores de deslocamento, você pode rolar suavemente as camadas de uma imagem perlinNoise. Cada ponto na matriz de deslocamento afeta uma função de ruído de oitava específica.
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData de 200 x 200 pixels que chama o método <code>perlinNoise()</code> para gerar um efeito de aquarela em vermelho e azul:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Realiza uma operação de dissolver pixels a partir de uma imagem de origem para uma imagem de destino ou usando a mesma imagem. O tempo de execução do Flash usa um valor <code>randomSeed</code> para gerar uma dissolução de pixels aleatória. O valor de retorno da função deve ser transmitido em chamadas subsequentes para continuar a dissolução de pixels até ela terminar.
     
     <p>Se a imagem de origem não for igual à de destino, os pixels serão copiados da origem para o destino usando todas as propriedades. Esse processo permite a dissolução de uma imagem branca em uma imagem totalmente preenchida.</p>
     
     <p>Se as imagens de origem e destino forem iguais, os pixels serão preenchidos com o parâmetro <code>cor</code>. Esse processo permite a dissolução a partir de uma imagem totalmente preenchida. Nesse modo, o parâmetro <code>ponto</code> de destino é ignorado.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência à ocorrência atual de BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O ponto na imagem de destino (a ocorrência atual de BitmapData) que corresponde ao canto superior esquerdo do retângulo de origem.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; A base aleatória a ser usada para iniciar a dissolução de pixels. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; O padrão é 1/30 da área de origem (largura x altura).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Um valor de cor ARGB que é usado para preencher pixels cujo valor de origem seja igual ao seu valor de destino. 
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; O novo valor base aleatório a ser usado para chamadas subsequentes.
     
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem ou pontoDest são "null".
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O valor de numPixels é negativo
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir usa o método <code>pixelDissolve()</code> para converter um objeto BitmapData cinza em um vermelho dissolvendo 40 pixels de uma vez até que todos os pixels tenham mudado de cor:
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Rola uma imagem em uma certa quantidade de pixels (<i>x</i>, <i>y</i>). As regiões de borda fora da área de rolagem são inalteradas.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A intensidade na qual rolar horizontalmente.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A intensidade na qual rolar verticalmente.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir mostra o efeito de rolar um objeto de dados Bitmap 40 pixels à direita:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Define um único pixel de um objeto BitmapData. O valor do canal alfa atual do pixel de imagem é preservado durante essa operação. O valor do parâmetro de cor RGB é tratado como um valor de cor não multiplicado.
     
     <p><b>Observação:</b> Para aumentar o desempenho, ao usar o método <code>setPixel()</code> ou <code>setPixel32()</code> repetidamente, chame o método <code>lock()</code> antes de chamar o método <code>setPixel()</code> ou <code>setPixel32()</code> e então chame o método <code>unlock()</code> quando tiver feito todas as alterações de pixel. Esse processo impede que os objetos que fazem referência a essa ocorrência de BitmapData sejam atualizados até você terminar de fazer as alterações de pixel.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>x</i> do pixel cujo valor é alterado.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>y</i> do pixel cujo valor é alterado.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; A cor RGB resultante para o pixel. 
     
     </td></tr></table></p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir usa o método <code>setPixel()</code> para desenhar uma linha vermelha em um objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Define os valores de cor e transparência alfa de um único pixel de um objeto BitmapData. Esse método é semelhante ao método <code>setPixel()</code>; a principal diferença é que o método <code>setPixel32()</code> usa um valor de cor ARGB que contém informações de canais alfa.
     
     <p>Todos os pixels em um objeto BitmapData são armazenados como valores de cor não multiplicados. Um pixel de imagem pré-multiplicado que tem os valores dos canais de cores de vermelho, verde e azul já multiplicados pelos dados alfa. Por exemplo, se o valor de alfa for 0, os valores para os canais RGB também serão 0, independentemente dos valores não multiplicados. Essa perda de dados poderá causar alguns problemas quando você realizar operações. Todos os métodos BitmapData usam e retornam valores não multiplicados. A representação de pixels internos é convertida de pré-multiplicada em não multiplicada antes de ser retornada como um valor. Durante uma operação de definição, o valor de pixel é pré-multiplicado antes de o pixel de imagem bruto ser definido.</p>
     
     <p><b>Observação:</b> Para aumentar o desempenho, ao usar o método <code>setPixel()</code> ou <code>setPixel32()</code> repetidamente, chame o método <code>lock()</code> antes de chamar o método <code>setPixel()</code> ou <code>setPixel32()</code> e então chame o método <code>unlock()</code> quando tiver feito todas as alterações de pixel. Esse processo impede que os objetos que fazem referência a essa ocorrência de BitmapData sejam atualizados até você terminar de fazer as alterações de pixel.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>x</i> do pixel cujo valor é alterado.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; A posição <i>y</i> do pixel cujo valor é alterado.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; A cor ARGB resultante para o pixel. Se o bitmap for opaco (não transparente), a parte da transparência alfa desse valor de cor será ignorada.
     
     </td></tr></table></p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir usa o método <code>setPixel32()</code> para desenhar uma linha vermelha transparente (alfa == 0x60) em um objeto BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Converte uma matriz de bytes em uma região retangular de dados de pixels. Para cada pixel, o método <code>ByteArray.readUnsignedInt()</code> é chamada e o valor de retorno é gravado no pixel. Se a matriz de bytes terminar antes da gravação de todo o retângulo, a função será retornada. Espera-se que os dados na matriz de bytes sejam valores de pixels ARGB de 32 bits. Nenhuma busca é realizada na matriz de bytes antes ou após a leitura dos pixels.  
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Especifica a região retangular do objeto BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Um objeto ByteArray que consistem em valores de pixels não multiplicados de 32 bits a serem usados na região retangular.
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; O objeto <code>inputByteArray</code> não inclui dados suficientes para preencher a área do retângulo <code>rect</code>. O método preenche a maior quantidade possível de pixels antes de lançar a exceção.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; O parâmetro ret ou matrizBytesEntrada é "null".
      
      </td></tr></table><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir usa os métodos <code>getPixels()</code> e <code>setPixels()</code> para copiar pixels de um objeto BitmapData para outro:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Converte um Vector em uma região retangular de dados de pixels. Para cada pixel, um elemento de Vector é lido e gravado no pixel BitmapData. Espera-se que os dados no Vector sejam valores de pixels ARGB de 32 bits. 
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Especifica a região retangular do objeto BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Um objeto Vector que consistem em valores de pixels não multiplicados de 32 bits a serem usados na região retangular.  
     
     </td></tr></table></p><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; A matriz de vetor não é grande o suficiente para ler todos os dados de pixel.
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Testa valores de pixels em uma imagem com base em um limite especificado e define os pixels aprovados no texto como novos valores de cor. Usando o método <code>threshold()</code>, você pode isolar e substituir faixas de cores em uma imagem e realizar outras operações lógicas em pixels de imagens. 
     
     <p>A lógica de teste do método <code>threshold()</code> é a seguinte:</p> 
     
     <ol><li>Se <code>((valorPixel e máscara) operação (limite e máscara))</code>, defina o pixel como <code>cor</code>;</li><li>Caso contrário, se <code>copiarOrigem == true</code>, defina o pixel como o valor de pixel correspondente a partir de <code>bitmapOrigem</code>.</li></ol>
     
     <p>O parâmetro <code>operação</code> especifica o operador de comparação a ser usado para o teste de limite. Por exemplo, usando "==" como o parâmetro <code>operação</code>, você pode isolar um valor de cor específico em uma imagem. Ou usando o <code>{operação: "&lt;", máscara: 0xFF000000, limite: 0x7F000000, cor: 0x00000000}</code>, é possível definir todos os pixels de destino de forma que eles sejam totalmente transparentes quando o alfa da imagem de origem for menor do que 0x7F. Essa técnica pode ser usada para transições animadas e outros efeitos.</p>
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; A imagem bitmap de entrada a ser usada. A imagem de origem pode ser um objeto BitmapData diferente ou pode fazer referência à ocorrência atual de BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Um retângulo que define a área da imagem de origem a ser usada como entrada.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; O ponto na imagem de destino (a ocorrência atual de BitmapData) que corresponde ao canto superior esquerdo do retângulo de origem.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; Um dos seguintes operadores de comparação, transmitidos como uma String: "&lt;", "&lt;=", ">", ">=", "==", "!="
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; O valor com base no qual cada pixel é testado para ver se ele atende ou excede o limite.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; O valor de cor para o qual um pixel será definido se o teste de limite for bem-sucedido. O valor padrão é 0x00000000.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; A máscara a ser usada para isolar um componente de cor. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Se o valor for <code>true</code>, os valores de pixel da imagem de origem serão copiados para o destino quando o teste de limite falhar. Se o valor for <code>false</code>, a imagem de origem não será copiada quando o teste de limite falhar. 
     
     </td></tr></table></p><p></p><span class="label">Retorna</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; O número de pixels que foram alterados.
     </td></tr></table><br/><span class="label">Lança</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Os parâmetros dadosBitmapOrigem, retOrigem, pontoDest ou operação são "null".
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; A string de operação não é uma operação válida 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir usa o método <code>perlinNoise()</code> para adicionar um padrão de azul e vermelho a um objeto BitmapData e usa o método <code>threshold()</code> para copiar esses pixels do primeiro objeto BitmapData para um segundo objeto, substituindo os pixels nos quais o valor de vermelho é maior do que 0x80 (50%) por um pixel definido como vermelho transparente (0x20FF0000):
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">método</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versão da linguagem:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Versões de runtime:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Desbloqueia uma imagem de forma que qualquer objeto que faça referência ao objeto BitmapData, como objetos Bitmap, seja atualizado quando esse objeto BitmapData for alterado. Para melhorar o desempenho, use esse método junto com o método <code>lock()</code> antes e depois de várias chamadas ao método <code>setPixel()</code> ou <code>setPixel32()</code>.
     
     </p><p><span class="label"> Parâmetros </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; A área do objeto BitmapData que foi alterada. Se você não especificar um valor para esse parâmetro, a área inteira do objeto BitmapData será considerada alterada. Este parâmetro exige o Flash Player versão 9.0.115.0 ou posterior.
     
     </td></tr></table></p><p><span class="label">Elementos da API relacionados</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Exemplo &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span>)
            </span><br/><br/><div class="detailBody"> O exemplo a seguir cria um objeto BitmapData com base na propriedade <code>bitmapData</code> de um objeto Bitmap, <code>picture</code>. Em seguida, ele chama o método <code>lock()</code> antes de chamar uma função personalizada complicada, <code>complexTransformation()</code>, que modifica o objeto BitmapData. (O objeto <code>picture</code> e a função <code>complexTransformation()</code> não são definidas neste exemplo.) Mesmo que a função <code>complexTransformation()</code> atualize a propriedade <code>bitmapData</code> do objeto <code>picture</code>, as alterações apenas serão refletidas quando o código chamar o método <code>unlock()</code> no objeto <code>bitmapData</code>:
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Exemplos<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_br"> Como usar este exemplo </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> O exemplo a seguir usa a classe BitmapDataExample para carregar a imagem Image.gif em DisplayObject, na localização padrão (0, 0). Uma cópia de Image.gif é então inserida à direita do original, que tem novas cores aplicadas aos pixels que passam em um teste usando o método <code>threshold()</code>. A tarefa é concluída com as seguintes etapas:
 <ol><li>Uma propriedade <code>url</code> é criada, representando a localização e o nome do arquivo de imagem</li><li>O construtor da classe cria um objeto Loader, que então instancia um ouvinte de evento que é despachado quando o método <code>completeHandler()</code> completa a manipulação da imagem.</li><li>O objeto URLRequest <code>request</code> é transmitido a <code>loader.load()</code>, que carrega a imagem na memória usando um objeto de exibição.</li><li>A imagem é então inserida na lista de exibição, que a exibe nas coordenadas <i>x = 0, y = 0</i> da tela.</li><li>O método <code>completeHandler()</code> realiza as seguintes tarefas: 
     <ul><li>Cria um segundo Loader, junto com um objeto Bitmap, que é inicializado com o objeto Loader.</li><li>Cria um segundo objeto Bitmap, <code>duplicate</code>, que, por sua vez, chama o método <code>duplicateImage()</code>, que cria uma duplicata da imagem original. </li><li>Cria um objeto BitmapData, que é atribuído ao objeto BitmapData do objeto <code>duplicate</code>.</li><li>Cria um novo objeto Rectangle inicializado com as mesmas coordenadas, largura e altura que a imagem original.</li><li>Cria um novo objeto Point, que assume como padrão <i>x = 0, y = 0</i>.</li><li>Cria as seguintes variáveis:
         <ul><li><code>operation</code> – Aplica a nova cor quando o valor de limite é maior do que ou igual ao original.</li><li><code>threshold</code> – O valor com base no qual cada pixel é comparado (neste exemplo, cinza-claro com um alfa de 0xCC). </li><li><code>color</code> – A cor com a qual serão definidos os pixels que passarem no teste de limite, que é amarelo sólido nesse caso.</li><li><code>mask</code> – O oposto exato da cor (azul transparente).</li><li><code>copySource</code> – Defina como <code>false</code>, indicando que os valores de pixel não serão copiados se o valor de limite não passar no teste. Esse valor não tem significado, já que a imagem é duplicada e somente os pixels que passarem no teste de limite serão alterados.</li></ul></li><li>Chama o método <code>threshold()</code> usando as variáveis anteriores. A equação de limite resultante é a seguinte: <code>se (Valor de pixel atual & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) defina o pixel como 0xFFFFFF00</code>. </li></ul></li></ol>
 <p> <b>Observações:</b>
 <ul><li>Será necessário compilar o arquivo SWF com a Segurança de reprodução local definida como Acessar somente arquivos locais.
 </li><li>Esse exemplo requer que um arquivo denominado Image.gif seja inserido no mesmo diretório que o seu arquivo SWF.
 </li><li>Convém usar uma imagem com aproximadamente até 80 pixels de largura. </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Wed Jun 13 2018, 11:10 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/pt_BR/legalnotices/index.html">Aspectos jurídicos</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Política de privacidade on-line</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Por que inglês?</span>
				</div>
				<div class="white_content_body">
					<b>O conteúdo na Referência do ActionScript 3.0 aparece em inglês</b><br><br>
					Nem todas as partes da Referência do ActionScript 3.0 estão traduzidas em todos os idiomas. Quando um elemento de um idioma não está traduzido, ele é exibido em inglês. Por exemplo, a classe ga.controls.HelpBox não está traduzida em nenhum idioma. Por isso, na versão da referência em português do Brasil, a classe ga.controls.HelpBox é exibida em inglês.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Wed Jun 13 2018, 11:10 AM Z  -->
