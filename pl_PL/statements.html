<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 &mdash; dokumentacja dla platformy Adobe&reg; Flash&reg;  "><meta name="lang" content="pl-pl"><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"><link rel="stylesheet" href="asfilter.css" type="text/css"><link rel="stylesheet" href="ion.css" type="text/css"><title>Instrukcje, słowa kluczowe i dyrektywy - Adobe ActionScript&reg; 3 (AS3) &mdash; dokumentacja interfejsu API</title>
		<link rel="stylesheet" href="filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="filter_new.css" type="text/css">
			
		<script src="jquery.js" type="text/javascript"></script>
		<script src="s_chl_code.js" type="text/javascript"></script>
		<script src="jquery.zclip.js" type="text/javascript"></script>
		<script src="jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="cookies.js" type="text/javascript"></script>
		<script src="asdoc.js" type="text/javascript"></script>
		<script src="iscroll.js" type="text/javascript"></script>
		<script src="AC_OETags.js" type="text/javascript"></script>
		<script src="omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Środowiska wykonawcze";
			var productsLabel = "Produkty";
			var noneLabel = "Brak";
			var qsearchBoxLabel = "Wyszukiwanie";
			var qsearchText = "Nie znaleziono terminu.";
			var ajaxErrorMsg="Błąd wczytywania strony";
			var ajaxErrorTryMsg="Ponów próbę";
			var ajaxLoadingMsg="Wczytywanie nadal w toku";
			var cancelMsg = "Anuluj";
			var classesText = "Klasy";
			var strJiveReply = "To pytanie zamieszczono w odpowiedzi na następujący artykuł: "
			var showFilters = "Pokaż filtry";
			var hideFilters = "Ukryj filtry";
			
		
			var baseRef = "./";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 &mdash; dokumentacja dla platformy Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="index.html"> Strona główna </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="statements.html#top" style="display:">Pokaż listę pakietów i klas</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="statements.html#top" style="display:none">Ukryj listę pakietów i klas</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="package-summary.html"> Pakiety </a>&nbsp;|&nbsp;
												<a target="_self" href="class-summary.html"> Klasy </a>&nbsp;|&nbsp;
												<a target="_self" href="whatsnew.html"> Nowości </a>&nbsp;|&nbsp;
												<a target="_self" href="all-index-Symbols.html"> Indeks </a>&nbsp;|&nbsp;
												<a target="_self" href="appendixes.html"> Dodatki </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Dlaczego język angielski?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/pl_PL/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('./')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('./')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="help.js"></script>
						<script language="javascript" type="text/javascript" src="asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filtry:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="statements.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">&nbsp;</a><br>
								<h1 id="classProductName">Instrukcje, słowa kluczowe i dyrektywy&nbsp;</h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="statements.html#propertySummary" style="display:none"> Właściwości </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Właściwości </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="statements.html#methodSummary" style="display:none"> Metody </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="statements.html#constantSummary" style="display:none"> Stałe globalne </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="statements.html#eventSummary" style="display:none"> Zdarzenia </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="statements.html#styleSummary" style="display:none"> Style </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="statements.html#SkinPartSummary" style="display:none"> Części karnacji </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="statements.html#SkinStateSummary" style="display:none"> Stany karnacji </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="statements.html#effectSummary" style="display:none"> Efekty </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="statements.html#constantSummary" style="display:none"> Stałe </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="statements.html#methodSummary" style="display:none"> Funkcje globalne </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="statements.html#methodSummary" style="display:none">Funkcje</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="statements.html#interfaceSummary" style="display:none"> Interfejsy </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="statements.html#classSummary" style="display:none"> Klasy </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="statements.html#includeExamplesSummary" style="display:none"> Przykłady </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="statements.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klasy
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><p>Instrukcje są to elementy języka, które wykonują lub określają operacje w czasie wykonywania skryptu. Na przykład instrukcja <code>return</code> zwraca wartość wynikową funkcji, w której jest wykonywana. Instrukcja <code>if</code> sprawdza warunek, aby określić, jaka operacja powinna zostać wykonana jako następna. Instrukcja <code>switch</code> tworzy rozgałęzioną strukturę instrukcji języka ActionScript. 
		<p>Słowa kluczowe atrybutów zmieniają znaczenie definicji i mogą być stosowane do definicji klas, zmiennych, funkcji i przestrzeni nazw. Słowa kluczowe definicji służą do definiowania takich elementów, jak zmienne, funkcje, klasy i interfejsy. Podstawowe słowa kluczowe wyrażeń reprezentują wartości literalne (literały). Wykaz słów zastrzeżonych zawiera publikacja <a href="http://www.adobe.com/go/learn_as3_reservedwords_pl" >Nauka języka ActionScript 3.0</a>.</p> 
		<p>Do dyrektyw zalicza się zarówno instrukcje, jak i definicje; dyrektywy mogą mieć wpływ na przebieg kompilacji lub wykonywania. Dyrektywy, które nie są ani instrukcjami, ani definicjami, zostały w poniższej tabeli oznaczone jako dyrektywy.</p>
		</p><br><a name="statementSummary"></a><table cellspacing="0" cellpadding="3" class="summaryTable"><tr><th>&nbsp;</th><th colspan="2">słowo kluczowe definicji</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#..._(rest)_parameter">... (rest) parameter</a></td><td class="summaryTableLastCol">Określa, że funkcja może przyjmować dowolną liczbę argumentów oddzielonych przecinkami.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#class">class</a></td><td class="summaryTableLastCol">Definiuje klasę, która umożliwia tworzenie instancji obiektów o wspólnych właściwościach i metodach zdefiniowanych w klasie.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#const">const</a></td><td class="summaryTableLastCol">Określa stałą, czyli zmienną, której można przypisać wartość tylko jeden raz.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#extends">extends</a></td><td class="summaryTableLastCol">Definiuje klasę będącą podklasą innej klasy.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#function">function</a></td><td class="summaryTableLastCol">Zawiera zestaw instrukcji zdefiniowanych w celu wykonywania określonego zadania.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#get">get</a></td><td class="summaryTableLastCol">Definiuje funkcję pobierającą, tj. metodę, którą można odczytywać tak, jak właściwość.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#implements">implements</a></td><td class="summaryTableLastCol">Określa, że klasa implementuje jeden lub więcej interfejsów.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#interface">interface</a></td><td class="summaryTableLastCol">Definiuje interfejs.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#namespace">namespace</a></td><td class="summaryTableLastCol">Umożliwia sterowanie widocznością definicji.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#package">package</a></td><td class="summaryTableLastCol">Pozwala podzielić kod na odrębne grupy, które można importować do innych skryptów.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#set">set</a></td><td class="summaryTableLastCol">Definiuje funkcję ustawiającą, tj. metodę widoczną w interfejsie publicznym jako właściwość.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#var">var</a></td><td class="summaryTableLastCol">Określa zmienną.</td></tr><tr><th>&nbsp;</th><th colspan="2">dyrektywa</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default_xml_namespace">default xml namespace</a></td><td class="summaryTableLastCol">
			Dyrektywa <code>default xml namespace</code> określa domyślną przestrzeń nazw, jaka ma być używana dla obiektów XML.
			</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#import">import</a></td><td class="summaryTableLastCol">Udostępnia dla lokalnego kodu klasy i pakiety zdefiniowane zewnętrznie względem niego.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#include">include</a></td><td class="summaryTableLastCol">Włącza zawartość określonego pliku w taki sposób, jak gdyby polecenia zawarte w tym pliku były częścią skryptu wywołującego.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#use_namespace">use namespace</a></td><td class="summaryTableLastCol">Powoduje dodanie określonych przestrzeni nazw do zestawu otwartych przestrzeni nazw.</td></tr><tr><th>&nbsp;</th><th colspan="2">instrukcja</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#break">break</a></td><td class="summaryTableLastCol">Występuje w pętli (<code>for</code>, <code>for...in</code>, <code>for each..in</code>, <code>do..while</code> lub <code>while</code>) lub w bloku instrukcji skojarzonym z konkretnym warunkiem w instrukcji <code>switch</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#case">case</a></td><td class="summaryTableLastCol">Definiuje miejsce docelowe skoku dla instrukcji <code>switch</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#continue">continue</a></td><td class="summaryTableLastCol">Przeskakuje poza wszystkie pozostałe instrukcje w najbardziej wewnętrznej pętli i rozpoczyna następną iterację pętli, tak jak przy normalnym przekazaniu sterowania na koniec pętli.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default">default</a></td><td class="summaryTableLastCol">Definiuje domyślny przypadek w instrukcji <code>switch</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#do..while">do..while</a></td><td class="summaryTableLastCol">Podobna do pętli <code>while</code> z jednym wyjątkiem: instrukcje są zawsze wykonywane jeden raz przed pierwszym sprawdzeniem warunku.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#else">else</a></td><td class="summaryTableLastCol">Określa instrukcje, które mają być wykonane, jeśli wyrażenie warunkowe w instrukcji <code>if</code> zwróci wartość <code>false</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for">for</a></td><td class="summaryTableLastCol">Jednokrotnie wyznacza wartość wyrażenia <code>init</code> (inicjacja) i rozpoczyna wykonywanie pętli.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for..in">for..in</a></td><td class="summaryTableLastCol">Przechodzi iteracyjnie do kolejnych dynamicznych właściwości obiektu lub elementów tablicy i wykonuje na każdym z nich instrukcję <code>statement</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for_each..in">for each..in</a></td><td class="summaryTableLastCol">Iteracyjnie przechodzi przez kolejne elementy kolekcji i wykonuje na każdym z nich instrukcję <code>statement</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#if">if</a></td><td class="summaryTableLastCol">Sprawdza warunek w celu określenia, którą instrukcję należy wykonać jako następną.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#label">label</a></td><td class="summaryTableLastCol">Kojarzy instrukcję z identyfikatorem, do którego można odwoływać się w instrukcji <code>break</code> lub <code>continue</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#return">return</a></td><td class="summaryTableLastCol">Powoduje natychmiastowe przekazanie sterowania (powrót) do funkcji wywołującej.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#switch">switch</a></td><td class="summaryTableLastCol">Przekazuje sterowanie do jednej z kilku instrukcji, w zależności od wartości wyrażenia.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#throw">throw</a></td><td class="summaryTableLastCol">Generuje (pot. <em>wyrzuca</em>, ang. throw) błąd, który może być obsłużony (pot. <em>przechwycony</em>, ang. catch) przez blok kodu <code>catch</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#try..catch..finally">try..catch..finally</a></td><td class="summaryTableLastCol">Otacza blok kodu, w którym może wystąpić błąd, i pozwala zareagować na błąd.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#while">while</a></td><td class="summaryTableLastCol">Wyznacza wartość warunku i jeśli wartość ta jest równa <code>true</code>, wykonuje jedną lub wiele instrukcji, po czym wraca na początek pętli i ponownie wyznacza wartość warunku.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#with">with</a></td><td class="summaryTableLastCol">Ustanawia obiekt domyślny, na którym mają być wykonywane instrukcje, pozwalając na skrócenie kodu programu.</td></tr><tr><th>&nbsp;</th><th colspan="2"> Przestrzenie nazw </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#AS3">AS3</a></td><td class="summaryTableLastCol">Definiuje metody i właściwości podstawowych klas języka ActionScript, które są właściwościami ustalonymi, a nie prototypowymi.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#flash_proxy">flash_proxy</a></td><td class="summaryTableLastCol">Definiuje metody klasy Proxy.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#object_proxy">object_proxy</a></td><td class="summaryTableLastCol">Definiuje metody klasy ObjectProxy.</td></tr><tr><th>&nbsp;</th><th colspan="2">podstawowe słowo kluczowe wyrażenia</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#false">false</a></td><td class="summaryTableLastCol">Wartość typu Boolean reprezentująca fałsz.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#null">null</a></td><td class="summaryTableLastCol">Wartość specjalna, która może być przypisywana zmiennym lub zwracana przez funkcję w przypadku braku danych.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#this">this</a></td><td class="summaryTableLastCol">Odwołanie do obiektu zawierającego metodę.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#true">true</a></td><td class="summaryTableLastCol">Wartość typu Boolean reprezentująca prawdę.</td></tr><tr><th>&nbsp;</th><th colspan="2"> Instrukcje </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#super">super</a></td><td class="summaryTableLastCol">Wywołuje nadklasę (czyli wersję będącą przodkiem) metody lub konstruktora.</td></tr><tr><th>&nbsp;</th><th colspan="2">słowo kluczowe atrybutu</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#dynamic">dynamic</a></td><td class="summaryTableLastCol">Określa, że instancje klasy mogą mieć właściwości dynamiczne, dodawane w czasie wykonywania.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#final">final</a></td><td class="summaryTableLastCol">Określa, że nie można przesłonić metody lub że nie można rozszerzyć klasy.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#internal">internal</a></td><td class="summaryTableLastCol">Określa, że klasa, zmienna, stała lub funkcja jest dostępna dla dowolnego kodu wywołującego w ramach tego samego pakietu.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#native">native</a></td><td class="summaryTableLastCol">Określa, że funkcja lub metoda jest zaimplementowana w kodzie macierzystym programu Flash Player.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#override">override</a></td><td class="summaryTableLastCol">Określa, że metoda zastępuje metodę dziedziczoną.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#private">private</a></td><td class="summaryTableLastCol">Określa, że zmienna, stała, metoda lub przestrzeń nazw jest dostępna tylko w tej klasie, w której ją zdefiniowano.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#protected">protected</a></td><td class="summaryTableLastCol">Określa, że zmienna, stała, metoda lub przestrzeń nazw jest dostępna tylko w tej klasie, w której ją zdefiniowano, oraz we wszystkich podklasach tej klasy.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#public">public</a></td><td class="summaryTableLastCol">Określa, że klasa, zmienna, stała lub metoda jest dostępna dla dowolnego kodu wywołującego.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#static">static</a></td><td class="summaryTableLastCol">Określa, że zmienna, stała lub metoda należy do klasy, a nie do wystąpienia klasy.</td></tr></table><div class="detailSectionHeader">Instrukcje, słowa kluczowe i szczegóły dyrektyw</div><a name="..._(rest)_parameter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">... (rest) parameter</td><td class="detailHeaderType">słowo kluczowe definicji</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName(parameter0, parameter1, ...rest){ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>Określa, że funkcja może przyjmować dowolną liczbę argumentów oddzielonych przecinkami. Lista argumentów staje się tablicą i jest dostępna w treści funkcji. Nazwę tablicy podaje się po znakach <code>...</code> w deklaracji parametrów. Parametr może mieć dowolną nazwę niebędącą słowem zastrzeżonym. 
			<p>Deklaracja parametrów <code>...</code> (rest), jeśli jest określona razem z innymi parametrami, musi być ostatnim parametrem. Tablica parametrów <code>...</code> (rest) jest zapełniana tylko wtedy, gdy liczba argumentów przekazanych do funkcji jest większa od liczby pozostałych zadeklarowanych parametrów.</p> 
			<p>Każdy argument na liście argumentów oddzielanych przecinkami jest umieszczany w jednym elemencie tablicy. W wypadku przekazania instancji klasy Array cała tablica jest umieszczana w jednym elemencie tablicy parametrów <code>...</code> (rest).</p>
			<p>Użycie tego parametru powoduje, że obiekt <code>arguments</code> staje się niedostępny. Mimo że parametr <code>...</code> (rest) zapewnia tę samą funkcjonalność, co tablica <code>arguments</code> i właściwość <code>arguments.length</code>, nie zapewnia funkcjonalności zbliżonej do oferowanej przez właściwość <code>arguments.callee</code>. Dlatego nie należy korzystać z parametru <code>...</code> (rest) w sytuacjach, w których konieczne byłoby użycie właściwości <code>arguments.callee</code>.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rest</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Identyfikator, który reprezentuje nazwę tablicy argumentów przekazanych do funkcji. Parametr nie musi mieć nazwy rest; może mieć dowolną nazwę niebędącą słowem kluczowym. Dozwolone jest określenie typu Array dla parametru ... (rest), jednak może to być mylące, ponieważ w istocie parametr musi być listą wartości oddzielonych przecinkami, a nie instancją klasy Array.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie parametr ... (rest) zastosowano w dwóch różnych funkcjach. Pierwsza funkcja, traceParams, wywołuje po prostu funkcję trace() dla każdego argumentu przekazanego w tablicy rest. Druga funkcja, average(), zwraca średnią z listy argumentów. Ponadto w drugiej funkcji parametr ma inną nazwę: args.
<div class="listing"><pre>
package {
	import flash.display.MovieClip;
	
	public class RestParamExample extends MovieClip {
		public function RestParamExample() {
			traceParams(100, 130, "two"); // 100,130,two
			trace(average(4, 7, 13));     // 8
		}
	}
}


function traceParams(... rest) {
 	trace(rest);
 }
 
function average(... args) : Number{
	var sum:Number = 0;
	for (var i:uint = 0; i < args.length; i++) {
		sum += args[i];
	}
	return (sum / args.length);
}
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments, obiekt</a></div></div><a name="AS3"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">AS3</td><td class="detailHeaderType"> Przestrzenie nazw </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Definiuje metody i właściwości podstawowych klas języka ActionScript, które są właściwościami ustalonymi, a nie prototypowymi. Ustawienie opcji kompilatora "-as3" na <code>true</code> (w programie Flex Builder 2 jest to ustawienie domyślne) powoduje automatyczne otwarcie przestrzeni nazw AS3 dla wszystkich klas podstawowych. Oznacza to, że w instancji klasy podstawowej będą używane właściwości i metody ustalone, a nie wersje tych samych właściwości i metod dołączone do obiektu prototypowego klasy. Zastosowanie właściwości ustalonych zapewnia zwykle lepszą wydajność kosztem zgodności wstecz z wydaniem 3 specyfikacji języka ECMAScript (ECMA-262).</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Object.html" target="">Klasa Object</a></div></div><a name="break"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">break</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>break [label]</code></p></p></td></tr></table><p></p><p><p>Występuje w pętli (<code>for</code>, <code>for...in</code>, <code>for each..in</code>, <code>do..while</code> lub <code>while</code>) lub w bloku instrukcji skojarzonym z konkretnym warunkiem w instrukcji <code>switch</code>. Instrukcja <code>break</code> użyta w pętli nakazuje pominięcie pozostałej części treści pętli, przerwanie pętli i wykonanie instrukcji następującej po instrukcji pętli. Instrukcja <code>break</code> użyta wewnątrz instrukcji <code>switch</code> nakazuje pominięcie pozostałych instrukcji w danym bloku <code>case</code> i przejście do pierwszej instrukcji, jaka następuje po zamykającej instrukcji <code>switch</code>. 
			<p>W pętlach zagnieżdżonych instrukcja <code>break</code> pomija tylko resztę bieżącej pętli i nie powoduje przerwania całego szeregu pętli zagnieżdżonych. Aby przerwać szereg pętli zagnieżdżonych, należy użyć instrukcji <code>label</code> lub <code>try..catch..finally</code>.</p>
			<p>Z instrukcją <code>break</code> może być skojarzona opcjonalna etykieta identyczna z etykietą jednej z instrukcji zewnętrznych. Użycie etykiety, która nie ma odpowiednika w etykietach instrukcji zewnętrznych, jest błędem składniowym. Instrukcje <code>break</code> z etykietami mogą służyć do przerywania wielopoziomowych pętli zagnieżdżonych, instrukcji <code>switch</code> lub instrukcji <code>block</code>. Odpowiedni przykład zamieszczono przy opisie instrukcji <code>label</code>.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa etykiety skojarzonej z instrukcją.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zastosowano instrukcję break do wyjścia z pętli nieskończonej: 
<div class="listing"><pre>
var i:int = 0;
while (true) { 
	trace(i); 
	if (i >= 10) { 
		break; // this will terminate/exit the loop 
	} 
	i++; 
} 
/*
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10*/</pre></div>  
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..w</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="case"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">case</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>case jumpTarget: statements</pre></p></td></tr></table><p></p><p><p>Definiuje miejsce docelowe skoku dla instrukcji <code>switch</code>. Jeśli parametr <code>jumpTarget</code> jest ściśle (zgodnie z działaniem operatora <code>===</code>) równy parametrowi <code>expression</code> instrukcji <code>switch</code>, program Flash Player wykonuje instrukcje w parametrze <code>statements</code>, dopóki nie napotka instrukcji <code>break</code> lub końca instrukcji <code>switch</code>. <p>Użycie instrukcji <code>case</code> poza instrukcją <code>switch</code> spowoduje zgłoszenie błędu i uniemożliwi skompilowanie skryptu.</p> 
			<p></p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">jumpTarget</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Dowolne wyrażenie.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Instrukcje, które mają być wykonane, jeśli parametr jumpTarget będzie równy wyrażeniu warunkowemu instrukcji switch.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zdefiniowano miejsca docelowe skoku dla instrukcji switch z warunkiem thisMonth. Jeśli wartość thisMonth będzie równa wyrażeniu w instrukcji case, zostaną wykonane instrukcje skojarzone z tym wyrażeniem. 
<div class="listing"><pre>
var thisMonth:int = new Date().getMonth(); 
switch (thisMonth) { 
	case 0 : 
		trace("January"); 
		break; 
	case 1 : 
		trace("February"); 
		break; 
	case 5 : 
	case 6 : 
	case 7 : 
		trace("Some summer month"); 
		break; 
	case 8 : 
		trace("September"); 
		break; 
	default : 
		trace("some other month"); 
}</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#switch" target="">switch</a></div></div><a name="class"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">class</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>[dynamic] [public | internal] [final] class className [ extends superClass ] [ implements interfaceName[, interfaceName... ] ] { 
	// class definition here
}</pre>
			</p></td></tr></table><p></p><p><p>Definiuje klasę, która umożliwia tworzenie instancji obiektów o wspólnych właściwościach i metodach zdefiniowanych w klasie. Na przykład, jeśli opracowujemy system rejestracji faktur, możemy utworzyć klasę Faktura definiującą wszystkie metody i właściwości wspólne dla każdej faktury. Następnie używalibyśmy polecenia <code>new Faktura()</code> do tworzenia obiektów klasy Faktura. 
			<p>Każdy plik źródłowy ActionScript może zawierać tylko jedną klasę widoczną dla innych plików źródłowych lub skryptów. Ta klasa widoczna na zewnątrz może być klasą publiczną lub wewnętrzną i musi być zdefiniowana wewnątrz instrukcji package. Jeśli ten sam plik zawiera inne klasy, muszą one być umieszczone poza instrukcją package, na końcu pliku. </p>
			<p>Nazwa klasy widocznej z zewnątrz musi być zgodna z nazwą pliku źródłowego ActionScript zawierającego tę klasę. Nazwa pliku źródłowego musi składać się z nazwy klasy z dodanym rozszerzeniem .as. Na przykład, jeśli nazwa klasy to Student, plik definiujący tę klasę musi nosić nazwę Student.as.</p> 
			<p>Nie jest dozwolone zagnieżdżanie definicji klas, tzn. nie można definiować dodatkowych klas wewnątrz definicji klasy.</p> 
			<p>Istnieje możliwość zdefiniowania metody-konstruktora, tj. metody wykonywanej za każdym razem, gdy jest tworzona nowa instancja klasy. Nazwa metody-konstruktora musi być identyczna z nazwą klasy. Jeśli metoda-konstruktor nie zostanie zdefiniowana jawnie, zostanie utworzony konstruktor domyślny.</p>
			<p>Aby wskazać, że obiekty mogą w czasie wykonywania dodawać właściwości dynamiczne i uzyskiwać do nich dostęp, należy poprzedzić instrukcję class słowem kluczowym <code>dynamic. </code> Aby zadeklarować, że klasa implementuje interfejs, należy użyć słowa kluczowego <code>implements</code>. Do tworzenia podklas klasy służy słowo kluczowe <code>extends</code>. (Klasa może stanowić rozszerzenie tylko jednej klasy, ale może implementować kilka interfejsów). Słów kluczowych <code>implements</code> i <code>extends</code> można użyć w tej samej instrukcji. Następujący przykład ilustruje typowe zastosowania słów kluczowych <code>implements</code> i <code>extends</code>:</p> 
<div class="listing"><pre>class C implements Interface_i, Interface_j // OK 
class C extends Class_d implements Interface_i, Interface_j // OK 
class C extends Class_d, Class_e // not OK </pre></div> 

			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; W pełni kwalifikowana nazwa klasy.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następujący przykład tworzy klasę o nazwie Plant. Konstruktor Plant ma dwa parametry. 
<div class="listing"><pre>// Filename Plant.as 
package {
  public class Plant { 
	// Define property names and types 
	private var _leafType:String; 
	private var _bloomSeason:String; 
	// Following line is constructor 
	// because it has the same name as the class 
	public function Plant(param_leafType:String, param_bloomSeason:String) { 
		// Assign passed values to properties when new Plant object is created 
		_leafType = param_leafType; 
		_bloomSeason = param_bloomSeason; 
	} 
	// Create methods to return property values, because best practice 
	// recommends against directly referencing a property of a class 
	public function get leafType():String { 
		return _leafType; 
	} 
	public function get bloomSeason():String { 
		return _bloomSeason; 
	} 
  }
}</pre></div> 
W skrypcie możemy użyć operatora new do utworzenia obiektu Plant.
<div class="listing"><pre>
var pineTree:Plant = new Plant("Evergreen", "N/A"); 
// Confirm parameters were passed correctly 
trace(pineTree.leafType); 
trace(pineTree.bloomSeason); </pre></div> 
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#dynamic" target="">dynamic</a><br/><a href="statements.html#extends" target="">extends</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="const"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">const</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>const identifier = value </pre></p></td></tr></table><p></p><p><p>Określa stałą, czyli zmienną, której można przypisać wartość tylko jeden raz.  
			<p>Możliwe jest ścisłe określenie typu stałej poprzez dopisanie za jej nazwą dwukropka (:) i typu danych.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">identifier</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Identyfikator stałej.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład dowodzi, że próba przypisania wartości do stałej więcej niż raz spowoduje zgłoszenie błędu.
<div class="listing"><pre>
const MIN_AGE:int = 21;
MIN_AGE = 18; // error</pre></div>
W poniższym przykładzie zademonstrowano, że nawet jeśli stała jest tablicą, dozwolone jest wywoływanie z niej metod klasy Array, w tym Array.push(). Nie można jednak przypisać stałej nowego literału tablicowego. 
<div class="listing"><pre>
const product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); // array operations are allowed
product_array = ["Other"];  // assignment is an error
trace(product_array); 
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#var" target="">var</a></div></div><a name="continue"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">continue</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>continue [label]</pre></p></td></tr></table><p></p><p><p>Przeskakuje poza wszystkie pozostałe instrukcje w najbardziej wewnętrznej pętli i rozpoczyna następną iterację pętli, tak jak przy normalnym przekazaniu sterowania na koniec pętli. Instrukcja <code>continue</code> nie ma wpływu na wykonywanie kodu poza pętlą. W pętlach zagnieżdżonych można użyć opcjonalnego parametru <code>label</code> w celu przeskoczenia nie tylko pętli najbardziej wewnętrznej, lecz także zewnętrznych.
			<p>Z instrukcją <code>continue</code> może być skojarzona opcjonalna etykieta identyczna z etykietą jednej z instrukcji zewnętrznych. Użycie etykiety, która nie ma odpowiednika w etykietach instrukcji zewnętrznych, jest błędem składniowym. Instrukcje <code>continue</code> z etykietami mogą służyć do przerywania wielopoziomowych pętli zagnieżdżonych.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższej pętli while instrukcja continue powoduje pominięcie pozostałej części treści pętli zawsze, gdy napotkana zostanie wielokrotność liczby 3; następuje wówczas skok na początek pętli, gdzie testowany jest warunek: 
<div class="listing"><pre>
var i:int = 0; 
while (i < 10) { 
	if (i % 3 == 0) { 
		i++; 
		continue; 
	} 
	trace(i); 
	i++; 
}</pre></div> 
W pętli for również można użyć instrukcji continue do przeskoczenia pozostałej części treści pętli. W poniższym przykładzie instrukcja trace(i) jest pomijana, jeśli i % 3 równa się 0: 
<div class="listing"><pre> 
for (var i:int = 0; i < 10; i++) { 
	if (i % 3 == 0) { 
		continue; 
	} 
	trace(i); 
}</pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..w</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="default"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>default: statements </pre></p></td></tr></table><p></p><p><p>Definiuje domyślny przypadek w instrukcji <code>switch</code>. Instrukcje są wykonywane, jeśli parametr <code>expression</code> instrukcji <code>switch</code> nie równa się (ściśle, zgodnie z działaniem operatora [<code>===</code>]) żadnemu z parametrów <code>expression</code> następujących po słowach kluczowych <code>case</code> danej instrukcji <code>switch</code>. 
			<p>Instrukcja <code>switch</code> nie musi zawierać instrukcji przypadku <code>default</code>. Instrukcja przypadku <code>default</code> nie musi być ostatnia na liście. Użycie instrukcji <code>default</code> poza instrukcją <code>switch</code> spowoduje zgłoszenie błędu i uniemożliwi skompilowanie skryptu.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Dowolne instrukcje.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie, jeśli dniem tygodnia jest Saturday (sobota) lub Sunday (niedziela), nie ma zastosowania żadna z instrukcji case, dlatego wykonywana jest instrukcja default. 
<div class="listing"><pre>
var dayOfWeek:int = new Date().getDay(); 
switch (dayOfWeek) { 
	case 1 : 
		trace("Monday"); 
		break; 
	case 2 : 
		trace("Tuesday"); 
		break; 
	case 3 : 
		trace("Wednesday"); 
		break; 
	case 4 : 
		trace("Thursday"); 
		break; 
	case 5 : 
		trace("Friday"); 
		break; 
	default : 
		trace("Weekend"); 
}</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#switch" target="">switch</a></div></div><a name="default_xml_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default xml namespace</td><td class="detailHeaderType">dyrektywa</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>default xml namespace = ns</code></p></p></td></tr></table><p></p><p><p>
			Dyrektywa <code>default xml namespace</code> określa domyślną przestrzeń nazw, jaka ma być używana dla obiektów XML. 
			
			<p>Jeśli dyrektywa <code>default xml namespace</code> nie zostanie użyta, domyślną przestrzenią nazw będzie przestrzeń unnamed (z pustym ciągiem znaków jako identyfikatorem URI). Zasięg deklaracji <code>default xml namespace</code> to blok funkcji, podobnie jak zasięg zmiennej.
			</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład demonstruje, że zasięgiem dyrektywy default xml namespace jest blok funkcji:
			<div class="listing"><pre>var nsDefault1:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault1;
	    
var x1:XML = <test1 />;
trace("x1 ns: " + x1.namespace());
			
scopeCheck();	

var x2:XML = <test2 />;
trace("x2 ns: " + x2.namespace());
		
function scopeCheck(): void {
	
	var x3:XML = <test3 />;
	trace("x3 ns: " + x3.namespace());
				
	var nsDefault2:Namespace = new Namespace("http://schemas.xmlsoap.org/soap/envelope/");
	default xml namespace = nsDefault2;
		    
	var x4:XML = <test4 />;
	trace("x4 ns: " + x4.namespace());

}</pre></div>
			
			Wyniki wykonania funkcji trace() w tym przykładzie są następujące:
			
			x1 ns: http://www.example.com/namespaces/
x3 ns: 
x4 ns: http://schemas.xmlsoap.org/soap/envelope/
x2 ns: http://www.example.com/namespaces/



W poniższym przykładzie dyrektywę default xml namespace zastosowano do przypisania domyślnej przestrzeni nazw. Ustawienie domyślne nie obowiązuje dla drugiego obiektu XML (x2), ponieważ obiekt x2 definiuje swoją własną domyślną przestrzeń nazw: 
<div class="listing"><pre>
var nsDefault:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault;
            
var x1:XML = <test1 />;

trace(x1.namespace());
	// http://www.example.com/namespaces/

var x2:XML = <test2 xmlns = "http://www.w3.org/1999/XSL/Transform/" />;
trace(x2.namespace());
	// http://www.w3.org/1999/XSL/Transform/

var x3:XML = <test3 xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" />;
trace(x3.namespace());
	// http://www.example.com/namespaces/
</pre></div>  
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#namespace" target="">namespace</a><br/><a href="Namespace.html" target="">Klasa przestrzeni nazw</a><br/><a href="statements.html#use_namespace" target="">use namespace</a><br/><a href="XML.html" target="">XML</a></div></div><a name="do..while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">do..while</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>do { statement(s) } while (condition)</pre></p></td></tr></table><p></p><p><p>Podobna do pętli <code>while</code> z jednym wyjątkiem: instrukcje są zawsze wykonywane jeden raz przed pierwszym sprawdzeniem warunku. Następnie instrukcje są wykonywane tylko wtedy, gdy wynik wyrażenia warunkowego jest równy <code>true</code>. <p>Pętla <code>do..while</code> gwarantuje co najmniej jednokrotne wykonanie kodu zawartego w pętli. Mimo że ten sam rezultat można uzyskać za pomocą pętli <code>while</code>, umieszczając kopię instrukcji przeznaczonych do wykonania przed rozpoczęciem pętli <code>while</code>, w opinii wielu programistów pętle <code>do..while</code> są bardziej czytelne.</p> 
			<p>Jeśli wynikiem wyrażenia warunkowego zawsze jest <code>true</code>, pętla <code>do..while</code> jest nieskończona. Wejście w pętlę nieskończoną spowoduje problemy z działaniem programu Flash Player i ostatecznie doprowadzi do wyświetlenia komunikatu ostrzegawczego lub awarii odtwarzacza. Jeśli liczba wykonań pętli jest z góry znana, należy w miarę możliwości korzystać z pętli <code>for</code>. Mimo że pętle <code>for</code> są czytelne i łatwe w debugowaniu, nie we wszystkich okolicznościach mogą zastąpić pętle <code>do..while</code>.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Warunek do sprawdzenia. Instrukcje statement(s) wewnątrz bloku kodu do będą wykonywane tak długo, jak wyrażenie określone parametrem condition będzie miało wartość true.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zastosowano pętlę do.. while, która sprawdza, czy warunek jest spełniony (true) i wyświetla wartość zmiennej myVar, dopóki wartość myVar nie będzie równa co najmniej 5. Wykonywanie pętli kończy się, gdy zmienna myVar osiągnie wartość 5 lub wyższą. 
<div class="listing"><pre>
var myVar:Number = 0; 
do { 
	trace(myVar); 
	myVar++; 
} 
while (myVar < 5); 
/*
0 
1 
2 
3 
4
*/</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="dynamic"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dynamic</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>dynamic class className { // class definition here }</pre></p></td></tr></table><p></p><p><p>Określa, że instancje klasy mogą mieć właściwości dynamiczne, dodawane w czasie wykonywania. Nadanie klasie atrybutu <code>dynamic</code> umożliwi dodawanie właściwości do instancji tej klasy w czasie wykonywania. Klasy nieoznaczone jako <code>dynamic</code> są uznawane za <em>zapieczętowane</em>, co oznacza, że do ich instancji nie można dodawać właściwości.
			<p>Jeśli klasa jest zapieczętowana (a nie dynamiczna), próba pobrania lub ustawienia właściwości w jej instancji spowoduje błąd. Jeśli kompilator działa w trybie ścisłym i podczas tworzenia instancji określony zostanie typ danych, próba dodania właściwości do obiektu zapieczętowanego spowoduje błąd kompilatora; w przeciwnym razie wystąpi błąd w czasie wykonywania.</p> 
			<p>Atrybut <code>dynamic</code> nie jest dziedziczony przez podklasy. W przypadku rozszerzenia klasy dynamicznej podklasa jest dynamiczna tylko wtedy, gdy zostanie zadeklarowana z atrybutem <code>dynamic</code>.</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie tworzone są dwie klasy: jedna klasa dynamiczna o nazwie Expando i jedna klasa zapieczętowana o nazwie Sealed. Klasy te będą używane w następnych przykładach.
<div class="listing"><pre>
package {

	dynamic class Expando  {
	}
	
	class Sealed {
	}
}
</pre></div>
Poniższy kod tworzy instancję klasy Expando i ilustruje możliwość dodawania właściwości do instancji.
<div class="listing"><pre>
var myExpando:Expando = new Expando();
myExpando.prop1 = "new";
trace(myExpando.prop1); // new
</pre></div>
Poniższy kod tworzy instancję klasy Sealed i demonstruje, że próba dodania właściwości spowoduje błąd.
<div class="listing"><pre>
var mySealed:Sealed = new Sealed();
mySealed.prop1 = "newer"; // error
</pre></div>
		

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">klasa</a></div></div><a name="else"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">else</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) { 
	// statement(s)
} 
else {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Określa instrukcje, które mają być wykonane, jeśli wyrażenie warunkowe w instrukcji <code>if</code> zwróci wartość <code>false</code>. Jeśli w ramach instrukcji <code>else</code> ma być wykonana tylko jedna instrukcja, nie jest wymagane ujmowanie jej w nawiasy sześcienne (<code>{}</code>).</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Wyrażenie, które daje w wyniku wartość true albo false.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie warunek else został wykorzystany do sprawdzenia, czy zmienna age_txt ma wartość większą, czy mniejszą od 18: 
<div class="listing"><pre>
if (age_txt.text>=18) { 
	trace("welcome, user"); 
} 
else { 
	trace("sorry, junior"); 
	userObject.minor = true; 
	userObject.accessAllowed = false;
}</pre></div> 
W poniższym przykładzie nawiasy sześcienne ({}) nie są potrzebne, ponieważ po instrukcji else następuje tylko jedna instrukcja:
<div class="listing"><pre>
if (age_txt.text>18) { 
	trace("welcome, user");
} 
else trace("sorry, junior");</pre></div>
W poniższym przykładzie użyto kombinacji instrukcji if i else w celu porównania zmiennej score_txt z określoną wartością: 
<div class="listing"><pre>

if (score_txt.text>90) { 
	trace("A"); 
} 
else if (score_txt.text>75) { 
	trace("B"); 
} 
else if (score_txt.text>60) { 
	trace("C"); 
} 
else { 
	trace("F"); 
}</pre></div><p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#if" target="">if</a></div></div><a name="extends"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">extends</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>class className extends otherClassName {}
interface interfaceName extends otherInterfaceName {} </pre> </p></td></tr></table><p></p><p><p>Definiuje klasę będącą podklasą innej klasy. Podklasa dziedziczy wszystkie metody, właściwości, funkcje itp. zdefiniowane w nadklasie. Klasy oznaczone jako <code>final</code> nie mogą być rozszerzane.
			<p>Możliwe jest również użycie słowa kluczowego <code>extends</code> w celu rozszerzenia interfejsu. Interfejs rozszerzający inny interfejs zawiera wszystkie deklaracje metod oryginalnego interfejsu.</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Nazwa definiowanej klasy.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie klasa Car rozszerza klasę Vehicle, dziedzicząc wszystkie jej metody, właściwości i funkcje. Jeśli w skrypcie zostanie utworzony obiekt klasy Car, możliwe będzie używanie zarówno metod z klasy Car, jak i z klasy Vehicle. 
			Poniższy przykład stanowi treść pliku Vehicle.as, który definiuje klasę Vehicle:  
<div class="listing"><pre>
package {
	class Vehicle { 
	    var numDoors:Number; 
	    var color:String; 
	    public function Vehicle(param_numDoors:Number = 2, param_color:String = null) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	    } 
	    public function start():void { 
	        trace("[Vehicle] start"); 
	    } 
	    public function stop():void { 
	        trace("[Vehicle] stop"); 
	    } 
	    public function reverse():void { 
	        trace("[Vehicle] reverse"); 
	    } 
	}	
}</pre></div> 
W poniższym przykładzie przedstawiono drugi plik ActionScript, o nazwie Car.as, umieszczony w tym samym katalogu. Ta klasa rozszerza klasę Vehicle, modyfikując ją pod trzema względami. Po pierwsze w klasie Car dodano zmienną fullSizeSpare, która zawiera informację o tym, czy samochód (obiekt Car) ma pełnowymiarowe koło zapasowe. Po drugie, dodano nową metodę charakterystyczną dla samochodów, activateCarAlarm(), która aktywuje autoalarm samochodu. Po trzecie, przesłonięto funkcję stop(), uwzględniając fakt, że w klasie Car hamulce są wyposażone w układ ABS.
<div class="listing"><pre>
package {

	public class Car extends Vehicle { 
	    var fullSizeSpare:Boolean; 
	    public function Car(param_numDoors:Number, param_color:String, param_fullSizeSpare:Boolean) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	        fullSizeSpare = param_fullSizeSpare; 
	    } 
	    public function activateCarAlarm():void { 
	        trace("[Car] activateCarAlarm"); 
	    } 
	    public override function stop():void { 
	        trace("[Car] stop with antilock brakes"); 
	    } 
	}
}</pre></div> 
W poniższym przykładzie tworzona jest instancja klasy Car, wywoływana jest metoda zdefiniowana w klasie Vehicle (start()), a następnie metoda przesłonięta przez klasę Car (stop()); na koniec wywoływana jest metoda z klasy Car (activateCarAlarm()):
<div class="listing"><pre>var myNewCar:Car = new Car(2, "Red", true); 
myNewCar.start(); // [Vehicle] start 
myNewCar.stop(); // [Car] stop with anti-lock brakes 
myNewCar.activateCarAlarm(); // [Car] activateCarAlarm</pre></div> 
Możemy również napisać podklasę klasy Vehicle, korzystając z instrukcji super, za pośrednictwem której podklasa może uzyskać dostęp do konstruktora nadklasy. W poniższym przykładzie przedstawiono trzeci plik ActionScript, o nazwie Truck.as, umieszczony w tym samym katalogu, co dwa pozostałe. W konstruktorze klasy Truck użyto instrukcji super; ponadto w klasie tej przesłonięto metodę reverse(). 
<div class="listing"><pre>
package {
	class Truck extends Vehicle {
		var numWheels:Number;
		public function Truck(param_numDoors:Number, param_color:String, param_numWheels:Number) { 
			super(param_numDoors, param_color); 
			numWheels = param_numWheels; 
		} 
		public override function reverse():void { 
			beep();
			super.reverse();
		} 
		public function beep():void { 
			trace("[Truck] make beeping sound"); 
		} 
	}
}</pre></div> 
W poniższym przykładzie tworzona jest instancja klasy Truck, wywoływana jest metoda przesłonięta przez klasę Truck (reverse()), a następnie metoda zdefiniowana w klasie Vehicle (stop()):  
<div class="listing"><pre>var myTruck:Truck = new Truck(2, "White", 18); 
myTruck.reverse(); // [Truck] make beeping sound [Vehicle] reverse 
myTruck.stop(); // [Vehicle] stop</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#interface" target="">interfejs</a></div></div><a name="false"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">false</td><td class="detailHeaderType">podstawowe słowo kluczowe wyrażenia</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>false</pre></p></td></tr></table><p></p><p><p>Wartość typu Boolean reprezentująca fałsz. Wartość typu Boolean może być równa albo <code>true</code>, albo <code>false</code>; wartością przeciwną do <code>false</code> jest <code>true</code>.
			<p>Gdy w wyniku automatycznej konwersji typu wartość <code>false</code> jest przekształcana w liczbę, staje się wartością <code>0</code>; gdy wartość <code>false</code> jest przekształcana w ciąg znaków, staje się ciągiem <code>"false"</code>.</p>
			<p><b>Uwaga:</b> Wynikiem konwersji ciągu znaków <code>"false"</code> na typ Boolean jest wartość <code>true</code>.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje automatyczną konwersję wartości false typu Boolean na liczbę i ciąg znaków:
<div class="listing"><pre>
var bool1:Boolean = Boolean(false);

// converts it to the number 0
trace(1 + bool1); // outputs 1

// converts it to a string
trace("String: " + bool1); // outputs String: false
</pre></div>
Poniższy przykład demonstruje, że wynikiem konwersji ciągu znaków "false" na typ Boolean jest wartość true:
<div class="listing"><pre>
trace(Boolean("false")); // true

if ("false") {
	trace("condition expression evaluated to true");
}
else {
	trace("condition expression evaluated to false");
}
// condition expression evaluated to true
</pre></div>

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Boolean.html" target="">Klasa typu Boolean</a><br/><a href="statements.html#true" target="">true</a></div></div><a name="final"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">final</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
final function methodName() { 
	// your statements here 
}
final class className {}</pre> </p></td></tr></table><p></p><p><p>Określa, że nie można przesłonić metody lub że nie można rozszerzyć klasy. Próba przesłonięcia metody lub rozszerzenia klasy oznaczonej jako <code>final</code> spowoduje zgłoszenie błędu.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa metody, której nie można przesłonić.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Nazwa klasy, której nie można rozszerzyć.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#override" target="">nadpisanie</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="flash_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">flash_proxy</td><td class="detailHeaderType"> Przestrzenie nazw </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Definiuje metody klasy Proxy. Metody klasy Proxy należą do ich własnej przestrzeni nazw, co pozwala uniknąć konfliktów nazw w sytuacji, gdy podklasa Proxy zdefiniowana przez użytkownika zawiera metody instancji o nazwach identycznych z metodami klasy Proxy.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="flash/utils/Proxy.html" target="">Proxy, klasa</a></div></div><a name="for"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for ([init]; [condition]; [next]) { 
	// statement(s)
}</pre>
			</p></td></tr></table><p></p><p><p>Jednokrotnie wyznacza wartość wyrażenia <code>init</code> (inicjacja) i rozpoczyna wykonywanie pętli. Każde wykonanie pętli rozpoczyna się od wyznaczenia wartości wyrażenia <code>condition</code>. Jeśli wynikiem wyrażenia <code>condition</code> jest <code>true</code>, wykonywana jest instrukcja <code>statement</code> i obliczane jest wyrażenie <code>next</code>. Następnie rozpoczyna się kolejne wykonanie pętli &mdash; od ponownego obliczenia wyrażenia <code>condition</code>. 
			<p>Jeśli w ramach instrukcji <code>for</code> ma być wykonana tylko jedna instrukcja, nie jest wymagane ujmowanie jej w nawiasy sześcienne (<code>{}</code>).</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">init</span></code> &mdash; Opcjonalne wyrażenie, którego wartość ma być wyznaczona przed rozpoczęciem wykonywania pętli; zwykle wyrażenie przypisania. W charakterze tego parametru można też użyć instrukcji var.</td></tr><tr><td width="20px"></td><td><code><span class="label">condition</span></code> &mdash; Opcjonalne wyrażenie, którego wartość ma być wyznaczona przed wykonaniem pętli; zwykle wyrażenie porównania. Jeśli wynikiem wyrażenia jest true, wykonywane są instrukcje skojarzone z instrukcją for.</td></tr><tr><td width="20px"></td><td><code><span class="label">next</span></code> &mdash; Opcjonalne wyrażenie, którego wartość ma być wyznaczona po wykonaniu pętli; zwykle wyrażenie inkrementacji lub dekrementacji.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie instrukcję for zastosowano do dodawania elementów tablicy: 
<div class="listing"><pre>
var my_array:Array = new Array(); 
for (var i:Number = 0; i < 10; i++) { 
	my_array[i] = (i + 5) * 10;  
} 
trace(my_array); // 50,60,70,80,90,100,110,120,130,140 </pre></div> 
W poniższym przykładzie zastosowano instrukcję for do wielokrotnego wykonywania tej samej operacji. W przykładowym kodzie pętla for dodaje liczby od 1 do 100. 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) { 
	sum += i; 
} 
trace(sum); // 5050</pre></div> 
W poniższym przykładzie nawiasy sześcienne ({}) nie są potrzebne, ponieważ wykonywana będzie tylko jedna instrukcja: 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) 
	sum += i; 
trace(sum); // 5050</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#increment" target="">++ (inkrementacja)</a></div></div><a name="for..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for..in</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>for (variableIterant:String in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>Przechodzi iteracyjnie do kolejnych dynamicznych właściwości obiektu lub elementów tablicy i wykonuje na każdym z nich instrukcję <code>statement</code>. Kolejność przechowywania właściwości w poszczególnych obiektach nie jest jednoznacznie określona, dlatego właściwości mogą być wybierane w pozornie losowym porządku. Właściwości ustalone, takie jak zmienne i metody zdefiniowane w klasie, nie są wyliczane przez instrukcję <code>for..in</code>. W celu uzyskania listy właściwości ustalonych należy zastosować funkcję <code>describeType()</code>, która znajduje się w pakiecie flash.utils.
			 
			 
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a href="String.html">String</a></code> &mdash; Nazwa zmiennej iteracyjnej, za pośrednictwem której będzie się można odwoływać do poszczególnych właściwości obiektu lub elementów tablicy.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zastosowano pętlę for..in do iteracyjnego wykonywania operacji na właściwościach obiektu: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var prop in myObject) { 
	trace("myObject."+prop+" = "+myObject[prop]); 
} 
/*
myObject.firstName = Tara 
myObject.age = 27 
myObject.city = San Francisco
*/</pre></div> 
W poniższym przykładzie zastosowano operator typeof razem z instrukcją for..in w celu iteracyjnego wybierania obiektów potomnych określonego typu. 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var name in myObject) { 
	if (typeof (myObject[name]) == "string") { 
		trace("I have a string property named "+name); 
	} 
}
/*
I have a string property named city
I have a string property named firstName
*/
</pre></div> 
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="flash/utils/package.html#describeType()" target="">describeType()</a></div></div><a name="for_each..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for each..in</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for each (variableIterant in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>Iteracyjnie przechodzi przez kolejne elementy kolekcji i wykonuje na każdym z nich instrukcję <code>statement</code>. Instrukcja <code>for each..in</code> wprowadzona jako element rozszerzeń języka E4X, może być stosowana nie tylko w odniesieniu do obiektów XML, lecz także innych obiektów i tablic. Pętla <code>for each..in</code> uwzględnia tylko właściwości dynamiczne obiektu, a nie właściwości ustalone. Właściwość ustalona to właściwość zdefiniowana jako część definicji klasy. Aby możliwe było zastosowanie instrukcji <code>for each..in</code> do instancji klasy zdefiniowanej przez użytkownika, należy zadeklarować tę klasę z atrybutem <code>dynamic</code>. 
			<p>W przeciwieństwie do instrukcji <code>for..in</code>, instrukcja <code>for each..in</code> wybiera iteracyjnie wartości właściwości obiektu, a nie ich nazwy.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej iteracyjnej, za pośrednictwem której będzie się można odwoływać do poszczególnych elementów kolekcji.</td></tr><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; Nazwa kolekcji, której dotyczy iteracja. Kolekcja może być obiektem XML, obiektem zwykłym lub tablicą.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zastosowano pętlę for each..in zastosowano do iteracyjnego przeglądania wartości właściwości obiektu: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	trace(item); 
} 
/*
Tara
27
San Francisco
*/</pre></div> 
W poniższym przykładzie zastosowano pętlę for each..in zastosowano do iteracyjnego przeglądania elementów tablicy: 
<div class="listing"><pre>
var myArray:Array = new Array("one", "two", "three"); 
for each(var item in myArray) 
	trace(item); 
/*
one
two
three
*/</pre></div> 
W poniższym przykładzie zastosowano operator is razem z instrukcją for each..in w celu iteracyjnego wybierania obiektów potomnych określonego typu: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	if (item is String) {  
		trace("I have a string property with value " + item); 
	} 
}

/*
I have a string property with value Tara
I have a string property with value San Francisco
*/
</pre></div> 

Poniższy przykład ilustruje zastosowanie instrukcji for each..in do iteracyjnego przeglądania właściwości obiektu XMLList (doc.pl):

<div class="listing"><pre>
var doc:XML = 
		<body>
			<p>Hello</p>
			<p>Hola</p>
			<hr />
			<p>Bonjour</p>
		</body>;
for each (var item in doc.p) {
	trace(item);
}

/*
Hello
Hola
Bonjour
*/
</pre></div>
			<p></p></div><a name="function"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">function</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} 
var functionName:Function = function ([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>Zawiera zestaw instrukcji zdefiniowanych w celu wykonywania określonego zadania. Funkcję można zdefiniować w jednym miejscu i <em>wywoływać</em> ją z różnych skryptów w pliku SWF. Definiując funkcję, można również określić jej parametry. Parametry reprezentują wartości, na których funkcja operuje. W każdym wywołaniu funkcji można przekazać do niej inne parametry, co pozwala na stosowanie tej samej funkcji w różnych sytuacjach. 
			<p>Instrukcja <code>return</code> w bloku <code>statement(s)</code> funkcji powoduje wygenerowanie, inaczej mówiąc <em>zwrócenie</em>, wartości przez funkcję.</p> 
			<p>Zastosowanie 1: Słowa kluczowego <code>function</code> można użyć do zdefiniowania funkcji o określonej nazwie, z określonymi parametrami, zawierającej określone instrukcje. Gdy skrypt wywołuje funkcję, wykonywane są instrukcje zawarte w jej definicji. Dozwolone są poprzedzające odwołania do funkcji &mdash; wywołanie funkcji może poprzedzać jej deklarację w tym samym skrypcie. Definicja funkcji zastępuje wszelkie wcześniejsze definicje tej samej funkcji. Składni tej można użyć w każdym miejscu, w którym dozwolone jest użycie instrukcji. </p> 
			<p>Zastosowanie 2: Słowa kluczowego <code>function</code> można także użyć do utworzenia funkcji anonimowej i zwrócenia referencji do niej. Ta składnia jest stosowana w wyrażeniach i bywa szczególnie przydatna do instalowania metod w obiektach.</p> 
			<p>Zastosowanie obiektu <code>arguments</code> w definicji funkcji stwarza pewne dodatkowe możliwości. Obiekt <code>arguments</code> jest często stosowany do tworzenia funkcji przyjmujących zmienną liczbę parametrów i do tworzenia rekurencyjnych funkcji anonimowych.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa nowej funkcji.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Typ danych zwracanej wartości.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zdefiniowano funkcję sqr, która zwraca wartość liczby podniesioną do kwadratu: 
<div class="listing"><pre>function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
} 
var yNum:Number = sqr(3); 
trace(yNum); // 9</pre></div> 
Jeśli funkcja jest zdefiniowana w tym samym skrypcie, w którym jest używana, jej definicja może następować po wywołaniu: 
<div class="listing"><pre>var yNum:Number = sqr(3); 
trace(yNum); // 9 
function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
}</pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments, obiekt</a><br/><a href="statements.html#return" target="">return</a></div></div><a name="get"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">get</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function get property() : returnType{ 
	// your statements here 
}</pre> </p></td></tr></table><p></p><p><p>Definiuje funkcję pobierającą, tj. metodę, którą można odczytywać tak, jak właściwość. Funkcja pobierająca jest to specjalna funkcja, która zwraca wartość właściwości zadeklarowanej przy użyciu słowa kluczowego <code>var</code> lub <code>const</code>. W przeciwieństwie do innych metod, funkcję pobierającą wywołuje się bez nawiasów (<code>()</code>), przez co jej wywołanie wygląda jak zmienna.
			<p>Funkcje pobierające umożliwiają realizację koncepcji ukrywania informacji, pozwalając na tworzenie interfejsu publicznego dla właściwości prywatnej. Zaletą ukrywania informacji jest zachowanie tego samego interfejsu publicznego niezależnie od ewentualnych zmian implementacji właściwości prywatnej.</p>
			<p>Inna zaleta funkcji pobierających to możliwość przesłaniania ich w podklasach, która odróżnia je od właściwości zadeklarowanych przy użyciu słów kluczowych <code>var</code> lub <code>const</code>.</p>
			<p>Funkcję pobierającą można utworzyć w parze z funkcją ustawiającą, tworząc tym samym właściwość z możliwością odczytu i zapisu. Aby utworzyć właściwość tylko do odczytu, należy utworzyć funkcję pobierającą bez odpowiadającej jej funkcji ustawiającej. Aby utworzyć właściwość tylko do zapisu, należy utworzyć funkcję ustawiającą bez odpowiadającej jej funkcji pobierającej.</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Identyfikator właściwości, do której instrukcja get uzyskuje dostęp; musi to być ta sama wartość, co używana w odpowiednim poleceniu set.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Typ danych zwracanej wartości.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zdefiniowano klasę Team. Klasa Team zawiera metody (funkcje) pobierające i ustawiające, które umożliwiają odczytywanie i ustawianie właściwości w klasie: 
<div class="listing"><pre>
package {
	public class Team { 
		var teamName:String; 
		var teamCode:String; 
		var teamPlayers:Array = new Array(); 
		public function Team(param_name:String, param_code:String) { 
			teamName = param_name; 
			teamCode = param_code; 
		} 
		public function get name():String { 
			return teamName; 
		} 
		public function set name(param_name:String):void { 
			teamName = param_name; 
		}
	} 
}</pre></div>
W skrypcie można teraz wprowadzić poniższy kod: 
<div class="listing"><pre>
var giants:Team = new Team("San Fran", "SFO"); 
trace(giants.name); 
giants.name = "San Francisco"; 
trace(giants.name); 
/*
San Fran San Francisco */</pre></div> 
W instrukcji trace(giants.name) używamy właśnie metody pobierającej, która zwraca wartość właściwości.
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#set" target="">set</a></div></div><a name="if"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">if</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Sprawdza warunek w celu określenia, którą instrukcję należy wykonać jako następną. Jeżeli warunek jest spełniony (<code>true</code>), program Flash Player wykonuje instrukcje w nawiasach sześciennych (<code>{}</code>). Jeśli wynikiem sprawdzenia warunku jest <code>false</code>, program Flash Player pomija instrukcje w nawiasach sześciennych i wykonuje instrukcje, które znajdują się za tymi nawiasami. Zastosowanie instrukcji <code>if</code> razem z instrukcją <code>else</code> umożliwia tworzenie rozgałęzionych struktur logicznych skryptów. 
			<p>Jeśli w ramach instrukcji <code>if</code> ma być wykonana tylko jedna instrukcja, nie jest wymagane ujmowanie jej w nawiasy sześcienne (<code>{}</code>).</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Wyrażenie, które daje w wyniku wartość true albo false.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#else" target="">else</a></div></div><a name="implements"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">implements</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>myClass implements interface01 [, interface02 , ...] </pre> </p></td></tr></table><p></p><p><p>Określa, że klasa implementuje jeden lub więcej interfejsów. Klasa, która implementuje interfejs, musi definiować wszystkie metody zadeklarowane w interfejsie. Każda instancja klasy implementującej interfejs jest uznawana za należącą do typu danych zdefiniowanego przez interfejs. W rezultacie operator <code>is</code> zwraca wartość <code>true</code>, gdy instancja klasy jest pierwszym operandem, a interfejs jest drugim operandem; ponadto działają (w obie strony) wymuszenia typu danych zdefiniowanego przez interfejs.
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#interface" target="">interface</a></div></div><a name="import"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">import</td><td class="detailHeaderType">dyrektywa</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>import packageName.className 
import packageName.*</pre> </p></td></tr></table><p></p><p><p>Udostępnia dla lokalnego kodu klasy i pakiety zdefiniowane zewnętrznie względem niego. Na przykład, aby użyć klasy flash.display.Sprite we własnym skrypcie, należy zaimportować tę klasę. To wymaganie stanowi różnice w stosunku do poprzednich wersji języka ActionScript, w których dyrektywa <code>import</code> była opcjonalna.
			<p>Po zastosowaniu dyrektywy <code>import</code> można używać pełnej nazwy klasy, wraz z nazwą pakietu, lub samej nazwy klasy.</p>
<div class="listing"><pre> 
import flash.display.Sprite; 

// name of class only
var mySprite:Sprite = new Sprite();

// full class name
var mySprite:flash.display.Sprite = new flash.display.Sprite();
</pre></div> 
<p>Jeśli pakiet zawiera kilka klas, do których chcemy uzyskać dostęp, można je wszystkie zaimportować w ramach jednej instrukcji, do ilustruje poniższy przykład:</p>
<div class="listing"><pre>import flash.display.*;</pre></div>
<p>Dyrektywa <code>import</code> importuje tylko klasy, funkcje i zmienne znajdujące się na najwyższym poziomie importowanego pakietu. Pakiety zagnieżdżone należy zaimportować jawnie.</p>
<p>Jeśli klasa zostanie zaimportowana, ale nie będzie używana w skrypcie, to nie zostanie wyeksportowana w ramach pliku SWF. Oznacza to, że można importować obszerne pakiety bez obaw o nadmierny rozmiar pliku SWF; kod bajtowy skojarzony z klasą zostanie umieszczony w pliku SWF tylko wówczas, gdy klasa będzie faktycznie używana. Niedogodnością związaną z importowaniem nieużywanych klas jest zwiększenie prawdopodobieństwa konfliktów nazw.</p> 
 
<pre>
// On Frame 1 of a FLA: 
import adobe.example.*; 
var myFoo:foo = new foo();</pre> 
 

			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa pakietu zdefiniowanego w osobnym pliku klas.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Nazwa klasy zdefiniowanej w osobnym pliku klas.</td></tr></table></div><a name="include"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">include</td><td class="detailHeaderType">dyrektywa</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>include "[path]filename.as"</pre></p></td></tr></table><p></p><p><p>Włącza zawartość określonego pliku w taki sposób, jak gdyby polecenia zawarte w tym pliku były częścią skryptu wywołującego. Dyrektywę <code>include</code> wywołuje się w czasie kompilacji. Dlatego po wprowadzeniu jakichkolwiek zmian do włączonego pliku należy go zapisać i ponownie skompilować wszystkie pliki SWG, w których jest używany.
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="interface"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">interface</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre> interface InterfaceName [extends InterfaceName ] {}</pre> </p></td></tr></table><p></p><p><p>Definiuje interfejs. Interfejsy są to typy danych definiujące zestaw metod; każda klasa implementująca dany interfejs musi zawierać definicje wszystkich jego metod.
			<p> Interfejs przypomina klasę, z następującymi ważnymi wyjątkami:</p> 
			<ul> 
			  <li>Interfejsy zawierają tylko deklaracje metod, a nie ich implementacje. Oznacza to, że każda klasa, która implementuje interfejs, musi zawierać implementacje wszystkich metod zadeklarowanych w tym interfejsie.</li> 
			  <li>Definicje metod interfejsu nie mogą mieć atrybutów, takich jak <code>public</code> lub <code>private</code>, ale zaimplementowane metody muszą być oznaczone jako <code>public</code> w definicji klasy implementującej interfejs.</li> 
			  <li>Jeden interfejs może dziedziczyć inne interfejsy przy wykorzystaniu instrukcji <code>extends</code> lub za pośrednictwem klasy, przy użyciu instrukcji <code>implements</code>.</li> 
			</ul>
			<p>Inaczej niż w wersji języka ActionScript 2.0, w języku ActionScript 3.0 dozwolone jest używanie metod (funkcji) pobierających i ustawiających w definicjach interfejsów.</p>
			
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#implements" target="">implements</a></div></div><a name="internal"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">internal</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
[internal] var varName
[internal] const kName
[internal] function functionName()  { 
	// your statements here 
}
[internal] class className{
	// your statements here 
}
[internal] namespace nsName
</pre> </p></td></tr></table><p></p><p><p>Określa, że klasa, zmienna, stała lub funkcja jest dostępna dla dowolnego kodu wywołującego w ramach tego samego pakietu. Klasy, właściwości i metody domyślnie należą do przestrzeni nazw <code>internal.</code></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Nazwa klasy, która ma być określona jako wewnętrzna.</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej, która ma być określona jako wewnętrzna. Atrybut internal można stosować niezależnie od tego, czy zmienna wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa stałej, która ma być określona jako wewnętrzna. Atrybut internal można stosować niezależnie od tego, czy stała wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa funkcji lub metody, która ma być określona jako wewnętrzna. Atrybut internal można stosować niezależnie od tego, czy funkcja wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Nazwa przestrzeni nazw, która ma być określona jako wewnętrzna. Atrybut internal można stosować niezależnie od tego, czy przestrzeń nazw wchodzi w skład klasy, czy nie.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#package" target="">pakiet</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="label"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">label</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>label: statement
label: {
    statements
}</pre></p></td></tr></table><p></p><p><p>Kojarzy instrukcję z identyfikatorem, do którego można odwoływać się w instrukcji <code>break</code> lub <code>continue</code>. W pętlach zagnieżdżonych instrukcja <code>break</code> lub <code>continue</code>, która nie odwołuje się do etykiety, może przeskoczyć tylko za pozostałą część bieżącej pętli, ale nie poza cały szereg pętli. Jeśli jednak z instrukcją definiującą szereg pętli jest skojarzona etykieta, instrukcja <code>break</code> lub <code>continue</code> może przeskoczyć cały szereg pętli, odwołując się do tej etykiety.
			<p>Etykiety umożliwiają również wymuszone wyjście z instrukcji blokowej. Nie jest dozwolone użycie instrukcji <code>break</code>, która nie odwołuje się do etykiety wewnątrz instrukcji blokowej, chyba że instrukcja blokowa jest częścią pętli. Jeśli z instrukcją blokową jest skojarzona etykieta, można użyć instrukcji <code>break</code> odwołującej się do tej etykiety wewnątrz instrukcji blokowej.</p>		
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Poprawny identyfikator, który ma być skojarzony z instrukcją.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Instrukcja, która ma być skojarzona z etykietą.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie etykiety w pętli zagnieżdżonej w celu wyjścia z całego szeregu pętli. W kodzie zastosowano pętlę zagnieżdżoną, która generuje listę liczb od 0 do 99. Instrukcja break jest wykonywana tuż przed osiągnięciem liczby 80. Gdyby w instrukcji break nie zastosowano etykiety outerLoop, nastąpiło by pominięcie wyłącznie pozostałej części bieżącej pętli i dalej generowane byłyby liczby od 90 do 99. Ponieważ jednak zastosowano etykietę outerLoop, instrukcja break przeskakuje pozostałą część całego szeregu pętli i ostatnią wygenerowaną liczbą jest 79.
<div class="listing"><pre>
outerLoop: for (var i:int = 0; i < 10; i++) {
	for (var j:int = 0; j < 10; j++) {
		if ( (i == 8) && (j == 0)) {
			break outerLoop;
		}
		trace(10 * i + j);
	}
}
/*
1
2
...
79
*/
</pre></div>
Poniższy przykład ilustruje użycie etykiety w instrukcji blokowej. Instrukcja blokowa jest opatrzona etykietą foo, dzięki czemu instrukcja break może pominąć ostatnią instrukcję w bloku:
<div class="listing"><pre>
foo: {
	trace("a");
	break foo;
	trace("b");
}
// a
</pre></div>

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a></div></div><a name="namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">namespace</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>namespace name [= uri]</pre> </p></td></tr></table><p></p><p><p>Umożliwia sterowanie widocznością definicji. Do wstępnie zdefiniowanych przestrzeni nazw należą: <code>public</code>, <code>private</code>, <code>protected</code> i <code>internal</code>. 
			<p>Poniżej przedstawiono krok po kroku sposób tworzenia przestrzeni nazw, stosowania jej i odwoływania się do niej:</p>
			<ul>
			  <li>Najpierw zdefiniuj niestandardową przestrzeń nazw, korzystając ze słowa kluczowego <code>namespace. </code> Na przykład kod <code>namespace version1</code> tworzy przestrzeń nazw o nazwie <code>version1</code>.</li>
			  <li>Następnie zastosuj przestrzeń nazw do właściwości lub metody, umieszczając nazwę własnej niestandardowej przestrzeni nazw w deklaracji właściwości lub metody. Na przykład kod <code>version1 myProperty:String</code> tworzy właściwość <code>myProperty</code>, która należy do przestrzeni nazw <code>version1</code>.</li>
			  <li>Na koniec odwołaj się do przestrzeni nazw, korzystając ze słowa kluczowego <code>use</code> lub poprzedzając identyfikator nazwą przestrzeni nazw. Na przykład kod <code>use namespace version1;</code> powoduje, że następne wiersze kodu będą odwoływały się do przestrzeni nazw <code>version1</code>, natomiast kod <code>version1::myProperty</code> odwołuje się do właściwości <code>myProperty</code> w przestrzeni nazw <code>version1</code>.</li>
			</ul>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Nazwa przestrzeni nazw, która może być dowolnym poprawnym identyfikatorem.</td></tr><tr><td width="20px"></td><td><code><span class="label">uri</span>:<a href="String.html">String</a></code> &mdash; Identyfikator URI (Uniform Resource Identifier) przestrzeni nazw. Jest to parametr opcjonalny.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#package" target="">pakiet</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="native"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">native</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
native function functionName();
class className { 
	native function methodName();
}</pre> </p></td></tr></table><p></p><p><p>Określa, że funkcja lub metoda jest zaimplementowana w kodzie macierzystym programu Flash Player. W programie Flash Player słowo kluczowe <code>native</code> jest używane wewnętrzne do deklarowania funkcji metod w interfejsie programowania aplikacji (API, ang. application programming interface) języka ActionScript. To słowo kluczowe nie może być używane we własnym kodzie użytkownika. &nbsp;			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="null"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">null</td><td class="detailHeaderType">podstawowe słowo kluczowe wyrażenia</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>null</pre></p></td></tr></table><p></p><p><p>Wartość specjalna, która może być przypisywana zmiennym lub zwracana przez funkcję w przypadku braku danych. Wartość specjalna <code>null</code> może reprezentować wartości nieistniejące lub takie, które nie mają zdefiniowanego typu danych.
				<p> Wartości <code>null</code> nie należy mylić z wartością specjalną <code>undefined</code>. Porównanie wartości <code>null</code> i <code>undefined</code> z pomocą operatora równości (<code>==</code>) wykaże ich równoważność. Porównanie wartości <code>null</code> i <code>undefined</code> za pomocą operatora ścisłej równości (<code>===</code>) wykaże jednak, że te wartości nie są równoważne.</p> 
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład sprawdza pierwszych sześć wartości tablicy indeksowanej i wyświetla komunikat, jeśli dana wartość nie jest ustawiona (tj. jeśli value == null):
<div class="listing"><pre>

var testArray:Array = new Array();
testArray[0] = "fee";
testArray[1] = "fi";
testArray[4] = "foo";

for (i = 0; i < 6; i++) {
    if (testArray[i] == null) {
        trace("testArray[" + i + "] == null");
    }
}

/* 
testArray[2] == null
testArray[3] == null
testArray[5] == null
*/
</pre></div>	

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="package.html#undefined" target="">undefined</a></div></div><a name="object_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">object_proxy</td><td class="detailHeaderType"> Przestrzenie nazw </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Definiuje metody klasy ObjectProxy. Metody klasy ObjectProxy należą do ich własnej przestrzeni nazw, co pozwala uniknąć konfliktów nazw w sytuacji, gdy podklasa Proxy zawiera metody instancji o nazwach identycznych z metodami klasy Proxy.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="override"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">override</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
override function name() { 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>Określa, że metoda zastępuje metodę dziedziczoną. Aby przesłonić metodę dziedziczoną, należy użyć atrybutu <code>override</code> i zadbać o to, aby nazwa metody, atrybut właściwości klasy, liczba i typy jej parametrów oraz typ wartości zwracanej były dokładnie takie same, jak w metodzie przesłanianej. Błędem jest próba przesłonięcia metody bez użycia atrybutu <code>override</code>. Nie jest również dozwolone użycie atrybutu <code>override</code> w sytuacji, gdy nie istnieje zgodna metoda dziedziczona, którą dana metoda mogłaby przesłonić.
			<p>Nie jest dozwolone użycie atrybutu <code>override</code> w odniesieniu do:</p>
			<ul>
			  <li>zmiennych;</li>
			  <li>Stałe</li>
			  <li>metod statycznych;</li>
			  <li>metod, które nie zostały odziedziczone;</li>
			  <li>metod, które implementują metodę zadeklarowaną w interfejsie;</li>
			  <li>metod dziedziczonych, które są w nadklasie oznaczone jako <code>final</code>.</li>
			</ul>
			<p>Mimo że nie jest dozwolone przesłonięcie właściwości zadeklarowanej za pomocą słowa kluczowego <code>var</code> lub <code>const</code>, można osiągnąć podobny efekt, deklarując właściwość klasy bazowej jako funkcję pobierającą-ustawiającą i przesłaniając metody zdefiniowane z użyciem słów kluczowych <code>get</code> i <code>set</code>.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa przesłanianej metody.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#final" target="">final</a><br/><a href="statements.html#get" target="">get</a><br/><a href="statements.html#set" target="">set</a></div></div><a name="package"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">package</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
package packageName {
    class someClassName { 
    } 
}</pre> </p></td></tr></table><p></p><p><p>Pozwala podzielić kod na odrębne grupy, które można importować do innych skryptów. Aby wskazać, że dana klasa wchodzi w skład pakietu, należy użyć słowa kluczowego <code>package.</code></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa pakietu.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a><br/><a href="statements.html#class" target="">class</a></div></div><a name="private"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">private</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	private var varName;
	private const kName;
	private function methodName() { 
		// your statements here 
	}
	private namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>Określa, że zmienna, stała lub metoda jest dostępna tylko w tej klasie, w której ją zadeklarowano lub zdefiniowano. Inaczej niż w języku ActionScript 2.0, w języku ActionScript 3.0 atrybut <code>private</code> nie umożliwia już dostępu do podklas. Ponadto atrybut <code>private</code> ogranicza dostęp zarówno w czasie kompilacji, jak i w czasie wykonywania. Domyślnie zmienna lub funkcja jest dostępna dla całego kodu wywołującego w ramach tego samego pakietu. Opisywanego słowa kluczowego należy użyć w celu ograniczenia dostępu do zmiennej lub funkcji. 
			<p>Tego słowa kluczowego można używać wyłącznie w definicjach klas, a nie w definicjach interfejsów. Słowa kluczowego <code>private</code> nie można stosować do definicji klas lub innych definicji na poziomie pakietu.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej, która ma być określona jako prywatna. Atrybut private można stosować tylko do zmiennych wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa stałej, która ma być określona jako prywatna. Atrybut private można stosować tylko do stałych wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa metody, która ma być określona jako prywatna. Atrybut private można stosować tylko do metod wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Nazwa przestrzeni nazw, która ma być określona jako prywatna. Atrybut private można stosować tylko do przestrzeni nazw wewnątrz klasy.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje, w jaki sposób można ukryć pewne właściwości klasy, korzystając ze słowa kluczowego private. 
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  public var beta:String = "visible everywhere"; 
}
	
class B extends A {
  function B() {
    alpha = "Access attempt from subclass"; // error
  }
}
</pre></div> 
Ponieważ alpha jest zmienną prywatną, nie można uzyskać do niej dostępu spoza klasy A, w tym nawet z podklasy B. Próba dostępu do zmiennej prywatnej spowoduje błąd.
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="protected"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">protected</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	protected var varName;
	protected const kName;
	protected function methodName() { 
		// your statements here 
	}
	protected namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>Określa, że zmienna, stała, metoda lub przestrzeń nazw jest dostępna tylko w tej klasie, w której ją zdefiniowano, oraz we wszystkich podklasach tej klasy. Definicja atrybutu <code>protected</code> w języku ActionScript 3.0 jest podobna do definicji atrybutu <code>private</code> w języku ActionScript 2.0, z tym że atrybut <code>protected</code> ogranicza dostęp zarówno w czasie kompilacji, jak i w czasie wykonywania. Domyślnie zmienna lub funkcja jest dostępna dla całego kodu wywołującego w ramach tego samego pakietu. Opisywanego słowa kluczowego należy użyć w celu ograniczenia dostępu do zmiennej lub funkcji.  
				<p>Tego słowa kluczowego można używać wyłącznie w definicjach klas, a nie w definicjach interfejsów. Słowa kluczowego <code>private</code> nie można stosować do definicji klas lub innych definicji na poziomie pakietu.</p>
				<p>Definicja atrybutu <code>protected</code> w języku ActionScript 3.0 jest bardziej restrykcyjna niż definicja atrybutu <code>protected</code> w języku programowania Java. W języku ActionScript 3.0 atrybut <code>protected</code> zezwala na dostęp wyłącznie do podklas, natomiast w języku Java atrybut <code>protected</code> zezwala również na dostęp do wszystkich klas w tym samym pakiecie. Na przykład, jeśli klasa o nazwie <code>Base</code> zawiera właściwość oznaczoną jako <code>protected</code>, w języku ActionScript 3.0 dostęp do tej właściwości będzie możliwy tylko z klas rozszerzających klasę Base. W języku Java dostęp do właściwości chronionej (protected) miałaby każda klasa w tym samym pakiecie, co klasa Base, w tym również klasy niebędące podklasami Base.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej, która ma być określona jako chroniona. Atrybut protected można stosować tylko do zmiennych wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa stałej, która ma być określona jako chroniona. Atrybut protected można stosować tylko do stałych wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa metody, która ma być określona jako chroniona. Atrybut protected można stosować tylko do metod wewnątrz klasy.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Nazwa przestrzeni nazw, która ma być określona jako chroniona. Atrybut protected można stosować tylko do przestrzeni nazw wewnątrz klasy.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie w klasie A tworzona jest zmienna chroniona, do której można uzyskać dostęp w klasie B, ponieważ B jest podklasą klasy A.
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  protected var beta:String = "visible inside class A and its subclasses"; 
}
	
class B extends A {
  public function B() {
    beta = "Access attempt from subclass succeeded";
    trace(beta);  // Access attempt from subclass succeeded
  }
}
</pre></div>
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="public"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">public</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
public var varName
public const kName
public function functionName()  { 
	// your statements here 
}
public class className {
	// your statements here 
}
public namespace nsName
</pre> </p></td></tr></table><p></p><p><p>Określa, że klasa, zmienna, stała lub metoda jest dostępna dla dowolnego kodu wywołującego. Klasy, zmienne i metody są domyślnie wewnętrzne (należą do przestrzeni nazw internal), czyli są widoczne tylko wewnątrz swojego pakietu. Aby klasa, zmienna lub metoda była widoczna dla każdego kodu wywołującego, należy użyć atrybutu <code>public.</code></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Nazwa klasy, która ma być określona jako publiczna.</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej, która ma być określona jako publiczna. Atrybut public można stosować niezależnie od tego, czy zmienna wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa stałej, która ma być określona jako publiczna. Atrybut public można stosować niezależnie od tego, czy stała wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa funkcji lub metody, która ma być określona jako publiczna. Atrybut public można stosować niezależnie od tego, czy funkcja wchodzi w skład klasy, czy nie.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Nazwa przestrzeni nazw, która ma być określona jako publiczna. Atrybut public można stosować niezależnie od tego, czy przestrzeń nazw wchodzi w skład klasy, czy nie.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie zmiennych publicznych w pliku klasy: 
<div class="listing"><pre>class User { 
	public var age:Number; 
	public var fname:String; 
} // end of class User definition
 
var jimmy:User = new User(); 
jimmy.age = 27; 
jimmy.fname = "jimmy";
trace(jimmy.age, jimmy.fname); // 27 jimmy</pre></div> 
Przekształcenie zmiennej publicznej w klasie User w zmienną prywatną spowoduje, że każda próba dostępu do tej zmiennej spoza klasy User będzie skutkować błędem w czasie kompilacji. 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a></div></div><a name="return"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">return</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function functionName () {
	return [expression]
}</pre></p></td></tr></table><p></p><p><p>Powoduje natychmiastowe przekazanie sterowania (powrót) do funkcji wywołującej. Jeśli po instrukcji <code>return</code> następuje wyrażenie, wyznaczana jest jego wartość i zwracany jest wynik. 
			<p>Jeśli w definicji funkcji zadeklarowano typ zwracanej wartości, po instrukcji <code>return</code> musi następować wyrażenie. Jeśli nie zadeklarowano typu zwracanej wartości i instrukcja <code>return</code> zostanie użyta bez wyrażenia, zwraca wartość <code>undefined</code>.</p>
			<p>Nie jest możliwe zwrócenie więcej niż jednej wartości. Próba taka spowoduje zwrócenie tylko ostatniej wartości. W następującym przykładzie zostanie zwrócona wartość <code>c</code>:</p> <pre>return a, b, c ;</pre> <p>Jeśli zachodzi konieczność zwrócenia wielu wartości, należy posłużyć się tablicą lub obiektem.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Wyrażenie, którego wartość ma być wyznaczona i zwrócona jako wartość funkcji. Ten parametr jest opcjonalny.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie instrukcji return użyto wewnątrz treści funkcji sum() w celu zwrócenia sumy trzech parametrów. Następny wiersz kodu wywołuje funkcję sum() i przypisuje zwróconą wartość do zmiennej newValue. 
<div class="listing"><pre>function sum(a:Number, b:Number, c:Number):Number { 
	return (a + b + c); 
} 
var newValue:Number = sum(4, 32, 78); 
trace(newValue); // 114</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#function" target="">funkcja</a></div></div><a name="set"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">set</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function set property(newValue:*) : void{ 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>Definiuje funkcję ustawiającą, tj. metodę widoczną w interfejsie publicznym jako właściwość. Funkcja ustawiająca jest to specjalna metoda, która ustawia wartość właściwości zadeklarowanej przy użyciu słowa kluczowego <code>var</code>. W przeciwieństwie do innych metod, funkcję ustawiającą wywołuje się bez nawiasów (<code>()</code>), przez co jej wywołanie wygląda jak zmienna.
			<p>Funkcje ustawiające umożliwiają realizację koncepcji ukrywania informacji, pozwalając na tworzenie interfejsu publicznego dla właściwości prywatnej. Zaletą ukrywania informacji jest zachowanie tego samego interfejsu publicznego niezależnie od ewentualnych zmian implementacji właściwości prywatnej.</p>
			<p>Inna zaleta funkcji ustawiających to możliwość przesłaniania ich w podklasach, która odróżnia je od właściwości zadeklarowanych przy użyciu słowa kluczowego <code>var</code>.</p>
			<p>Typ zwracany przez funkcję ustawiającą musi być zadeklarowany jako <code>void</code> albo nieokreślony.</p>
			<p>Funkcję ustawiającą można utworzyć w parze z funkcją pobierającą, tworząc tym samym właściwość z możliwością odczytu i zapisu. Aby utworzyć właściwość tylko do odczytu, należy utworzyć funkcję pobierającą bez odpowiadającej jej funkcji ustawiającej. Aby utworzyć właściwość tylko do zapisu, należy utworzyć funkcję ustawiającą bez odpowiadającej jej funkcji pobierającej.</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Identyfikator właściwości, którą modyfikuje instrukcja set; musi to być ta sama wartość, co używana w odpowiednim poleceniu get.</td></tr><tr><td width="20px"></td><td><code><span class="label">newValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nowa wartość, która ma zostać przypisana.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zdefiniowana jest funkcja pobierająca i ustawiająca w celu utworzenia właściwości o nazwie age, którą można odczytywać i zapisywać.
<div class="listing"><pre>
package {
	class User { 
	    private var userAge:Number; 
	    
	    public function get age():Number {
	    	return userAge;
	    }
	    
	    public function set age(x:Number):void {
	    	userAge = x;	
	    }
	} 
} 
</pre></div>
W skrypcie można teraz wprowadzić poniższy kod:
<div class="listing"><pre>
var myUser:User = new User();
myUser.age = 25;
trace(myUser.age); // 25
</pre></div>
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#get" target="">get</a></div></div><a name="static"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">static</td><td class="detailHeaderType">słowo kluczowe atrybutu</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>class someClassName{ 
	static var varName; 
	static const kName;
	static function methodName() { 
		// your statements here
	} 
}</pre> </p></td></tr></table><p></p><p><p>Określa, że zmienna, stała lub metoda należy do klasy, a nie do instancji klasy.
			<p>Aby uzyskać dostęp do statycznego elementu klasy, należy zamiast nazwy instancji użyć nazwy klasy. Na przykład klasa Date ma metodę statyczną o nazwie <code>parse()</code>, którą można wywołać tylko przy użyciu następującej składni:</p>
			<div class="listing"><pre>Date.parse()</pre></div>
			<p>Metody <code>parse()</code> nie można wywoływać z instancji klasy Date. Na przykład poniższy kod spowoduje wygenerowanie błędu:</p>
			<div class="listing"><pre>var myDate:Date = new Date();
            myDate.parse("Jan 01 00:00:00 2006"); // error</pre></div>
			<p>Słowa kluczowego <code>static</code> można używać wyłącznie w definicjach klas, a nie w definicjach interfejsów.</p>
			<p>Statyczne elementy klas nie są dziedziczone. Nie można odwoływać się do statycznego elementu klasy, używając nazwy podklasy, tak jak jest to dozwolone w językach Java lub C++. Możliwe jest natomiast odwoływanie się do zmiennych i metod statycznych wewnątrz klasy lub podklasy, bez stosowania jakiegokolwiek kwalifikatora. Ilustruje to poniższy przykład.</p>
			<p>Wewnątrz metody statycznej nie można używać instrukcji <code>super</code> ani słowa kluczowego <code>this</code>.</p>
			
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa zmiennej, która ma być określona jako statyczna.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Nazwa stałej, która ma być określona jako statyczna.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Nazwa metody, która ma być określona jako statyczna.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje zastosowanie słowa kluczowego static do utworzenia licznika, który zlicza tworzone instancje klasy. Ponieważ zmienna numInstances jest statyczna, zostanie utworzona tylko raz dla całej klasy, a nie każdorazowo dla instancji klasy. Utworzymy nowy plik ActionScript o nazwie Users.as i wprowadzimy następujący kod: 
<div class="listing"><pre>class Users { 
	private static var numInstances:Number = 0; 
	function Users() { 
		numInstances++; 
	} 
	static function get instances():Number { 
		return numInstances; 
	} 
}</pre></div> 
W skrypcie można teraz wprowadzić poniższy kod:
<div class="listing"><pre>
trace(Users.instances); 
var user1:Users = new Users(); 
trace(Users.instances); 
var user2:Users = new Users(); 
trace(Users.instances); 
</pre></div>
W poniższym przykładzie klasa Users została rozszerzona w celu zademonstrowania, że zmienne i metody statyczne nie są dziedziczone, ale można do nich odwoływać się w podklasach.
<div class="listing"><pre>
class PowerUsers extends Users{
    function PowerUsers() {
        instances++;  // unqualified reference to static property Users.instances is legal
    }
}

trace(PowerUsers.instances); // error, cannot access static property using PowerUsers class
</pre></div>

			<p></p></div><a name="super"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">super</td><td class="detailHeaderType"> Instrukcje </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>super([arg1, ..., argN])
super.method([arg1, ..., argN])</pre></p></td></tr></table><p></p><p><p>Wywołuje nadklasę (czyli wersję będącą przodkiem) metody lub konstruktora. Instrukcja <code>super()</code> użyta w treści konstruktora klasy wywołuje wersję konstruktora zdefiniowaną w nadklasie. W wywołaniu konstruktora nadklasy musi być podana poprawna liczba argumentów. Należy zwrócić uwagę, że konstruktor nadklasy jest wywoływany zawsze, niezależnie od tego, czy zostanie wywołany jawnie. W wypadku braku wywołania jawnego przed pierwszą instrukcją w treści konstruktora podklasy zostanie automatycznie wstawione wywołanie bez argumentów. Oznacza to, że jeśli w podklasie jest zdefiniowany konstruktor, a konstruktor nadklasy przyjmuje co najmniej jeden argument, należy jawnie wywołać konstruktor nadklasy z poprawną liczbą argumentów, gdyż w przeciwnym razie zostanie zgłoszony błąd. Wywołanie konstruktora nadklasy nie musi być pierwszą instrukcją w konstruktorze podklasy (było to wymagane w języku ActionScript 2.0).
			<p>Instrukcja <code>super</code> zastosowana w metodzie instancji może być uzupełniona o operator (.) w celu wywołana wersji metody z nadklasy i opcjonalnego przekazania do niej argumentów <code>(arg1 ... argN)</code>. Jest to użyteczne w przypadku tworzenia metod podklasy, które nie tylko uzupełniają metody nadklasy o dodatkowe zachowanie, lecz również wywołują metody nadklasy w celu zrealizowania ich pierwotnego zachowania.</p>
			<p>Nie jest dozwolone użycie instrukcji <code>super</code> w metodzie statycznej.</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">method</span>:<a href="Function.html">Function</a></code> &mdash; Metoda, która ma zostać wywołana w nadklasie.</td></tr><tr><td width="20px"></td><td><code><span class="label">argN</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Opcjonalne parametry przekazywane do wersji metody zdefiniowanej w nadklasie lub do konstruktora nadklasy.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="switch"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">switch</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>
switch (expression) {
	caseClause: 
	[defaultClause:] 
}</pre></p></td></tr></table><p></p><p><p>Przekazuje sterowanie do jednej z kilku instrukcji, w zależności od wartości wyrażenia. Wszystkie instrukcje <code>switch</code> powinny uwzględniać przypadek domyślny, który zostanie wykonany, jeśli wartość wyrażenia nie będzie pasować do żadnej z instrukcji <code>case</code>. Każda instrukcja <code>case</code> powinna kończyć się instrukcją <code>break</code>, która zapobiega niekontrolowanemu przejściu do następnego przypadku. Niekontrolowane przejście polega na wykonaniu kodu w następnej instrukcji <code>case</code>, nawet jeśli nie pasuje ona do wartości testowanego wyrażenia.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Dowolne wyrażenie.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zdefiniowano instrukcję switch, która w razie niedopasowania wartości wyrażenia wykonuje instrukcję określoną w przypadku domyślnym:

<div class="listing"><pre>

var switchExpression:int = 3;
		
switch (switchExpression) {
	case 0:
		trace(0);
		break;
	case 1:
		trace(1);
		break;
	case 2:
		trace(2);
		break;
	default:
		trace("Not 0, 1, or 2");
}

// Not 0, 1, or 2
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="statements.html#case" target="">case</a><br/><a href="statements.html#default" target="">default</a></div></div><a name="this"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">this</td><td class="detailHeaderType">podstawowe słowo kluczowe wyrażenia</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>this</pre></p></td></tr></table><p></p><p><p>Odwołanie do obiektu zawierającego metodę. Podczas wykonywania skryptu słowo kluczowe <code>this</code> oznacza odwołanie do obiektu, w którym ten skrypt jest zawarty. W treści metody słowo kluczowe <code>this</code> oznacza odwołanie do instancji klasy zawierającej wywołaną metodę.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Aby wywołać funkcję zdefiniowaną w klasie dynamicznej, należy użyć słowa this w celu wywołania funkcji we właściwym zasięgu:
<div class="listing"><pre>
// incorrect version of Simple.as
/*
dynamic class Simple {
    function callfunc() {
        func();
    }
}
*/
// correct version of Simple.as
dynamic class Simple {
    function callfunc() {
        this.func();
    }
}
</pre></div>
Do skryptu możemy teraz dodać następujący kod:
<div class="listing"><pre>
var simpleObj:Simple = new Simple();
simpleObj.func = function() {
	trace("hello there");
}
simpleObj.callfunc();
</pre></div>
Powyższy kod działa prawidłowo, gdy słowa kluczowego this używamy w metodzie callfunc(). Jednak użycie niepoprawnej wersji pliku Simple.as, ujętej powyżej w komentarz, spowodowałoby błąd składniowy.

			
			<p></p></div><a name="throw"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">throw</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>throw expression </pre></p></td></tr></table><p></p><p><p>Generuje (pot. <em>wyrzuca</em>, ang. throw) błąd, który może być obsłużony (pot. <em>przechwycony</em>, ang. catch) przez blok kodu <code>catch</code>. Jeśli wyjątek nie zostanie przechwycony przez blok <code>catch</code>, ciąg znaków reprezentujący wygenerowaną wartość zostanie wyświetlony w panelu Wyjście. Jeśli wyjątek nie zostanie przechwycony przez blok <code>catch</code> lub <code>finally</code>, ciąg reprezentujący wygenerowaną wartość zostanie zapisany w pliku dziennika.  <p>Zwykle za pomocą instrukcji throw generowane są instancje klasy Error lub jej podklas (zob. sekcja Przykład).</p></p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Wyrażenie lub obiekt języka ActionScript.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie funkcja o nazwie checkEmail() sprawdza, czy przekazany do niej ciąg znaków jest prawidłowo sformatowanym adresem e-mail. Jeśli ciąg nie zawiera symbolu @, funkcja generuje błąd. 
<div class="listing"><pre>function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new Error("Invalid email address"); 
	} 
} 
checkEmail("someuser_theirdomain.com");</pre></div> 
Poniższy kod wywołuje następnie tę samą funkcję, checkEmail(), wewnątrz bloku kodu try. Jeśli ciąg znaków nie zawiera poprawnego adresu e-mail, za pomocą instrukcji trace wyświetlany jest komunikat o błędzie.
<div class="listing"><pre>
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e); 
}
// Error: Invalid email address.</pre></div> 
W poniższym przykładzie generowana jest podklasa klasy Error. Funkcja checkEmail() została zmodyfikowana w taki sposób, aby generowała instancję tej podklasy.
<div class="listing"><pre>
// Define Error subclass InvalidEmailError 
class InvalidEmailAddress extends Error { 
    public function InvalidEmailAddress() {
    	message = "Invalid email address."; 
    }
}
</pre></div> 
W skrypcie możemy teraz wprowadzić poniższy kod:
<div class="listing"><pre>
import InvalidEmailAddress; 
function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new InvalidEmailAddress(); 
	} 
} 
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e);
}
// Error: Invalid email address.</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Error.html" target="">Klasa Error</a><br/><a href="statements.html#try..catch..finally" target="">Instrukcja try..catch..finally</a></div></div><a name="true"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">true</td><td class="detailHeaderType">podstawowe słowo kluczowe wyrażenia</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>true</pre></p></td></tr></table><p></p><p><p>Wartość typu Boolean reprezentująca prawdę. Wartość typu Boolean może być równa albo <code>true</code>, albo <code>false</code>; wartością przeciwną do <code>true</code> jest <code>false</code>. Gdy w wyniku automatycznej konwersji typów wartość <code>true</code> jest przekształcana w liczbę, staje się wartością <code>1</code>; gdy wartość <code>true</code> jest przekształcana w ciąg znaków, staje się ciągiem "true".
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie wartości true w instrukcji if:
<div class="listing"><pre>

var shouldExecute:Boolean;
// ...
// code that sets shouldExecute to either true or false goes here
// shouldExecute is set to true for this example:

shouldExecute = true;

if (shouldExecute == true) {
    trace("your statements here");
}

// true is also implied, so the if statement could also be written:
// if (shouldExecute) {
//         trace("your statements here");
// }</pre></div>
Poniższy przykład ilustruje automatyczną konwersję wartości true typu Boolean na liczbę 1:
<div class="listing"><pre>

var myNum:Number;
myNum = 1 + true;
trace(myNum); // 2</pre></div>

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Boolean.html" target="">Klasa typu Boolean</a><br/><a href="statements.html#false" target="">false</a></div></div><a name="try..catch..finally"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">try..catch..finally</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>try { 
    // try block 
} finally { 
    // finally block  
} 

try { 
    // try block 
} catch(error[:ErrorType1]) {
    // catch block 
} [catch(error[:ErrorTypeN]) { 
    // catch block 
}] [finally {
    // finally block 
}]</pre></p></td></tr></table><p></p><p><p>Otacza blok kodu, w którym może wystąpić błąd, i pozwala zareagować na błąd. Obsługa wyjątków, implementowana za pomocą instrukcji <code>try..catch..finally</code> jest podstawowym mechanizmem, jaki język ActionScript 3.0 oferuje do obsługi błędów występujących w czasie wykonywania. Gdy w czasie wykonywania wystąpi błąd, program Flash Player generuje wyjątek, a tym samym zawiesza normalne wykonywanie kodu i tworzy specjalny obiekt typu <code>Error</code>. Następnie program Flash Player przekazuje (pot. <em>wyrzuca</em>) obiekt błędu o pierwszego dostępnego bloku <code>catch</code>. Jeśli nie ma dostępnych bloków <code>catch</code>, wyjątek jest uznawany za nieprzechwycony. Nieprzechwycone wyjątki powodują zakończenie wykonywania skryptu.
			<p>Instrukcja <code>throw</code> umożliwia jawne generowanie wyjątków w kodzie. Dozwolone jest generowanie dowolnej wartości, ale dobrą praktyką jest generowanie obiektów, ponieważ taki sposób postępowania jest zgodny z zachowaniem samego odtwarzacza Flash Player i zapewnia elastyczność.</p>
			<p>Aby przechwycić wyjątek wygenerowany przez program Flash Player lub przez własny kod użytkownika, należy umieścić kod, który może wygenerować wyjątek, wewnątrz bloku <code>try</code>. Jeśli kod w bloku <code>try</code> wygeneruje wyjątek, sterowanie jest przekazywane do bloku <code>catch</code>, o ile taki blok istnieje, a następnie do bloku <code>finally</code>, o ile taki blok istnieje. Blok <code>finally</code> jest wykonywany zawsze, niezależnie od tego, czy wyjątek został wygenerowany. Jeśli kod w bloku <code>try</code> nie wygeneruje wyjątku (tj. blok kodu <code>try</code> zostanie wykonany bezbłędnie), kod w bloku <code>catch</code> zostanie zignorowany, ale kod w bloku <code>finally</code> i tak zostanie wykonany. Blok <code>finally</code> jest wykonywany nawet wówczas, gdy wyjście z bloku <code>try</code> nastąpi poprzez użycie instrukcji <code>return</code>. </p>
			<p>Po bloku <code>try</code> musi następować blok <code>catch</code>, blok <code>finally</code> lub oba te bloki. Z jednym blokiem <code>try</code> może być skojarzonych wiele bloków <code>catch</code>, ale tylko jeden blok <code>finally</code>. Dozwolone jest zagnieżdżanie bloków <code>try</code> na dowolną głębokość.</p> 
			<p>Parametr <code>error</code> określony w bloku obsługi <code>catch</code> musi być prostym identyfikatorem, takim jak <code>e</code>, <code>theException</code> lub <code>x</code>. Parametr ten może również mieć określony typ. Parametry o określonym typie, używane razem z wieloma blokami <code>catch</code>, pozwalają na przechwytywanie wielu typów obiektów błędów w jednym bloku <code>try</code>.</p> 
			<p>Jeśli wygenerowany wyjątek jest obiektem, typ zostanie uznany za dopasowany, jeśli wygenerowany obiekt będzie podklasą określonego typu. Jeśli zostanie wygenerowany błąd określonego typu, zostanie wykonany blok <code>catch</code> obsługujący błędy tego typu. Jeśli zostanie wygenerowany wyjątek nienależący do określonego typu, blok <code>catch</code> nie zostanie wykonany, a wyjątek zostanie automatycznie przekazany poza blok <code>try</code> do pasującego bloku obsługi <code>catch</code>. </p> 
			<p>Jeśli błąd zostanie wygenerowany wewnątrz funkcji, a funkcja nie zawiera bloku obsługi <code>catch</code>, program Flash Player wychodzi z tej funkcji, a potem z funkcji, które ją wywołały, dopóki nie napotka bloku <code>catch</code>. W trakcie tego procesu na wszystkich poziomach wykonywane są bloki obsługi <code>finally</code>.</p>
			<p>Uwaga: Jeśli na przykład blok try zawiera obiekt wywołujący zdarzenie jego modułu obsługi zdarzeń, blok catch nie przechwytuje błędu w przypadku wygenerowania błędu przez ten moduł. Każdy błąd wygenerowany później może zostać przechwycony przez wykrywanie zdarzenia <code>LoaderInfo.uncaughtErrorEvents</code>.</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">error</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Wyrażenie generowane przez instrukcję throw, zazwyczaj instancja klasy Error lub jednej z jej podklas.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie instrukcji try..catch. Kod w bloku try zawiera niedozwoloną operację. Ikonka nie może dodać siebie samej jako obiekt potomny. W rezultacie program Flash Player generuje wyjątek i przekazuje obiekt typu ArgumentError do odpowiedniego bloku catch.
<div class="listing"><pre>
import flash.display.Sprite;

var spr:Sprite = new Sprite();
try {
	spr.addChild(spr);
}
catch (e:ArgumentError) {
	trace (e); // ArgumentError: Error #2024: An object may not be added as a child of itself.
}
</pre></div> 
W poniższym przykładzie obiekty RecordSetException i MalformedRecord są podklasami klasy Error.  
<div class="listing"><pre>
class RecordSetException extends Error { 
	public function RecordSetException () {
		message = "Record set exception occurred."; 
	}
}

class MalformedRecord extends Error { 
	public function MalformedRecord {
		message = "Malformed record exception occurred."; 
	}
}</pre></div> 

W metodzie sortRows() klasy RecordSet generowany jest jeden z tych zdefiniowanych wcześniej obiektów błędów, w zależności od typu wyjątku, jaki wystąpił. Poniższy przykład ilustruje możliwą postać takiego kodu: 
<div class="listing"><pre>
class RecordSet { 
	public function sortRows() { 
		var returnVal:Number = randomNum(); 
		if (returnVal == 1) { 
			throw new RecordSetException(); 
		} 
		else if (returnVal == 2) { 
			throw new MalformedRecord(); 
		} 
	}
	public function randomNum():Number { 
		return Math.round(Math.random() * 10) % 3; 
	}
}</pre></div> 
Na koniec poniższy kod wywołuje metodę sortRows() w instancji klasy RecordSet. W przykładzie zdefiniowano bloki catch dla wszystkich typów obiektów błędów generowanych przez metodę sortRows().
<div class="listing"><pre>import RecordSet; 
var myRecordSet:RecordSet = new RecordSet();
try { 
	myRecordSet.sortRows(); 
	trace("everything is fine"); 
} 
catch (e:RecordSetException) { 
	trace(e.toString()); 
} 
catch (e:MalformedRecord) { 
	trace(e.toString()); 
}</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Error.html" target="">Klasa Error</a><br/><a href="statements.html#throw" target="">throw</a></div></div><a name="use_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">use namespace</td><td class="detailHeaderType">dyrektywa</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>use namespace ns1[, ns2, ...nsN]</pre></p></td></tr></table><p></p><p><p>Powoduje dodanie określonych przestrzeni nazw do zestawu otwartych przestrzeni nazw. Określone przestrzenie nazw zostaną usunięte z zestawu otwartych przestrzeni nazw po wyjściu z bieżącego bloku kodu. Dyrektywa <code>use namespace</code> może być umieszczona na najwyższym poziomie programu, definicji pakietu lub definicji klasy.</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">nsN</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Jedna lub więcej przestrzeni nazw, które mają zostać dodane do zestawu otwartych przestrzeni nazw.</td></tr></table><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#default_xml_namespace" target="">default xml namespace</a><br/><a href="statements.html#namespace" target="">namespace</a><br/><a href="XML.html" target="">Klasa XML</a></div></div><a name="var"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">var</td><td class="detailHeaderType">słowo kluczowe definicji</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>var variableName [= value1][...,variableNameN[=valueN]] </pre></p></td></tr></table><p></p><p><p>Określa zmienną. Zmienne zadeklarowane wewnątrz funkcji są lokalne. Są zdefiniowane dla tej funkcji i przestają istnieć po zakończeniu wywołania funkcji. 
			 
			<p>Zmiennej, która znajduje się w zasięgu innego obiektu, nie można zadeklarować jako lokalnej.</p> 
<pre>my_array.length = 25; // ok 
var my_array.length = 25; // syntax error </pre> 
			<p>Zmiennej można przypisać typ danych, dopisując za jej nazwą dwukropek i typ danych.</p>
			<p>W jednej instrukcji można zadeklarować wiele zmiennych, oddzielając deklaracje przecinkami (jednak użycie takiej składni może zmniejszyć przejrzystość kodu):</p>
			<pre>var first:String = "Bart", middle:String = "J.", last:String = "Bartleby";</pre>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Identyfikator.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy kod ActionScript tworzy nową tablicę nazw produktów. Metoda Array.push dodaje element na końcu tablicy. 
<div class="listing"><pre>
var product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); 
trace(product_array); 
// Studio,Dreamweaver,Flash,ColdFusion,Contribute,Breeze,Flex</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#const" target="">const</a></div></div><a name="while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">while</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>while (condition) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Wyznacza wartość warunku i jeśli wartość ta jest równa <code>true</code>, wykonuje jedną lub wiele instrukcji, po czym wraca na początek pętli i ponownie wyznacza wartość warunku. Gdy wyznaczona wartość warunku to <code>false</code>, instrukcje w pętli są pomijane i pętla kończy się. 
			<p>Instrukcja <code>while</code> wykonuje następującą sekwencję kroków. Każde powtórzenie kroków od 1 do 4 jest nazywane <em>iteracją</em> pętli. Na początku każdej iteracji testowany jest warunek. Działanie instrukcji dokładniej opisano w poniższych krokach:</p> 
			<ol> 
				<li>Wyznaczana jest wartość wyrażenia <code>condition</code>.</li> 
				<li>Jeśli wyznaczona wartość wyrażenia <code>condition</code> jest równa <code>true</code> lub jest wartością, która po przekonwertowaniu na typ Boolean daje wartość <code>true</code> (np. liczbą niezerową), następuje przejście do kroku 3. W przeciwnym razie wykonywanie instrukcji <code>while</code> kończy się, a sterowanie przechodzi do następnej instrukcji po pętli <code>while</code>.</li> 
				<li>Wykonywany jest blok instrukcji <code>statement(s)</code>. W razie napotkania instrukcji <code>continue</code> pozostałe instrukcje są pomijane i następuje powrót do kroku 1. W razie napotkania instrukcji <code>break</code> wykonywanie instrukcji <code>while</code> kończy się, a sterowanie jest przekazywane do następnej instrukcji po pętli <code>while</code>.</li> 
				<li>Następuje powrót do kroku 1.</li> 
			</ol> 
			<p>Pętle są często stosowane do wykonywania pewnej operacji tak długo, jak długo zmienna licznikowa jest mniejsza od określonej wartości. Na końcu każdej pętli licznik jest inkrementowany, aż do osiągnięcia określonej wartości. W tym momencie wyrażenie <code>condition</code> przestaje mieć wartość <code>true</code> i pętla kończy się.</p> 
			<p>Jeśli w ramach instrukcji <code>while</code> ma być wykonana tylko jedna instrukcja, nie jest wymagane ujmowanie jej w nawiasy sześcienne (<code>{}</code>).</p>
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Wyrażenie, które daje w wyniku wartość true albo false.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie instrukcja while testuje wyrażenie. Gdy wartość i jest mniejsza niż 20, wykonywana jest instrukcja trace(i) wyświetlająca tę wartość. Gdy wyznaczona wartość warunku przestanie być równa true, następuje wyjście z pętli. 
<div class="listing"><pre>
var i:Number = 0; 
while (i < 20) { 
	trace(i); 
	i += 3; 
}
/*
0 
3 
6 
9 
12
15 
18
*/</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#do..while" target="">do..while</a></div></div><a name="with"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">with</td><td class="detailHeaderType">instrukcja</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>with (object:Object) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Ustanawia obiekt domyślny, na którym mają być wykonywane instrukcje, pozwalając na skrócenie kodu programu.
			<p>Parametr <code>object</code> staje się kontekstem, w którym interpretowane są właściwości, zmienne i funkcje w parametrze <code>statement(s)</code>. Na przykład, jeśli <code>object</code> to tablica <code>my_array</code>, a dwie spośród określonych właściwości to <code>length</code> i <code>concat</code>, właściwości te będą automatycznie interpretowane jako <code>my_array.length</code> i <code>my_array.concat</code>. A oto inny przykład: jeśli <code>object</code> to <code>state.california</code>, wszelkie operacje lub instrukcje wewnątrz instrukcji <code>with</code> będą traktowane tak, jak gdyby były wywoływane z instancji <code>california</code>.</p> 
			<p>Aby wyznaczyć wartość identyfikatora w parametrze <code>statement(s)</code>, kompilator języka ActionScript rozpoczyna analizę od początku łańcucha zasięgu określonego przez <code>object</code> i szuka identyfikatora na każdym poziomie łańcucha zasięgu, w ustalonej kolejności. </p> 
			<p>Łańcuch zasięgu używany w instrukcji <code>with</code> do interpretacji identyfikatorów zaczyna się od pierwszego elementu na poniższej liście i zawiera kolejne elementy tej listy:</p> 
			<ul> 
				<li>Obiekt określony w parametrze <code>object</code> najbardziej wewnętrznej instrukcji <code>with</code>.</li> 
				<li>Obiekt określony w parametrze <code>object</code> najbardziej zewnętrznej instrukcji <code>with</code>.</li> 
				<li>Obiekt Activation (obiekt tymczasowy tworzony automatycznie, gdy skrypt wywołuje funkcję zawierającą zmienne lokalne wywoływane w funkcji).</li> 
				<li>Obiekt zawierający obecnie wykonywany skrypt.</li> 
				<li>Obiekt Global (do tej klasy należą obiekty wbudowane, takie jak Math i String).</li> 
			</ul> 
			<p>Aby wewnątrz instrukcji <code>with</code> można było nadać wartość zmiennej, zmienna ta musi być zadeklarowana poza instrukcją <code>with</code> lub należy wprowadzić pełną ścieżkę do osi czasu, na której ta zmienna ma istnieć. Próba nadania niezadeklarowanej zmiennej wartości wewnątrz instrukcji <code>with</code> spowoduje, że deklaracja zmiennej będzie poszukiwana zgodnie z łańcuchem zasięgu.<code></code> Jeśli zmienna jeszcze nie istnieje, nowa wartość zostanie ustawiona na osi czasu, z której wywołano instrukcję <code>with</code>.</p> 
			</p></p><p></p><span class="label">Parametry</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; Instancja obiektu języka ActionScript lub klipu filmowego.</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie ustawiane są wartości właściwości _x i _y instancji someOther_mc, a następnie obiekt someOther_mc otrzymuje instrukcję przejścia do klatki nr 3 i zatrzymania. 
with (someOther_mc) { 
	_x = 50; 
	_y = 100; 
	gotoAndStop(3); 
} 
Poniższy wycinek kodu ilustruje możliwy sposób zapisania poprzedniego przykładu bez użycia instrukcji with. 
someOther_mc._x = 50; 
someOther_mc._y = 100; 
someOther_mc.gotoAndStop(3); 
Instrukcja with jest przydatna, gdy chcemy jednocześnie uzyskać dostęp do wielu elementów w łańcuchu zasięgu. W poniższym przykładzie wbudowany obiekt Math znajduje się na początku łańcucha zasięgu. Ustawienie obiektu Math jako obiektu domyślnego powoduje, że identyfikatory cos, sin i PI są interpretowane odpowiednio jako Math.cos, Math.sin i Math.PI. Identyfikatory a, x, y oraz r nie są metodami ani właściwościami obiektu Math, ale ponieważ istnieją w zasięgu aktywacji obiektu funkcji polar(), są interpretowane jako odpowiednie zmienne lokalne. 
<div class="listing"><pre>function polar(r:Number):void { 
	var a:Number, x:Number, y:Number; 
	with (Math) { 
		a = PI * pow(r, 2); 
		x = r * cos(PI); 
		y = r * sin(PI / 2); 
	} 
	trace("area = " + a); 
	trace("x = " + x); 
	trace("y = " + y); 
} polar(3);
/* 
area = 28.2743338823081 
x = -3 
y = 3
*/</pre></div>
			<p></p></div><p></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:24 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/pl_PL/legalnotices/index.html">Informacje prawne</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Zasady prywatności online</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Dlaczego język angielski?</span>
				</div>
				<div class="white_content_body">
					<b>Treść dokumentacji języka ActionScript 3.0 wyświetlana w języku angielskim</b><br><br>
					Niektóre części dokumentacji języka ActionScript 3.0 nie są przetłumaczone na poszczególne języki. Gdy element nie jest przetłumaczony na dany język, jest wyświetlany tekst angielski. Na przykład opis klasy ga.controls.HelpBox nie jest przetłumaczony na żaden dodatkowy język. Z tego powodu polska wersja dokumentacji zawiera opis klasy ga.controls.HelpBox w języku angielskim.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:24 PM Z  -->
