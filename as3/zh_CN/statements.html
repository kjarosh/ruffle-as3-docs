<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="用于 Adobe&reg; Flash&reg; Platform 的 ActionScript&reg; 3.0 参考"><meta name="lang" content="zh-cn"><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"><link rel="stylesheet" href="asfilter.css" type="text/css"><link rel="stylesheet" href="ion.css" type="text/css"><title>语句、关键字和指令 - Adobe ActionScript&reg; 3 (AS3 ) API 参考</title>
		<link rel="stylesheet" href="filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="filter_new.css" type="text/css">
			
		<script src="jquery.js" type="text/javascript"></script>
		<script src="s_chl_code.js" type="text/javascript"></script>
		<script src="jquery.zclip.js" type="text/javascript"></script>
		<script src="jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="cookies.js" type="text/javascript"></script>
		<script src="asdoc.js" type="text/javascript"></script>
		<script src="iscroll.js" type="text/javascript"></script>
		<script src="AC_OETags.js" type="text/javascript"></script>
		<script src="omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "运行时";
			var productsLabel = "产品";
			var noneLabel = "无";
			var qsearchBoxLabel = "快速搜索";
			var qsearchText = "未找到所搜索的词";
			var ajaxErrorMsg="加载页面时出错";
			var ajaxErrorTryMsg="重试";
			var ajaxLoadingMsg="仍在加载中";
			var cancelMsg = "取消";
			var classesText = "类";
			var strJiveReply = "此问题针对以下文章提出： "
			var showFilters = "显示过滤条件";
			var hideFilters = "隐藏过滤条件";
			
		
			var baseRef = "./";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											用于 Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform 的 ActionScript<sup>&reg;</sup> 3.0 参考<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="index.html"> 主页 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="statements.html#top" style="display:">显示包列表和类列表</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="statements.html#top" style="display:none">隐藏包列表和类列表</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="package-summary.html"> 包 </a>&nbsp;|&nbsp;
												<a target="_self" href="class-summary.html"> 类 </a>&nbsp;|&nbsp;
												<a target="_self" href="whatsnew.html"> 新增内容 </a>&nbsp;|&nbsp;
												<a target="_self" href="all-index-Symbols.html"> 索引 </a>&nbsp;|&nbsp;
												<a target="_self" href="appendixes.html"> 附录 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">为什么显示为英语？</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/zh_CN/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('./')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('./')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="help.js"></script>
						<script language="javascript" type="text/javascript" src="asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>过滤条件:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">正在从服务器检索数据...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">正在从服务器检索数据...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="statements.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">&nbsp;</a><br>
								<h1 id="classProductName">语句、关键字和指令&nbsp;</h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="statements.html#propertySummary" style="display:none"> 属性 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 属性 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 构造函数 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="statements.html#methodSummary" style="display:none"> 方法 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="statements.html#constantSummary" style="display:none"> 全局常量 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="statements.html#eventSummary" style="display:none"> 事件 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="statements.html#styleSummary" style="display:none"> 样式 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="statements.html#SkinPartSummary" style="display:none"> 外观部件 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="statements.html#SkinStateSummary" style="display:none"> 外观状态 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="statements.html#effectSummary" style="display:none"> 效果 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="statements.html#constantSummary" style="display:none"> 常量 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="statements.html#methodSummary" style="display:none"> 全局函数 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="statements.html#methodSummary" style="display:none">函数</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="statements.html#interfaceSummary" style="display:none"> 接口 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="statements.html#classSummary" style="display:none"> 类 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="statements.html#includeExamplesSummary" style="display:none"> 示例 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="statements.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								类
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><p>语句是在运行时执行或指定动作的语言元素。例如，<code>return</code> 语句会为执行该语句的函数返回一个结果。<code>if</code> 语句对条件进行计算，以确定应采取的下一个动作。<code>switch</code> 语句创建 ActionScript 语句的分支结构。 
		<p>属性关键字更改定义的含义，可以应用于类、变量、函数和命名空间定义。定义关键字用于定义实体，例如变量、函数、类和接口。主要表达式关键字表示文本值。若要获得保留字的列表，请参见<a href="http://www.adobe.com/go/learn_as3_reservedwords_cn" >学习使用 ActionScript 3.0</a>。</p> 
		<p>指令包含语句和定义，在编译时或运行时起作用。下表中将既不是语句也不是定义的指令标记为指令。</p>
		</p><br><a name="statementSummary"></a><table cellspacing="0" cellpadding="3" class="summaryTable"><tr><th>&nbsp;</th><th colspan="2">语句</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#break">break</a></td><td class="summaryTableLastCol">出现在循环（<code>for</code>、<code>for..in</code>、<code>for each..in</code>、<code>do..while</code> 或 <code>while</code>）内，或出现在与 <code>switch</code> 语句中的特定情况相关联的语句块中。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#case">case</a></td><td class="summaryTableLastCol">定义 <code>switch</code> 语句的跳转目标。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#continue">continue</a></td><td class="summaryTableLastCol">跳过最内层循环中所有其余的语句并开始循环的下一次遍历，就像控制正常传递到了循环结尾一样。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default">default</a></td><td class="summaryTableLastCol">定义 <code>switch</code> 语句的默认情况。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#do..while">do..while</a></td><td class="summaryTableLastCol">与 <code>while</code> 循环类似，不同之处是在对条件进行初始计算前执行一次语句。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#else">else</a></td><td class="summaryTableLastCol">指定当 <code>if</code> 语句中的条件返回 <code>false</code> 时要运行的语句。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for">for</a></td><td class="summaryTableLastCol">计算一次 <code>init</code>（初始化）表达式，然后开始一个循环序列。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for..in">for..in</a></td><td class="summaryTableLastCol">遍历对象的动态属性或数组中的元素，并对每个属性或元素执行 <code>statement</code>。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for_each..in">for each..in</a></td><td class="summaryTableLastCol">遍历集合的项目，并对每个项目执行 <code>statement</code>。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#if">if</a></td><td class="summaryTableLastCol">计算条件以确定下一条要执行的语句。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#label">label</a></td><td class="summaryTableLastCol">将语句与可由 <code>break</code> 或 <code>continue</code> 引用的标识符相关联。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#return">return</a></td><td class="summaryTableLastCol">导致立即返回执行调用函数。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#super">super</a></td><td class="summaryTableLastCol">调用方法或构造函数的超类或父版本。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#switch">switch</a></td><td class="summaryTableLastCol">根据表达式的值，使控制转移到多条语句的其中一条。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#throw">throw</a></td><td class="summaryTableLastCol">生成或<em>引发</em>一个可由 <code>catch</code> 代码块处理或<em>捕获</em>的错误。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#try..catch..finally">try..catch..finally</a></td><td class="summaryTableLastCol">包含一个代码块，在其中可能会发生错误，然后对该错误进行响应。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#while">while</a></td><td class="summaryTableLastCol">计算一个条件，如果该条件的计算结果为 <code>true</code>，则会执行一条或多条语句，之后循环会返回并再次计算条件。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#with">with</a></td><td class="summaryTableLastCol">建立要用于执行一条或多条语句的默认对象，从而潜在地减少需要编写的代码量。</td></tr><tr><th>&nbsp;</th><th colspan="2"> 命名空间 </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#AS3">AS3</a></td><td class="summaryTableLastCol">定义核心 ActionScript 类的方法和属性，将其作为固定属性而非原型属性。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#flash_proxy">flash_proxy</a></td><td class="summaryTableLastCol">定义 Proxy 类的方法。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#object_proxy">object_proxy</a></td><td class="summaryTableLastCol">定义 ObjectProxy 类的方法。</td></tr><tr><th>&nbsp;</th><th colspan="2">主要表达式关键字</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#false">false</a></td><td class="summaryTableLastCol">表示 false 的布尔值。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#null">null</a></td><td class="summaryTableLastCol">一个可以分配给变量的或由未提供数据的函数返回的特殊值。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#this">this</a></td><td class="summaryTableLastCol">对方法的包含对象的引用。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#true">true</a></td><td class="summaryTableLastCol">表示 true 的布尔值。</td></tr><tr><th>&nbsp;</th><th colspan="2">定义关键字</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#..._(rest)_parameter">... (rest) parameter</a></td><td class="summaryTableLastCol">指定函数将接受任意多个以逗号分隔的参数。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#class">class</a></td><td class="summaryTableLastCol">定义一个类，它允许实例化共享您定义的方法和属性的对象。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#const">const</a></td><td class="summaryTableLastCol">指定一个常量，它是只能赋值一次的变量。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#extends">extends</a></td><td class="summaryTableLastCol">定义一个类以作为其他类的子类。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#function">function</a></td><td class="summaryTableLastCol">包含为执行特定任务而定义的一组语句。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#get">get</a></td><td class="summaryTableLastCol">定义一个 getter，它是一种可像属性一样读取的方法。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#implements">implements</a></td><td class="summaryTableLastCol">指定一个类可实现一个或多个接口。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#interface">interface</a></td><td class="summaryTableLastCol">定义接口。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#namespace">namespace</a></td><td class="summaryTableLastCol">允许您控制定义的可见性。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#package">package</a></td><td class="summaryTableLastCol">允许您将代码组织为可由其他脚本导入的离散组。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#set">set</a></td><td class="summaryTableLastCol">定义一个 setter，它是一种在 public 接口中作为属性出现的方法。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#var">var</a></td><td class="summaryTableLastCol">指定一个变量。</td></tr><tr><th>&nbsp;</th><th colspan="2">属性关键字</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#dynamic">dynamic</a></td><td class="summaryTableLastCol">指定类的实例可具有在运行时添加的动态属性。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#final">final</a></td><td class="summaryTableLastCol">指定不能覆盖方法或者不能扩展类。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#internal">internal</a></td><td class="summaryTableLastCol">指定类、变量、常量或函数可用于同一包中的任何调用者。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#native">native</a></td><td class="summaryTableLastCol">指定函数或方法由 Flash Player 以本机代码的形式实现。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#override">override</a></td><td class="summaryTableLastCol">指定用一种方法替换继承的方法。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#private">private</a></td><td class="summaryTableLastCol">指定变量、常量、方法或命名空间仅可供定义它的类使用。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#protected">protected</a></td><td class="summaryTableLastCol">指定变量、常量、方法或命名空间只可用于定义它的类及该类的任何子类。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#public">public</a></td><td class="summaryTableLastCol">指定类、变量、常量或方法可用于任何调用者。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#static">static</a></td><td class="summaryTableLastCol">指定变量、常量或方法属于类，而不属于类的实例。</td></tr><tr><th>&nbsp;</th><th colspan="2">指令</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default_xml_namespace">default xml namespace</a></td><td class="summaryTableLastCol">
			<code>default xml namespace</code> 指令可将默认的命名空间设置为用于 XML 对象。
			</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#import">import</a></td><td class="summaryTableLastCol">使外部定义的类和包可用于您的代码。</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#include">include</a></td><td class="summaryTableLastCol">包括指定文件的内容，就像该文件中的命令是调用脚本的一部分一样。</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#use_namespace">use namespace</a></td><td class="summaryTableLastCol">使指定的命名空间添加到打开的命名空间集中。</td></tr></table><div class="detailSectionHeader">语句、关键字和指令详细信息</div><a name="..._(rest)_parameter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">... (rest) parameter</td><td class="detailHeaderType">定义关键字</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName(parameter0, parameter1, ...rest){ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>指定函数将接受任意多个以逗号分隔的参数。参数列表成为了在整个函数体中可用的数组。在参数声明中，数组的名称在 <code>...</code> 字符后指定。参数可以拥有保留字以外的任意名称。 
			<p>如果与其他参数共同使用，则 <code>...</code> (rest) 参数声明必须是最后指定的参数。只有传递给函数的参数数目超过其他参数的数目时，才会填充 <code>...</code> (rest) 参数数组。</p> 
			<p>逗号分隔参数列表中的每一个参数都将放置在该数组的一个元素中。如果您传递了 Array 类的实例，则整个数组会放置到 <code>...</code> (rest) 参数数组的单个元素中。</p>
			<p>使用此参数会使 <code>arguments</code> 对象不可用。尽管 <code>...</code> (rest) 参数提供了与 <code>arguments</code> 数组和 <code>arguments.length</code> 属性相同的功能，但是未提供与由 <code>arguments.callee</code> 提供的功能类似的功能。在使用 <code>...</code> (rest) 参数之前，应确保不需要使用 <code>arguments.callee</code>。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rest</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 标识符表示传递至函数的参数数组的名称。不需要将参数命名为 rest；它可以具有不同于关键字的任意名称。可以将 ...(rest) 参数的数据类型指定为 Array，但是这样可能会产生混淆，因为该参数可接受逗号分隔值列表，该列表与 Array 类的实例不同。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例将 ... (rest) 参数用于两个不同的函数。第一个函数 traceParams 仅对 rest 数组中的各个参数调用 trace() 函数。第二个函数 average() 调用参数列表并返回平均值。第二个函数还使用了该参数的其他名称 args。
<div class="listing"><pre>
package {
	import flash.display.MovieClip;
	
	public class RestParamExample extends MovieClip {
		public function RestParamExample() {
			traceParams(100, 130, "two"); // 100,130,two
			trace(average(4, 7, 13));     // 8
		}
	}
}


function traceParams(... rest) {
 	trace(rest);
 }
 
function average(... args) : Number{
	var sum:Number = 0;
	for (var i:uint = 0; i < args.length; i++) {
		sum += args[i];
	}
	return (sum / args.length);
}
</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments 对象</a></div></div><a name="AS3"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">AS3</td><td class="detailHeaderType"> 命名空间 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>定义核心 ActionScript 类的方法和属性，将其作为固定属性而非原型属性。将“-as3”编译器选项设置为 <code>true</code>（这是 Flex Builder 2 中的默认设置）时，将为所有核心类自动打开 AS3 命名空间。这意味着核心类的单个实例将使用固定的属性和方法，而不是使用同一属性和方法附加到此类的原型对象上的版本。使用固定属性通常可以提供更好的性能，但将无法向后兼容 ECMAScript 第 3 版语言规范 (ECMA-262)。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="Object.html" target="">Object 类</a></div></div><a name="break"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">break</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>break [label]</code></p></p></td></tr></table><p></p><p><p>出现在循环（<code>for</code>、<code>for..in</code>、<code>for each..in</code>、<code>do..while</code> 或 <code>while</code>）内，或出现在与 <code>switch</code> 语句中的特定情况相关联的语句块内。当在循环中使用时，<code>break</code> 语句指示 Flash 跳过循环体的其余部分，停止循环动作，并执行循环语句后面的语句。在 <code>switch</code> 中使用 <code>break</code> 语句时，该语句将指示 Flash 跳过此 <code>case</code> 块中的其余语句，并跳到包含它的 <code>switch</code> 语句后面的第一个语句。 
			<p>在嵌套循环中，<code>break</code> 语句只跳过当前循环的其余部分，而不是中断整个系列的嵌套循环。要中断整个系列的嵌套循环，请使用 <code>label</code> 或 <code>try..catch..finally</code>。</p>
			<p><code>break</code> 语句可以具有可选标签，该标签必须与外部标记语句相匹配。使用与外部语句的标签不匹配的标签是一种语法错误。可以使用标记的 <code>break</code> 语句中断多层嵌套循环语句、<code>switch</code> 语句或 <code>block</code> 语句。有关示例，请参见 <code>label</code> 语句条目。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 与语句关联的标签名称。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例使用 break 以退出一个循环（如果没有该语句，该循环为无限循环）： 
<div class="listing"><pre>
var i:int = 0;
while (true) { 
	trace(i); 
	if (i >= 10) { 
		break; // this will terminate/exit the loop 
	} 
	i++; 
} 
/*
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10*/</pre></div>  
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="case"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">case</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>case jumpTarget: statements</pre></p></td></tr></table><p></p><p><p>定义 <code>switch</code> 语句的跳转目标。如果 <code>jumpTarget</code> 参数等同于使用 strict equality (<code>===</code>) 的 <code>switch</code> 语句的 <code>expression</code> 参数，则 Flash Player 将执行 <code>statements</code> 参数中的语句，直到遇到一个 <code>break</code> 语句或 <code>switch</code> 语句结束。 <p>如果在 <code>switch</code> 语句外部使用 <code>case</code> 语句，会产生错误，而且脚本不能编译。</p> 
			<p></p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">jumpTarget</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 任何表达式。</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 如果 jumpTarget 和 switch 语句中的条件表达式匹配，则执行语句。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例定义了 switch 语句 thisMonth 的跳转目标。如果 thisMonth 等同于 case 语句中的表达式，则执行该语句。 
<div class="listing"><pre>
var thisMonth:int = new Date().getMonth(); 
switch (thisMonth) { 
	case 0 : 
		trace("January"); 
		break; 
	case 1 : 
		trace("February"); 
		break; 
	case 5 : 
	case 6 : 
	case 7 : 
		trace("Some summer month"); 
		break; 
	case 8 : 
		trace("September"); 
		break; 
	default : 
		trace("some other month"); 
}</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#switch" target="">switch</a></div></div><a name="class"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">class</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>[dynamic] [public | internal] [final] class className [ extends superClass ] [ implements interfaceName[, interfaceName... ] ] { 
	// class definition here
}</pre>
			</p></td></tr></table><p></p><p><p>定义一个类，它允许实例化共享您定义的方法和属性的对象。例如，如果您正开发一个发票跟踪系统，则可以创建一个 Invoice 类，它定义每个发票应具有的所有方法和属性。然后您可以使用 <code>new Invoice()</code> 命令来创建 Invoice 对象。 
			<p>每个 ActionScript 源文件只能包含一个对其他源文件或脚本可见的类。外部可见的类可以是 public 或 internal 类，必须在包语句内定义。如果在同一个文件中包括其他类，则该类必须放在包语句之外、文件结尾处。 </p>
			<p>外部可见的类的名称必须与包含该类的 ActionScript 源文件的名称匹配。源文件名称必须是类的名称加上文件扩展名 .as。例如，如果您将一个类命名为 Student，则定义该类的文件必须命名为 Student.as。</p> 
			<p>您不能嵌套类定义；即，不能在一个类定义内定义其他类。</p> 
			<p>可以定义构造函数方法，每次创建该类的新实例时执行该方法。该构造函数方法的名称必须与类的名称匹配。如果未定义构造函数方法，则为您创建一个默认的构造函数。</p>
			<p>若要表示对象可在运行时添加和访问动态属性，请在 class 语句前面放置 <code>dynamic</code> 关键字。若要声明一个类实现一个接口，请使用 <code>implements</code> 关键字。若要创建一个类的子类，请使用 <code>extends</code> 关键字。（某一类只能扩展一个类，但可以实现多个接口。）可以在一个语句中使用 <code>implements</code> 和 <code>extends</code>。下列示例将介绍 <code>implements</code> 和 <code>extends</code> 关键字的典型用法：</p> 
<div class="listing"><pre>class C implements Interface_i, Interface_j // OK 
class C extends Class_d implements Interface_i, Interface_j // OK 
class C extends Class_d, Class_e // not OK </pre></div> 

			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 类的完全限定名称。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下面的示例创建一个名为 Plant 的类。Plant 构造函数采用两个参数。 
<div class="listing"><pre>// Filename Plant.as 
package {
  public class Plant { 
	// Define property names and types 
	private var _leafType:String; 
	private var _bloomSeason:String; 
	// Following line is constructor 
	// because it has the same name as the class 
	public function Plant(param_leafType:String, param_bloomSeason:String) { 
		// Assign passed values to properties when new Plant object is created 
		_leafType = param_leafType; 
		_bloomSeason = param_bloomSeason; 
	} 
	// Create methods to return property values, because best practice 
	// recommends against directly referencing a property of a class 
	public function get leafType():String { 
		return _leafType; 
	} 
	public function get bloomSeason():String { 
		return _bloomSeason; 
	} 
  }
}</pre></div> 
在脚本中，使用 new 运算符来创建一个 Plant 对象。
<div class="listing"><pre>
var pineTree:Plant = new Plant("Evergreen", "N/A"); 
// Confirm parameters were passed correctly 
trace(pineTree.leafType); 
trace(pineTree.bloomSeason); </pre></div> 
			
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#dynamic" target="">dynamic</a><br/><a href="statements.html#extends" target="">extends</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="const"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">const</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>const identifier = value </pre></p></td></tr></table><p></p><p><p>指定一个常量，它是只能赋值一次的变量。  
			<p>附加后跟数据类型的 colon (:) 字符可以严格指定常量的类型。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">identifier</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 常量的标识符。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例说明，如果尝试多次为一个常量赋值将发生错误。
<div class="listing"><pre>
const MIN_AGE:int = 21;
MIN_AGE = 18; // error</pre></div>
下例说明，如果常量是一个数组，仍然可以调用 Array 类方法，包括 Array.push()。但是无法分配新数组文本。 
<div class="listing"><pre>
const product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); // array operations are allowed
product_array = ["Other"];  // assignment is an error
trace(product_array); 
</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#var" target="">var</a></div></div><a name="continue"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">continue</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>continue [label]</pre></p></td></tr></table><p></p><p><p>跳过最内层循环中的所有剩余语句并开始循环的下一次遍历，就像控制正常传递到了循环结尾一样。<code>continue</code> 语句在循环外不起作用。在嵌套循环中，使用可选的 <code>label</code> 参数以跳过最内层以内的循环。
			<p><code>continue</code> 语句可以具有可选标签，该标签必须与外部标记语句相匹配。使用与外部语句的标签不匹配的标签是一种语法错误。使用标记的 <code>continue</code> 语句可以跳过多层嵌套循环语句。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在下面的 while 循环中，continue 语句用于遇到 3 的整数倍时跳过循环体的其余部分，并跳转到循环的顶端（在该处进行条件测试）： 
<div class="listing"><pre>
var i:int = 0; 
while (i < 10) { 
	if (i % 3 == 0) { 
		i++; 
		continue; 
	} 
	trace(i); 
	i++; 
}</pre></div> 
在 for 循环中，还可以使用 continue 语句跳过循环体的其余部分。在以下示例中，如果 i % 3 等于 0，则跳过 trace(i) 语句： 
<div class="listing"><pre> 
for (var i:int = 0; i < 10; i++) { 
	if (i % 3 == 0) { 
		continue; 
	} 
	trace(i); 
}</pre></div> 

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="default"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>default: statements </pre></p></td></tr></table><p></p><p><p>定义 <code>switch</code> 语句的默认情况。如果 <code>switch</code> 语句的 <code>expression</code> 参数不等于（使用 strict equality [<code>===</code>] 运算符）给定 <code>switch</code> 语句的 <code>case</code> 关键字后的任何 <code>expression</code> 参数，则执行这些语句。 
			<p><code>switch</code> 语句不需要 <code>default</code> case 语句。<code>default</code> case 语句也不一定要出现在列表的最后。如果在 <code>switch</code> 语句外部使用 <code>default</code> 语句，会产生错误，而且脚本不能编译。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 任何语句。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在以下示例中，如果某天是星期六或星期日，则不调用任何 case 语句，因此将转为执行 default 语句。 
<div class="listing"><pre>
var dayOfWeek:int = new Date().getDay(); 
switch (dayOfWeek) { 
	case 1 : 
		trace("Monday"); 
		break; 
	case 2 : 
		trace("Tuesday"); 
		break; 
	case 3 : 
		trace("Wednesday"); 
		break; 
	case 4 : 
		trace("Thursday"); 
		break; 
	case 5 : 
		trace("Friday"); 
		break; 
	default : 
		trace("Weekend"); 
}</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#switch" target="">switch</a></div></div><a name="default_xml_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default xml namespace</td><td class="detailHeaderType">指令</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>default xml namespace = ns</code></p></p></td></tr></table><p></p><p><p>
			<code>default xml namespace</code> 指令可将默认的命名空间设置为用于 XML 对象。 
			
			<p>如果未设置 <code>default xml namespace</code>，则默认命名空间是未命名的命名空间（当 URI 设置为空字符串时）。<code>default xml namespace</code> 声明的作用域在函数块内，类似于变量的作用域。
			</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例说明 default xml namespace 的作用域是函数块：
			<div class="listing"><pre>var nsDefault1:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault1;
	    
var x1:XML = <test1 />;
trace("x1 ns: " + x1.namespace());
			
scopeCheck();	

var x2:XML = <test2 />;
trace("x2 ns: " + x2.namespace());
		
function scopeCheck(): void {
	
	var x3:XML = <test3 />;
	trace("x3 ns: " + x3.namespace());
				
	var nsDefault2:Namespace = new Namespace("http://schemas.xmlsoap.org/soap/envelope/");
	default xml namespace = nsDefault2;
		    
	var x4:XML = <test4 />;
	trace("x4 ns: " + x4.namespace());

}</pre></div>
			
			以下是本示例 trace() 的输出：
			
			x1 ns: http://www.example.com/namespaces/
x3 ns: 
x4 ns: http://schemas.xmlsoap.org/soap/envelope/
x2 ns: http://www.example.com/namespaces/



下例使用 default xml namespace 来分配默认的命名空间。因为第二个 XML 对象 (x2) 定义了自己的默认命名空间，所以 x2 未使用此设置： 
<div class="listing"><pre>
var nsDefault:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault;
            
var x1:XML = <test1 />;

trace(x1.namespace());
	// http://www.example.com/namespaces/

var x2:XML = <test2 xmlns = "http://www.w3.org/1999/XSL/Transform/" />;
trace(x2.namespace());
	// http://www.w3.org/1999/XSL/Transform/

var x3:XML = <test3 xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" />;
trace(x3.namespace());
	// http://www.example.com/namespaces/
</pre></div>  
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#namespace" target="">namespace</a><br/><a href="Namespace.html" target="">Namespace 类</a><br/><a href="statements.html#use_namespace" target="">use namespace</a><br/><a href="XML.html" target="">XML</a></div></div><a name="do..while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">do..while</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>do { statement(s) } while (condition)</pre></p></td></tr></table><p></p><p><p>与 <code>while</code> 循环类似，不同之处是在对条件进行初始计算前执行一次语句。随后，仅当条件计算结果是 <code>true</code> 时执行语句。 <p><code>do..while</code> 循环确保循环内的代码至少执行一次。尽管这也可以通过使用 <code>while</code> 循环在 <code>while</code> 循环开始前放置要执行的语句的副本来实现，但很多程序员认为 <code>do..while</code> 循环更易于阅读。</p> 
			<p>如果条件计算结果始终为 <code>true</code>，<code>do..while</code> 就会无限循环。如果进入了无限循环，则 Flash Player 会遇到问题，最终会发出警告信息，或播放器崩溃。如果知道要循环的次数，应该尽可能使用 <code>for</code> 循环。尽管 <code>for</code> 循环易于读取和调试，但不是在所有情况下都能代替 <code>do..while</code> 循环。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 要计算的条件。只要 condition 参数的计算结果为 true，就会执行 do 代码块内的语句。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例使用 do..while 循环来计算条件是否为 true，并跟踪 myVar，直到 myVar 大于等于 5 为止。myVar 大于等于 5 时，循环结束。 
<div class="listing"><pre>
var myVar:Number = 0; 
do { 
	trace(myVar); 
	myVar++; 
} 
while (myVar < 5); 
/*
0 
1 
2 
3 
4
*/</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="dynamic"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dynamic</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>dynamic class className { // class definition here }</pre></p></td></tr></table><p></p><p><p>指定类的实例可具有在运行时添加的动态属性。如果在对类使用 <code>dynamic</code> 特性，可以在运行时向该类的实例添加属性。将未标记为 <code>dynamic</code> 的类视为<em>密封的</em>，这意味着无法向该类的实例添加属性。
			<p>如果类是密封的（非动态），尝试在类实例上获得属性或设置属性将导致错误。创建实例时，如果将编译器设置为严谨模式并指定数据类型，尝试向密封的对象添加属性将导致编译器错误；否则，将发生运行时错误。</p> 
			<p><code>dynamic</code> 属性不是由子类继承。如果扩展了动态类，则只有声明该子类具有 <code>dynamic</code> 属性时，子类才是动态的。</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例创建了两个类，一个是命名为 Expando 的动态类，另一个是命名为 Sealed 的密封类，将在随后的示例中使用它们。
<div class="listing"><pre>
package {

	dynamic class Expando  {
	}
	
	class Sealed {
	}
}
</pre></div>
以下代码创建 Expando 类的实例，并说明可以向该实例添加属性。
<div class="listing"><pre>
var myExpando:Expando = new Expando();
myExpando.prop1 = "new";
trace(myExpando.prop1); // new
</pre></div>
以下代码创建 Sealed 类的实例，并说明尝试添加属性将导致错误。
<div class="listing"><pre>
var mySealed:Sealed = new Sealed();
mySealed.prop1 = "newer"; // error
</pre></div>
		

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a></div></div><a name="else"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">else</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) { 
	// statement(s)
} 
else {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>指定当 <code>if</code> 语句中的条件返回 <code>false</code> 时要运行的语句。如果仅执行一条语句，则不必用大括号 (<code>{}</code>) 将 <code>else</code> 语句所执行的语句括起来。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 计算结果为 true 或 false 的表达式。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在以下示例中，else 条件用于检查 age_txt 变量是大于还是小于 18： 
<div class="listing"><pre>
if (age_txt.text>=18) { 
	trace("welcome, user"); 
} 
else { 
	trace("sorry, junior"); 
	userObject.minor = true; 
	userObject.accessAllowed = false;
}</pre></div> 
在以下示例中，不必使用大括号 ({})，因为 else 语句后面只有一条语句：
<div class="listing"><pre>
if (age_txt.text>18) { 
	trace("welcome, user");
} 
else trace("sorry, junior");</pre></div>
以下示例使用 if 和 else 语句的组合来对 score_txt 和特定的值进行比较： 
<div class="listing"><pre>

if (score_txt.text>90) { 
	trace("A"); 
} 
else if (score_txt.text>75) { 
	trace("B"); 
} 
else if (score_txt.text>60) { 
	trace("C"); 
} 
else { 
	trace("F"); 
}</pre></div><p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#if" target="">if</a></div></div><a name="extends"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">extends</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>class className extends otherClassName {}
interface interfaceName extends otherInterfaceName {} </pre> </p></td></tr></table><p></p><p><p>定义一个类以作为其他类的子类。子类继承超类中定义的所有方法、属性、函数等。无法扩展标记为 <code>final</code> 的类。
			<p>也可以使用 <code>extends</code> 关键字来扩展接口。扩展另一个接口的接口包含原始接口的所有方法声明。</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 您所定义的类的名称。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在下面的示例中，Car 类扩展 Vehicle 类，以继承其所有方法、属性和函数。如果您的脚本对 Car 对象进行实例化，则来自 Car 类的方法和来自 Vehicle 类的方法都可以使用。 
			下面的示例显示名为 Vehicle.as 的文件（它定义 Vehicle 类）的内容：  
<div class="listing"><pre>
package {
	class Vehicle { 
	    var numDoors:Number; 
	    var color:String; 
	    public function Vehicle(param_numDoors:Number = 2, param_color:String = null) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	    } 
	    public function start():void { 
	        trace("[Vehicle] start"); 
	    } 
	    public function stop():void { 
	        trace("[Vehicle] stop"); 
	    } 
	    public function reverse():void { 
	        trace("[Vehicle] reverse"); 
	    } 
	}	
}</pre></div> 
下面的示例显示同一目录下名为 Car.as 的第二个 ActionScript 文件。此类扩展 Vehicle 类，通过三种方式修改它。第一种是 Car 类添加变量 fullSizeSpare 以跟踪 car 对象是否具有标准尺寸的备用轮胎。第二种是它添加特定于汽车的新方法 activateCarAlarm()，该方法用于激活汽车的防盗警报。第三种是它覆盖 stop() 函数以添加 Car 类使用防抱死制动系统来停车的事实。
<div class="listing"><pre>
package {

	public class Car extends Vehicle { 
	    var fullSizeSpare:Boolean; 
	    public function Car(param_numDoors:Number, param_color:String, param_fullSizeSpare:Boolean) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	        fullSizeSpare = param_fullSizeSpare; 
	    } 
	    public function activateCarAlarm():void { 
	        trace("[Car] activateCarAlarm"); 
	    } 
	    public override function stop():void { 
	        trace("[Car] stop with antilock brakes"); 
	    } 
	}
}</pre></div> 
以下示例对 Car 对象进行实例化，调用在 Vehicle 类中定义的方法 (start())，然后调用由 Car 类覆盖的方法 (stop())，最后从 Car 类调用一个方法 (activateCarAlarm())：
<div class="listing"><pre>var myNewCar:Car = new Car(2, "Red", true); 
myNewCar.start(); // [Vehicle] start 
myNewCar.stop(); // [Car] stop with anti-lock brakes 
myNewCar.activateCarAlarm(); // [Car] activateCarAlarm</pre></div> 
使用 super 语句也可以编写 Vehicle 类的子类，此子类可以使用该语句访问超类的构造函数。下面的示例显示第三个 ActionScript 文件，该文件名为 Truck.as，也在同一目录中。在构造函数和覆盖的 reverse() 方法中，Truck 类使用 super。 
<div class="listing"><pre>
package {
	class Truck extends Vehicle {
		var numWheels:Number;
		public function Truck(param_numDoors:Number, param_color:String, param_numWheels:Number) { 
			super(param_numDoors, param_color); 
			numWheels = param_numWheels; 
		} 
		public override function reverse():void { 
			beep();
			super.reverse();
		} 
		public function beep():void { 
			trace("[Truck] make beeping sound"); 
		} 
	}
}</pre></div> 
以下示例对 Truck 对象进行实例化，调用由 Truck 类覆盖的方法 (reverse())，然后调用在 Vehicle 类中定义的方法 (stop())：  
<div class="listing"><pre>var myTruck:Truck = new Truck(2, "White", 18); 
myTruck.reverse(); // [Truck] make beeping sound [Vehicle] reverse 
myTruck.stop(); // [Vehicle] stop</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#interface" target="">接口</a></div></div><a name="false"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">false</td><td class="detailHeaderType">主要表达式关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>false</pre></p></td></tr></table><p></p><p><p>表示 false 的布尔值。布尔值为 <code>true</code> 或 <code>false</code>；<code>false</code> 与 <code>true</code> 相反。
			<p>如果自动设置数据类型时将 <code>false</code> 转换为数字，则它变为 <code>0</code>；如果其将 <code>false</code> 转换为字符串，则它变为 <code>"false"</code>。</p>
			<p><b>注意：</b>字符串 <code>"false"</code> 转换为布尔值 <code>true</code>。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>此示例说明自动设置数据类型如何将 false 转换为数字以及转换为字符串：
<div class="listing"><pre>
var bool1:Boolean = Boolean(false);

// converts it to the number 0
trace(1 + bool1); // outputs 1

// converts it to a string
trace("String: " + bool1); // outputs String: false
</pre></div>
以下示例显示字符串 "false" 转换为布尔值 true：
<div class="listing"><pre>
trace(Boolean("false")); // true

if ("false") {
	trace("condition expression evaluated to true");
}
else {
	trace("condition expression evaluated to false");
}
// condition expression evaluated to true
</pre></div>

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="Boolean.html" target="">Boolean 类</a><br/><a href="statements.html#true" target="">true</a></div></div><a name="final"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">final</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
final function methodName() { 
	// your statements here 
}
final class className {}</pre> </p></td></tr></table><p></p><p><p>指定不能覆盖方法或者不能扩展类。尝试覆盖方法或扩展类，并标记为 <code>final</code> 将导致错误。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; 无法覆盖的方法的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 无法扩展的类的名称。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#override" target="">覆盖</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="flash_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">flash_proxy</td><td class="detailHeaderType"> 命名空间 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>定义 Proxy 类的方法。Proxy 类方法位于自己的命名空间内，这是为了避免在 Proxy 子类包含与任一 Proxy 类方法名称相匹配的实例方法名称时发生名称冲突。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="flash/utils/Proxy.html" target="">Proxy 类</a></div></div><a name="for"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for ([init]; [condition]; [next]) { 
	// statement(s)
}</pre>
			</p></td></tr></table><p></p><p><p>计算一次 <code>init</code>（初始化）表达式，然后开始一个循环序列。循环序列从计算 <code>condition</code> 表达式开始。如果 <code>condition</code> 表达式的计算结果为 <code>true</code>，则执行 <code>statement</code> 并计算 <code>next</code>。然后循环序列再次从计算 <code>condition</code> 表达式开始。 
			<p>如果仅执行一条语句，则不必用大括号 (<code>{}</code>) 将 <code>for</code> 语句所执行的语句块括起来。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">init</span></code> &mdash; 在开始循环序列前要计算的可选表达式，通常为赋值表达式。还允许对此参数使用 var 语句。</td></tr><tr><td width="20px"></td><td><code><span class="label">condition</span></code> &mdash; 在开始循环序列前要计算的可选表达式，通常为比较表达式。如果表达式的计算结果为 true，则执行与 for 语句相关联的语句。</td></tr><tr><td width="20px"></td><td><code><span class="label">next</span></code> &mdash; 循环序列后要计算的可选表达式，通常是递增或递减表达式。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下面的示例使用 for 在数组中添加元素： 
<div class="listing"><pre>
var my_array:Array = new Array(); 
for (var i:Number = 0; i < 10; i++) { 
	my_array[i] = (i + 5) * 10;  
} 
trace(my_array); // 50,60,70,80,90,100,110,120,130,140 </pre></div> 
下面的示例使用 for 重复执行相同的动作。在代码中，for 循环将从 1 到 100 的数字相加。 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) { 
	sum += i; 
} 
trace(sum); // 5050</pre></div> 
以下示例说明，如果仅执行一条语句，则不必用大括号 ({})： 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) 
	sum += i; 
trace(sum); // 5050</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="operators.html#increment" target="">++ (increment)</a></div></div><a name="for..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for..in</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>for (variableIterant:String in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>遍历对象的动态属性或数组中的元素，并对每个属性或元素执行 <code>statement</code>。对象属性不按任何特定的顺序保存，因此属性看似以随机的顺序出现。固定属性（如在类中定义的变量和方法）不能由 <code>for..in</code> 语句来枚举。要获得固定属性列表，请使用 flash.utils 包中的 <code>describeType()</code> 函数。
			 
			 
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a href="String.html">String</a></code> &mdash; 要作为迭代变量的变量的名称，迭代变量引用对象的每个属性或数组中的每个元素。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例使用 for..in 遍历对象的属性： 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var prop in myObject) { 
	trace("myObject."+prop+" = "+myObject[prop]); 
} 
/*
myObject.firstName = Tara 
myObject.age = 27 
myObject.city = San Francisco
*/</pre></div> 
以下示例将 typeof 运算符与 for..in 结合使用以遍历特定类型的子集： 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var name in myObject) { 
	if (typeof (myObject[name]) == "string") { 
		trace("I have a string property named "+name); 
	} 
}
/*
I have a string property named city
I have a string property named firstName
*/
</pre></div> 
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="flash/utils/package.html#describeType()" target="">describeType()</a></div></div><a name="for_each..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for each..in</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for each (variableIterant in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>遍历集合的项目，并对每个项目执行 <code>statement</code>。<code>for each..in</code> 语句作为 E4X 语言扩展的一部分引入，不仅可以用于 XML 对象，而且可以用于对象和数组。<code>for each..in</code> 语句仅遍历对象的动态属性，而不是固定属性。固定属性是指定义为类定义的一部分的属性。要使用具有用户定义的类的实例的 <code>for each..in</code> 语句，则必须声明具有 <code>dynamic</code> 属性的类。 
			<p>与 <code>for..in</code> 语句不同，<code>for each..in</code> 语句遍历对象属性的值，而不是属性名称。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要作为迭代变量的变量的名称引用集合中的项。</td></tr><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; 要遍历的集合的名称。集合可以是 XML 对象、通用对象或数组。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例使用 for each..in 遍历对象的属性具有的值： 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	trace(item); 
} 
/*
Tara
27
San Francisco
*/</pre></div> 
以下示例使用 for each..in 遍历数组元素： 
<div class="listing"><pre>
var myArray:Array = new Array("one", "two", "three"); 
for each(var item in myArray) 
	trace(item); 
/*
one
two
three
*/</pre></div> 
以下示例将 is 运算符与 for each..in 结合使用以遍历特定类型的子集： 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	if (item is String) {  
		trace("I have a string property with value " + item); 
	} 
}

/*
I have a string property with value Tara
I have a string property with value San Francisco
*/
</pre></div> 

以下示例显示使用 for each..in 遍历 XMLList 对象中的属性 (doc.p)：

<div class="listing"><pre>
var doc:XML = 
		<body>
			<p>Hello</p>
			<p>Hola</p>
			<hr />
			<p>Bonjour</p>
		</body>;
for each (var item in doc.p) {
	trace(item);
}

/*
Hello
Hola
Bonjour
*/
</pre></div>
			<p></p></div><a name="function"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">function</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} 
var functionName:Function = function ([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>包含为执行特定任务而定义的一组语句。可以在 SWF 文件的一个地方定义函数，然后从 SWF 文件的其他脚本中<em>调用</em>它。定义函数时，还可以为其指定参数。参数是函数要对其进行操作的值的占位符。可以在每次调用一个函数时传递不同的参数，这样就可将一个函数重复用于不同的情况。 
			<p>在一个函数的 <code>statement(s)</code> 块中使用 <code>return</code> 语句，以生成函数或<em>返回</em>一个值。</p> 
			<p>用法 1：可以使用 <code>function</code> 关键字来定义具有指定的函数名称、参数和语句的函数。当脚本调用函数时，就会执行函数定义中的语句。允许提前引用；在同一脚本中，函数可以先调用后声明。一个函数定义会替换同一函数先前的任何定义。只要是允许使用语句的地方就可使用此语法。 </p> 
			<p>用法 2：也可以使用 <code>function</code> 来创建匿名函数，并返回对它的引用。此语法用于表达式中，对于在对象中安装方法尤其有用。</p> 
			<p>若需要其他功能，可以在函数定义中使用 <code>arguments</code> 对象。通常使用 <code>arguments</code> 对象来创建一个接受可变数量的参数的函数和递归的匿名函数。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; 新函数的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 返回值的数据类型。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例定义了函数 sqr，此函数将返回数字的平方值： 
<div class="listing"><pre>function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
} 
var yNum:Number = sqr(3); 
trace(yNum); // 9</pre></div> 
如果在同一脚本中定义和使用函数，使用该函数后可出现函数定义： 
<div class="listing"><pre>var yNum:Number = sqr(3); 
trace(yNum); // 9 
function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
}</pre></div> 

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="arguments.html" target="">arguments 对象</a><br/><a href="statements.html#return" target="">return</a></div></div><a name="get"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">get</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function get property() : returnType{ 
	// your statements here 
}</pre> </p></td></tr></table><p></p><p><p>定义一个 getter，它是一种可像属性一样读取的方法。getter 是一个特殊的函数，它将返回使用 <code>var</code> 或 <code>const</code> 关键字声明的属性的值。与其他的方法不同，调用 getter 时不使用括号 (<code>()</code>)，这样 getter 看起来就像是变量。
			<p>通过允许创建 private 属性的 public 接口，getter 允许您应用信息隐藏规则。信息隐藏的好处是：即使 private 属性的基础实现发生更改，public 接口也会保持不变。</p>
			<p>getter 的另一个优点是它们可在子类中覆盖，而使用 <code>var</code> 或 <code>const</code> 声明的属性则不能。</p>
			<p>可结合使用 getter 和 setter 创建读写属性。要创建只读属性，请创建一个没有对应 setter 的 getter。要创建只写属性，请创建一个没有对应 getter 的 setter。</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; get 访问的属性的标识符；此值必须与对应的设置命令中使用的值相同。</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 返回值的数据类型。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例定义 Team 类。Team 类包括用于在该类内检索和设置属性的 getter 和 setter 方法： 
<div class="listing"><pre>
package {
	public class Team { 
		var teamName:String; 
		var teamCode:String; 
		var teamPlayers:Array = new Array(); 
		public function Team(param_name:String, param_code:String) { 
			teamName = param_name; 
			teamCode = param_code; 
		} 
		public function get name():String { 
			return teamName; 
		} 
		public function set name(param_name:String):void { 
			teamName = param_name; 
		}
	} 
}</pre></div>
在脚本中输入下面的代码： 
<div class="listing"><pre>
var giants:Team = new Team("San Fran", "SFO"); 
trace(giants.name); 
giants.name = "San Francisco"; 
trace(giants.name); 
/*
San Fran San Francisco */</pre></div> 
在跟踪 giants.name 时，使用 getter 方法以返回属性的值。
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#set" target="">set</a></div></div><a name="if"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">if</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>计算条件以确定下一条要执行的语句。如果条件为 <code>true</code>，则 Flash Player 将运行大括号 (<code>{}</code>) 内条件后面的语句。如果条件为 <code>false</code>，则 Flash Player 将跳过花括号内的语句，并运行花括号后面的语句。将 <code>if</code> 语句与 <code>else</code> 语句一起使用，以在脚本中创建分支逻辑。 
			<p>如果仅执行一条语句，则不必用大括号 (<code>{}</code>) 将 <code>if</code> 语句所执行的语句括起来。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 计算结果为 true 或 false 的表达式。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#else" target="">else</a></div></div><a name="implements"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">implements</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>myClass implements interface01 [, interface02 , ...] </pre> </p></td></tr></table><p></p><p><p>指定一个类可实现一个或多个接口。当类实现一个接口时，此类必须定义在该接口中声明的所有方法。将所有实现接口的类的实例视为由接口定义的数据类型的成员。因此，第一个操作数是类实例且第二个操作数是接口时，<code>is</code> 运算符将返回 <code>true</code>；此外，接口操作将定义来自和施于数据类型的类型强制。
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#interface" target="">接口</a></div></div><a name="import"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">import</td><td class="detailHeaderType">指令</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>import packageName.className 
import packageName.*</pre> </p></td></tr></table><p></p><p><p>使外部定义的类和包可用于您的代码。例如，如果希望在脚本中使用 flash.display.Sprite 类，则必须导入它。此要求与 ActionScript 的先前版本不同，在这些版本中 <code>import</code> 指令是可选的。
			<p>使用 <code>import</code> 指令后，可以使用完整的类名称，此名称包含包名称，或只是类的名称。</p>
<div class="listing"><pre> 
import flash.display.Sprite; 

// name of class only
var mySprite:Sprite = new Sprite();

// full class name
var mySprite:flash.display.Sprite = new flash.display.Sprite();
</pre></div> 
<p>如果要访问的包中有多个类，可以用一条语句将它们全部导入，如下例所示：</p>
<div class="listing"><pre>import flash.display.*;</pre></div>
<p><code>import</code> 指令仅导入类、函数和位于导入包顶级的变量。必须显式导入嵌套包。</p>
<p>如果导入一个类，但没有在脚本中使用该类，则该类不作为 SWF 文件的一部分导出。这意味着您导入大型包时可以不必担心 SWF 文件的大小；只有在实际使用某一类的情况下，才会在 SWF 文件中包括与该类关联的字节码。导入类的一个缺点是将增加名称冲突的可能性。</p> 
 
<pre>
// On Frame 1 of a FLA: 
import adobe.example.*; 
var myFoo:foo = new foo();</pre> 
 

			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 在单独类文件中定义的包的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 在单独类文件中定义的类的名称。</td></tr></table></div><a name="include"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">include</td><td class="detailHeaderType">指令</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>include "[path]filename.as"</pre></p></td></tr></table><p></p><p><p>包括指定文件的内容，就像该文件中的命令是调用脚本的一部分一样。<code>include</code> 指令在编译时调用。因此，如果对包含的文件进行了任何更改，则必须保存该文件，并重新编译使用它的任何 SWF 文件。
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="interface"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">interface</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre> interface InterfaceName [extends InterfaceName ] {}</pre> </p></td></tr></table><p></p><p><p>定义接口。接口是定义一个方法组的数据类型，其中的方法必须由实现接口的任何类定义。
			<p> 接口与类相似，但也有以下重要差异：</p> 
			<ul> 
			  <li>接口仅包含方法的声明，而不包含其实现。也就是说，实现接口的每个类必须为该接口中声明的每个方法提供实现。</li> 
			  <li>接口方法定义无法具有任何属性，例如 <code>public</code> 或 <code>private</code>，但是在实现接口的类的定义中，实现方法必须标记为 <code>public</code>。</li> 
			  <li>多个接口可以通过 <code>extends</code> 语句由接口继承，或通过 <code>implements</code> 语句由类继承。</li> 
			</ul>
			<p>与 ActionScript 2.0 不同的是，ActionScript 3.0 允许在接口定义中使用 getter 和 setter 方法。</p>
			
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#implements" target="">implements</a></div></div><a name="internal"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">internal</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
[internal] var varName
[internal] const kName
[internal] function functionName()  { 
	// your statements here 
}
[internal] class className{
	// your statements here 
}
[internal] namespace nsName
</pre> </p></td></tr></table><p></p><p><p>指定类、变量、常量或函数可用于同一包中的任何调用者。默认情况下，类、属性和方法属于 <code>internal</code> 命名空间。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 要指定为 internal 的类的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 internal 的变量的名称。无论该变量是否是类的一部分，都可以应用 internal 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 internal 的常量的名称。无论该常量是否是类的一部分，都可以应用 internal 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; 要指定为 internal 的函数或方法的名称。无论该函数是否是类的一部分，都可以应用 internal 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 要指定为 internal 的命名空间的名称。无论该命名空间是否是类的一部分，都可以应用 internal 属性。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#package" target="">包</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="label"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">label</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>label: statement
label: {
    statements
}</pre></p></td></tr></table><p></p><p><p>将语句与可由 <code>break</code> 或 <code>continue</code> 引用的标识符相关联。在嵌套循环中，未引用标签的 <code>break</code> 或 <code>continue</code> 语句仅会跳过下一循环的其余部分，而不是跳过整个系列的循环。但是，如果定义整个系列循环的语句具有相关联的标签，则 <code>break</code> 或 <code>continue</code> 语句通过引用该标签可以跳过整个系列的循环。
			<p>标签还允许您跳出块语句。除非块语句是循环的一部分，否则无法放置未在该块语句内引用标签的 <code>break</code> 语句。如果块语句有相关联的标签，则可以放置在该块语句内部引用该标签的 <code>break</code> 语句。</p>		
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要与语句相关联的有效标识符。</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要与标签相关联的语句。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例说明如何使用嵌套循环的标签来跳出整个系列的循环。代码使用嵌套循环以生成从 0 到 99 的数字列表。在数字即将达到 80 前产生 break 语句。如果 break 语句未使用 outerLoop 标签，则代码将仅跳过下一循环的其余部分，并且代码将继续输出从 90 到 99 的数字。然而，因为使用了 outerLoop 标签，break 语句将跳过整个系列循环的其余部分，最后输出的数字是 79。
<div class="listing"><pre>
outerLoop: for (var i:int = 0; i < 10; i++) {
	for (var j:int = 0; j < 10; j++) {
		if ( (i == 8) && (j == 0)) {
			break outerLoop;
		}
		trace(10 * i + j);
	}
}
/*
1
2
...
79
*/
</pre></div>
下例说明如何使用块语句的标签。在以下示例中，块语句标记为 foo，它允许 break 语句跳过块中的 final 语句：
<div class="listing"><pre>
foo: {
	trace("a");
	break foo;
	trace("b");
}
// a
</pre></div>

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a></div></div><a name="namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">namespace</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>namespace name [= uri]</pre> </p></td></tr></table><p></p><p><p>允许您控制定义的可见性。预定义的命名空间包括 <code>public</code>、<code>private</code>、<code>protected</code> 和 <code>internal</code>。 
			<p>下列步骤说明如何创建、应用和引用命名空间：</p>
			<ul>
			  <li>首先，使用 <code>namespace</code> 关键字来定义自定义命名空间。例如，代码 <code>namespace version1</code> 将创建名为 <code>version1</code> 的命名空间。</li>
			  <li>其次，在属性或方法的声明中使用自定义命名空间将此命名空间应用于属性或方法。例如，代码 <code>version1 myProperty:String</code> 将创建名为 <code>myProperty</code> 的属性，该属性属于 <code>version1</code> 命名空间</li>
			  <li>最后，通过使用 <code>use</code> 关键字或使用命名空间作为标识符的前缀来引用该命名空间。例如，代码 <code>use namespace version1;</code> 引用后续代码行的 <code>version1</code> 命名空间，而代码 <code>version1::myProperty</code> 引用 <code>myProperty</code> 属性的 <code>version1</code> 命名空间。</li>
			</ul>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 命名空间的名称，可以是任意合法的标识符。</td></tr><tr><td width="20px"></td><td><code><span class="label">uri</span>:<a href="String.html">String</a></code> &mdash; 命名空间的统一资源标识符 (URI)。这是一个可选参数。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#package" target="">包</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="native"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">native</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
native function functionName();
class className { 
	native function methodName();
}</pre> </p></td></tr></table><p></p><p><p>指定函数或方法由 Flash Player 以本机代码的形式实现。Flash Player 内部使用 <code>native</code> 关键字来声明 ActionScript 应用程序接口 (API) 中的函数和方法。在您自己的代码中无法使用此关键字。			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="null"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">null</td><td class="detailHeaderType">主要表达式关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>null</pre></p></td></tr></table><p></p><p><p>一个可以分配给变量的或由未提供数据的函数返回的特殊值。您可以使用 <code>null</code> 表示缺少的或不具有已定义数据类型的值。
				<p> 不要将值 <code>null</code> 与特殊值 <code>undefined</code> 相混淆。使用等于运算符 (<code>==</code>) 对 <code>null</code> 和 <code>undefined</code> 进行比较时，它们的比较结果为相等。但是，使用 strict equality (<code>===</code>) 运算符对 <code>null</code> 和 <code>undefined</code> 进行比较时，它们的比较结果为不相等。</p> 
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例检查索引数组的前六个值，如果没有设置值（如果 value == null），则输出一条消息：
<div class="listing"><pre>

var testArray:Array = new Array();
testArray[0] = "fee";
testArray[1] = "fi";
testArray[4] = "foo";

for (i = 0; i < 6; i++) {
    if (testArray[i] == null) {
        trace("testArray[" + i + "] == null");
    }
}

/* 
testArray[2] == null
testArray[3] == null
testArray[5] == null
*/
</pre></div>	

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="package.html#undefined" target="">undefined</a></div></div><a name="object_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">object_proxy</td><td class="detailHeaderType"> 命名空间 </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>定义 ObjectProxy 类的方法。ObjectProxy 类的方法位于自己的命名空间内，从而避免了 Proxy 子类中实例方法的名称与 Proxy 类的方法名称相匹配时，发生名称冲突。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="override"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">override</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
override function name() { 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>指定用一种方法替换继承的方法。若要覆盖继承的方法，则必须使用 <code>override</code> 属性，并确保名称、类属性、数字和参数类型和返回类型完全匹配。在未使用 <code>override</code> 属性的情况下尝试覆盖方法是错误的。同样的，如果方法没有匹配的继承方法，则使用 <code>override</code> 属性也是错误的。
			<p>无法对下列任一项使用 <code>override</code> 属性：</p>
			<ul>
			  <li>变量</li>
			  <li>常量</li>
			  <li>静态方法</li>
			  <li>未继承的方法</li>
			  <li>实施接口方法的方法</li>
			  <li>超类中标记为 <code>final</code> 的继承方法</li>
			</ul>
			<p>尽管不能覆盖使用 <code>var</code> 或 <code>const</code> 声明的属性，但是通过使基类属性为 getter-setter，并覆盖使用 <code>get</code> 和 <code>set</code> 定义的方法，可以实现类似的功能。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Function.html">Function</a></code> &mdash; 要覆盖的方法的名称。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#final" target="">final</a><br/><a href="statements.html#get" target="">get</a><br/><a href="statements.html#set" target="">set</a></div></div><a name="package"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">package</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
package packageName {
    class someClassName { 
    } 
}</pre> </p></td></tr></table><p></p><p><p>允许您将代码组织为可由其他脚本导入的离散组。您必须使用 <code>package</code> 关键字以指示类是包的成员。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 包的名称。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a><br/><a href="statements.html#class" target="">类</a></div></div><a name="private"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">private</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	private var varName;
	private const kName;
	private function methodName() { 
		// your statements here 
	}
	private namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>指定变量、常量或方法仅可供声明或定义它的类使用。与在 ActionScript 2.0 中的情况不同，在 ActionScript 3.0 中，<code>private</code> 不再提供对子类的访问。此外，<code>private</code> 限制编译时和运行时的访问。默认情况下，变量和函数对同一包中的任何调用者均可用。使用此关键字可以限制对变量或函数的访问。 
			<p>您只能在类定义中使用此关键字，不能在接口定义中使用。无法将 <code>private</code> 应用于类或任何其他包级定义。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 private 的变量的名称。仅当该变量位于类内部时，才可以应用 private 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 private 的常量的名称。仅当该常量位于类内部时，才可以应用 private 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; 要指定为 private 的方法的名称。仅当该方法位于类内部时，才可以应用 private 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 要指定为 private 的命名空间的名称。仅当该命名空间位于类内部时，才可以应用 private 属性。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下面的示例说明了如何使用 private 关键字隐藏类中的某些属性。 
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  public var beta:String = "visible everywhere"; 
}
	
class B extends A {
  function B() {
    alpha = "Access attempt from subclass"; // error
  }
}
</pre></div> 
因为 alpha 是 private 变量，从 A 类的外部无法访问它，即使从子类 B 中也无法访问。尝试访问 private 变量将生成错误。
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="protected"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">protected</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	protected var varName;
	protected const kName;
	protected function methodName() { 
		// your statements here 
	}
	protected namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>指定变量、常量、方法或命名空间只可用于定义它的类及该类的任何子类。ActionScript 3.0 中的 <code>protected</code> 的定义与 ActionScript 2.0 版本中的 <code>private</code> 的定义类似，只不过 <code>protected</code> 同时限制了编译时和运行时的访问。默认情况下，变量或函数可用于同一包中的任何调用者。使用此关键字可以限制对变量或函数的访问。  
				<p>您只能在类定义中使用此关键字，不能在接口定义中使用。无法将 <code>private</code> 应用于类或任何其他包级定义。</p>
				<p>ActionScript 3.0 中的 <code>protected</code> 的定义比 Java 编程语言中的 <code>protected</code> 的定义更具限制性。ActionScript 3.0 中的 <code>protected</code> 严格限制对子类的访问，而 Java 中的 <code>protected</code> 允许对同一包中的任何类进行访问。例如，如果名为 <code>Base</code> 的类包含被标为 <code>protected</code> 的属性，则在 ActionScript 3.0 中，只有扩展 Base 的类才能访问该受保护属性。在 Java 中，Base 所在的同一个包中的所有类都可以访问受保护的属性，即使该类不是 Base 的子类。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 protected 的变量的名称。仅当该变量位于类内部时，才可以应用 protected 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 protected 的常量的名称。仅当该常量位于类内部时，才可以应用 protected 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; 要指定为 protected 的方法的名称。仅当该方法位于类内部时，才可以应用 protected 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 要指定为 protected 的命名空间的名称。仅当该命名空间位于类内部时，才可以应用 protected 属性。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例在类 A 中创建一个 protected 类变量，并在类 B 中成功访问该变量，这是因为类 B 是类 A 的子类。
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  protected var beta:String = "visible inside class A and its subclasses"; 
}
	
class B extends A {
  public function B() {
    beta = "Access attempt from subclass succeeded";
    trace(beta);  // Access attempt from subclass succeeded
  }
}
</pre></div>
			
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="public"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">public</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
public var varName
public const kName
public function functionName()  { 
	// your statements here 
}
public class className {
	// your statements here 
}
public namespace nsName
</pre> </p></td></tr></table><p></p><p><p>指定类、变量、常量或方法可用于任何调用者。默认情况下，类、变量和方法为 internal，这意味着它们仅在当前包中可见。若要使类、变量或方法对所有调用者可见，则必须使用 <code>public</code> 属性。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; 要指定为 public 的类的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 public 的变量的名称。无论该变量是否是类的一部分，都可以应用 public 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为 public 的常量的名称。无论该常量是否是类的一部分，都可以应用 public 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; 要指定为 public 的函数的名称。无论该函数是否是类的一部分，都可以应用 public 属性。</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 要指定为 public 的命名空间的名称。无论该命名空间是否是类的一部分，都可以应用 public 属性。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例说明如何在类文件中使用 public 变量： 
<div class="listing"><pre>class User { 
	public var age:Number; 
	public var fname:String; 
} // end of class User definition
 
var jimmy:User = new User(); 
jimmy.age = 27; 
jimmy.fname = "jimmy";
trace(jimmy.age, jimmy.fname); // 27 jimmy</pre></div> 
如果将 User 类中的 public 变量之一更改为 private 变量，则尝试在 User 类之外访问该变量就会产生编译时错误。 

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a></div></div><a name="return"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">return</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function functionName () {
	return [expression]
}</pre></p></td></tr></table><p></p><p><p>导致立即返回执行调用函数。如果 <code>return</code> 语句后跟表达式，则计算此表达式并返回结果。 
			<p>如果函数定义包含返回类型，则 <code>return</code> 语句必须后跟表达式。如果未指定返回类型且单独使用 <code>return</code> 语句，则返回 <code>undefined</code>。</p>
			<p>无法返回多个值。如果尝试返回多个值，则将只返回最后一个值。在下面的示例中，返回 <code>c</code>：</p> <pre>return a, b, c ;</pre> <p>如果需要返回多个值，则应改用数组或对象。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要计算并返回为函数的值的表达式。此参数是可选的。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例使用 sum() 函数体内的 return 语句返回三个参数相加后的值。下一行代码调用 sum() 并将返回的值赋予变量 newValue。 
<div class="listing"><pre>function sum(a:Number, b:Number, c:Number):Number { 
	return (a + b + c); 
} 
var newValue:Number = sum(4, 32, 78); 
trace(newValue); // 114</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#function" target="">函数</a></div></div><a name="set"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">set</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function set property(newValue:*) : void{ 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>定义一个 setter，它是一种在 public 接口中作为属性出现的方法。setter 是一种特殊方法，它设置使用 <code>var</code> 关键字声明的属性的值。与其他的方法不同，调用 setter 时不使用括号 (<code>()</code>)，这样 setter 看起来就像是变量。
			<p>通过允许创建 private 属性的 public 接口，Setter 允许您应用信息隐藏规则。信息隐藏的好处是：即使 private 属性的基础实现发生更改，public 接口也会保持不变。</p>
			<p>setter 的另一个优点是它们可在子类中覆盖，而使用 <code>var</code> 声明的属性则不能。</p>
			<p>setter 的返回类型必须为 <code>void</code> 或未指定。</p>
			<p>可以将 setter 与 getter 相接合来创建读写属性。要创建只读属性，请创建一个没有对应 setter 的 getter。要创建只写属性，请创建一个没有对应 getter 的 setter。</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; set 修改的属性的标识符；此值必须与对应的 get 命令中使用的值相同。</td></tr><tr><td width="20px"></td><td><code><span class="label">newValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要分配的新值。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例通过定义 getter-setter 创建了名为 age 的读写属性。
<div class="listing"><pre>
package {
	class User { 
	    private var userAge:Number; 
	    
	    public function get age():Number {
	    	return userAge;
	    }
	    
	    public function set age(x:Number):void {
	    	userAge = x;	
	    }
	} 
} 
</pre></div>
在脚本中输入下面的代码：
<div class="listing"><pre>
var myUser:User = new User();
myUser.age = 25;
trace(myUser.age); // 25
</pre></div>
			
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#get" target="">get</a></div></div><a name="static"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">static</td><td class="detailHeaderType">属性关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>class someClassName{ 
	static var varName; 
	static const kName;
	static function methodName() { 
		// your statements here
	} 
}</pre> </p></td></tr></table><p></p><p><p>指定变量、常量或方法属于类，而不属于类的实例。
			<p>若要访问静态类成员，请使用类的名称而不是实例的名称。例如，Date 类具有名为 <code>parse()</code> 的静态方法，该方法仅能使用以下语法调用：</p>
			<div class="listing"><pre>Date.parse()</pre></div>
			<p>对 Date 类的实例无法调用 <code>parse()</code> 方法。例如，以下代码将生成错误：</p>
			<div class="listing"><pre>var myDate:Date = new Date();
            myDate.parse("Jan 01 00:00:00 2006"); // error</pre></div>
			<p>您只能在类定义中使用 <code>static</code>，而不能在接口定义中使用。</p>
			<p>未继承静态类成员。不能像在 Java 或 C++ 中那样，使用子类的名称引用静态类成员。然而，无需使用任何限定词，就可以在类或子类中引用静态变量或方法。请参见下例。</p>
			<p>不能在静态方法的内部使用 <code>super</code> 语句或 <code>this</code> 关键字。</p>
			
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为静态的变量的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 要指定为静态的常量的名称。</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; 要指定为静态的方法的名称。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下面的示例说明如何使用 static 关键字创建一个计数器，该计数器跟踪已创建类的实例的数量。由于 numInstances 变量是静态的，因此它只对整个类创建一次，而不是对每个单独实例都创建一次。创建一个名为 Users.as 的新 ActionScript 文件，然后输入以下代码： 
<div class="listing"><pre>class Users { 
	private static var numInstances:Number = 0; 
	function Users() { 
		numInstances++; 
	} 
	static function get instances():Number { 
		return numInstances; 
	} 
}</pre></div> 
在脚本中输入下面的代码：
<div class="listing"><pre>
trace(Users.instances); 
var user1:Users = new Users(); 
trace(Users.instances); 
var user2:Users = new Users(); 
trace(Users.instances); 
</pre></div>
下例扩展了 Users 类，以说明尽管未继承静态变量和方法，但是可以在子类中引用它们。
<div class="listing"><pre>
class PowerUsers extends Users{
    function PowerUsers() {
        instances++;  // unqualified reference to static property Users.instances is legal
    }
}

trace(PowerUsers.instances); // error, cannot access static property using PowerUsers class
</pre></div>

			<p></p></div><a name="super"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">super</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>super([arg1, ..., argN])
super.method([arg1, ..., argN])</pre></p></td></tr></table><p></p><p><p>调用方法或构造函数的超类或父版本。在类构造函数体内使用 <code>super()</code> 语句时，该语句将调用构造函数的超类版本。对超类构造函数的调用必须有正确的参数数目。请注意，不管是否显式调用超类函数，都会调用到超类构造函数。如果不是显式调用它，则将在子类构造函数体中的第一个语句前自动插入不带参数的调用。这意味着，如果在子类中定义了构造函数，并且超类构造函数具有一个或多个参数，则必须显式调用具有正确参数数目的超类构造函数，否则将产生错误。然而，根据 ActionScript 2.0 的要求，对超类构造函数的调用无需是子类构造函数中的第一个语句。
			<p>在实例方法体中使用时，<code>super</code> 可以与 dot (.) 运算符共同使用以调用方法的超类版本，并可以选择将参数 <code>(arg1 ... argN)</code> 传递给超类方法。这对于创建某些子类方法很有用，这些子类方法在向超类方法添加附加行为的同时，又调用这些超类方法执行其原始行为。</p>
			<p>在静态方法中不能使用 <code>super</code> 语句。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">method</span>:<a href="Function.html">Function</a></code> &mdash; 要在超类中调用的方法。</td></tr><tr><td width="20px"></td><td><code><span class="label">argN</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 可选参数，这些参数传递给方法的超类版本，或者传递给超类的构造函数。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#class" target="">类</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="switch"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">switch</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>
switch (expression) {
	caseClause: 
	[defaultClause:] 
}</pre></p></td></tr></table><p></p><p><p>根据表达式的值，使控制转移到多条语句的其中一条。如果没有任何 <code>case</code> 语句与表达式相匹配，则所有 <code>switch</code> 语句应该包含将执行的默认 case。每个 <code>case</code> 语句应该以 <code>break</code> 语句结尾，以避免发生落空错误。当一个 case 落空时，即使下一个 <code>case</code> 语句可能与测试表达式不匹配，它仍将执行此 case 中的代码。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 任何表达式。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下例定义了落空至默认 case 的 switch 语句：

<div class="listing"><pre>

var switchExpression:int = 3;
		
switch (switchExpression) {
	case 0:
		trace(0);
		break;
	case 1:
		trace(1);
		break;
	case 2:
		trace(2);
		break;
	default:
		trace("Not 0, 1, or 2");
}

// Not 0, 1, or 2
</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="operators.html#strict_equality" target="">=== (strict equality)</a><br/><a href="statements.html#case" target="">case</a><br/><a href="statements.html#default" target="">default</a></div></div><a name="this"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">this</td><td class="detailHeaderType">主要表达式关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>this</pre></p></td></tr></table><p></p><p><p>对方法的包含对象的引用。执行脚本时，<code>this</code> 关键字引用包含该脚本的对象。在方法体的内部，<code>this</code> 关键字引用包含调用方法的类实例。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>若要调用在动态类中定义的函数，则必须使用 this 调用适当作用域内的函数：
<div class="listing"><pre>
// incorrect version of Simple.as
/*
dynamic class Simple {
    function callfunc() {
        func();
    }
}
*/
// correct version of Simple.as
dynamic class Simple {
    function callfunc() {
        this.func();
    }
}
</pre></div>
将下面的代码添加到您的脚本中：
<div class="listing"><pre>
var simpleObj:Simple = new Simple();
simpleObj.func = function() {
	trace("hello there");
}
simpleObj.callfunc();
</pre></div>
当您在 callfunc() 方法中使用 this 时，以上代码生效。不过，如果您使用了不正确的 Simple.as 版本，将出现语法错误（在上例中已被注释掉）。

			
			<p></p></div><a name="throw"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">throw</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>throw expression </pre></p></td></tr></table><p></p><p><p>生成或<em>引发</em>一个可由 <code>catch</code> 代码块处理或<em>捕获</em>的错误。如果 <code>catch</code> 块未捕获异常，则将引发值的字符串表示形式发送到“输出”面板。如果 <code>catch</code> 或 <code>finally</code> 块未捕获异常，则将引发值的字符串表示形式发送到日志文件。 <p>通常，引发的错误是 Error 类或其子类的实例（请参阅“示例”部分）。</p></p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 一个 ActionScript 表达式或对象。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在此示例中，一个名为 checkEmail() 的函数检查传递给它的字符串是否为格式正确的电子邮件地址。如果该字符串不包含 @ 符号，则该函数将抛出一个错误。 
<div class="listing"><pre>function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new Error("Invalid email address"); 
	} 
} 
checkEmail("someuser_theirdomain.com");</pre></div> 
然后，以下代码调用 try 代码块内的同一函数 checkEmail()。如果电子邮件字符串不包含有效的电子邮件地址，则 trace 语句将输出错误消息。
<div class="listing"><pre>
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e); 
}
// Error: Invalid email address.</pre></div> 
在下面的示例中，将抛出 Error 类的一个子类。对 checkEmail() 函数进行了修改，使其抛出该子类的一个实例。
<div class="listing"><pre>
// Define Error subclass InvalidEmailError 
class InvalidEmailAddress extends Error { 
    public function InvalidEmailAddress() {
    	message = "Invalid email address."; 
    }
}
</pre></div> 
在脚本中输入下面的代码：
<div class="listing"><pre>
import InvalidEmailAddress; 
function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new InvalidEmailAddress(); 
	} 
} 
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e);
}
// Error: Invalid email address.</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="Error.html" target="">Error 类</a><br/><a href="statements.html#try..catch..finally" target="">try..catch..finally</a></div></div><a name="true"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">true</td><td class="detailHeaderType">主要表达式关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>true</pre></p></td></tr></table><p></p><p><p>表示 true 的布尔值。布尔值为 <code>true</code> 或 <code>false</code>；<code>true</code> 与 <code>false</code> 相反。如果自动设置数据类型时将 <code>true</code> 转换为数字，则它变为 1；如果将 <code>true</code> 转换为字符串，则它变为 <code>"true"</code>。
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例说明 true 在 if 语句中的使用情况：
<div class="listing"><pre>

var shouldExecute:Boolean;
// ...
// code that sets shouldExecute to either true or false goes here
// shouldExecute is set to true for this example:

shouldExecute = true;

if (shouldExecute == true) {
    trace("your statements here");
}

// true is also implied, so the if statement could also be written:
// if (shouldExecute) {
//         trace("your statements here");
// }</pre></div>
以下示例说明自动设置数据类型如何将 true 转换为数字 1：
<div class="listing"><pre>

var myNum:Number;
myNum = 1 + true;
trace(myNum); // 2</pre></div>

			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="Boolean.html" target="">Boolean 类</a><br/><a href="statements.html#false" target="">false</a></div></div><a name="try..catch..finally"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">try..catch..finally</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>try { 
    // try block 
} finally { 
    // finally block  
} 

try { 
    // try block 
} catch(error[:ErrorType1]) {
    // catch block 
} [catch(error[:ErrorTypeN]) { 
    // catch block 
}] [finally {
    // finally block 
}]</pre></p></td></tr></table><p></p><p><p>包含一个代码块，在其中可能会发生错误，然后对该错误进行响应。异常处理是使用 <code>try..catch..finally</code> 语句实现的，是 ActionScript 3.0 中处理运行时错误条件的主要机制。产生运行时错误时，Flash Player 将引发异常，这意味着 Flash Player 暂停正常的执行，创建一个 <code>Error</code> 类型的特殊对象。然后 Flash Player 将错误对象传递或<em>抛给</em> 第一个可用的 <code>catch</code> 块。如果没有可用的 <code>catch</code> 块，会将此异常视为未捕获的异常。未捕获的异常将导致脚本终止。
			<p>可以使用 <code>throw</code> 语句以显式引发代码中的异常。可以引发任意值，但是最佳做法是引发一个对象，因为这样比较灵活，并能与 Flash Player 的行为相匹配。</p>
			<p>若要捕获一个异常，无论它是由 Flash Player 还是您自己的代码引发的，都要将可能引发异常的代码放置在 <code>try</code> 块中。如果 <code>try</code> 块中的任何代码引发异常，控制会传递到 <code>catch</code> 块（如果有），然后传递到 <code>finally</code> 块（如果有）。无论是否引发了异常，始终会执行 <code>finally</code> 块。如果 <code>try</code> 块中的代码未引发异常（即如果 <code>try</code> 块正常完成），则会忽略 <code>catch</code> 块中的代码，但是仍将执行 <code>finally</code> 块中的代码。即使 <code>try</code> 代码块使用 <code>return</code> 语句退出，仍会执行 <code>finally</code> 代码块。 </p>
			<p><code>try</code> 代码块后面必须跟有 <code>catch</code> 代码块、<code>finally</code> 代码块，或两者都有。单个 <code>try</code> 代码块可以有多个 <code>catch</code> 代码块，但只能有一个 <code>finally</code> 代码块。您可以根据需要嵌套任意层数的 <code>try</code> 代码块。</p> 
			<p><code>catch</code> 处理函数中指定的 <code>error</code> 参数必须是一个简单的标识符，如 <code>e</code>、<code>theException</code> 或 <code>x</code>。还可以为参数指定类型。当与多个 <code>catch</code> 块一起使用时，如果指定了参数类型，则可以捕获从一个 <code>try</code> 块引发的多种类型的错误。</p> 
			<p>如果抛出的异常是对象，则当抛出的对象是指定类型的子类时，类型将匹配。如果抛出的错误属于特定类型，将执行处理相应错误的 <code>catch</code> 代码块。如果抛出的异常不属于指定类型，则不执行 <code>catch</code> 代码块，而自动将该异常从 <code>try</code> 代码块抛出到与其匹配的 <code>catch</code> 处理函数。 </p> 
			<p>如果在某个函数内引发了错误，而该函数不包含 <code>catch</code> 处理函数，则 Flash Player 将退出该函数以及任何调用函数，直到找到一个 <code>catch</code> 块。在此过程中，在各层上都会调用 <code>finally</code> 处理函数。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">error</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 从 throw 语句引发的表达式，通常是 Error 类或其子类之一的实例。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例演示了 try..catch 语句。在 try 块内的代码包含非法操作。sprite 无法将自己添加为子项。因此，Flash Player 将引发异常，并将类型 ArgumentError 的对象传递到相应的 catch 块。
<div class="listing"><pre>
import flash.display.Sprite;

var spr:Sprite = new Sprite();
try {
	spr.addChild(spr);
}
catch (e:ArgumentError) {
	trace (e); // ArgumentError: Error #2024: An object may not be added as a child of itself.
}
</pre></div> 
在下面的示例中，RecordSetException 和 MalformedRecord 对象是 Error 类的子类。  
<div class="listing"><pre>
class RecordSetException extends Error { 
	public function RecordSetException () {
		message = "Record set exception occurred."; 
	}
}

class MalformedRecord extends Error { 
	public function MalformedRecord {
		message = "Malformed record exception occurred."; 
	}
}</pre></div> 

在 RecordSet 类的 sortRows() 方法内，将根据所发生异常的类型抛出其中一个以前定义的错误对象。下面的示例说明此代码的外观： 
<div class="listing"><pre>
class RecordSet { 
	public function sortRows() { 
		var returnVal:Number = randomNum(); 
		if (returnVal == 1) { 
			throw new RecordSetException(); 
		} 
		else if (returnVal == 2) { 
			throw new MalformedRecord(); 
		} 
	}
	public function randomNum():Number { 
		return Math.round(Math.random() * 10) % 3; 
	}
}</pre></div> 
最后，下面的代码调用 RecordSet 类的实例上的 sortRows() 方法。它为 sortRows() 引发的各种类型的错误定义 catch 块。
<div class="listing"><pre>import RecordSet; 
var myRecordSet:RecordSet = new RecordSet();
try { 
	myRecordSet.sortRows(); 
	trace("everything is fine"); 
} 
catch (e:RecordSetException) { 
	trace(e.toString()); 
} 
catch (e:MalformedRecord) { 
	trace(e.toString()); 
}</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="Error.html" target="">Error 类</a><br/><a href="statements.html#throw" target="">throw</a></div></div><a name="use_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">use namespace</td><td class="detailHeaderType">指令</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>use namespace ns1[, ns2, ...nsN]</pre></p></td></tr></table><p></p><p><p>使指定的命名空间添加到打开的命名空间集中。退出当前代码块时，将从打开的命名空间集中删除指定的命名空间。<code>use namespace</code> 指令可以出现在程序、包定义或类定义的顶层。</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">nsN</span>:<a href="Namespace.html">Namespace</a></code> &mdash; 将一个或多个命名空间添加到打开的命名空间集中。</td></tr></table><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#default_xml_namespace" target="">default xml namespace</a><br/><a href="statements.html#namespace" target="">namespace</a><br/><a href="XML.html" target="">XML 类</a></div></div><a name="var"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">var</td><td class="detailHeaderType">定义关键字</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>var variableName [= value1][...,variableNameN[=valueN]] </pre></p></td></tr></table><p></p><p><p>指定一个变量。如果变量是在函数内声明的，则这些变量是局部变量。它们是为该函数声明的，在函数调用结束时到期。 
			 
			<p>无法将其他对象作用域内的变量声明为局部变量。</p> 
<pre>my_array.length = 25; // ok 
var my_array.length = 25; // syntax error </pre> 
			<p>为变量分配数据类型的方法是在变量后加冒号字符，后跟数据类型。</p>
			<p>您可以在一条语句中声明多个变量，用逗号分隔各个声明（尽管此语法可能会降低代码的清晰程度）：</p>
			<pre>var first:String = "Bart", middle:String = "J.", last:String = "Bartleby";</pre>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 一个标识符。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>下面的 ActionScript 创建一个新的产品名称数组。Array.push 将一个元素添加到该数组的末尾。 
<div class="listing"><pre>
var product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); 
trace(product_array); 
// Studio,Dreamweaver,Flash,ColdFusion,Contribute,Breeze,Flex</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#const" target="">const</a></div></div><a name="while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">while</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>while (condition) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>计算一个条件，如果该条件的计算结果为 <code>true</code>，则会执行一条或多条语句，之后循环会返回并再次计算条件。若该条件的计算结果为 <code>false</code>，则会跳过语句，并结束循环。 
			<p><code>while</code> 语句执行下面一系列步骤。第 1 步至第 4 步的每次重复，称作循环的一次<em>迭代</em>。每次遍历开始时都将测试该条件，具体步骤如下所示：</p> 
			<ol> 
				<li>计算表达式 <code>condition</code>。</li> 
				<li>如果 <code>condition</code> 的计算结果为 <code>true</code> 或一个转换为布尔值 <code>true</code> 的值（如一个非零数），则转到第 3 步。否则，<code>while</code> 语句结束并继续执行 <code>while</code> 循环后面的下一语句。</li> 
				<li>运行语句块 <code>statement(s)</code>。如果遇到 <code>continue</code> 语句，则跳过其余的语句并转到步骤 1。如果遇到 <code>break</code> 语句，则 <code>while</code> 语句结束并从 <code>while</code> 循环之后的下一语句继续开始执行。</li> 
				<li>转到步骤 1。</li> 
			</ol> 
			<p>通常当计数器变量小于某指定值时，使用循环执行动作。在每个循环的结尾递增计数器的值，直到达到指定值为止。此时，<code>condition</code> 不再为 <code>true</code>，因此循环结束。</p> 
			<p>如果仅执行一条语句，则不必用大括号 (<code>{}</code>) 将 <code>while</code> 语句所执行的语句括起来。</p>
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 计算结果为 true 或 false 的表达式。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>在下面的示例中，while 语句用于测试表达式。在 i 的值小于 20 时，跟踪 i 的值。当条件不再为 true 时，循环将退出。 
<div class="listing"><pre>
var i:Number = 0; 
while (i < 20) { 
	trace(i); 
	i += 3; 
}
/*
0 
3 
6 
9 
12
15 
18
*/</pre></div>
			<p></p><p><span class="label"> 相关 API 元素 </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#do..while" target="">do..while</a></div></div><a name="with"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">with</td><td class="detailHeaderType">语句</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">用法</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>with (object:Object) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>建立要用于执行一条或多条语句的默认对象，从而潜在地减少需要编写的代码量。
			<p><code>object</code> 参数变为在其中读取 <code>statement(s)</code> 参数中的属性、变量和函数的上下文。例如，如果 <code>object</code> 为 <code>my_array</code>，并且指定的两个属性为 <code>length</code> 和 <code>concat</code>，则这些属性将自动读取为 <code>my_array.length</code> 和 <code>my_array.concat</code>。在另一个示例中，如果 <code>object</code> 为 <code>state.california</code>，则 <code>with</code> 语句内部的任何动作或语句将从 <code>california</code> 实例的内部调用。</p> 
			<p>要查找 <code>statement(s)</code> 参数中某个标识符的值，ActionScript 将从 <code>object</code> 指定的范围链的开头处开始，按照特定的顺序在范围链的每个级别中搜索该标识符。 </p> 
			<p><code>with</code> 语句使用范围链解析标识符，该范围链从下面列表中的第一项开始，到最后一项结束：</p> 
			<ul> 
				<li>该对象在最内层的 <code>with</code> 语句中的 <code>object</code> 参数中指定</li> 
				<li>该对象在最外层的 <code>with</code> 语句中的 <code>object</code> 参数中指定</li> 
				<li>Activation 对象（脚本调用函数时自动创建的临时对象，该函数包含函数中调用的局部变量）</li> 
				<li>该对象包含当前正在执行的脚本</li> 
				<li>全局对象（如 Math 和 String 等内置对象）。</li> 
			</ul> 
			<p>要在 <code>with</code> 语句内部设置变量，必须已在 <code>with</code> 语句外部声明了该变量，或必须输入了希望该变量所存在的时间轴的完整路径。如果在 <code>with</code> 语句中设置了未声明的变量，<code>with</code> 语句将根据作用域链查找该值。如果该变量尚不存在，则将在调用 <code>with</code> 语句的时间轴上设置此新值。</p> 
			</p></p><p></p><span class="label">参数</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; ActionScript 对象或影片剪辑的一个实例。</td></tr></table><br/><span class="label">示例</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_cn"> 如何使用本示例 </a></span><br/>以下示例设置 someOther_mc 实例的 _x 和 _y 属性，然后指示 someOther_mc 转到第 3 帧并停止。 
with (someOther_mc) { 
	_x = 50; 
	_y = 100; 
	gotoAndStop(3); 
} 
下面的代码片断说明如何在不使用 with 语句的情况下编写上述代码。 
someOther_mc._x = 50; 
someOther_mc._y = 100; 
someOther_mc.gotoAndStop(3); 
with 语句对于同时访问一个范围链列表中的多个项很有用。下例中，内置的 Math 对象放置在范围链的前部。将 Math 设置为默认对象会将标识符 cos、sin 和 PI 分别解析为 Math.cos、Math.sin 和 Math.PI。标识符 a、x、y 和 r 不是 Math 对象的方法或属性，但由于它们存在于函数 polar() 的对象激活作用域内，所以将其解析为相应的局部变量。 
<div class="listing"><pre>function polar(r:Number):void { 
	var a:Number, x:Number, y:Number; 
	with (Math) { 
		a = PI * pow(r, 2); 
		x = r * cos(PI); 
		y = r * sin(PI / 2); 
	} 
	trace("area = " + a); 
	trace("x = " + x); 
	trace("y = " + y); 
} polar(3);
/* 
area = 28.2743338823081 
x = -3 
y = 3
*/</pre></div>
			<p></p></div><p></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:21 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/zh_CN/legalnotices/index.html">法律声明</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">在线隐私策略</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">为什么显示为英语？</span>
				</div>
				<div class="white_content_body">
					<b>《ActionScript 3.0 参考》中的内容以英语显示</b><br><br>
					《ActionScript 3.0 参考》中的部分内容未翻译成所有语言。当某个语言元素未翻译时，将显示为英语。例如，ga.controls.HelpBox 类未翻译成任何语言。因此在简体中文版的参考中，ga.controls.HelpBox 类显示为英语。
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:21 AM Z  -->
