<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Справочник по ActionScript&reg; 3.0 для платформы Adobe&reg; Flash&reg;  "><meta name="lang" content="ru-ru"><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"><link rel="stylesheet" href="asfilter.css" type="text/css"><link rel="stylesheet" href="ion.css" type="text/css"><title>Инструкции, ключевые слова и директивы - Adobe ActionScript&reg; 3 (AS3)</title>
		<link rel="stylesheet" href="filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="filter_new.css" type="text/css">
			
		<script src="jquery.js" type="text/javascript"></script>
		<script src="s_chl_code.js" type="text/javascript"></script>
		<script src="jquery.zclip.js" type="text/javascript"></script>
		<script src="jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="cookies.js" type="text/javascript"></script>
		<script src="asdoc.js" type="text/javascript"></script>
		<script src="iscroll.js" type="text/javascript"></script>
		<script src="AC_OETags.js" type="text/javascript"></script>
		<script src="omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Среды выполнения";
			var productsLabel = "Продукты";
			var noneLabel = "Не задан";
			var qsearchBoxLabel = "Быстрый поиск";
			var qsearchText = "Термин не найден";
			var ajaxErrorMsg="Ошибка при загрузке страницы";
			var ajaxErrorTryMsg="Повторите попытку";
			var ajaxLoadingMsg="Загрузка еще не завершена";
			var cancelMsg = "Отмена";
			var classesText = "Классы";
			var strJiveReply = "Этот вопрос был задан по поводу следующей статьи: "
			var showFilters = "Показать фильтры";
			var hideFilters = "Скрыть фильтры";
			
		
			var baseRef = "./";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Справочник по ActionScript<sup>&reg;</sup> 3.0 для платформы Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="index.html"> Домашняя страница </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="statements.html#top" style="display:">Показать список пакетов и классов</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="statements.html#top" style="display:none">Скрыть список пакетов и классов</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="package-summary.html"> Пакеты </a>&nbsp;|&nbsp;
												<a target="_self" href="class-summary.html"> Классы </a>&nbsp;|&nbsp;
												<a target="_self" href="whatsnew.html"> Что нового </a>&nbsp;|&nbsp;
												<a target="_self" href="all-index-Symbols.html"> Указатель </a>&nbsp;|&nbsp;
												<a target="_self" href="appendixes.html"> Приложения </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Почему по-английски?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ru_RU/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('./')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('./')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="help.js"></script>
						<script language="javascript" type="text/javascript" src="asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Фильтры:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Получение данных с сервера...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Получение данных с сервера...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="statements.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">&nbsp;</a><br>
								<h1 id="classProductName">Инструкции, ключевые слова и директивы&nbsp;</h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="statements.html#propertySummary" style="display:none"> Свойства </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Свойства </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="statements.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Конструктор </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="statements.html#methodSummary" style="display:none"> Методы </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="statements.html#constantSummary" style="display:none"> Глобальные константы </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="statements.html#eventSummary" style="display:none"> События </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="statements.html#styleSummary" style="display:none"> Стили </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="statements.html#SkinPartSummary" style="display:none"> Компоненты темы оформления </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="statements.html#SkinStateSummary" style="display:none"> Состояния тем оформления </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="statements.html#effectSummary" style="display:none"> Эффекты </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="statements.html#constantSummary" style="display:none"> Константы </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="statements.html#methodSummary" style="display:none"> Глобальные функции </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="statements.html#methodSummary" style="display:none">Функции</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="statements.html#interfaceSummary" style="display:none"> Интерфейсы </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="statements.html#classSummary" style="display:none"> Классы </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="statements.html#includeExamplesSummary" style="display:none"> Примеры </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="statements.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Классы
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><p>Инструкции &mdash; это элементы языка, выполняющие или задающие действие во время выполнения кода. Например, инструкция <code>return</code> возвращает результирующее значение функции, в которой выполняется эта инструкция. Инструкция <code>if</code> вычисляет условие для определения того, какое действие должно быть выполнено далее. Инструкция <code>switch</code> создает разветвленную структуру для элементов ActionScript. 
		<p>Ключевые слова атрибутов используются для изменения значения определений и могут применяться к определениям классов, переменных, функций и пространств имен. Ключевые слова определения используются для определения различных сущностей, например переменных, функций, классов и интерфейсов. Ключевые слова первичных выражений используются для представления литеральных значений. Список зарезервированных слов см. здесь: <a href="http://www.adobe.com/go/learn_as3_reservedwords_ru" >Изучение ActionScript 3.0</a>.</p> 
		<p>Директивы включают инструкции и определения и могут действовать на этапе компиляции или на этапе выполнения. Директивы, которые не являются ни инструкциями, ни определениями, отмечены как директивы в следующей таблице.</p>
		</p><br><a name="statementSummary"></a><table cellspacing="0" cellpadding="3" class="summaryTable"><tr><th>&nbsp;</th><th colspan="2">ключевое слово первичного выражения</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#false">false</a></td><td class="summaryTableLastCol">Логическое значение, представляющее false.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#null">null</a></td><td class="summaryTableLastCol">Специальное значение, которое может быть присвоено переменным или возвращено функцией в отсутствие данных для обработки.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#this">this</a></td><td class="summaryTableLastCol">Ссылка на объект, содержащий метод.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#true">true</a></td><td class="summaryTableLastCol">Логическое значение, представляющее true.</td></tr><tr><th>&nbsp;</th><th colspan="2"> Пространства имен </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#AS3">AS3</a></td><td class="summaryTableLastCol">Определяет методы и свойства базовых классов ActionScript, которые являются фиксированными свойствами, а не свойствами прототипа.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#flash_proxy">flash_proxy</a></td><td class="summaryTableLastCol">Определяет методы класса Proxy.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#object_proxy">object_proxy</a></td><td class="summaryTableLastCol">Определяет методы класса ObjectProxy.</td></tr><tr><th>&nbsp;</th><th colspan="2">директива</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default_xml_namespace">default xml namespace</a></td><td class="summaryTableLastCol">
			Директива <code>default xml namespace</code> задает пространство имен по умолчанию для объектов XML.
			</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#import">import</a></td><td class="summaryTableLastCol">Делает внешне определенные классы и пакеты доступными для пользовательского кода.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#include">include</a></td><td class="summaryTableLastCol">Включает содержимое заданного файла, как если бы команды в файле были частью вызывающего сценария.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#use_namespace">use namespace</a></td><td class="summaryTableLastCol">Приводит к добавлению заданных пространств имен в набор открытых пространств имен.</td></tr><tr><th>&nbsp;</th><th colspan="2">инструкция</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#break">break</a></td><td class="summaryTableLastCol">Используется в цикле (<code>for</code>, <code>for..in</code>, <code>for each..in</code>, <code>do..while</code> или <code>while</code>) или в блоке инструкций, связанных с определенным случаем в инструкции <code>switch</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#case">case</a></td><td class="summaryTableLastCol">Определяет цель перехода для инструкции <code>switch</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#continue">continue</a></td><td class="summaryTableLastCol">Пропускает все оставшиеся инструкции в наиболее глубоко вложенном цикле и приступает к выполнению следующей итерации цикла, как если бы управление передавалось к концу цикла обычным способом.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#default">default</a></td><td class="summaryTableLastCol">Определяет условие по умолчанию для инструкции <code>switch</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#do..while">do..while</a></td><td class="summaryTableLastCol">Работает аналогично циклу <code>while</code> за исключением того, что инструкции выполняются однократно перед начальным вычислением условия.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#else">else</a></td><td class="summaryTableLastCol">Задает инструкции, которые выполняются, если условие в инструкции <code>if</code> возвращает значение <code>false</code>.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for">for</a></td><td class="summaryTableLastCol">Вычисляет однократно выражение <code>init</code> (инициализация), затем запускает циклическую последовательность.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for..in">for..in</a></td><td class="summaryTableLastCol">Выполняет итерацию через динамические свойства объекта или элементы массива и выполняет инструкцию <code>statement</code> для каждого свойства или элемента.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#for_each..in">for each..in</a></td><td class="summaryTableLastCol">Выполняет итерацию через элементы коллекции и выполняет инструкцию <code>statement</code> для каждого элемента.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#if">if</a></td><td class="summaryTableLastCol">Вычисляет условие, по которому определяется следующая инструкция для выполнения.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#label">label</a></td><td class="summaryTableLastCol">Связывает инструкцию с идентификатором, ссылка на который может указываться при помощи инструкции <code>break</code> или <code>continue</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#return">return</a></td><td class="summaryTableLastCol">Заставляет процесс выполнения незамедлительно вернуться к вызывающей функции.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#super">super</a></td><td class="summaryTableLastCol">Вызывает суперклассовую или родительскую версию метода или конструктора.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#switch">switch</a></td><td class="summaryTableLastCol">Приводит к передаче управления одной из нескольких инструкций в зависимости от значения выражения.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#throw">throw</a></td><td class="summaryTableLastCol">Генерирует, или <em>выбрасывает</em>, ошибку, которая может быть обработана, или <em>перехвачена</em>, блоком кода <code>catch</code>.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#try..catch..finally">try..catch..finally</a></td><td class="summaryTableLastCol">Обрамляет блок кода, в котором может произойти ошибка, затем реагирует на ошибку.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#while">while</a></td><td class="summaryTableLastCol">Вычисляет условие и, если получено значение <code>true</code>, выполняет инструкцию или набор инструкций перед возвращением по циклу к повторному вычислению условия.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#with">with</a></td><td class="summaryTableLastCol">Устанавливает объект по умолчанию, который используется при выполнении одной или нескольких инструкций, потенциально сокращая размер кода, который будет написан.</td></tr><tr><th>&nbsp;</th><th colspan="2">ключевое слово атрибута</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#dynamic">dynamic</a></td><td class="summaryTableLastCol">Показывает, что экземпляры класса могут обладать динамическими свойствами, добавляемыми во время выполнения.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#final">final</a></td><td class="summaryTableLastCol">Показывает, что метод невозможно переопределить или что класс невозможно расширить.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#internal">internal</a></td><td class="summaryTableLastCol">Показывает, что класс, переменная, константа или функция доступны любой вызывающей программе в пределах того же пакета.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#native">native</a></td><td class="summaryTableLastCol">Показывает, что функция или метод реализуются проигрывателем Flash Player в собственном коде.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#override">override</a></td><td class="summaryTableLastCol">Показывает, что метод заменяет наследуемый метод.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#private">private</a></td><td class="summaryTableLastCol">Показывает, что переменная, константа, метод или пространство имен доступны только для класса, который определяет их.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#protected">protected</a></td><td class="summaryTableLastCol">Показывает, что переменная, константа, метод или пространство имен доступны только для класса, который определяет их, и для подклассов этого класса.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#public">public</a></td><td class="summaryTableLastCol">Показывает, что класс, переменная, константа или метод доступны любой вызывающей программе.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#static">static</a></td><td class="summaryTableLastCol">Показывает, что переменная, константа или метод принадлежит классу, а не экземплярам класса.</td></tr><tr><th>&nbsp;</th><th colspan="2">ключевое слово определения</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#..._(rest)_parameter">... (rest) parameter</a></td><td class="summaryTableLastCol">Показывает, что функция принимает любое число разделенных запятыми аргументов.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#class">class</a></td><td class="summaryTableLastCol">Определяет класс, который позволяет создавать экземпляры объектов, применяющие заданные общие методы и свойства.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#const">const</a></td><td class="summaryTableLastCol">Задает константу, являющуюся переменной, значение которой можно присвоить только один раз.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#extends">extends</a></td><td class="summaryTableLastCol">Определяет класс, который является подклассом другого класса.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#function">function</a></td><td class="summaryTableLastCol">Составляет набор инструкций, заданный пользователем для выполнения определенной задачи.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#get">get</a></td><td class="summaryTableLastCol">Определяет получателя &mdash; метод, который может быть прочитан как свойство.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#implements">implements</a></td><td class="summaryTableLastCol">Указывает на то, что класс реализует один или несколько интерфейсов.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#interface">interface</a></td><td class="summaryTableLastCol">Определяет интерфейс.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#namespace">namespace</a></td><td class="summaryTableLastCol">Позволяет управлять видимостью определений.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#package">package</a></td><td class="summaryTableLastCol">Позволяет организовать код в дискретные группы, которые смогут импортировать другие сценарии.</td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#set">set</a></td><td class="summaryTableLastCol">Определяет установщик &mdash; метод, отображаемый в общедоступном интерфейсе как свойство.</td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableStatementCol"><a class="signatureLink" href="statements.html#var">var</a></td><td class="summaryTableLastCol">Задает переменную.</td></tr></table><div class="detailSectionHeader">Сведения об инструкциях, ключевых словах и директивах</div><a name="..._(rest)_parameter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">... (rest) parameter</td><td class="detailHeaderType">ключевое слово определения</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName(parameter0, parameter1, ...rest){ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>Показывает, что функция принимает любое число разделенных запятыми аргументов. Список аргументов становится массивом, доступным на протяжении всего тела функции. Имя массива указывается после символов <code>...</code> в объявлении параметра. Параметр может иметь любое имя, кроме зарезервированного слова. 
			<p>При использовании с другими параметрами объявление параметра <code>...</code> (rest) должно быть последним. Массив параметра <code>...</code> (rest) заполняется, только если число аргументов, переданных функции, превышает число других параметров.</p> 
			<p>Каждый аргумент в списке разделенных запятой аргументов помещается в элемент массива. При передаче экземпляра класса Array весь массив помещается в один элемент массива параметра <code>...</code> (rest).</p>
			<p>Использование данного параметра делает объект <code>arguments</code> недоступным. Хотя параметр <code>...</code> (rest) дает ту же функциональность, что и массив <code>arguments</code> и свойство <code>arguments.length</code>, он не обеспечивает возможностей свойства <code>arguments.callee</code>. Убедитесь, что использовать <code>arguments.callee</code> не требуется, перед тем, как использовать параметр <code>...</code> (rest).</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rest</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Идентификатор, представляющий собой имя массива аргументов, переданного функции. Параметр не обязательно должен иметь имя rest; он может иметь любое имя, не являющееся ключевым словом. Можно задать для параметра «...» (rest) тип данных Array, но это может привести к путанице, так как параметр принимает список разделенных запятой значений, который не идентичен экземпляру класса Array.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере параметр ... (rest) используется в двух различных функциях. Первая функция traceParams просто вызывает функцию trace() для каждого аргумента в массиве rest. Вторая функция average() принимает список аргументов и возвращает среднее значение. Во второй функции для параметра используется другое имя &mdash; args.
<div class="listing"><pre>
package {
	import flash.display.MovieClip;
	
	public class RestParamExample extends MovieClip {
		public function RestParamExample() {
			traceParams(100, 130, "two"); // 100,130,two
			trace(average(4, 7, 13));     // 8
		}
	}
}


function traceParams(... rest) {
 	trace(rest);
 }
 
function average(... args) : Number{
	var sum:Number = 0;
	for (var i:uint = 0; i < args.length; i++) {
		sum += args[i];
	}
	return (sum / args.length);
}
</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="arguments.html" target="">объект arguments</a></div></div><a name="AS3"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">AS3</td><td class="detailHeaderType"> Пространства имен </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Определяет методы и свойства базовых классов ActionScript, которые являются фиксированными свойствами, а не свойствами прототипа. При установке параметра компилятора «-as3» на значение <code>true</code> (что является установкой по умолчанию в Flex Builder 2)пространство имен AS3 автоматически открывается для всех базовых классов. Это значит, что экземпляр базового класса будет использовать фиксированные свойства и методы вместо версий этих свойств и методов, прикрепленных к объекту-прототипу этого класса. Использование фиксированных свойств обычно обеспечивает лучшую производительность, но в ущерб обратной совместимости со спецификацией языка ECMAScript редакции 3 (ECMA-262).</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="Object.html" target="">класс Object</a></div></div><a name="break"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">break</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>break [label]</code></p></p></td></tr></table><p></p><p><p>Используется в цикле (<code>for</code>, <code>for..in</code>, <code>for each..in</code>, <code>do..while</code> или <code>while</code>) или в блоке инструкций, связанных с определенным случаем в инструкции <code>switch</code>. При использовании в цикле инструкция <code>break</code> предписывает Flash пропустить оставшуюся часть тела цикла, остановить процесс организации циклов и выполнить инструкцию, следующую за инструкцией цикла. При использовании в инструкции <code>switch</code> инструкция <code>break</code> предписывает Flash пропустить оставшиеся инструкции в блоке <code>case</code> и перейти к первой инструкции, следующей за закрывающей инструкцией <code>switch</code>. 
			<p>Во вложенных циклах инструкция <code>break</code> только пропускает оставшуюся часть выполняемого цикла, не останавливая выполнение всей серии вложенных циклов. Для выхода из всей серии вложенных циклов используйте <code>label</code> или <code>try..catch..finally</code>.</p>
			<p>Инструкция <code>break</code> может иметь дополнительную метку, которая должна совпадать с меткой внешней инструкции. Использование метки, не совпадающей с меткой внешней инструкции, является синтаксической ошибкой. Помеченные инструкции <code>break</code> можно использовать для выхода из нескольких уровней вложенных инструкций цикла, инструкций <code>switch</code> или инструкций <code>block</code>. Для примера см. описание инструкции <code>label</code>.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя метки, связанной с инструкцией.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере используется инструкция break для выхода из бесконечного цикла: 
<div class="listing"><pre>
var i:int = 0;
while (true) { 
	trace(i); 
	if (i >= 10) { 
		break; // this will terminate/exit the loop 
	} 
	i++; 
} 
/*
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10*/</pre></div>  
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="case"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">case</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>case jumpTarget: statements</pre></p></td></tr></table><p></p><p><p>Определяет цель перехода для инструкции <code>switch</code>. Если параметр <code>jumpTarget</code> приравнивается параметру <code>expression</code> инструкции <code>switch</code> при помощи оператора строгого равенства (<code>===</code>), проигрыватель Flash Player выполняет инструкции в параметре <code>statements</code> до появления инструкции <code>break</code> или до окончания инструкции <code>switch</code>. <p>При использовании инструкции <code>case</code> за пределами инструкции <code>switch</code> выдается ошибка, и сценарий не компилируется.</p> 
			<p></p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">jumpTarget</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Любое выражение.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Инструкции, выполняемые, если jumpTarget совпадает с условным выражением в инструкции switch.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример определяет цели перехода для инструкции switch как thisMonth. Если thisMonth совпадает с выражением в инструкции case, инструкция выполняется. 
<div class="listing"><pre>
var thisMonth:int = new Date().getMonth(); 
switch (thisMonth) { 
	case 0 : 
		trace("January"); 
		break; 
	case 1 : 
		trace("February"); 
		break; 
	case 5 : 
	case 6 : 
	case 7 : 
		trace("Some summer month"); 
		break; 
	case 8 : 
		trace("September"); 
		break; 
	default : 
		trace("some other month"); 
}</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#switch" target="">switch</a></div></div><a name="class"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">class</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>[dynamic] [public | internal] [final] class className [ extends superClass ] [ implements interfaceName[, interfaceName... ] ] { 
	// class definition here
}</pre>
			</p></td></tr></table><p></p><p><p>Определяет класс, который позволяет создавать экземпляры объектов, применяющие заданные общие методы и свойства. Например, при разработке системы отслеживания счетов можно создать класс Invoice, определяющий все методы и свойства, используемые каждым счетом. Затем при помощи команды <code>new Invoice()</code> можно создать объекты Invoice. 
			<p>Каждый исходный файл ActionScript может содержать только один класс, видимый для других исходных файлов или сценариев. Внешне видимый класс может быть общедоступным или внутренним и должен быть определен внутри инструкции пакета. При включении других классов в тот же файл эти классы необходимо разместить вне инструкции пакета в конце файла. </p>
			<p>Имя внешне видимого класса должно совпадать с именем исходного файла ActionScript, содержащего этот класс. Имя исходного файла должно состоять из имени класса с расширением файла .as. Например, если класс имеет имя Student, файлу, определяющему этот класс, необходимо присвоить имя Student.as.</p> 
			<p>Определения классов вкладывать нельзя, т.е. нельзя определить дополнительные классы в определении другого класса.</p> 
			<p>Можно определить метод конструктора, т.е. метод, выполняемый при каждом создании нового экземпляра класса. Имя метода конструктора должно совпадать с именем класса. Если не определить метод конструктора, будет создан конструктор по умолчанию.</p>
			<p>Для указания на то, что объекты могут добавлять динамические свойства и получать к ним доступ во время выполнения, вставьте перед инструкцией класса ключевое слово <code>dynamic. </code> Для объявления того, что класс реализует интерфейс, используйте ключевое слово <code>implements</code>. Для создания подклассов класса используйте ключевое слово <code>extends</code>. (Класс может расширить только один класс, но реализовывать несколько интерфейсов.) Можно использовать <code>implements</code> и <code>extends</code> в одной инструкции. Следующие примеры иллюстрируют типичное использование ключевых слов <code>implements</code> и <code>extends</code>:</p> 
<div class="listing"><pre>class C implements Interface_i, Interface_j // OK 
class C extends Class_d implements Interface_i, Interface_j // OK 
class C extends Class_d, Class_e // not OK </pre></div> 

			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Полное имя класса.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере создается класс с именем Plant. Конструктор Plant имеет два параметра. 
<div class="listing"><pre>// Filename Plant.as 
package {
  public class Plant { 
	// Define property names and types 
	private var _leafType:String; 
	private var _bloomSeason:String; 
	// Following line is constructor 
	// because it has the same name as the class 
	public function Plant(param_leafType:String, param_bloomSeason:String) { 
		// Assign passed values to properties when new Plant object is created 
		_leafType = param_leafType; 
		_bloomSeason = param_bloomSeason; 
	} 
	// Create methods to return property values, because best practice 
	// recommends against directly referencing a property of a class 
	public function get leafType():String { 
		return _leafType; 
	} 
	public function get bloomSeason():String { 
		return _bloomSeason; 
	} 
  }
}</pre></div> 
В своем сценарии используйте оператор new для создания объекта Plant.
<div class="listing"><pre>
var pineTree:Plant = new Plant("Evergreen", "N/A"); 
// Confirm parameters were passed correctly 
trace(pineTree.leafType); 
trace(pineTree.bloomSeason); </pre></div> 
			
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#dynamic" target="">dynamic</a><br/><a href="statements.html#extends" target="">extends</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="const"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">const</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>const identifier = value </pre></p></td></tr></table><p></p><p><p>Задает константу, являющуюся переменной, значение которой можно присвоить только один раз.  
			<p>Константу можно строго типизировать, вставив двоеточие (:), за которым следует тип данных.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">identifier</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Идентификатор константы.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример показывает, что при попытке присвоить значение константе больше одного раза возникает ошибка.
<div class="listing"><pre>
const MIN_AGE:int = 21;
MIN_AGE = 18; // error</pre></div>
В следующем примере показано, что если константа является массивом, все же можно вызывать методы класса Array, в том числе Array.push(). Однако невозможно присвоить новый литерал массива. 
<div class="listing"><pre>
const product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); // array operations are allowed
product_array = ["Other"];  // assignment is an error
trace(product_array); 
</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#var" target="">var</a></div></div><a name="continue"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">continue</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>continue [label]</pre></p></td></tr></table><p></p><p><p>Пропускает все оставшиеся инструкции в наиболее глубоко вложенном цикле и приступает к выполнению следующей итерации цикла, как если бы управление передавалось к концу цикла обычным способом. Инструкция <code>continue</code> не действует за пределами цикла. Во вложенных циклах используйте дополнительный параметр <code>label</code>, чтобы пропустить другие циклы, помимо наиболее глубоко вложенного.
			<p>Инструкция <code>continue</code> может иметь дополнительную метку, которая должна совпадать с меткой внешней инструкции. Использование метки, не совпадающей с меткой внешней инструкции, является синтаксической ошибкой. Помеченные инструкции <code>continue</code> можно использовать для выхода из нескольких уровней вложенных инструкций цикла.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем цикле while инструкция continue используется для пропуска оставшейся части тела цикла каждый раз, когда встречается число, кратное трем, и перехода в верхнюю часть цикла, где проверяется условие: 
<div class="listing"><pre>
var i:int = 0; 
while (i < 10) { 
	if (i % 3 == 0) { 
		i++; 
		continue; 
	} 
	trace(i); 
	i++; 
}</pre></div> 
В цикле for инструкция continue также используется для пропуска оставшейся части тела цикла. В следующем примере, если i % 3 равно 0, инструкция trace(i) пропускается: 
<div class="listing"><pre> 
for (var i:int = 0; i < 10; i++) { 
	if (i % 3 == 0) { 
		continue; 
	} 
	trace(i); 
}</pre></div> 

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#do..while" target="">do..while</a><br/><a href="statements.html#for" target="">for</a><br/><a href="statements.html#for..in" target="">for..in</a><br/><a href="statements.html#for_each..in" target="">for each..in</a><br/><a href="statements.html#label" target="">label</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="default"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>default: statements </pre></p></td></tr></table><p></p><p><p>Определяет условие по умолчанию для инструкции <code>switch</code>. Инструкции выполняются, если параметр <code>expression</code> инструкции <code>switch</code> не приравнивается (при помощи операции строгого равенства [<code>===</code>]) ни к одному из параметров <code>expression</code>, следующих за ключевыми словами <code>case</code> в данной инструкции <code>switch</code>. 
			<p>Для инструкции <code>switch</code> не требуется инструкция условия <code>default. </code> Инструкция условия <code>default</code> не обязательно должна быть последней в списке. При использовании инструкции <code>default</code> за пределами инструкции <code>switch</code> выдается ошибка, и сценарий не компилируется.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Любые инструкции.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере, если днем недели является Saturday или Sunday, ни одна из инструкций case не применяется, а выполняется переход к инструкции default. 
<div class="listing"><pre>
var dayOfWeek:int = new Date().getDay(); 
switch (dayOfWeek) { 
	case 1 : 
		trace("Monday"); 
		break; 
	case 2 : 
		trace("Tuesday"); 
		break; 
	case 3 : 
		trace("Wednesday"); 
		break; 
	case 4 : 
		trace("Thursday"); 
		break; 
	case 5 : 
		trace("Friday"); 
		break; 
	default : 
		trace("Weekend"); 
}</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#switch" target="">switch</a></div></div><a name="default_xml_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">default xml namespace</td><td class="detailHeaderType">директива</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><p><code>default xml namespace = ns</code></p></p></td></tr></table><p></p><p><p>
			Директива <code>default xml namespace</code> задает пространство имен по умолчанию для объектов XML. 
			
			<p>Если директива <code>default xml namespace</code> не задана, то пространством имен по умолчанию является пространство имен без имени (в качестве URI будет задана пустая строка). Область видимости объявления <code>default xml namespace</code> находится в блоке функции, как и в случае с областью видимости переменной.
			</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере показано, что областью видимости default xml namespace является блок функций:
			<div class="listing"><pre>var nsDefault1:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault1;
	    
var x1:XML = <test1 />;
trace("x1 ns: " + x1.namespace());
			
scopeCheck();	

var x2:XML = <test2 />;
trace("x2 ns: " + x2.namespace());
		
function scopeCheck(): void {
	
	var x3:XML = <test3 />;
	trace("x3 ns: " + x3.namespace());
				
	var nsDefault2:Namespace = new Namespace("http://schemas.xmlsoap.org/soap/envelope/");
	default xml namespace = nsDefault2;
		    
	var x4:XML = <test4 />;
	trace("x4 ns: " + x4.namespace());

}</pre></div>
			
			Результатом trace() для данного примера будет следующее:
			
			x1 ns: http://www.example.com/namespaces/
x3 ns: 
x4 ns: http://schemas.xmlsoap.org/soap/envelope/
x2 ns: http://www.example.com/namespaces/



В следующем примере default xml namespace используется для назначения пространства имен по умолчанию. Для второго объекта XML (x2) данный параметр не используется, так как x2 определяет собственное пространство имен по умолчанию: 
<div class="listing"><pre>
var nsDefault:Namespace = new Namespace("http://www.example.com/namespaces/");
default xml namespace = nsDefault;
            
var x1:XML = <test1 />;

trace(x1.namespace());
	// http://www.example.com/namespaces/

var x2:XML = <test2 xmlns = "http://www.w3.org/1999/XSL/Transform/" />;
trace(x2.namespace());
	// http://www.w3.org/1999/XSL/Transform/

var x3:XML = <test3 xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" />;
trace(x3.namespace());
	// http://www.example.com/namespaces/
</pre></div>  
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#namespace" target="">namespace</a><br/><a href="Namespace.html" target="">Класс Namespace</a><br/><a href="statements.html#use_namespace" target="">use namespace</a><br/><a href="XML.html" target="">XML</a></div></div><a name="do..while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">do..while</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>do { statement(s) } while (condition)</pre></p></td></tr></table><p></p><p><p>Работает аналогично циклу <code>while</code> за исключением того, что инструкции выполняются однократно перед начальным вычислением условия. Впоследствии инструкции выполняются, только если условие принимает значение <code>true</code>. <p>Цикл <code>do..while</code> обеспечивает выполнение кода внутри цикла по крайней мере один раз. Хотя такого же эффекта можно достичь при помощи цикла <code>while</code>, вставив копию инструкций для выполнения перед началом цикла <code>while</code>, многие программисты полагают, что циклы <code>do..while</code> более удобочитаемы.</p> 
			<p>Если значение всегда возвращает значение <code>true</code>, цикл <code>do..while</code> является бесконечным. При создании бесконечного цикла возникают проблемы с проигрывателем Flash Player, которые ведут к появлению предупреждающего сообщения или сбою в работе проигрывателя. По возможности используйте цикл <code>for</code>, если известно количество раз выполнения цикла. Хотя циклы <code>for</code> удобны для чтения и отладки, они могут заменить циклы <code>do..while</code> не во всех ситуациях.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Вычисляемое условие. Инструкции statement(s) в пределах блока кода do будут выполняться, пока параметр condition принимает значение true.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере цикл do..while используется для вычисления того, принимает ли условие значение true, и для отслеживания переменной myVar, пока переменная myVar не примет значение 5 или больше. Когда переменная myVar принимает значение 5 или больше, цикл завершается. 
<div class="listing"><pre>
var myVar:Number = 0; 
do { 
	trace(myVar); 
	myVar++; 
} 
while (myVar < 5); 
/*
0 
1 
2 
3 
4
*/</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#while" target="">while</a></div></div><a name="dynamic"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">dynamic</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>dynamic class className { // class definition here }</pre></p></td></tr></table><p></p><p><p>Показывает, что экземпляры класса могут обладать динамическими свойствами, добавляемыми во время выполнения. Если к классу применить атрибут <code>dynamic</code>, можно добавлять свойства к экземплярам этого класса во время выполнения. Классы, не отмеченные как <code>dynamic</code>, имеют статус <em>запечатанных</em>, т. е. свойства не могут добавляться к экземплярам этого класса.
			<p>Если класс запечатан (не является динамическим), то при попытке определить или задать свойства класса возникает ошибка. Если компилятор работает в строгом режиме и вы указали тип данных при создании экземпляров, то при попытках добавить свойства в запечатанные объекты возникнет ошибка компилятора; в противном случае &mdash; ошибка этапа выполнения.</p> 
			<p>Атрибут <code>dynamic</code> не наследуется подклассами. При расширении динамического класса подкласс становится динамическим, только если он объявлен с атрибутом <code>dynamic</code>.</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере создаются два класса: один динамический с именем Expando и один запечатанный с именем Sealed, которые используются в последовательных примерах.
<div class="listing"><pre>
package {

	dynamic class Expando  {
	}
	
	class Sealed {
	}
}
</pre></div>
Следующий код создает экземпляр класса Expando и показывает, что к этому экземпляру можно добавлять свойства.
<div class="listing"><pre>
var myExpando:Expando = new Expando();
myExpando.prop1 = "new";
trace(myExpando.prop1); // new
</pre></div>
Следующий код создает экземпляр класса Sealed и показывает, что при попытках добавить свойство к этому экземпляру возникает ошибка.
<div class="listing"><pre>
var mySealed:Sealed = new Sealed();
mySealed.prop1 = "newer"; // error
</pre></div>
		

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a></div></div><a name="else"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">else</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) { 
	// statement(s)
} 
else {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Задает инструкции, которые выполняются, если условие в инструкции <code>if</code> возвращает значение <code>false</code>. Фигурные скобки (<code>{}</code>), в которых заключены инструкции для выполнения инструкцией <code>else</code>, не требуются при выполнении только одной инструкции.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Выражение, принимающее значение true или false.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере условие else используется для проверки того, принимает ли переменная age_txt значение больше или меньше 18: 
<div class="listing"><pre>
if (age_txt.text>=18) { 
	trace("welcome, user"); 
} 
else { 
	trace("sorry, junior"); 
	userObject.minor = true; 
	userObject.accessAllowed = false;
}</pre></div> 
В следующем примере фигурные скобки ({}) не требуются, так как за инструкцией else следует только одна инструкция:
<div class="listing"><pre>
if (age_txt.text>18) { 
	trace("welcome, user");
} 
else trace("sorry, junior");</pre></div>
В следующем примере используется сочетание инструкций if и else для сравнения score_txt с заданным значением: 
<div class="listing"><pre>

if (score_txt.text>90) { 
	trace("A"); 
} 
else if (score_txt.text>75) { 
	trace("B"); 
} 
else if (score_txt.text>60) { 
	trace("C"); 
} 
else { 
	trace("F"); 
}</pre></div><p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#if" target="">if</a></div></div><a name="extends"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">extends</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>class className extends otherClassName {}
interface interfaceName extends otherInterfaceName {} </pre> </p></td></tr></table><p></p><p><p>Определяет класс, который является подклассом другого класса. Подкласс наследует все методы, свойства, функции и т. д., определенные для суперкласса. Классы с пометкой <code>final</code> не могут быть расширены.
			<p>Для расширения интерфейса можно также использовать ключевое слово <code>extends. </code> Интерфейс, расширяющий другой интерфейс, включает в себя все методы, объявленные для исходного интерфейса.</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Имя определяемого класса.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере класс Car расширяет класс Vehicle с наследованием всех методов, свойств и функций. Если сценарий создает экземпляр объекта Car, можно использовать методы обоих классов &mdash; класса Car и класса Vehicle. 
			В следующем примере показано содержимое файла с именем Vehicle.as, который определяет класс Vehicle:  
<div class="listing"><pre>
package {
	class Vehicle { 
	    var numDoors:Number; 
	    var color:String; 
	    public function Vehicle(param_numDoors:Number = 2, param_color:String = null) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	    } 
	    public function start():void { 
	        trace("[Vehicle] start"); 
	    } 
	    public function stop():void { 
	        trace("[Vehicle] stop"); 
	    } 
	    public function reverse():void { 
	        trace("[Vehicle] reverse"); 
	    } 
	}	
}</pre></div> 
В следующем примере показан второй файл ActionScript с именем Car.as, расположенный в том же каталоге. Этот класс расширяет класс Vehicle, изменяя его тремя способами. Во-первых, класс Car добавляет переменную fullSizeSpare для проверки того, имеет ли объект car полноразмерное запасное колесо. Во-вторых, добавляется новый метод, предназначенный только для автомобилей, activateCarAlarm(), который активирует противоугонную сигнализацию автомобиля. В-третьих, переопределяется функция stop() для добавления того факта, что класс Car использует противоблокировочную тормозную систему для остановки.
<div class="listing"><pre>
package {

	public class Car extends Vehicle { 
	    var fullSizeSpare:Boolean; 
	    public function Car(param_numDoors:Number, param_color:String, param_fullSizeSpare:Boolean) { 
	        numDoors = param_numDoors; 
	        color = param_color; 
	        fullSizeSpare = param_fullSizeSpare; 
	    } 
	    public function activateCarAlarm():void { 
	        trace("[Car] activateCarAlarm"); 
	    } 
	    public override function stop():void { 
	        trace("[Car] stop with antilock brakes"); 
	    } 
	}
}</pre></div> 
В следующем примере создается экземпляр объекта Car, вызывается метод, определенный в классе Vehicle (start()), затем вызывается метод, переопределенный классом Car (stop()), и, наконец, вызывается метод класса Car (activateCarAlarm()):
<div class="listing"><pre>var myNewCar:Car = new Car(2, "Red", true); 
myNewCar.start(); // [Vehicle] start 
myNewCar.stop(); // [Car] stop with anti-lock brakes 
myNewCar.activateCarAlarm(); // [Car] activateCarAlarm</pre></div> 
Подкласс класса Vehicle можно также записать с использованием инструкции super, которую подкласс может использовать для доступа к конструктору суперкласса. В следующем примере показан третий файл ActionScript с именем Truck.as, расположенный в том же каталоге. Класс Truck использует инструкцию super в конструкторе и в переопределенном методе reverse(). 
<div class="listing"><pre>
package {
	class Truck extends Vehicle {
		var numWheels:Number;
		public function Truck(param_numDoors:Number, param_color:String, param_numWheels:Number) { 
			super(param_numDoors, param_color); 
			numWheels = param_numWheels; 
		} 
		public override function reverse():void { 
			beep();
			super.reverse();
		} 
		public function beep():void { 
			trace("[Truck] make beeping sound"); 
		} 
	}
}</pre></div> 
В следующем примере создается экземпляр объекта Truck, вызывается метод, переопределенный классом Truck (reverse()), затем вызывается метод, определенный в классе Vehicle (stop()):  
<div class="listing"><pre>var myTruck:Truck = new Truck(2, "White", 18); 
myTruck.reverse(); // [Truck] make beeping sound [Vehicle] reverse 
myTruck.stop(); // [Vehicle] stop</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#final" target="">final</a><br/><a href="statements.html#interface" target="">interface</a></div></div><a name="false"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">false</td><td class="detailHeaderType">ключевое слово первичного выражения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>false</pre></p></td></tr></table><p></p><p><p>Логическое значение, представляющее false. Логическим значением становится либо <code>true</code>, либо <code>false</code>, причем значения <code>false</code> и <code>true</code> являются противоположными.
			<p>Если в процессе автоматической типизации данных <code>false</code> преобразуется в число, то оно становится <code>0</code>; при преобразовании <code>false</code> в строку, оно принимает вид <code>"false"</code>.</p>
			<p><b>Примечание.</b> Строка <code>"false"</code> преобразуется в логическое значение <code>true</code>.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует преобразование значения false в число и в строку при автоматической типизации данных:
<div class="listing"><pre>
var bool1:Boolean = Boolean(false);

// converts it to the number 0
trace(1 + bool1); // outputs 1

// converts it to a string
trace("String: " + bool1); // outputs String: false
</pre></div>
Следующий пример показывает, как строка "false" преобразуется в логическое значение true:
<div class="listing"><pre>
trace(Boolean("false")); // true

if ("false") {
	trace("condition expression evaluated to true");
}
else {
	trace("condition expression evaluated to false");
}
// condition expression evaluated to true
</pre></div>

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="Boolean.html" target="">Класс Boolean</a><br/><a href="statements.html#true" target="">true</a></div></div><a name="final"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">final</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
final function methodName() { 
	// your statements here 
}
final class className {}</pre> </p></td></tr></table><p></p><p><p>Показывает, что метод невозможно переопределить или что класс невозможно расширить. При попытке переопределить метод или расширить класс, отмеченный как <code>final</code>, возникнет ошибка.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Имя метода, который невозможно переопределить.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Имя класса, который невозможно расширить.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#override" target="">override</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="flash_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">flash_proxy</td><td class="detailHeaderType"> Пространства имен </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Определяет методы класса Proxy. Методы класса Proxy находятся в собственном пространстве имен во избежание конфликтов имен в случаях, когда подкласс Proxy содержит методы экземпляра с именами, которые совпадают с именами методов класса Proxy.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="flash/utils/Proxy.html" target="">класс Proxy</a></div></div><a name="for"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for ([init]; [condition]; [next]) { 
	// statement(s)
}</pre>
			</p></td></tr></table><p></p><p><p>Вычисляет однократно выражение <code>init</code> (инициализация), затем запускает циклическую последовательность. Циклическая последовательность начинается с вычисления выражения <code>condition</code>. Если выражение <code>condition</code> принимает значение <code>true</code>, выполняется инструкция <code>statement</code> и вычисляется <code>next</code>. Циклическая последовательность затем начинается снова с вычисления выражения <code>condition</code>. 
			<p>Фигурные скобки (<code>{}</code>), в которых заключены инструкции для выполнения инструкцией <code>for</code>, не требуются при выполнении только одной инструкции.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">init</span></code> &mdash; Дополнительное выражение для вычисления перед началом выполнения циклической последовательности; как правило, это выражение присваивания. Инструкция var также допустима для данного параметра.</td></tr><tr><td width="20px"></td><td><code><span class="label">condition</span></code> &mdash; Дополнительное выражение для вычисления перед началом выполнения циклической последовательности; как правило, это выражение сравнения. Если выражение принимает значение true, инструкции, связанные с инструкцией for, выполняются.</td></tr><tr><td width="20px"></td><td><code><span class="label">next</span></code> &mdash; Дополнительное выражение для вычисления после выполнения циклической последовательности; как правило, это выражение увеличения или уменьшения на единицу.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере инструкция for используется для добавления элементов в массив: 
<div class="listing"><pre>
var my_array:Array = new Array(); 
for (var i:Number = 0; i < 10; i++) { 
	my_array[i] = (i + 5) * 10;  
} 
trace(my_array); // 50,60,70,80,90,100,110,120,130,140 </pre></div> 
В следующем примере инструкция for используется для повторяющегося выполнения того же действия. В этом коде цикл for добавляет числа от 1 до 100. 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) { 
	sum += i; 
} 
trace(sum); // 5050</pre></div> 
Следующий пример показывает, что фигурные скобки ({}) не требуются, если выполняется только одна инструкция: 
<div class="listing"><pre>var sum:Number = 0; 
for (var i:Number = 1; i <= 100; i++) 
	sum += i; 
trace(sum); // 5050</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="operators.html#increment" target="">++ (увеличение на единицу)</a></div></div><a name="for..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for..in</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>for (variableIterant:String in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>Выполняет итерацию через динамические свойства объекта или элементы массива и выполняет инструкцию <code>statement</code> для каждого свойства или элемента. Свойства объекта не хранятся в определенном порядке, поэтому могут отображаться в произвольной последовательности. Фиксированные свойства, например переменные и методы, определенные в классе, не перечисляются в инструкции <code>for..in</code>. Для получения списка фиксированных свойств используйте функцию <code>describeType()</code>, которая находится в пакете flash.utils.
			 
			 
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a href="String.html">String</a></code> &mdash; Имя переменной, выступающей в роли итеранта, ссылающейся на каждое свойство объекта или элемента массива.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере цикл for..in используется с целью выполнения итерации для всех свойств объекта: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var prop in myObject) { 
	trace("myObject."+prop+" = "+myObject[prop]); 
} 
/*
myObject.firstName = Tara 
myObject.age = 27 
myObject.city = San Francisco
*/</pre></div> 
В следующем примере оператор typeof с циклом for..in используется с целью выполнения итерации для определенного типа дочерних объектов: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for (var name in myObject) { 
	if (typeof (myObject[name]) == "string") { 
		trace("I have a string property named "+name); 
	} 
}
/*
I have a string property named city
I have a string property named firstName
*/
</pre></div> 
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="flash/utils/package.html#describeType()" target="">describeType()</a></div></div><a name="for_each..in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">for each..in</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>for each (variableIterant in object){ 
	// statement(s)
} </pre></p></td></tr></table><p></p><p><p>Выполняет итерацию через элементы коллекции и выполняет инструкцию <code>statement</code> для каждого элемента. Инструкцию <code>for each..in</code>, введенную в составе расширений языка E4X, можно использовать не только для объектов XML, но также для объектов и массивов. Инструкция цикла <code>for each..in</code> выполняет итерацию только через динамические, а не фиксированные, свойства объекта. Фиксированным является свойство, являющееся частью определения класса. Для использования инструкции <code>for each..in</code> с экземпляром класса, определенного пользователем, необходимо объявить класс с атрибутом <code>dynamic</code>. 
			<p>В отличие от <code>for..in</code>, инструкция <code>for each..in</code> выполняет итерацию для значений свойств объекта, а не для имен свойств.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableIterant</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, выступающей в роли итеранта, ссылающейся на элемент коллекции.</td></tr><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; Имя коллекции, через которую выполняется итерация. Коллекцией может быть объект XML, типовой объект или массив.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере цикл for each..in используется с целью выполнения итерации для всех значений, содержащихся в свойствах объекта: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	trace(item); 
} 
/*
Tara
27
San Francisco
*/</pre></div> 
В следующем примере цикл for each..in используется с целью выполнения итерации для всех элементов массива: 
<div class="listing"><pre>
var myArray:Array = new Array("one", "two", "three"); 
for each(var item in myArray) 
	trace(item); 
/*
one
two
three
*/</pre></div> 
В следующем примере оператор is с циклом for each..in используется с целью выполнения итерации для определенного типа дочерних объектов: 
<div class="listing"><pre>
var myObject:Object = {firstName:"Tara", age:27, city:"San Francisco"}; 
for each (var item in myObject) { 
	if (item is String) {  
		trace("I have a string property with value " + item); 
	} 
}

/*
I have a string property with value Tara
I have a string property with value San Francisco
*/
</pre></div> 

В следующем примере цикл for each..in используется с целью выполнения итерации для свойств объекта XMLList (doc.p):

<div class="listing"><pre>
var doc:XML = 
		<body>
			<p>Hello</p>
			<p>Hola</p>
			<hr />
			<p>Bonjour</p>
		</body>;
for each (var item in doc.p) {
	trace(item);
}

/*
Hello
Hola
Bonjour
*/
</pre></div>
			<p></p></div><a name="function"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">function</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>function functionName([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} 
var functionName:Function = function ([parameter0, parameter1,...parameterN]) : returnType{ 
	// statement(s) 
} </pre>
			</p></td></tr></table><p></p><p><p>Составляет набор инструкций, заданный пользователем для выполнения определенной задачи. Можно определить функцию в одном местоположении и <em>вызывать</em> ее из различных сценариев в SWF-файле. При определении функции можно также задать для нее параметры. Параметры являются местозаполнителями для значений, которыми оперирует функция. При каждом вызове функции ей можно передавать различные параметры, т.е. использовать функцию в различных ситуациях. 
			<p>Используйте инструкцию <code>return</code> в блоке <code>statement(s)</code> функции для того, чтобы функция сгенерировала, или <em>возвратила</em>, значение.</p> 
			<p>Применение 1. Ключевое слово <code>function</code> можно использовать для определения функции с заданным именем, параметрами и инструкциями. При вызове функции сценарием выполняются инструкции, заложенные в определении функции. Допускается опережающая ссылка; в рамках одного сценария функцию можно объявить после ее вызова. Последующее определение функции заменяет любое предыдущее определение этой функции. Этот синтаксис можно использовать там, где разрешается выполнение инструкции. </p> 
			<p>Применение 2. Инструкцию <code>function</code> можно также использовать для создания анонимной функции и возврата ссылки на нее. Этот синтаксис используется в выражениях и особенно полезен для установки методов объектов.</p> 
			<p>Для дополнительной функциональности в определении функции можно использовать объект <code>arguments. </code> Объект <code>arguments</code> обычно используется для создания функции, принимающей различное число параметров, и для создания рекурсивной анонимной функции.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Имя новой функции.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Тип данных возвращаемого значения.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Далее приводится пример определения функции sqr, которая возвращает число, возведенное в квадрат: 
<div class="listing"><pre>function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
} 
var yNum:Number = sqr(3); 
trace(yNum); // 9</pre></div> 
Если функция используется в том же сценарии, в котором была определена, определение функции может появиться после ее использования: 
<div class="listing"><pre>var yNum:Number = sqr(3); 
trace(yNum); // 9 
function sqr(xNum:Number) { 
	return Math.pow(xNum, 2); 
}</pre></div> 

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="arguments.html" target="">объект arguments</a><br/><a href="statements.html#return" target="">return</a></div></div><a name="get"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">get</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function get property() : returnType{ 
	// your statements here 
}</pre> </p></td></tr></table><p></p><p><p>Определяет получателя &mdash; метод, который может быть прочитан как свойство. Получатель &mdash; это специальная функция, которая возвращает значение свойства, объявленного при помощи ключевого слова <code>var</code> или <code>const</code>. В отличие от других методов, получатель вызывается без использования круглых скобок (<code>()</code>), что делает его похожим на переменную.
			<p>Получатели дают возможность применять принцип скрытия информации, позволяя создавать общедоступный интерфейс для частного свойства. Преимуществом скрытия информации является то, что общедоступный интерфейс не изменяется даже при изменении реализации частного свойства.</p>
			<p>Еще одним преимуществом получателей является то, что они могут переопределяться в подклассах, а свойства, объявленные при помощи ключевых слов <code>var</code> или <code>const</code>, не могут.</p>
			<p>Получатель может использоваться совместно с установщиком для создания свойства чтения-записи. Для создания свойства только для чтения создайте получатель без соответствующего установщика. Для создания свойства только для записи создайте установщик без соответствующего получателя.</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Идентификатор свойства, к которому обращается инструкция get; это значение должно быть тем же, что используется в соответствующей команде set.</td></tr><tr><td width="20px"></td><td><code><span class="label">returnType</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Тип данных возвращаемого значения.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Далее приводится пример определения класса Team.  Класс Team включает в себя методы получателя и установщика, которые позволяют считывать и задавать свойства в классе: 
<div class="listing"><pre>
package {
	public class Team { 
		var teamName:String; 
		var teamCode:String; 
		var teamPlayers:Array = new Array(); 
		public function Team(param_name:String, param_code:String) { 
			teamName = param_name; 
			teamCode = param_code; 
		} 
		public function get name():String { 
			return teamName; 
		} 
		public function set name(param_name:String):void { 
			teamName = param_name; 
		}
	} 
}</pre></div>
Введите в сценарий следующий код: 
<div class="listing"><pre>
var giants:Team = new Team("San Fran", "SFO"); 
trace(giants.name); 
giants.name = "San Francisco"; 
trace(giants.name); 
/*
San Fran San Francisco */</pre></div> 
При трассировке giants.name метод получателя используется для возврата значения свойства.
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#set" target="">set</a></div></div><a name="if"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">if</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>if (condition) {
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Вычисляет условие, по которому определяется следующая инструкция для выполнения. Если условие принимает значение <code>true</code>, Flash Player выполняет следующие за условием инструкции в фигурных скобках (<code>{}</code>). Если условие принимает значение <code>false</code>, Flash Player пропускает инструкции в фигурных скобках и выполняет инструкции, следующие за фигурными скобками. Используйте инструкцию <code>if</code> в сочетании с инструкцией <code>else</code> для создания логики ветвления в сценариях. 
			<p>Фигурные скобки (<code>{}</code>), в которых заключены инструкции для выполнения инструкцией <code>if</code>, не требуются при выполнении только одной инструкции.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Выражение, принимающее значение true или false.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#else" target="">else</a></div></div><a name="implements"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">implements</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>myClass implements interface01 [, interface02 , ...] </pre> </p></td></tr></table><p></p><p><p>Указывает на то, что класс реализует один или несколько интерфейсов. Если класс реализует интерфейс, в нем должны быть определены все методы, объявленные в интерфейсе. Любой экземпляр класса, реализующий интерфейс, относится к типу данных, определенному интерфейсом. В результате оператор <code>is</code> возвращает <code>true</code>, когда экземпляр класса является первым операндом, а интерфейс &mdash; вторым; более того, действует преобразование в тип данных и из типа данных, определенного интерфейсом.
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">класс</a><br/><a href="statements.html#interface" target="">интерфейс</a></div></div><a name="import"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">import</td><td class="detailHeaderType">директива</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>import packageName.className 
import packageName.*</pre> </p></td></tr></table><p></p><p><p>Делает внешне определенные классы и пакеты доступными для пользовательского кода. Например, для использования в сценарии класса flash.display.Sprite необходимо его импортировать. Данное требование является отличием от предыдущих версий ActionScript, в которых директива <code>import</code> была необязательной.
			<p>После использования директивы <code>import</code> можно использовать полное имя класса, которое включает в себя имя пакета или только имя самого класса.</p>
<div class="listing"><pre> 
import flash.display.Sprite; 

// name of class only
var mySprite:Sprite = new Sprite();

// full class name
var mySprite:flash.display.Sprite = new flash.display.Sprite();
</pre></div> 
<p>Если необходимо получить доступ к нескольким классам в пакете, их все можно импортировать в одной инструкции, как показано в следующем примере:</p>
<div class="listing"><pre>import flash.display.*;</pre></div>
<p>Директива <code>import</code> импортирует только классы, функции и переменные верхнего уровня импортируемого пакета. Вложенные пакеты необходимо импортировать явным образом.</p>
<p>Если импортированный класс не использовать в сценарии, он не будет экспортирован как часть SWF-файла. Это значит, что можно импортировать большие пакеты, не заботясь о размере SWF-файла; байт-код, связанный с классом, включается в SWF-файл, только если этот класс действительно используется. Недостатком импортирования классов, которые не понадобятся, является повышение вероятности конфликта имен.</p> 
 
<pre>
// On Frame 1 of a FLA: 
import adobe.example.*; 
var myFoo:foo = new foo();</pre> 
 

			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя пакета, определенного пользователем в отдельном файле класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Имя класса, определенного пользователем в отдельном файле класса.</td></tr></table></div><a name="include"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">include</td><td class="detailHeaderType">директива</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>include "[path]filename.as"</pre></p></td></tr></table><p></p><p><p>Включает содержимое заданного файла, как если бы команды в файле были частью вызывающего сценария. Директива <code>include</code> вызывается во время компиляции. Следовательно, при внесении изменений в файл необходимо его сохранить и повторно скомпилировать SWF-файлы, в которых он используется.
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="interface"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">interface</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre> interface InterfaceName [extends InterfaceName ] {}</pre> </p></td></tr></table><p></p><p><p>Определяет интерфейс. Интерфейсы &mdash; это типы данных, которые определяют набор методов; эти методы должны определяться любым классом, реализующим интерфейс.
			<p> Интерфейс подобен классу, но имеет следующие важные отличия:</p> 
			<ul> 
			  <li>Интерфейсы содержат только объявления методов, а не их реализацию. Другими словами, каждый класс, реализующий интерфейс, должен обеспечить реализацию каждого метода, объявленного в интерфейсе.</li> 
			  <li>Определения методов интерфейса не могут иметь таких атрибутов, как <code>public</code> или <code>private</code>, но реализованные методы должны быть отмечены как <code>public</code> в определении класса, реализующего интерфейс.</li> 
			  <li>Несколько интерфейсов могут быть унаследованы интерфейсом при помощи инструкции <code>extends</code> или классом посредством инструкции <code>implements</code>.</li> 
			</ul>
			<p>В отличие от ActionScript 2.0, ActionScript 3.0 позволяет использовать методы получателя и установщика в определениях интерфейса.</p>
			
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">класс</a><br/><a href="statements.html#implements" target="">implements</a></div></div><a name="internal"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">internal</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
[internal] var varName
[internal] const kName
[internal] function functionName()  { 
	// your statements here 
}
[internal] class className{
	// your statements here 
}
[internal] namespace nsName
</pre> </p></td></tr></table><p></p><p><p>Показывает, что класс, переменная, константа или функция доступны для любой вызывающей программы в пределах того же пакета. Классы, свойства и методы принадлежат пространству имен <code>internal</code> по умолчанию.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Имя класса, который нужно задать как внутренний (internal).</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, которую нужно задать как внутреннюю (internal). Атрибут internal можно применять независимо от того, является переменная частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя константы, которую нужно задать как внутреннюю (internal). Атрибут internal можно применять независимо от того, является константа частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Имя функции или метода, которые нужно задать как внутренние (internal). Атрибут internal можно применять независимо от того, является функция частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Имя пространства имен, которое нужно задать как внутреннее (internal). Атрибут internal можно применять независимо от того, является пространство имен частью класса или нет.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#package" target="">package</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="label"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">label</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>label: statement
label: {
    statements
}</pre></p></td></tr></table><p></p><p><p>Связывает инструкцию с идентификатором, ссылка на который может указываться при помощи инструкции <code>break</code> или <code>continue</code>. Во вложенных циклах инструкция <code>break</code> или <code>continue</code>, которая не ссылается на метку, может пропустить только оставшуюся часть выполняемого на тот момент цикла, а не всю серию циклов. Однако если инструкция, которая определяет всю серию циклов, имеет связанную метку, то инструкция <code>break</code> или <code>continue</code> может пропустить всю серию циклов путем ссылки на эту метку.
			<p>Метки также позволяют выйти из блока инструкций. Нельзя вставить инструкцию <code>break</code>, которая не ссылается на метку, в блок инструкций, если этот блок инструкций не является частью цикла. Если блок инструкций имеет связанную метку, можно вставить инструкцию <code>break</code>, которая ссылается на эту метку в блоке инструкций.</p>		
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">label</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Действительный идентификатор, связываемый с инструкцией.</td></tr><tr><td width="20px"></td><td><code><span class="label">statements</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Инструкция, связываемая с меткой.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует использование метки во вложенном цикле для выхода из всей серии циклов. В коде используется вложенный цикл для создания списка чисел от 0 до 99. Инструкция break появляется непосредственно перед тем, как счет достигнет 80. Если бы инструкция break не использовала метку outerLoop, код пропустил бы только оставшуюся часть непосредственно выполняемого цикла и продолжил бы выводить числа от 90 до 99. Однако за счет использования метки outerLoop инструкция break пропускает всю серию циклов, и последним выводится число 79.
<div class="listing"><pre>
outerLoop: for (var i:int = 0; i < 10; i++) {
	for (var j:int = 0; j < 10; j++) {
		if ( (i == 8) && (j == 0)) {
			break outerLoop;
		}
		trace(10 * i + j);
	}
}
/*
1
2
...
79
*/
</pre></div>
В следующем примере показано использование метки с блоком инструкций. В следующем примере блок инструкций имеет метку foo, что позволяет инструкции break пропустить последнюю инструкцию в блоке:
<div class="listing"><pre>
foo: {
	trace("a");
	break foo;
	trace("b");
}
// a
</pre></div>

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a></div></div><a name="namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">namespace</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>namespace name [= uri]</pre> </p></td></tr></table><p></p><p><p>Позволяет управлять видимостью определений. Предопределенные пространства имен включают в себя <code>public</code>, <code>private</code>, <code>protected</code> и <code>internal</code>. 
			<p>Далее приводится процедура создания, применения и ссылки на пространство имен:</p>
			<ul>
			  <li>Во-первых, определите пользовательское пространство имен при помощи ключевого слова <code>namespace. </code> Например, код <code>namespace version1</code> создает пространство имен с именем <code>version1</code>.</li>
			  <li>Во-вторых, примените это пространство имен к свойству или методу путем его использования в объявлении свойства или метода. Например, код <code>version1 myProperty:String</code> создает свойство с именем <code>myProperty</code>, которое принадлежит пространству имен <code>version1</code></li>
			  <li>В-третьих, создайте ссылку на пространство имен при помощи ключевого слова <code>use</code> или путем использования пространства имен в качестве префикса идентификатора. Например, код <code>use namespace version1;</code> ссылается на пространство имен <code>version1</code> для последующих строк кода, а код <code>version1::myProperty</code> ссылается на пространство имен <code>version1</code> для свойства <code>myProperty</code>.</li>
			</ul>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Имя пространства имен, которым может быть любой допустимый идентификатор.</td></tr><tr><td width="20px"></td><td><code><span class="label">uri</span>:<a href="String.html">String</a></code> &mdash; Унифицированный идентификатор ресурса (URI-адрес) пространства имен. Этот параметр не является обязательным.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#package" target="">package</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="native"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">native</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
native function functionName();
class className { 
	native function methodName();
}</pre> </p></td></tr></table><p></p><p><p>Показывает, что функция или метод реализуются проигрывателем Flash Player в собственном коде. Проигрыватель Flash Player использует ключевое слово <code>native</code> внутренне для объявления функций и методов в интерфейсе программирования приложений (API) ActionScript. Данное ключевое слово нельзя использовать в пользовательском коде. &nbsp;			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="null"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">null</td><td class="detailHeaderType">ключевое слово первичного выражения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>null</pre></p></td></tr></table><p></p><p><p>Специальное значение, которое может быть присвоено переменным или возвращено функцией в отсутствие данных для обработки. Можно использовать <code>null</code> для представления значений, которые отсутствуют или которые не имеют определенного типа данных.
				<p> Значение <code>null</code> не следует путать со специальным значением <code>undefined</code>. Если значения <code>null</code> и <code>undefined</code> сравниваются с оператором равенства (<code>==</code>), они считаются равными. Однако когда значения <code>null</code> и <code>undefined</code> сравниваются с оператором строгого равенства (<code>===</code>), они не рассматриваются как равные.</p> 
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере проверяются первые шесть значений проиндексированного массива и выводится сообщение, если значение не задано (если value == null):
<div class="listing"><pre>

var testArray:Array = new Array();
testArray[0] = "fee";
testArray[1] = "fi";
testArray[4] = "foo";

for (i = 0; i < 6; i++) {
    if (testArray[i] == null) {
        trace("testArray[" + i + "] == null");
    }
}

/* 
testArray[2] == null
testArray[3] == null
testArray[5] == null
*/
</pre></div>	

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="package.html#undefined" target="">undefined</a></div></div><a name="object_proxy"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">object_proxy</td><td class="detailHeaderType"> Пространства имен </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><p></p><p><p>Определяет методы класса ObjectProxy. Методы класса ObjectProxy находятся в собственном пространстве имен во избежание конфликтов имен в случаях, когда подкласс Proxy содержит методы экземпляра с именами, которые совпадают с именами методов класса Proxy.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table></div><a name="override"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">override</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
override function name() { 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>Показывает, что метод заменяет наследуемый метод. Для переопределения наследуемого метода необходимо использовать атрибут <code>override</code> и убедиться в том, что имя, атрибут свойства класса, число, тип параметров и тип возвращаемого значения полностью совпадают. Попытка переопределить метод без использования атрибута <code>override</code> считается ошибкой. Более того, ошибкой считается использование атрибута <code>override</code>, если для метода не существует соответствующего наследуемого метода.
			<p>Атрибут <code>override</code> нельзя использовать с:</p>
			<ul>
			  <li>Переменные</li>
			  <li>Константы</li>
			  <li>Статическими методами</li>
			  <li>Методами, которые не наследуются</li>
			  <li>Методами, реализующими метод интерфейса</li>
			  <li>Наследуемыми методами, отмеченными в суперклассе как <code>final</code></li>
			</ul>
			<p>Хотя невозможно переопределить свойство, объявленное при помощи <code>var</code> или <code>const</code>, схожей функциональности можно достигнуть, преобразовав свойство базового класса в получатель-установщик и переопределив методы, определенные при помощи <code>get</code> и <code>set</code>.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">name</span>:<a href="Function.html">Function</a></code> &mdash; Имя переопределяемого метода.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#final" target="">final</a><br/><a href="statements.html#get" target="">get</a><br/><a href="statements.html#set" target="">set</a></div></div><a name="package"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">package</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
package packageName {
    class someClassName { 
    } 
}</pre> </p></td></tr></table><p></p><p><p>Позволяет организовать код в дискретные группы, которые смогут импортировать другие сценарии. Ключевое слово <code>package</code> необходимо использовать для указания на принадлежность класса пакету.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">packageName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя пакета.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#public" target="">public</a><br/><a href="statements.html#class" target="">class</a></div></div><a name="private"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">private</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	private var varName;
	private const kName;
	private function methodName() { 
		// your statements here 
	}
	private namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>Показывает, что переменная, константа или метод доступны только для класса, который объявляет или определяет их. В отличие от ActionScript 2.0, в ActionScript 3.0 <code>private</code> больше не обеспечивает доступ к подклассам. Более того, <code>private</code> ограничивает доступ как во время компиляции, так и во время выполнения. По умолчанию переменная или функция доступны любой вызывающей программе в пределах того же пакета. Используйте это ключевое слово для ограничения доступа к переменной или функции. 
			<p>Это ключевое слово можно использовать только в определениях класса, а не интерфейса. Ключевое слово <code>private</code> нельзя применить к классу или к другим определениям на уровне пакета.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, которую нужно задать как частную (private). Атрибут private можно применить, только если переменная находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя константы, которую нужно задать как частную (private). Атрибут private можно применить, только если константа находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Имя метода, который нужно задать как частный (private). Атрибут private можно применить, только если метод находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Имя пространства имен, которое нужно задать как частное (private). Атрибут private можно применить, только если пространство имен находится внутри класса.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует способ скрытия определенных свойств в классе при помощи ключевого слова private. 
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  public var beta:String = "visible everywhere"; 
}
	
class B extends A {
  function B() {
    alpha = "Access attempt from subclass"; // error
  }
}
</pre></div> 
Поскольку alpha является частной переменной, к ней нельзя получить доступ вне класса A, даже из подкласса B. Попытки получить доступ к этой частной переменной приведут к возникновению ошибки.
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#protected" target="">protected</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="protected"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">protected</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
class className{ 
	protected var varName;
	protected const kName;
	protected function methodName() { 
		// your statements here 
	}
	protected namespace nsName;
}</pre> </p></td></tr></table><p></p><p><p>Показывает, что переменная, константа, метод или пространство имен доступны только для класса, который определяет их, и для подклассов этого класса. Определение ключевого слова <code>protected</code> в ActionScript 3.0 подобно определению ключевого слова <code>private</code> версии ActionScript 2.0 за исключением того, что <code>protected</code> ограничивает доступ как во время компиляции, так и во время выполнения. По умолчанию переменная или функция доступны любой вызывающей программе в пределах того же пакета. Используйте это ключевое слово для ограничения доступа к переменной или функции.  
				<p>Это ключевое слово можно использовать только в определениях класса, а не интерфейса. Ключевое слово <code>private</code> нельзя применить к классу или к другим определениям на уровне пакета.</p>
				<p>Определение ключевого слова <code>protected</code> в ActionScript 3.0 является более ограничительным, чем определение <code>protected</code> в языке программирования Java. В ActionScript 3.0 <code>protected</code> разрешает доступ строго к подклассам, тогда как в Java <code>protected</code> разрешает доступ также к любому классу в пределах того же пакета. Например, если класс с именем <code>Base</code> содержит свойство, отмеченное как <code>protected</code>, в ActionScript 3.0 только классы, расширяющие класс Base, имеют доступ к этому защищенному свойству. В Java любой класс, который находится в том же пакете, что и класс Base, имеет доступ к защищенному свойству, даже если этот класс не является подклассом класса Base.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, которую нужно задать как защищенную (protected). Атрибут protected можно применить, только если переменная находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя константы, которую нужно задать как защищенную (protected). Атрибут protected можно применить, только если константа находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Имя метода, который нужно задать как защищенный (protected). Атрибут protected можно применить, только если метод находится внутри класса.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Имя пространства имен, которое нужно задать как защищенное (protected). Атрибут protected можно применить, только если пространство имен находится внутри класса.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий код создает переменную в защищенном классе A и успешно получает доступ к этой переменной в классе B, так как класс B является подклассом класса A.
<div class="listing"><pre>
class A { 
  private var alpha:String = "visible only inside class A"; 
  protected var beta:String = "visible inside class A and its subclasses"; 
}
	
class B extends A {
  public function B() {
    beta = "Access attempt from subclass succeeded";
    trace(beta);  // Access attempt from subclass succeeded
  }
}
</pre></div>
			
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#public" target="">public</a></div></div><a name="public"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">public</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
public var varName
public const kName
public function functionName()  { 
	// your statements here 
}
public class className {
	// your statements here 
}
public namespace nsName
</pre> </p></td></tr></table><p></p><p><p>Показывает, что класс, переменная, константа или метод доступны для любой вызывающей программы. Классы, переменные и методы являются внутренними (internal) по умолчанию, т.е. они видимы только в пределах текущего пакета. Чтобы сделать класс, переменную или метод видимыми для всех вызывающих программ, необходимо использовать атрибут <code>public</code>.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">className</span>:<a href="Class.html">Class</a></code> &mdash; Имя класса, который нужно задать как общедоступный (public).</td></tr><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, которую нужно задать как общедоступную (public). Атрибут public можно применять независимо от того, является переменная частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя константы, которую нужно задать как общедоступную (public). Атрибут public можно применять независимо от того, является константа частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; Имя функции или метода, которые нужно задать как общедоступные (public). Атрибут public можно применять независимо от того, является функция частью класса или нет.</td></tr><tr><td width="20px"></td><td><code><span class="label">nsName</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Имя пространства имен, которое нужно задать как общедоступное (public). Атрибут public можно применять независимо от того, является пространство имен частью класса или нет.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует использование общедоступных переменных в файле класса: 
<div class="listing"><pre>class User { 
	public var age:Number; 
	public var fname:String; 
} // end of class User definition
 
var jimmy:User = new User(); 
jimmy.age = 27; 
jimmy.fname = "jimmy";
trace(jimmy.age, jimmy.fname); // 27 jimmy</pre></div> 
Если изменить одну из общедоступных переменных в классе User на частную переменную, любая попытка получить доступ к этой переменной за пределами класса User приведет к ошибке этапа компиляции. 

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#internal" target="">internal</a><br/><a href="statements.html#private" target="">private</a><br/><a href="statements.html#protected" target="">protected</a></div></div><a name="return"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">return</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function functionName () {
	return [expression]
}</pre></p></td></tr></table><p></p><p><p>Заставляет процесс выполнения незамедлительно вернуться к вызывающей функции. Если за инструкцией <code>return</code> следует выражение, то выражение вычисляется, и возвращается результат. 
			<p>Если определение функции содержит тип возвращаемого значения, за инструкцией <code>return</code> должно следовать выражение. Если тип возвращаемого значения не указан и инструкция <code>return</code> используется одна, возвращается значение <code>undefined</code>.</p>
			<p>Возврат нескольких значений невозможен. При попытке сделать это будет возвращено только последнее значение. В следующем примере <code>c</code> возвращается:</p> <pre>return a, b, c ;</pre> <p>Если необходим возврат нескольких значений, используйте вместо этого массив или объект.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Выражение, которое нужно вычислить и вернуть в качестве значения функции. Этот параметр является необязательным.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере инструкция return используется в теле функции sum() для возврата суммы трех параметров. Следующая строка кода вызывает sum() и присваивает возвращенное значение переменной newValue. 
<div class="listing"><pre>function sum(a:Number, b:Number, c:Number):Number { 
	return (a + b + c); 
} 
var newValue:Number = sum(4, 32, 78); 
trace(newValue); // 114</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#function" target="">функция</a></div></div><a name="set"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">set</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>
function set property(newValue:*) : void{ 
	// your statements here 
}</pre> 
			</p></td></tr></table><p></p><p><p>Определяет установщик &mdash; метод, отображаемый в общедоступном интерфейсе как свойство. Установщик &mdash; это специальный метод, который задает значение свойства, объявленного при помощи ключевого слова <code>var</code>. В отличие от других методов, установщик вызывается без использования круглых скобок (<code>()</code>), что делает его похожим на переменную.
			<p>Установщики дают возможность применять принцип скрытия информации, позволяя создавать общедоступный интерфейс для частного свойства. Преимуществом скрытия информации является то, что общедоступный интерфейс не изменяется даже при изменении реализации частного свойства.</p>
			<p>Еще одним преимуществом установщиков является то, что они могут переопределяться в подклассах, а свойства, объявленные при помощи ключевых слов <code>var</code>, не могут.</p>
			<p>Возвращаемое установщиком значение может относиться к типу <code>void</code> или не указываться.</p>
			<p>Установщик может использоваться совместно с получателем для создания свойства чтения-записи. Для создания свойства только для чтения создайте получатель без соответствующего установщика. Для создания свойства только для записи создайте установщик без соответствующего получателя.</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">property</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Идентификатор свойства, которое изменяется при помощи инструкции set; это значение должно быть тем же, что используется в соответствующей команде get.</td></tr><tr><td width="20px"></td><td><code><span class="label">newValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Новое присваиваемое значение.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере создается свойство чтения-записи с именем age путем определения получателя-установщика.
<div class="listing"><pre>
package {
	class User { 
	    private var userAge:Number; 
	    
	    public function get age():Number {
	    	return userAge;
	    }
	    
	    public function set age(x:Number):void {
	    	userAge = x;	
	    }
	} 
} 
</pre></div>
Введите в сценарий следующий код:
<div class="listing"><pre>
var myUser:User = new User();
myUser.age = 25;
trace(myUser.age); // 25
</pre></div>
			
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#get" target="">get</a></div></div><a name="static"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">static</td><td class="detailHeaderType">ключевое слово атрибута</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>class someClassName{ 
	static var varName; 
	static const kName;
	static function methodName() { 
		// your statements here
	} 
}</pre> </p></td></tr></table><p></p><p><p>Показывает, что переменная, константа или метод принадлежит классу, а не экземплярам класса.
			<p>Для доступа к статическому члену класса используйте имя класса вместо имени экземпляра. Например, класс Date имеет статический метод с именем <code>parse()</code>, который можно вызвать только при помощи следующего синтаксиса:</p>
			<div class="listing"><pre>Date.parse()</pre></div>
			<p>Метод <code>parse()</code> невозможно вызвать для экземпляра класса Date. Например, в следующем коде создается ошибка:</p>
			<div class="listing"><pre>var myDate:Date = new Date();
            myDate.parse("Jan 01 00:00:00 2006"); // error</pre></div>
			<p>Можно использовать <code>static</code> только в определениях класса, а не интерфейса.</p>
			<p>Статические члены класса не наследуются. Невозможно сослаться на статический член класса, используя имя подкласса, что возможно в Java или C++. Однако можно сослаться на статическую переменную или статический метод в пределах класса или подкласса без использования квалификатора. См. пример ниже.</p>
			<p>Инструкцию <code>super</code> или ключевое слово <code>this</code> нельзя использовать внутри статического метода.</p>
			
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">varName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя переменной, которую нужно задать как статическую (static).</td></tr><tr><td width="20px"></td><td><code><span class="label">kName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Имя константы, которую нужно задать как статическую (static).</td></tr><tr><td width="20px"></td><td><code><span class="label">methodName</span>:<a href="Function.html">Function</a></code> &mdash; Имя метода, который нужно задать как статический (static).</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует использование ключевого слова static для создания счетчика, который отслеживает количество созданных экземпляров класса. Поскольку переменная numInstances является статической, она будет создана только один раз для всего класса, а не для отдельных экземпляров. Создайте новый файл ActionScript с именем Users.as и введите следующий код: 
<div class="listing"><pre>class Users { 
	private static var numInstances:Number = 0; 
	function Users() { 
		numInstances++; 
	} 
	static function get instances():Number { 
		return numInstances; 
	} 
}</pre></div> 
Введите в сценарий следующий код:
<div class="listing"><pre>
trace(Users.instances); 
var user1:Users = new Users(); 
trace(Users.instances); 
var user2:Users = new Users(); 
trace(Users.instances); 
</pre></div>
В следующем примере класс Users расширяется, чтобы показать, что статические переменные и методы не наследуются, но на них можно сослаться в подклассах.
<div class="listing"><pre>
class PowerUsers extends Users{
    function PowerUsers() {
        instances++;  // unqualified reference to static property Users.instances is legal
    }
}

trace(PowerUsers.instances); // error, cannot access static property using PowerUsers class
</pre></div>

			<p></p></div><a name="super"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">super</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>super([arg1, ..., argN])
super.method([arg1, ..., argN])</pre></p></td></tr></table><p></p><p><p>Вызывает суперклассовую или родительскую версию метода или конструктора. При использовании в теле конструктора класса инструкция <code>super()</code> вызывает суперклассовую версию конструктора. В вызове конструктора суперкласса должно быть правильное количество аргументов. Заметьте, что конструктор суперкласса вызывается всегда, независимо от того, осуществляется ли его вызов явным образом. Если он не вызывается явным образом, вызов без аргументов автоматически вставляется перед первой инструкцией в теле конструктора подкласса. Это значит, что если функция конструктора определена в подклассе, а конструктор суперкласса принимает один или несколько аргументов, необходимо вызвать конструктор суперкласса явным образом с правильным числом аргументов, иначе произойдет ошибка. Вызов конструктора суперкласса, однако, не обязательно должен быть первой инструкцией в конструкторе подкласса, как это должно быть в ActionScript 2.0.
			<p>При использовании в теле метода экземпляра <code>super</code> может использоваться с оператором «точка» (.) для вызова суперклассовой версии метода и дополнительно передавать аргументы <code>(arg1 ... argN)</code> методу суперкласса. Это полезно для создания методов подкласса, которые не только обеспечивают дополнительное поведение методов суперкласса, но и вызывают методы суперкласса для реализации их исходного поведения.</p>
			<p>Инструкцию <code>super</code> нельзя использовать в статическом методе.</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">method</span>:<a href="Function.html">Function</a></code> &mdash; Метод, который нужно вызвать в суперклассе.</td></tr><tr><td width="20px"></td><td><code><span class="label">argN</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Дополнительные параметры, передаваемые суперклассовой версии метода или функции конструктора суперкласса.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#class" target="">class</a><br/><a href="statements.html#extends" target="">extends</a></div></div><a name="switch"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">switch</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p>
<pre>
switch (expression) {
	caseClause: 
	[defaultClause:] 
}</pre></p></td></tr></table><p></p><p><p>Приводит к передаче управления одной из нескольких инструкций в зависимости от значения выражения. Все инструкции <code>switch</code> должны включать в себя блок по умолчанию, который будет выполняться, если ни одна из инструкций <code>case</code> не соответствует выражению. Каждая инструкция <code>case</code> должна заканчиваться инструкцией <code>break</code>, что предотвращает ошибку прохода при невыполнении условия. При такой ошибке выполняется код в следующей инструкции <code>case</code>, даже если этот блок не соответствует проверяемому выражению.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Любое выражение.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере определяется инструкция switch, которая переходит к блоку по умолчанию:

<div class="listing"><pre>

var switchExpression:int = 3;
		
switch (switchExpression) {
	case 0:
		trace(0);
		break;
	case 1:
		trace(1);
		break;
	case 2:
		trace(2);
		break;
	default:
		trace("Not 0, 1, or 2");
}

// Not 0, 1, or 2
</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="operators.html#strict_equality" target="">=== (строгое равенство)</a><br/><a href="statements.html#case" target="">case</a><br/><a href="statements.html#default" target="">default</a></div></div><a name="this"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">this</td><td class="detailHeaderType">ключевое слово первичного выражения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>this</pre></p></td></tr></table><p></p><p><p>Ссылка на объект, содержащий метод. При выполнении сценария ключевое слово <code>this</code> ссылается на объект, содержащий сценарий. В теле метода ключевое слово <code>this</code> ссылается на экземпляр класса, который содержит вызываемый метод.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Для вызова функции, определенной в динамическом классе, ключевое слово this используется для вызова этой функции в соответствующей области видимости:
<div class="listing"><pre>
// incorrect version of Simple.as
/*
dynamic class Simple {
    function callfunc() {
        func();
    }
}
*/
// correct version of Simple.as
dynamic class Simple {
    function callfunc() {
        this.func();
    }
}
</pre></div>
Добавьте в сценарий следующий код:
<div class="listing"><pre>
var simpleObj:Simple = new Simple();
simpleObj.func = function() {
	trace("hello there");
}
simpleObj.callfunc();
</pre></div>
Предыдущий код работает при использовании ключевого слова this в методе callfunc(). Однако произошла бы синтаксическая ошибка при использовании неправильной версии Simple.as, которая была обозначена комментарием в примере выше.

			
			<p></p></div><a name="throw"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">throw</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>throw expression </pre></p></td></tr></table><p></p><p><p>Генерирует, или <em>выбрасывает</em>, ошибку, которая может быть обработана, или <em>перехвачена</em>, блоком кода <code>catch</code>. Если исключение не перехвачено блоком <code>catch</code>, строковое представление возвращенного значения отправляется на панель «Вывод». Если исключение не перехвачено блоком <code>catch</code> или блоком <code>finally</code>, строковое представление возвращенного значения отправляется на панель «Вывод». <p>Как правило, возвращаются экземпляры класса Error или его подклассов (см. раздел «Примеры»).</p></p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Выражение или объект ActionScript.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В данном примере функция с именем checkEmail() проверяет, является ли переданная ей строка верно отформатированным адресом электронной почты. Если строка не содержит символ @, функция выдает ошибку. 
<div class="listing"><pre>function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new Error("Invalid email address"); 
	} 
} 
checkEmail("someuser_theirdomain.com");</pre></div> 
Затем следующий код вызывает ту же функцию, checkEmail(), с блоком кода try. Если строка не содержит действительный адрес электронной почты, инструкция trace выдает сообщение об ошибке.
<div class="listing"><pre>
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e); 
}
// Error: Invalid email address.</pre></div> 
В следующем примере возвращается подкласс класса Error. Функция checkEmail() изменяется, чтобы возвратить экземпляр этого подкласса.
<div class="listing"><pre>
// Define Error subclass InvalidEmailError 
class InvalidEmailAddress extends Error { 
    public function InvalidEmailAddress() {
    	message = "Invalid email address."; 
    }
}
</pre></div> 
Введите в сценарий следующий код:
<div class="listing"><pre>
import InvalidEmailAddress; 
function checkEmail(email:String) { 
	if (email.indexOf("@") == -1) { 
		throw new InvalidEmailAddress(); 
	} 
} 
try { 
	checkEmail("Joe Smith"); 
} 
catch (e) { 
	trace(e);
}
// Error: Invalid email address.</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="Error.html" target="">Класс Error</a><br/><a href="statements.html#try..catch..finally" target="">try..catch..finally</a></div></div><a name="true"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">true</td><td class="detailHeaderType">ключевое слово первичного выражения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>true</pre></p></td></tr></table><p></p><p><p>Логическое значение, представляющее true. Логическим значением становится либо <code>true</code>, либо <code>false</code>, причем значения <code>true</code> и <code>false</code> являются противоположными. Если в процессе автоматической типизации данных <code>true</code> преобразуется в число, то оно становится 1; при преобразовании <code>true</code> в строку, оно принимает вид <code>"true"</code>.
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует использование значения true в инструкции if:
<div class="listing"><pre>

var shouldExecute:Boolean;
// ...
// code that sets shouldExecute to either true or false goes here
// shouldExecute is set to true for this example:

shouldExecute = true;

if (shouldExecute == true) {
    trace("your statements here");
}

// true is also implied, so the if statement could also be written:
// if (shouldExecute) {
//         trace("your statements here");
// }</pre></div>
В следующем примере показано преобразование true в число 1 во время процесса автоматической типизации:
<div class="listing"><pre>

var myNum:Number;
myNum = 1 + true;
trace(myNum); // 2</pre></div>

			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="Boolean.html" target="">Класс Boolean</a><br/><a href="statements.html#false" target="">false</a></div></div><a name="try..catch..finally"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">try..catch..finally</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>try { 
    // try block 
} finally { 
    // finally block  
} 

try { 
    // try block 
} catch(error[:ErrorType1]) {
    // catch block 
} [catch(error[:ErrorTypeN]) { 
    // catch block 
}] [finally {
    // finally block 
}]</pre></p></td></tr></table><p></p><p><p>Обрамляет блок кода, в котором может произойти ошибка, затем реагирует на ошибку. Обработка исключений, реализованная с использованием инструкций <code>try..catch..finally</code>, является основным механизмом обработки ошибок времени выполнения в ActionScript 3.0. Когда возникает ошибка времени выполнения, Flash Player выдает исключение, то есть Flash Player прекращает нормальное выполнение кода и создает специальный объект типа <code>Error</code>. Затем проигрыватель Flash Player передает, или <em>выбрасывает</em>, объект ошибки первому доступному блоку <code>catch</code>. Если доступных блоков <code>catch</code> нет, исключение считается неперехваченным. Неперехваченные исключения прерывают выполнение сценария.
			<p>Инструкцию <code>throw</code> можно использовать для возврата исключений в коде явным образом. Рекомендуется возвращать объект, так как это обеспечивает гибкость и соответствует поведению проигрывателя Flash Player.</p>
			<p>Для перехвата исключения, возвращенного проигрывателем Flash Player или пользовательским кодом, вставьте код, который может выдать исключение в блоке <code>try. </code> Если какой-либо код в блоке <code>try</code> выдаст исключение, управление передается блоку <code>catch</code> при его наличии, затем блоку <code>finally</code>, если такой существует. Блок <code>finally</code> всегда выполняется, независимо от того, было ли возвращено исключение. Если код в блоке <code>try</code> не выдает исключение (т.е. при нормальном выполнении блока <code>try</code>), код в блоке <code>catch</code> игнорируется, но код в блоке <code>finally</code> все же выполняется. Блок <code>finally</code> выполняется, даже если блок <code>try</code> завершается инструкцией <code>return</code>. </p>
			<p>За блоком <code>try</code> должен следовать блок <code>catch</code>, блок <code>finally</code> или и тот, и другой. Один блок <code>try</code> может содержать несколько блоков <code>catch</code>, но только один блок <code>finally</code>. Можно вложить столько уровней блока <code>try</code>, сколько нужно.</p> 
			<p>Параметр <code>error</code>, заданный в обработчике <code>catch</code>, должен быть простым идентификатором, например, <code>e</code> или <code>theException</code> или<code>x</code>. Параметр может быть типизированным. При использовании с несколькими блоками <code>catch</code> типизированные параметры позволяют перехватывать различные типы объектов ошибок, возвращенные одним блоком <code>try</code>.</p> 
			<p>Если возвращенное исключение является объектом, совпадение типов произойдет, если возвращенный объект является подклассом указанного типа. Если возвратилась ошибка конкретного типа, выполняется блок <code>catch</code>, обрабатывающий соответствующие ошибки. Если возвращено исключение не указанного типа, блок <code>catch</code> не выполняется, и исключение автоматически передается из блока <code>try</code> соответствующему обработчику <code>catch</code>. </p> 
			<p>Если ошибка произошла в функции, которая не содержит обработчик <code>catch</code>, Flash Player завершает выполнение этой функции, а также вызывающих функций, пока не будет найден блок <code>catch. </code> Во время этого процесса обработчики <code>finally</code> вызываются на всех уровнях.</p>
			<p>Примечание. Если в блоке try имеется диспетчер событий, который вызывает обработчик событий, блок catch не перехватывает ошибку, если ее выдает обработчик событий. Любую ошибку, выданную после этого момента, можно перехватить, прослушивая <code>LoaderInfo.uncaughtErrorEvents</code>.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">error</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Выражение, возвращенное инструкцией throw; как правило, это экземпляр класса Error или один из его подклассов.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий пример иллюстрирует использование инструкции try..catch. Код в блоке try содержит недопустимую операцию. Спрайт не может добавить себя в качестве дочернего объекта. В результате проигрыватель Flash Player выдает исключение и передает объект типа ArgumentError соответствующему блоку catch.
<div class="listing"><pre>
import flash.display.Sprite;

var spr:Sprite = new Sprite();
try {
	spr.addChild(spr);
}
catch (e:ArgumentError) {
	trace (e); // ArgumentError: Error #2024: An object may not be added as a child of itself.
}
</pre></div> 
В следующем примере объекты RecordSetException и MalformedRecord являются подклассами класса Error.  
<div class="listing"><pre>
class RecordSetException extends Error { 
	public function RecordSetException () {
		message = "Record set exception occurred."; 
	}
}

class MalformedRecord extends Error { 
	public function MalformedRecord {
		message = "Malformed record exception occurred."; 
	}
}</pre></div> 

В методе sortRows() класса RecordSet возвращается один из ранее определенных объектов ошибки в зависимости от типа исключения. В следующем примере показано, как может выглядеть такой код: 
<div class="listing"><pre>
class RecordSet { 
	public function sortRows() { 
		var returnVal:Number = randomNum(); 
		if (returnVal == 1) { 
			throw new RecordSetException(); 
		} 
		else if (returnVal == 2) { 
			throw new MalformedRecord(); 
		} 
	}
	public function randomNum():Number { 
		return Math.round(Math.random() * 10) % 3; 
	}
}</pre></div> 
Наконец, следующий код вызывает метод sortRows() для экземпляра класса RecordSet. Он определяет блоки catch для каждого типа объекта ошибки, возвращаемого методом sortRows().
<div class="listing"><pre>import RecordSet; 
var myRecordSet:RecordSet = new RecordSet();
try { 
	myRecordSet.sortRows(); 
	trace("everything is fine"); 
} 
catch (e:RecordSetException) { 
	trace(e.toString()); 
} 
catch (e:MalformedRecord) { 
	trace(e.toString()); 
}</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="Error.html" target="">Класс Error</a><br/><a href="statements.html#throw" target="">throw</a></div></div><a name="use_namespace"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">use namespace</td><td class="detailHeaderType">директива</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>use namespace ns1[, ns2, ...nsN]</pre></p></td></tr></table><p></p><p><p>Приводит к добавлению заданных пространств имен в набор открытых пространств имен. Заданные пространства имен удаляются из набора открытых пространств имен при выходе из текущего блока кода. Директива <code>use namespace</code> может быть на верхнем уровне программы, определения пакета или определения класса.</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">nsN</span>:<a href="Namespace.html">Namespace</a></code> &mdash; Одно или несколько пространств имен, добавляемых в набор открытых пространств имен.</td></tr></table><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#default_xml_namespace" target="">default xml namespace</a><br/><a href="statements.html#namespace" target="">namespace</a><br/><a href="XML.html" target="">Класс XML</a></div></div><a name="var"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">var</td><td class="detailHeaderType">ключевое слово определения</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>var variableName [= value1][...,variableNameN[=valueN]] </pre></p></td></tr></table><p></p><p><p>Задает переменную. При объявлении переменных в функции переменные становятся локальными. Они определяются для функции и прекращают действовать в конце вызова функции. 
			 
			<p>Невозможно объявить переменную, которая входит в область видимости другого объекта, как локальную.</p> 
<pre>my_array.length = 25; // ok 
var my_array.length = 25; // syntax error </pre> 
			<p>Переменной можно присвоить тип данных, добавив к ней двоеточие, за которым следует обозначение типа данных.</p>
			<p>Можно объявить несколько переменных в одной инструкции, разделяя объявления запятыми (хотя такой синтаксис может ухудшить ясность кода):</p>
			<pre>var first:String = "Bart", middle:String = "J.", last:String = "Bartleby";</pre>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; Идентификатор.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий сценарий ActionScript создает новый массив названий продуктов. Array.push добавляет элемент в конец массива. 
<div class="listing"><pre>
var product_array:Array = new Array("Studio", "Dreamweaver", "Flash", "ColdFusion", "Contribute", "Breeze"); 
product_array.push("Flex"); 
trace(product_array); 
// Studio,Dreamweaver,Flash,ColdFusion,Contribute,Breeze,Flex</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#const" target="">const</a></div></div><a name="while"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">while</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>while (condition) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Вычисляет условие и, если получено значение <code>true</code>, выполняет инструкцию или набор инструкций перед возвращением по циклу к повторному вычислению условия. Если в результате вычисления условия получено значение <code>false</code>, инструкции не выполняются, и цикл завершается. 
			<p>Инструкция <code>while</code> выполняет следующую серию действий. Каждое повторение шагов с 1 по 4 называется <em>итерацией</em> цикла. Условие проверяется в начале каждой итерации, как показано ниже:</p> 
			<ol> 
				<li>Выражение <code>condition</code> вычисляется.</li> 
				<li>Если выражение <code>condition</code> принимает значение <code>true</code> или значение, которое может быть преобразовано в логическое значение <code>true</code>, например число, отличное от нуля, выполняется переход к шагу 3. В противном случае завершается инструкция <code>while</code>, и выполнение возобновляется со следующей инструкции после цикла <code>while</code>.</li> 
				<li>Выполните блок инструкций <code>statement(s)</code>. При появлении инструкции <code>continue</code> пропустите оставшиеся инструкции и перейдите к шагу 1. При появлении инструкции <code>break</code> завершается инструкция <code>while</code>, и выполнение возобновляется со следующей инструкции после цикла <code>while</code>.</li> 
				<li>Перейдите к шагу 1.</li> 
			</ol> 
			<p>Зацикливание обычно используется для выполнения действия до тех пор, пока переменная counter меньше заданного значения. В конце каждого цикла счетчик увеличивается на единицу до тех пор, пока не будет получено заданное значение. При этом выражение <code>condition</code> не принимает значение <code>true</code>, и цикл завершается.</p> 
			<p>Фигурные скобки (<code>{}</code>), в которых заключены инструкции для выполнения инструкцией <code>while</code>, не требуются при выполнении только одной инструкции.</p>
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">condition</span>:<a href="Boolean.html">Boolean</a></code> &mdash; Выражение, принимающее значение true или false.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>В следующем примере инструкция while используется для проверки выражения. Когда значение i меньше 20, выполняется трассировка значенияi. Когда условие перестает принимать значение true, цикл завершается. 
<div class="listing"><pre>
var i:Number = 0; 
while (i < 20) { 
	trace(i); 
	i += 3; 
}
/*
0 
3 
6 
9 
12
15 
18
*/</pre></div>
			<p></p><p><span class="label"> Связанные элементы API </span></p><div class="seeAlso"><a href="statements.html#break" target="">break</a><br/><a href="statements.html#continue" target="">continue</a><br/><a href="statements.html#do..while" target="">do..while</a></div></div><a name="with"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">with</td><td class="detailHeaderType">инструкция</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Применение</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p><pre>with (object:Object) { 
	// statement(s)
}</pre></p></td></tr></table><p></p><p><p>Устанавливает объект по умолчанию, который используется при выполнении одной или нескольких инструкций, потенциально сокращая размер кода, который будет написан.
			<p>Параметр <code>object</code> становится контекстом, в котором считываются свойства, переменные и функции в параметре <code>statement(s)</code>. Например, если <code>object</code> является <code>my_array</code>, для которого заданы свойства <code>length</code> и <code>concat</code>, эти свойства автоматически считываются как <code>my_array.length</code> и <code>my_array.concat</code>. Или если <code>object</code> является <code>state.california</code>, любые действия или инструкции в инструкции <code>with</code> вызываются из экземпляра <code>california</code>.</p> 
			<p>ActionScript начинает поиск значения идентификатора в параметре <code>statement(s)</code> с начала цепочки областей видимости, заданной объектом <code>object</code>, и выполняет поиск идентификатора на каждом уровне этой цепочки в определенном порядке. </p> 
			<p>Цепочка областей видимости, используемая в инструкции <code>with</code> для разрешения идентификаторов, начинается с первого элемента следующего списка и заканчивается последним элементом:</p> 
			<ul> 
				<li>Объект, заданный параметром <code>object</code> в наиболее глубоко вложенной инструкции <code>with</code></li> 
				<li>Объект, заданный параметром <code>object</code> в самой ближней внешней инструкции <code>with</code></li> 
				<li>Объект Activation (временный объект, создаваемый автоматически при вызове сценарием функции, содержащей локальные переменные, вызываемые функцией)</li> 
				<li>Объект, содержащий сценарий, который выполняется в данный момент</li> 
				<li>Объект Global (встроенные объекты, например Math и String)</li> 
			</ul> 
			<p>Чтобы задать переменную в инструкции <code>with</code>, необходимо предварительно объявить переменную за пределами инструкции <code>with</code> или ввести полный путь к временной шкале, на которой будет находиться переменная. Если задать переменную в инструкции <code>with</code> без ее объявления, инструкция <code>with</code> будет выполнять поиск значения в соответствии с цепочкой областей видимости. Если переменная еще не существует, то временной шкале, из которой была вызвана инструкция <code>with</code>, будет задано новое значение.</p> 
			</p></p><p></p><span class="label">Параметры</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; Экземпляр объекта ActionScript или фрагмент ролика.</td></tr></table><br/><span class="label">Пример</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span><br/>Следующий код задает свойства _x и _y экземпляра someOther_mc, затем предписывает someOther_mc перейти к Кадру 3 и остановиться. 
with (someOther_mc) { 
	_x = 50; 
	_y = 100; 
	gotoAndStop(3); 
} 
Следующий фрагмент кода иллюстрирует написание предшествующего кода без использования инструкции with. 
someOther_mc._x = 50; 
someOther_mc._y = 100; 
someOther_mc.gotoAndStop(3); 
Инструкция with используется для доступа к нескольким элементам в списке цепочки областей видимости одновременно. В следующем примере встроенный объект Math помещается в начало цепочки областей видимости. Установка Math в качестве объекта по умолчанию разрешает идентификаторы cos, sin и PI в Math.cos, Math.sin и Math.PI соответственно. Идентификаторы a, x, y и r не являются методами или свойствами объекта Math, но поскольку они существуют в области активации объекта функции polar(), они разрешаются в соответствующие локальные переменные. 
<div class="listing"><pre>function polar(r:Number):void { 
	var a:Number, x:Number, y:Number; 
	with (Math) { 
		a = PI * pow(r, 2); 
		x = r * cos(PI); 
		y = r * sin(PI / 2); 
	} 
	trace("area = " + a); 
	trace("x = " + x); 
	trace("y = " + y); 
} polar(3);
/* 
area = 28.2743338823081 
x = -3 
y = 3
*/</pre></div>
			<p></p></div><p></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:52 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ru_RU/legalnotices/index.html">Юридическая информация</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Политика конфиденциальности онлайн</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Почему по-английски?</span>
				</div>
				<div class="white_content_body">
					<b>Содержимое Справочника ActionScript 3.0 отображается на английском языке</b><br><br>
					Не все части Справочника ActionScript 3.0 переводятся на все языки. Если какой-то текстовый элемент не переведен, он отображается на английском языке. Например, компонент ga.controls.HelpBox не переведен ни на один из языков. Это значит, что в русской версии справки компонент ga.controls.HelpBox будет отображаться на английском языке.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:52 AM Z  -->
