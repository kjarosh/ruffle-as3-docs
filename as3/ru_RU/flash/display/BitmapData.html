<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Справочник по ActionScript&reg; 3.0 для платформы Adobe&reg; Flash&reg;  "><meta name="lang" content="ru-ru"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Adobe ActionScript&reg; 3 (AS3 )</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Среды выполнения";
			var productsLabel = "Продукты";
			var noneLabel = "Не задан";
			var qsearchBoxLabel = "Быстрый поиск";
			var qsearchText = "Термин не найден";
			var ajaxErrorMsg="Ошибка при загрузке страницы";
			var ajaxErrorTryMsg="Повторите попытку";
			var ajaxLoadingMsg="Загрузка еще не завершена";
			var cancelMsg = "Отмена";
			var classesText = "Классы";
			var strJiveReply = "Этот вопрос был задан по поводу следующей статьи: "
			var showFilters = "Показать фильтры";
			var hideFilters = "Скрыть фильтры";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Справочник по ActionScript<sup>&reg;</sup> 3.0 для платформы Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Домашняя страница </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">Показать список пакетов и классов</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">Скрыть список пакетов и классов</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Пакеты </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Классы </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Что нового </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Указатель </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Приложения </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Почему по-английски?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ru_RU/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Фильтры:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Получение данных с сервера...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Получение данных с сервера...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> Свойства </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Свойства </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Конструктор </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> Методы </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> Глобальные константы </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> События </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> Стили </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> Компоненты темы оформления </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> Состояния тем оформления </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> Эффекты </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> Константы </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> Глобальные функции </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">Функции</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> Интерфейсы </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> Классы </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> Примеры </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Классы
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Пакет</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">Класс</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">Наследование</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">Реализует</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 Класс BitmapData позволяет работать с данными (пикселями) <span>объекта Bitmap</span>. Методы класса BitmapData можно использовать для создания прозрачных или непрозрачных растровых изображений произвольного размера и выполнять с ними различные операции. <span> Также можно обращаться к BitmapData для получения растрового изображения, загружаемого с помощью класса <code>flash.display.Loader</code>. </span> 
 
               <p>Этот класс позволяет отделить операции по визуализации растрового изображения от внутренних подпрограмм обновления отображения проигрывателя Flash Player. Путем манипуляции с объектом BitmapData напрямую можно создавать сложные изображения без необходимости постоянно перерисовывать содержимое из векторных данных в каждом кадре.</p>
 
               <p>Методы класса BitmapData поддерживают эффекты, не доступные через фильтры, предусмотренные для нерастровых экранных объектов.</p>
 
               <p>Объект BitmapData содержит массив пиксельных данных. Эти данные могут представлять собой либо полностью непрозрачное растровое изображение, либо прозрачное растровое изображение с данными альфа-канала. Объекты BitmapData любого типа сохраняются в виде буфера 32-разрядных целых чисел. Каждое 32-разрядное целое число определяет свойства одного пикселя в растровом изображении.</p>
 
               <p>Каждое 32-разрядное целое число представляет собой комбинацию 8-разрядных значений каналов (от 0 до 255), описывающих альфа-прозрачность и значения красного, зеленого и синего (ARGB) пикселя. (Для значений ARGB наиболее значимый байт представляет значение альфа-канала, а за ним следуют красный, зеленый и синий.)</p>
 
               <p>Четыре канала (альфа-канал, красный, зеленый и синий) представлены числами при использовании в методе <code>BitmapData.copyChannel()</code> или свойствами <code>DisplacementMapFilter.componentX</code> и <code>DisplacementMapFilter.componentY</code>, и эти числа представлены следующими константами класса BitmapDataChannel:</p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>Объекты BitmapData можно присоединить к объекту Bitmap с помощью свойства <code>bitmapData</code> объекта Bitmap.</p>
 
               <p>Объект BitmapData можно использовать для заполнения объекта Graphics с помощью метода<code>Graphics.beginBitmapFill()</code>.</p>
 
               <p>Во время выполнения AIR классы DockIcon, Icon, InteractiveIcon и SystemTrayIcon имеют свойство <code>bitmaps</code>, которое является массивом объектов BitmapData, определяющих растровые изображения значка.</p>
 
               <p>В AIR 1.5 и Flash Player 10 максимальный размер объекта BitmapData составляет 8,191 пикселя в ширину или высоту, а общее количество пикселей не может превышать 16,777,215. (Т. е. если ширина объекта BitmapData составляет 8,191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину.</p>
 
               <p>Начиная с версии AIR 3 и проигрывателя Flash Player 11 ограничения по размеру для объекта BitmapData удалены. Максимальный размер растрового изображения теперь зависит от операционной системы.</p>
 
               <p>Вызовы любого метода или свойства объекта BitmapData выдают ошибку ArgumentError, если объект BitmapData недействителен (например, если <code>height == 0</code> и <code>width == 0</code>) или если он был удален с помощью метода dispose(). </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">Посмотреть примеры</a></p><p><span class="classHeaderTableLabel">Связанные элементы API</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Общедоступные свойства</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Скрыть унаследованные общедоступные свойства</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Показать унаследованные общедоступные свойства</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Свойство</th><th>Определено</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Ссылка на объект класса или функцию конструктора для данного экземпляра объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[только для чтения] 
     Высота растрового изображения в пикселях.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[только для чтения] 
     Прямоугольник, определяющий размер и расположение растрового изображения.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[только для чтения] 
     Определяет, поддерживает ли растровое изображение попиксельную прозрачность.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[только для чтения] 
     Ширина растрового изображения в пикселях.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Общедоступные методы </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Скрыть унаследованные общедоступные методы</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Показать унаследованные общедоступные методы</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Метод</th><th>Определено</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     Создает объект BitmapData заданной ширины и высоты.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Создает фильтрованное изображение по исходному изображению и объекту filter.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     Возвращает новый объект BitmapData, являющийся клоном исходного экземпляра с точной копией содержащегося в нем растрового изображения.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Изменяет значения цветов в заданной области растрового изображения с помощью объекта ColorTransform.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     Сравнивает два объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Переносит данные из одного канала отдельного объекта BitmapData или текущего объекта BitmapData в канал текущего объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Представляет собой процедуру быстрой обработки точек изображений без растяжения, поворота и цветовых эффектов.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Заполняет пространство байтовым массивом из прямоугольного участка пиксельных данных.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Очищает память, задействованную для хранения объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Отображает исходный экранный объект source поверх растрового изображения с помощью векторного средства визуализации среды выполнения Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Отображает исходный экранный объект source поверх растрового изображения с помощью векторного средства визуализации среды выполнения Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Сжимает данный объект BitmapData с использованием выбранного алгоритма сжатия и возвращает новый объект ByteArray.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Заполняет прямоугольную область пикселей заданным цветом ARGB.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Выполняет операцию заливки изображения, начиная с точки с координатами (x, y) и заполняя область определенным цветом.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Определяет целевой прямоугольник, на который оказывает влияние вызов метода applyFilter() при наличии объекта BitmapData, исходного прямоугольника и объекта фильтра.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Определяет прямоугольный участок, полностью охватывающий все пиксели заданного цвета в пределах растрового изображения (если параметру findColor присвоено значение true), либо полностью охватывает все пиксели, не содержащие заданный цвет (если параметру findColor присвоено значение false).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Возвращает целое число, представляющее RGB-значение пикселя из объекта BitmapData в конкретной точке (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Возвращает значение цвета ARGB, содержащее данные альфа-канала и данные RGB.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Формирует байтовый массив из прямоугольного участка пиксельных данных.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     Формирует векторный массив из прямоугольного участка пиксельных данных.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает, определено ли заданное свойство для объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     Вычисление гистограммы двоичных чисел с 256 значениями для объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     Выполняет распознавание на уровне пикселей между одним растровым изображением и точкой, прямоугольником или другим растровым изображением.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает, есть ли экземпляр класса Object в цепи прототипов объекта, заданного в качестве параметра.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Блокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, не обновлялись при изменении данного объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Проводит наложение каналов исходного изображения на целевое изображение.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Заполняет изображение пикселями, представляющими собой белый шум.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Переназначает значения цветовых каналов в изображении, содержащем до четырех массивов данных цветовой палитры, по одному для каждого канала.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Создает изображение с шумом Перлина.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     Выполняет растворение точек от исходного изображения до целевого или для одного изображения.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает наличие заданного свойства и его перечисляемость.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Прокручивает изображение на заданное число точек (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Задает одиночный пиксель объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Задает значения цвета и альфа-прозрачности отдельно взятой точки объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Преобразует массив байтов в прямоугольный участок пиксельных данных.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Задает доступность динамического свойства для операций цикла.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Преобразует вектор в прямоугольную область пиксельных данных.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Сопоставляет пиксельные значения в изображении с заданным пороговым значением и присваивает пикселям, прошедшим проверку, новые цветовые значения.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Возвращает строковое представление этого объекта, отформатированного в соответствии со стандартами, принятыми для данной локали.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Возвращает строковое представление заданного объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Разблокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, обновлялись при изменении данного объекта BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Возвращает элементарное значение заданного объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Сведения о свойстве</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">свойство</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Высота растрового изображения в пикселях.
     
     </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Прямоугольник, определяющий размер и расположение растрового изображения. Верхняя левая точка прямоугольника имеет значение 0; ширина и высота в пикселях равны размерам объекта BitmapData.
     
     </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Определяет, поддерживает ли растровое изображение попиксельную прозрачность. Это значение можно задавать, только когда при создании объекта BitmapData в конструкторе передается значение<code>true</code> для параметра <code>transparent</code>. Затем, когда объект BitmapData создан, можно узнать, поддерживает ли он попиксельную прозрачность: для этого нужно проверить, имеет ли свойство <code>transparent</code> значение <code>true</code>.
     
     
     </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ширина растрового изображения в пикселях.
     
     </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">Сведения о конструкторе</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Конструктор</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     Создает объект BitmapData заданной ширины и высоты. Если задать значение для параметра <code>fillColor</code>, каждый пиксель растрового изображения будет окрашен в этот цвет.
     
     <p>По умолчанию растровое изображение создается прозрачным, если не передано значение <code>false</code> для параметра <code>transparent</code>. Создав непрозрачное растровое изображение, его нельзя сделать прозрачным. Каждый пиксель непрозрачного растрового изображения использует только 24 бита информации о цветовых каналах. Если растровое изображение определено как прозрачное, каждый пиксель использует 32 бита информации о цветовых каналах, включая канал альфа-прозрачности.</p>
     
     <p>В AIR 1.5 и Flash Player 10 максимальный размер объекта BitmapData составляет 8&nbsp;191 пиксель в ширину или высоту, а общее количество пикселей не может превышать 16&nbsp;777&nbsp;215. (Т. е. если ширина объекта BitmapData составляет 8,191 пикселя, его высота не может быть больше 2 048 пикселей.) В проигрывателе Flash Player 9 и более ранних версий, а также в AIR 1.1 и более ранних версий, это ограничение составляет 2 880 пикселей в высоту и 2 880 пикселей в ширину. Если задать значение ширины или высоты, превышающее 2880, новый экземпляр не будет создан.</p>
     
     </p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Ширина растрового изображения в пикселях.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Высота растрового изображения в пикселях.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Определяет, поддерживает ли растровое изображение попиксельную прозрачность. Значение по умолчанию &mdash; <code>true</code> (прозрачное). Чтобы создать полностью прозрачное растровое изображение, параметру <code>transparent</code> нужно присвоить значение <code>true</code>, а параметру <code>fillColor</code> &mdash; 0x00000000 (или 0). Если задать свойству <code>transparent</code> значение <code>false</code>, то можно незначительно улучшить производительность визуализации. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 32-разрядное ARGB-значение цвета, используемое для заливки области растрового изображения. Значение по умолчанию &mdash; 0xFFFFFFFF (сплошной белый).
     
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; ширина и/или высота превышает максимальное значение.
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Сведения о методе</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Создает фильтрованное изображение по исходному изображению и объекту filter.
     
     <p>Этот метод базируется на поведении встроенных объектов фильтра, которые определяют целевой прямоугольник, затрагиваемый вводным исходным прямоугольником.</p>
     
     <p>Полученное после применения фильтра изображение может быть больше вводного. Например, если класс BlurFilter используется, чтобы размыть очертания исходного прямоугольника с координатами (50,50,100,100) и точку назначения с координатами (10,10), то область конечного изображения будет больше (10,10,60,60) в результате размытости. Это происходит на внутреннем уровне при вызове метода <code>applyFilter()</code>.</p>
     
     <p>Если параметр <code>sourceRect</code> параметра <code>sourceBitmapData</code> является внутренней областью, например (50,50,100,100) в изображении 200 x 200, фильтр использует исходные пиксели за пределами параметра <code>sourceRect</code>, чтобы создать целевой прямоугольник.</p>
     
     <p>Если объект BitmapData является объектом, указанным в качестве параметра <code>sourceBitmapData</code>, приложение использует временную копию объекта для выполнения фильтрации. Если требуется обеспечить максимальную производительность, такую ситуацию лучше избегать.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Объект фильтра, который будет использоваться для выполнения фильтрации. Каждый тип фильтра имеет определенные требования, приведенные ниже.
     
     <ul><li><b>BlurFilter</b> &mdash; этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения. Если форматы изображений не совпадают, то при сопоставлении формата конечного изображения в ходе фильтрации создается копия исходного изображения.</li><li><b>BevelFilter, DropShadowFilter, GlowFilter, ChromeFilter</b> &mdash; конечное изображение этих фильтров должно быть прозрачным. При вызове фильтра DropShadowFilter или GlowFilter создается изображение, содержащее данные альфа-канала для тени или бликов. Он не создает тень на конечном изображении. Если использовать эти фильтры для непрозрачного конечного изображения, создается исключение.</li><li><b>ConvolutionFilter</b> &mdash; этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения.</li><li><b>ColorMatrixFilter</b> &mdash; этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения.</li><li><b>DisplacementMapFilter</b> &mdash; этот фильтр может использовать и прозрачные и непрозрачные исходные и конечные изображения, но форматы исходного и конечного изображений должны совпадать.</li></ul>
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect, destPoint или filter имеют значение null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; Прозрачность объектов BitmapData несовместима с операцией фильтрации.
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере показано применение размывающего фильтра к экземпляру BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Возвращает новый объект BitmapData, являющийся клоном исходного экземпляра с точной копией содержащегося в нем растрового изображения.
     
     </p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; Новый объект BitmapData, идентичный исходному.
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере клонируется экземпляр BitmapData и показывается, что изменение клонированного экземпляра BitmapData не затрагивает оригинал.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Изменяет значения цветов в заданной области растрового изображения с помощью объекта <code>ColorTransform</code>. Если прямоугольник соответствует границам растрового изображения, этот метод преобразует значения цветов для всего изображения.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Объект Rectangle, определяющий область изображения, в которой применяется объект ColorTransform.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; Объект ColorTransform, описывающий применяемые значения преобразования цвета.
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты rect и colorTransform имеют значение null.
      
      </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере показано применение преобразования цвета к левой половине объекта BitmapData (прямоугольнику).
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     Сравнивает два объекта BitmapData. Если два объекта BitmapData имеют одинаковые размеры (ширину и высоту), метод возвращает новый объект BitmapData, в котором каждый пиксель представляет «разницу» между пикселями двух исходных объектов.
     
     <ul><li>Если пиксели равны, то пиксель разницы будет иметь значение 0x00000000. </li><li>Если у двух пикселей разные RGB-значения (игнорирующие значение альфа-канала), то пиксель разницы будет иметь значение 0xRRGGBB, где RR/GG/BB &mdash; это индивидуальные значения разницы между красными, зелеными и синими каналами (значение пикселя в исходном объекте минус значение пикселя в объекте <code>otherBitmapData</code>). В данном случае различия значений альфа-канала игнорируются. </li><li>Если же альфа-канал имеет другое значение, то значением пикселя будет 0x<i>ZZ</i>FFFFFF, где <i>ZZ</i> - это разница между альфа-значениями (альфа-значение исходного объекта минус альфа-значение объекта <code>otherBitmapData</code>).</li></ul>
     
     <p>В качестве примера рассмотрим два следующих объекта BitmapData.</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>Примечание.</b> Цвета, использованные для заливки двух объектов BitmapData, имеют немного разные RGB-значения (0xFF0000 и 0xFFAA00). В результате использования метода <code>compare()</code> создается новый объект BitmapData, каждый пиксель которого показывает разницу RGB-значений между двумя растровыми изображениями.</p>
     
     <p>Рассмотрим следующие два объекта BitmapData, у которых одинаковые RGB-цвета, но разные значения альфа-канала.</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p>В результате использования метода <code>compare()</code> создается новый объект BitmapData, каждый пиксель которого показывает разницу значений альфа-канала между двумя растровыми изображениями.</p>
     
     <p>Если объекты BitmapData идентичны (имеют одинаковую высоту, ширину и значения пикселей), метод возвращает значение 0.</p>
     
     <p>Если объекты BitmapData имеют разную ширину, метод возвращает значение -3. </p>
     
     <p>Если объекты BitmapData имеют разную высоту, но одинаковую ширину, метод возвращает значение -4.</p>
     
     <p>В следующем примере сравниваются два объекта Bitmap с разной шириной (50 и 60).</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Объект BitmapData, сравниваемый с исходным объектом BitmapData.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; Если два объекта BitmapData имеют одинаковые размеры (ширину и высоту), метод возвращает новый объект BitmapData с различиями между двумя объектами (см. главное обсуждение темы). Если объекты BitmapData идентичны, метод возвращает значение 0. Если объекты BitmapData имеют разную ширину, метод возвращает значение -3. Если объекты BitmapData имеют разную высоту, метод возвращает значение -4. 
     
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объект otherBitmapData имеет значение null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере показывается значение пикселя объекта BitmapData, полученное в результате сравнения двух объектов BitmapData с одинаковыми размерами.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Переносит данные из одного канала отдельного объекта BitmapData или текущего объекта BitmapData в канал текущего объекта BitmapData. Все данные в других каналах конечного объекта BitmapData сохраняются.
     
     <p>Исходным или конечным значением канала может быть одно из следующих: </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий объект BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Исходный объект Rectangle. Чтобы скопировать только данные каналов из меньшей по размеру области растрового изображения, задайте исходный прямоугольник, размер которого меньше общего размера объекта BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Целевой объект Point, представляющий верхний левый угол прямоугольной области, в которую помещаются новые данные канала. Чтобы скопировать только данные канала из одной области в другую в конечном изображении, укажите другую точку вместо исходной (0,0).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Исходный канал. Используйте значение класса BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Целевой канал. Используйте значение класса BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
      
      </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере копируется красный канал объекта BitmapData в его собственный синий канал в области с размером 20 x 20 пикселей.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Представляет собой процедуру быстрой обработки точек изображений без растяжения, поворота и цветовых эффектов. Этот метод копирует прямоугольную область исходного изображения в прямоугольную область того же размера в точке назначения конченого объекта BitmapData.
     
     <p>Если включены параметры <code>alphaBitmap</code> и <code>alphaPoint</code>, можно использовать вторичное изображение в качестве источника альфа-канала для исходного изображения. Если исходное изображение имеет данные альфа-канала, то для переноса пикселей из исходного изображения в конечное используются оба набора данных альфа-канала. Параметр <code>alphaPoint</code> &mdash; это точка на альфа-изображении, соответствующая верхнему левому углу исходного прямоугольника. Все пиксели, не находящиеся в области пересечения исходного изображения и альфа-изображения, не копируются в конечное изображение.</p>
     
     <p>Свойство <code>mergeAlpha</code> контролирует, используется или нет альфа-канал при копировании одного прозрачного изображение в другое прозрачное изображение. Чтобы копировать пиксели с данными альфа-канала, задайте свойству <code>mergeAlpha</code> значение <code>true</code>. По умолчанию свойство <code>mergeAlpha</code> имеет значение <code>false</code>.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение, из которого копируются пиксели. Исходным изображением может быть другой экземпляр BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка назначения, представляющая верхний левый угол прямоугольной области, в которую помещаются новые пиксели канала.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; Вторичный источник альфа-канала объекта BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Точка в альфа-источнике объекта BitmapData, соответствующая верхнему левому углу параметра <code>sourceRect</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Чтобы использовать альфа-канал, нужно задать значение <code>true</code>. Чтобы копировать пиксели без альфа-канала, нужно задать значение <code>false</code>.
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере копируются пиксели из области 20 х 20 пикселей одного объекта BitmapData в другой объект BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     Заполняет пространство байтовым массивом из прямоугольного участка пиксельных данных. Начиная с индекса <code>position</code> в ByteArray, этот метод записывает в байтовый массив беззнаковое целое (32-разрядное неумноженное значение) для каждого пикселя. При необходимости размер массива увеличивается до числа байт, необходимого для хранения данных всех пикселей.
           
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольная область в текущем объекте BitmapData
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; целевой объект ByteArray
     
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Если параметр <code>rect</code> имеет значение <code>null</code> или параметр <code>data</code> имеет значение <code>null</code>
     
	 </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Очищает память, задействованную для хранения объекта BitmapData. 
     
     <p>Когда для изображения вызывается метод <code>dispose()</code>, его ширина и высота получают значение 0. Все последующие вызовы методов и свойств данного экземпляра BitmapData заканчиваются неудачно и приводят к появлению исключения. </p>
     <p>Метод <code>BitmapData.dispose()</code> мгновенно освобождает память, занятую фактическими данными растрового изображения (растровое изображение может потреблять до 64 МБ памяти). После вызова <code>BitmapData.dispose()</code> объект BitmapData больше не может использоваться, и среда выполнения Flash выдает исключение в случае последующего вызова функции для объекта BitmapData. Однако метод <code>BitmapData.dispose()</code> не утилизирует объект BitmapData (около 128 байт); память, занимаемая фактическим объектом BitmapData, освобождается при его утилизации сборщиком мусора.</p>
     
     </p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере показан результат вызова метода объекта BitmapData после вызова метода <code>dispose()</code> (выдается исключение).
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Отображает исходный экранный объект <code>source</code> поверх растрового изображения с помощью векторного средства визуализации среды выполнения Flash. Можно задать параметры <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> и <code>clipRect</code> назначения, чтобы управлять процессом визуализации. Также можно указать, должно ли сглаживать растровое изображение при масштабировании (это применимо только если источником является объект BitmapData).
     
     <p><b>Примечание. </b>Метод <code>drawWithQuality()</code> работает так же, как метод <code>draw()</code>, но вместо использования свойства <code>Stage.quality</code> для определения качества визуализации вектора необходимо указать параметр <code>quality</code> в методе <code>drawWithQuality()</code>.</p>
      
     <p>Этот метод напрямую соответствует тому, как рисуются объекты с помощью стандартного векторного средства визуализации в интерфейсе инструмента разработки.</p>
     
     <p>Исходный экранный объект не использует свои примененные преобразования для этого вызова. Он обрабатывается в том виде, в котором представлен в библиотеке или файле: без преобразования матрицы, цвета и без режима наложения. Чтобы нарисовать экранный объект (например, фрагмент ролика) с помощью его собственных свойств преобразования, можно скопировать его объект свойства <code>transform</code> в свойство <code>transform</code> объекта Bitmap, использующего объект BitmapData.</p>
     
     <p>Этот метод поддерживается через протокол RTMP в <span>Flash Player 9.0.115.0 и более поздних версиях и в</span> Adobe AIR. Можно контролировать потоки на сервере Flash Media Server в сценарии, выполняемом на стороне сервера. Более подробную информацию см. в статьях о свойствах <code>Client.audioSampleAccess</code> и <code>Client.videoSampleAccess</code> в <a href="http://www.adobe.com/go/learn_flash_ss_as_ru" target="external"> <i>Справочном руководстве по серверному языку ActionScript для Adobe Flash Media Server</i></a>.</p>
     
     <p>Если объект source и (в случае с объектами Sprite и MovieClip) все его дочерние объекты не находятся в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <code>Security.allowDomain()</code>, вызов метода <code>draw()</code> выдает исключение SecurityError. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.</p>
     
     <p>Существуют также ограничения по использованию загруженного растрового изображения в качестве объекта <code>source</code>. Вызов метода <code>draw()</code> будет успешным, если загруженное изображение принадлежит тому же домену, что и вызывающий объект. Более того, файл междоменной политики на сервере изображения может предоставить право доступа домену содержимого SWF, вызывающего метод <code>draw()</code>. В таком случае необходимо задать свойство <code>checkPolicyFile</code> объекта LoaderContext и использовать этот объект в качестве параметра <code>context</code> при вызове метода <code>load()</code> объекта Loader, используемого для загрузки изображения. Эти ограничения не применимы к содержимому AIR в изолированной программной среде безопасности приложения.</p>
     
     <p>В Windows метод <code>draw()</code> не может выполнить захват содержимого SWF, встроенного в страницу HTML <span>в объекте HTMLLoader в Adobe AIR</span>.</p>
     
     <p>Метод <code>draw()</code> не может выполнить захват содержимого PDF <span>в Adobe AIR</span>. Он также не может выполнить захват содержимого SWF, встроенного в HTML-файл, в котором атрибут <code>wmode</code> имеет значение <code>window</code> <span>в Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Экранный объект или объект BitmapData для рисования объекта BitmapData. Классы DisplayObject и BitmapData реализуют интерфейс IBitmapDrawable.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Объект Matrix, используемый для масштабирования, поворота и перемещения координат растрового изображения. Если не требуется применять преобразование матрицы в изображение, задайте для этого параметра идентификационную матрицу, созданную с помощью конструктора <code>new Matrix()</code> по умолчанию, или передайте значение <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Объект ColorTransform, используемый для настройки значений цвета растрового изображения. Если объект не указан, цвета растрового изображения не преобразуются. Если вам необходимо передать этот параметр, но преобразовывать изображение не нужно, задайте для него объект ColorTransform, созданный с помощью конструктора <code>new ColorTransform()</code> по умолчанию.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Строковое значение класса flash.display.BlendMode, задающее режим наложения, которые будет применен к полученному растровому изображению. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Объект Rectangle, определяющий для рисования область исходного объекта. Если это значение не задано, то обрезка не производится и исходный объект рисуется полностью.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Логическое значение, которое определяет, будет ли объект BitmapData сглаживаться при масштабировании или повороте вследствие масштабирования или поворота в параметре <code>matrix</code>. Параметр <code>smoothing</code> применяется, только если параметром <code>source</code> является объект BitmapData. Если <code>smoothing</code> имеет значение <code>false</code>, повернутое или масштабированное изображение BitmapData может получиться нечетким или с зазубренными очертаниями. Например в следующих двух изображениях в качестве параметра <code>source</code> используется один и тот же объект BitmapData, но для левого параметр <code>smoothing</code> имеет значение <code>true</code>, а для правого - <code>false</code>.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Два изображения: левое со сглаживанием и правое без сглаживание."></img></p>
     
     <p>Рисование с параметром <code>smoothing</code> в значении <code>true</code> требует больше времени, чем со <code>smoothing</code> в значении <code>false</code>.</p>
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Параметр <code>source</code> не является объектом BitmapData или DisplayObject.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Объект <code>source</code> и (в случае с объектами Sprite и MovieClip) все его дочерние объекты находятся не в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <code>Security.allowDomain()</code>. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Источник имеет значение null или не является действительным объектом IBitmapDrawable.
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере рисуется объект TextField в объекте BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Отображает исходный экранный объект <code>source</code> поверх растрового изображения с помощью векторного средства визуализации среды выполнения Flash. Можно задать параметры <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> и <code>clipRect</code> назначения, чтобы управлять процессом визуализации. Также можно указать, должно ли сглаживать растровое изображение при масштабировании (это применимо только если источником является объект BitmapData).
     
     <p><b>Примечание. </b>Метод <code>drawWithQuality()</code> работает так же, как метод <code>draw()</code>, но вместо использования свойства <code>Stage.quality</code> для определения качества визуализации вектора необходимо указать параметр <code>quality</code> в методе <code>drawWithQuality()</code>.</p>
      
     <p>Этот метод напрямую соответствует тому, как рисуются объекты с помощью стандартного векторного средства визуализации в интерфейсе инструмента разработки.</p>
     
     <p>Исходный экранный объект не использует свои примененные преобразования для этого вызова. Он обрабатывается в том виде, в котором представлен в библиотеке или файле: без преобразования матрицы, цвета и без режима наложения. Чтобы нарисовать экранный объект (например, фрагмент ролика) с помощью его собственных свойств преобразования, можно скопировать его объект свойства <code>transform</code> в свойство <code>transform</code> объекта Bitmap, использующего объект BitmapData.</p>
     
     <p>Этот метод поддерживается через протокол RTMP в <span>Flash Player 9.0.115.0 и более поздних версиях и в</span> Adobe AIR. Можно контролировать потоки на сервере Flash Media Server в сценарии, выполняемом на стороне сервера. Дополнительные сведения см. в разделах о свойствах <code>Client.audioSampleAccess</code> и <code>Client.videoSampleAccess</code> в документе <a href="http://www.adobe.com/go/documentation_ru" target="external"> <i>Справочник по языку ActionScript на стороне сервера для Adobe Flash Media Server</i></a>.</p>
     
     <p>Если объект source и (в случае с объектами Sprite и MovieClip) все его дочерние объекты не находятся в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <code>Security.allowDomain()</code>, вызов метода <code>drawWithQuality()</code> выдает исключение SecurityError. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.</p>
     
     <p>Существуют также ограничения по использованию загруженного растрового изображения в качестве объекта <code>source</code>. Вызов метода <code>drawWithQuality()</code> будет успешным, если загруженное изображение принадлежит тому же домену, что и вызывающий объект. Более того, файл междоменной политики на сервере изображения может предоставить право доступа домену содержимого SWF, вызывающего метод <code>drawWithQuality()</code>. В таком случае необходимо задать свойство <code>checkPolicyFile</code> объекта LoaderContext и использовать этот объект в качестве параметра <code>context</code> при вызове метода <code>load()</code> объекта Loader, используемого для загрузки изображения. Эти ограничения не применимы к содержимому AIR в изолированной программной среде безопасности приложения.</p>
     
     <p>В Windows метод <code>drawWithQuality()</code> не может выполнить захват содержимого SWF, встроенного в страницу HTML <span>в объекте HTMLLoader в Adobe AIR</span>.</p>
     
     <p>Метод <code>drawWithQuality()</code> не может выполнить захват содержимого PDF <span>в Adobe AIR</span>. Он также не может выполнить захват содержимого SWF, встроенного в HTML-файл, в котором атрибут <code>wmode</code> имеет значение <code>window</code> <span>в Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Экранный объект или объект BitmapData для рисования объекта BitmapData. Классы DisplayObject и BitmapData реализуют интерфейс IBitmapDrawable.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Объект Matrix, используемый для масштабирования, поворота и перемещения координат растрового изображения. Если не требуется применять преобразование матрицы в изображение, задайте для этого параметра идентификационную матрицу, созданную с помощью конструктора <code>new Matrix()</code> по умолчанию, или передайте значение <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Объект ColorTransform, используемый для настройки значений цвета растрового изображения. Если объект не указан, цвета растрового изображения не преобразуются. Если вам необходимо передать этот параметр, но преобразовывать изображение не нужно, задайте для него объект ColorTransform, созданный с помощью конструктора <code>new ColorTransform()</code> по умолчанию.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Строковое значение класса flash.display.BlendMode, задающее режим наложения, которые будет применен к полученному растровому изображению. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Объект Rectangle, определяющий для рисования область исходного объекта. Если это значение не задано, то обрезка не производится и исходный объект рисуется полностью.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Логическое значение, которое определяет, будет ли объект BitmapData сглаживаться при масштабировании или повороте вследствие масштабирования или поворота в параметре <code>matrix</code>. Параметр <code>smoothing</code> применяется, только если параметром <code>source</code> является объект BitmapData. Если <code>smoothing</code> имеет значение <code>false</code>, повернутое или масштабированное изображение BitmapData может получиться нечетким или с зазубренными очертаниями. Например в следующих двух изображениях в качестве параметра <code>source</code> используется один и тот же объект BitmapData, но для левого параметр <code>smoothing</code> имеет значение <code>true</code>, а для правого - <code>false</code>.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Два изображения: левое со сглаживанием и правое без сглаживание."></img></p>
     
     <p>Рисование с параметром <code>smoothing</code> в значении <code>true</code> требует больше времени, чем со <code>smoothing</code> в значении <code>false</code>.</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Любое из значений StageQuality. Выбирает качество сглаживания для использования при рисовании векторной графики. 
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Параметр <code>source</code> не является объектом BitmapData или DisplayObject.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Объект <code>source</code> и (в случае с объектами Sprite и MovieClip) все его дочерние объекты находятся не в том же домене, что и вызывающий объект, или не находятся в содержимом, доступном вызывающему объекту посредством вызова метода <code>Security.allowDomain()</code>. Это ограничение не применимо к содержимому AIR в изолированной программной среде безопасности приложения.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Источник имеет значение null или не является действительным объектом IBitmapDrawable.
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере рисуется объект TextField в объекте BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Сжимает данный объект BitmapData с использованием выбранного алгоритма сжатия и возвращает новый объект ByteArray. Дополнительно записывает результирующие данные в указанный объект ByteArray. Аргумент <code>compressor</code> задает алгоритм кодирования и может принимать значение PNGEncoderOptions, JPEGEncoderOptions или JPEGXREncoderOptions.
     
     <p>В следующем примере выполняется сжатие объекта BitmapData с использованием алгоритма JPEGEncoderOptions:</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Сжимаемая область объекта BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; Тип используемого сжатия. Допустимые значения: <code>flash.display.PNGEncoderOptions</code>, <code>flash.display.JPEGEncoderOptions</code> и <code>flash.display.JPEGXREncoderOptions</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; Выходной объект ByteArray, содержащий закодированное изображение.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Объект ByteArray, содержащий закодированное изображение.
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Заполняет прямоугольную область пикселей заданным цветом ARGB.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольная область для заливки.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Цвет ARGB для заливки области. Цвета ARGB часто указываются в шестнадцатеричном формате, например 0xFF336699.
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объект rect имеет значение null.
      
      </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере прямоугольная область объекта BitmapData заливается синим цветом:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Выполняет операцию заливки изображения, начиная с точки с координатами (<i>x</i>, <i>y</i>) и заполняя область определенным цветом. Метод <code>floodFill()</code> напоминает инструмент заливки в различных программах для рисования. Цвет представляет собой цвет ARGB, содержащий информацию альфа-канала и данные цвета.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Координата <i>x</i> изображения.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Координата <i>y</i> изображения.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Цвет ARGB для заливки.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В примере ниже показана заливка области объекта BitmapData (т. е. области вокруг пикселя в точке с координатами <code>(10, 10)</code>, в которой все цвета граничат с цветом в данной точке) красным цветом.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Определяет целевой прямоугольник, на который оказывает влияние вызов метода <code>applyFilter()</code> при наличии объекта BitmapData, исходного прямоугольника и объекта фильтра.
     
     <p>Например, размывающий фильтр обычно воздействует на область, размер которой превышает размер исходного изображения. Изображение размером 100 x 200 пикселей, отфильтрованное с использованием экземпляра BlurFilter по умолчанию, где <code>blurX = blurY = 4</code> создает целевой прямоугольник с координатами <code>(-2,-2,104,204)</code>. Метод <code>generateFilterRect()</code> позволяет заранее определять размер целевого прямоугольника, чтобы соответствующим образом изменить его размеры перед применением фильтра.</p>
     
     <p>Некоторые фильтры обрезают целевой прямоугольник по размеру исходного изображения. Например, внутренний фильтр <code>DropShadow</code> не увеличивает размер по сравнению с исходным изображением. В данном API-интерфейсе объект BitmapData используется в качестве исходных границ, а не исходного параметра <code>rect</code>.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Объект фильтра, используемый для вычисления конечного прямоугольника.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Целевой прямоугольник, вычисленный с использованием изображения, параметра <code>sourceRect</code> и фильтра.
     
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceRect и filter имеют значение null.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере метод <code>generateFilterRect()</code> используется для определения прямоугольной области, которую будет занимать изображение после применения фильтра размытия. Результаты метода <code>generateFilterRect()</code> выводятся с помощью функции <code>trace()</code>.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> Обратите внимание, что метод <code>generateFilterRect()</code> не применяет фильтр. Вызовите метод <code>applyFilter()</code>, чтобы применить фильтр. 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Определяет прямоугольный участок, полностью охватывающий все пиксели заданного цвета в пределах растрового изображения (если параметру <code>findColor</code> присвоено значение <code>true</code>), либо полностью охватывает все пиксели, не содержащие заданный цвет (если параметру <code>findColor</code> присвоено значение <code>false</code>). 
     
     <p>Например, если имеется исходное изображение и требуется определить прямоугольник изображения, содержащий ненулевой альфа-канал, передайте в качестве параметров <code>{mask: 0xFF000000, color: 0x00000000}</code>. Если параметру <code>findColor</code> задано значение <code>true</code>, в пределах всего изображения ведется поиск границ с пикселями, для которых <code>(value & mask) == color</code> (где <code>value</code> - это значение цвета пикселя). Если параметру <code>findColor</code> задано значение <code>false</code>, в пределах всего изображения ведется поиск границ пикселей, для которых <code>(value & mask)!= color</code> (где <code>value</code> - это значение цвета пикселя). Чтобы определить белое пространство вокруг изображения, передайте <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code>, чтобы найти границы не белых пикселей.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, указывающее рассматриваемые биты цвета ARGB. Значение цвета объединяется с данным шестнадцатеричным значением с использованием оператора <code>&</code> (побитовое И).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, задающее цвет ARGB для соответствия (если <code>findColor</code> имеет значение <code>true</code>) или <i>не</i> соответствия (если <code>findColor</code> имеет значение <code>false</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Если задано значение <code>true</code>, то возвращаются границы значения цвета в изображения. Если задано значение <code>false</code>, возвращаются границы области изображения, в которой этого цвета нет. 
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Область изображения, заполненная заданным цветом. 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData с красным цветом в верхней половине пикселей. Затем вызывается метод <code>getColorBoundsRect()</code> для определения прямоугольника, содержащего красные пиксели (0xFF0000), после чего тот же метод вызывается для определения прямоугольника, пиксели которого не красные (параметру <code>findColor</code> задается значение <code>false</code>.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Возвращает целое число, представляющее RGB-значение пикселя из объекта BitmapData в конкретной точке (<i>x</i>, <i>y</i>). Метод <code>getPixel()</code> возвращает неумноженное значение пикселя. Информация альфа-канала не возвращается.
     
     <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Положение пикселя по оси <i>x</i>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Положение пикселя по оси <i>y</i>.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Число, представляющее RGB-значение пикселя. Если координаты (<i>x</i>, <i>y</i>) находятся за пределами изображения, метод возвращает 0. 
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере объект BitmapData заливается красным, а с помощью метода <code>getPixel()</code> определяется значение цвета для верхнего левого пикселя.
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Возвращает значение цвета ARGB, содержащее данные альфа-канала и данные RGB. Этот метод подобен методу <code>getPixel()</code>, который возвращает RGB-цвет без данных альфа-канала.
     
     <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Положение пикселя по оси <i>x</i>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Положение пикселя по оси <i>y</i>.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Число, представляющее значение пикселя ARGB. Если координаты (<i>x</i>, <i>y</i>) находятся за пределами изображения, возвращается значение 0.
     
     </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData, залитый цветом, а затем с помощью метода <code>getPixel32()</code> определяется значение цвета в верхнем левом пикселе, после чего определяются шестнадцатеричные значения для каждого компонента цвета (альфа-канал, красный, зеленый и синий).
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Формирует байтовый массив из прямоугольного участка пиксельных данных. Записывает неподписанное целое число (32-разрядное неумноженное значение пикселя) для каждого пикселя в байтовом массиве.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольная область в текущем объекте BitmapData.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Объект ByteArray, представляющий пиксели в данном объекте Rectangle.
     
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объект rect имеет значение null.
      
      </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData, заполненный пикселями, образующими белый шум, а затем с помощью метода <code>getPixels()</code> объект ByteArray заполняется пиксельными значениями объекта BitmapData.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Формирует векторный массив из прямоугольного участка пиксельных данных. Возвращает объект Vector беззнаковых целых чисел (32-разрядное неумноженное пиксельное значение) для заданного прямоугольника.
     
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольная область в текущем объекте BitmapData.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Объект Vector, представляющий указанный объект Rectangle.
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объект rect имеет значение null.
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Вычисление гистограммы двоичных чисел с 256 значениями для объекта BitmapData. Этот метод возвращает объект Vector, содержащий четыре экземпляра Vector.&lt;Number> (четыре объекта Vector, содержащие объекты Number). Четыре экземпляра Vector представляют красный, зеленый, синий и альфа компоненты по порядку. Каждый экземпляр Vector содержит 256 значений, которые представляют распространение отдельного значения компонента: от 0 до 255.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Используемая область объекта BitmapData.
      
      </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Выполняет распознавание на уровне пикселей между одним растровым изображением и точкой, прямоугольником или другим растровым изображением. Попаданием считается наложение точки или прямоугольника на непрозрачный пиксель или два накладывающихся непрозрачных пикселя. При тестировании нажатия растягивание, поворот и другие преобразования обоих объектов не учитываются. 
     
     <p>Если изображение непрозрачное, то при использовании данного метода оно считается полностью непрозрачным прямоугольником. Для тестирования нажатия, при котором учитывается прозрачность, оба изображения должны быть прозрачными. Когда тестируются два прозрачных изображения, параметры порога альфа-значений контролируют, какие значения альфа-канала (от 0 до 255) считаются непрозрачными.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  Положение верхнего левого угла изображения BitmapData в произвольном координатном пространстве. То же координатное пространство используется при определении параметра <code>secondBitmapPoint</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Самое низкое значение альфа-канала, рассматриваемое как непрозрачное, для данной проверки попадания.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Объект Rectangle, Point, Bitmap или BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Точка, определяющая местоположение пикселя во втором объекте BitmapData. Используйте этот параметр, только когда значением <code>secondObject</code> является объект BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; Самое низкое значение альфа-канала, рассматриваемое как непрозрачное во втором объекте BitmapData. Используйте этот параметр, только когда значением <code>secondObject</code> является BitmapData и оба объекта BitmapData прозрачные.
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; Имеет значение <code>true</code> при наличии совпадений; в противном случае - <code>false</code>.
        
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Параметр <code>secondObject</code> не является объектом Point, Rectangle, Bitmap или BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объект firstPoint имеет значение null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData, являющийся непрозрачным только в прямоугольной области с координатами (20, 20, 40, 40), и вызывается метод <code>hitTest()</code> с объектом Point в качестве <code>secondObject</code>. При первом вызове объект Point определяет верхний левый угол объекта BitmapData, который является прозрачным, а при втором вызове объект Point определяет центр объекта BitmapData, который является непрозрачным.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Блокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, не обновлялись при изменении данного объекта BitmapData. Чтобы повысить производительность, используйте этот метод вместе с методом <code>unlock()</code> до или после многочисленных вызовов метода <code>setPixel()</code> или <code>setPixel32()</code>.
     
     </p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData на базе свойства <code>bitmapData</code> объекта Bitmap с именем <code>picture</code>. Затем вызывается метод <code>lock()</code> перед вызовом сложной пользовательской функции, <code>complexTransformation()</code>, изменяющей объект BitmapData. (Объект <code>picture</code> и функция <code>complexTransformation()</code> в этом примере не определяются.) Даже если функция <code>complexTransformation()</code> обновляет свойство <code>bitmapData</code> объекта <code>picture</code>, изменения не отображаются, пока код не вызовет метод <code>unlock()</code> объекта <code>bitmapData</code>.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Проводит наложение каналов исходного изображения на целевое изображение. Для каждого канала и каждого пикселя вычисляется новое значение на основе значений каналов исходных и целевых пикселей. Например, в красном канале новое значение вычисляется следующим образом (где <code>redSrc</code> - это значение красного канала для пикселя в исходном изображении, а <code>redDest</code> - это значение красного канала в соответствующем пикселе целевого изображения): 
     <p>
     <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p>Значения <code>redMultiplier</code>, <code>greenMultiplier</code>, <code>blueMultiplier</code> и <code>alphaMultiplier</code> являются множителями, используемыми для канала каждого цвета. Используйте шестнадцатеричное значение от <code>0</code> до <code>0x100</code> (256), где <code>0</code> обозначает, что в результате используется полное значение целевого изображения, а <code>0x100</code> - что используется полное значение исходного изображения, а промежуточные числа означают, что используется наложение (так <code>0x80</code> указывает на 50-процентное наложение).</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий объект BitmapData.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, на которое будет умножаться значение красного канала. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, на которое будет умножаться значение зеленого канала. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, на которое будет умножаться значение синего канала.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Шестнадцатеричное значение, на которое будет умножаться значение альфа-канала.
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создаются два объекта BitmapData. Размер обоих составляет 100 х 80 пикселей. Первый объект заливается зеленым цветом, а второй &mdash; красным. Код вызывает метод <code>merge()</code>, накладывающий пиксели второго объекта BitmapData на первый объект BitmapData, но только в заданной прямоугольной области:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Заполняет изображение пикселями, представляющими собой белый шум.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Начальное значение, используемое для создания случайных чисел. Если не изменять остальных параметров, можно создавать различные псевдослучайные результаты, изменяя начальное значение случайной последовательности. Функция шума является функцией наложения, а не настоящей функцией создания случайных чисел, поэтому при использовании одного и того же начального числа она каждый раз дает одинаковые результаты.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Самое низкое значение для создания случайных чисел для каждого канала (от 0 до 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; Самое высокое значение для создания случайных чисел для каждого канала (от 0 до 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; Число, которое может представлять собой любую комбинацию значений четырех каналов цвета (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> и <code>BitmapDataChannel.ALPHA</code>). Можно использовать логический оператор ИЛИ (<code>|</code>) для комбинирования значений каналов. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Логическое значение. Если имеет значение <code>true</code>, создается изображение с использованием серой шкалы путем присвоения всем цветовым каналам одного и того же значения. На значение альфа-канала не воздействует задание значения <code>true</code> для этого параметра. 
     
     </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается два объекта BitmapData и для каждого из них вызывается метод <code>noise()</code>. Однако параметру <code>grayscale</code> задано значение <code>false</code> для вызова метода <code>noise()</code> первого объекта и <code>true</code> для вызова метода <code>noise()</code> второго объекта.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Переназначает значения цветовых каналов в изображении, содержащем до четырех массивов данных цветовой палитры, по одному для каждого канала. 
     
     <p>Среда выполнения Flash предпринимает следующие шаги для создания конечного изображения.</p>
     
     <ol><li>После вычисления значения красного, зеленого, синего и альфа-каналов складываются, образуя стандартное 32-разрядное целое число. </li><li>Значения красного, зеленого, синего и альфа-каналов каждого пикселя извлекаются в отдельные значения от 0 до 255. Эти значения используются для поиска новых значений цвета в соответствующем массиве: <code>redArray</code>, <code>greenArray</code>, <code>blueArray</code> и <code>alphaArray</code>. Каждый из этих четырех массивов должен содержать 256 значений. </li><li>После получения новых значений для всех четырех каналов, они образуют стандартное значение ARGB, которое применяется к пикселю.</li></ol>
     
     <p>Этот метод может поддерживать эффекты, создаваемые с использованием разных каналов. Каждый вводный массив содержит полные 32-разрядные значения, поэтому при складывании значений не происходит смещения. Эта подпрограмма не поддерживает фиксацию по каналам. </p>
     
     <p>Если для канала не задан массив, то канал цвета копируется из исходного изображения в целевое.</p>
     
     <p>Этот метод можно использовать для самых разнообразных эффектов, таких как общее наложение палитры (преобразование одного канала для создания псевдо-цветного изображения). Этот метод можно использовать для различных расширенных алгоритмов манипуляций с цветом, таких как использование гаммы, кривых, уровней и квантизации.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка в целевом изображении (текущем объекте BitmapData), соответствующая правому левому углу исходного прямоугольника.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Если <code>redArray</code> не имеет значение <code>null</code>, красный = redArray[исходное значение красного], в противном случае красный = исходное значение красного (<code>red = redArray[source red value] else red = source rect value</code>).
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Если <code>greenArray</code> не имеет значение <code>null</code>, зеленый = greenArray[исходное значение зеленого], в противном случае зеленый = исходное значение зеленого (<code>green = greenArray[source green value] else green = source green value.</code>)
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Если <code>blueArray</code> не имеет значение <code>null</code>, синий = blueArray[исходное значение синего], в противном случае синий = исходное значение синего (<code>blue = blueArray[source blue value] else blue = source blue value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Если <code>alphaArray</code> не имеет значение <code>null</code>, альфа = alphaArray[исходное альфа-значение], в противном случае альфа = исходное альфа-значение (<code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>).
     
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается зеленый объект BitmapData с красным квадратом по центру, а затем вызывается метод <code>paletteMap()</code>, чтобы поменять местами красный и зеленый в нижней прямоугольной области объекта BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Создает изображение с шумом Перлина.
     
     <p>Алгоритм создания шума Перлина интерполирует и объединяет отдельные функции случайного шума (называемые октавами) в одну функцию, создающую более естественный случайный шум. Как и в музыкальных октавах, каждая функция октавы удваивает частоту предыдущей. Шум Перлина описывается как «фрактальная сумма шума», так как он объединяет несколько наборов шумовых данных с разным уровнем детализации.</p>
     
     <p>Функции шума Перлина можно использовать для симуляции естественных явлений и ландшафтов, таких как текстура древесины, облака и горные хребты. В большинстве случаев результат функции шума Перлина не отображается непосредственно: он используется для доработки других изображений, придавая им псевдослучайные вариации.</p>
     
     <p>Простые функции цифрового белого шума часто дают изображения с резко контрастирующими точками. Такое явление редко встречается в естественных условиях. Алгоритм шума Перлина объединяет несколько функций шума с разным уровнем детализации. В результате чего разница между значениями соседних пикселей становится не столь большой.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; Частота, используемая по оси <i>x</i>. Например, чтобы создать объект с шумом для изображения размером 64 x 128, передайте 64 для значения <code>baseX</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; Частота для использования в направлении <i>y</i>. Например, чтобы создать объект с шумом для изображения размером 64 x 128, передайте 128 для значения <code>baseY</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; Количество октав или индивидуальных функций шума, которые необходимо объединить с целью создания шума. Чем больше октав, тем более детальное изображение создается. Также чем больше октав, тем больше времени требуется на обработку.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Начальное значение, используемое для создания случайных чисел. Если не изменять остальных параметров, можно создавать различные псевдослучайные результаты, изменяя начальное значение случайной последовательности. Функция шума Перлина является функцией наложения, а не настоящей функцией создания случайных чисел, поэтому при использовании одного и того же начального числа она каждый раз дает одинаковые результаты.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Логическое значение. При значении <code>true</code> метод пытается сгладить края перехода изображения, чтобы создать бесшовную текстуру для мозаичной заливки растровым изображением.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Логическое значение. При значении <code>true</code> метод создает фрактальный шум, в противном случае создается турбулентность. Изображение с турбулентностью имеет видимые прерывания градиента, благодаря чему оно больше подходит для более резких визуальных эффектов, например для создания языков пламени или морских волн.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  Число, которое может представлять собой любую комбинацию значений четырех каналов цвета (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> и <code>BitmapDataChannel.ALPHA</code>). Можно использовать логический оператор ИЛИ (<code>|</code>) для комбинирования значений каналов.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Логическое значение. При значении <code>true</code> создается изображение с использованием серой шкалы путем присвоения каналам красного, зеленого и синего цветов идентичных значений. Значение альфа-канала остается без изменений, если данному параметру задано значение <code>true</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Массив точек, соответствующий смещениям в направлениях <i>x</i> и <i>y</i> для каждой октавы. Изменяя значения смещения, можно плавно прокручивать слои изображения с шумом Перлина. Каждая точка в массиве смещения применяется к функции шума конкретной октавы.
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData 200 х 200 пикселей, который вызывает метод <code>perlinNoise()</code> для создания эффекта красной и синей акварели.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Выполняет растворение точек от исходного изображения до целевого или для одного изображения. Среда выполнения Flash использует значение <code>randomSeed</code> для выполнения случайного растворения точек. Возвращаемое значение функции должно передаваться при последующих вызовах для продолжения растворения точек вплоть до завершения операции.
     
     <p>Если исходное изображение отличается от целевого, пиксели копируются из первого во второе с использованием всех свойств. Этот процесс позволяет выполнить растворение от пустого изображения до заполненного.</p>
     
     <p>Если исходное и целевое изображения одинаковы, пиксели заполняются с помощью параметра <code>color</code>. Этот процесс позволяет выполнить растворение из заполненного изображения. В данном режиме целевой параметр <code>point</code> игнорируется.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Начальное значение случайного числа, используемое для начала растворения точек. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; По умолчанию составляет 1/30 исходной области (ширина x высота).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Значение цвета ARGB, используемое для заливки пикселей, для которых исходное значение равно целевому. 
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; Новое начальное значение случайного числа для последующих вызовов.
     
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect и destPoint имеют значение null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; numPixels имеет отрицательное значение.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере метод <code>pixelDissolve()</code> используется для преобразования серого объекта BitmapData в красный: одновременно растворяется по 40 пикселей до тех пор, пока не будет изменен цвет всех пикселей.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Прокручивает изображение на заданное число точек (<i>x</i>, <i>y</i>). Края за пределами области прокрутки остаются без изменений.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Число точек для прокрутки по горизонтали.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Число точек для прокрутки по вертикали.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере показывается эффект прокрутки объекта BitmapData на 40 пикселей вправо.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Задает одиночный пиксель объекта BitmapData. При выполнении этой операции сохраняется текущее значение альфа-канала пикселя изображения. Значение параметра RGB-цвета обрабатывается как неумноженное значение цвета.
     
     <p><b>Примечание.</b> Для повышения производительности при многократном использовании метода <code>setPixel()</code> или <code>setPixel32()</code> вызовите метод <code>lock()</code> перед тем, как вызывать <code>setPixel()</code> или <code>setPixel32()</code>, а по завершении внесения изменений в пиксели, вызовите метод <code>unlock()</code>. Эта процедура не позволяет объектам, ссылающимся на данный экземпляр BitmapData, обновляться, пока не будет завершено изменение пикселей.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Положение по оси <i>x</i> пикселей, значение которого меняется.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Положение по оси <i>y</i> пикселя, значение которого меняется.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Полученный RGB-цвет пикселя. 
     
     </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере с помощью метода <code>setPixel()</code> рисуется красная линия в объекте BitmapData.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Задает значения цвета и альфа-прозрачности отдельно взятой точки объекта BitmapData. Этот метод поход на метод <code>setPixel()</code>. Основное различие заключается в том, что метод <code>setPixel32()</code> принимает ARGB-значение цвета, содержащее информацию об альфа-канале.
     
     <p>Все пиксели в объекте BitmapData сохраняются как предварительно умноженные значения цвета. В предварительно умноженном пикселе изображения значения красного, зеленого и синего канала уже умножены на данные альфа-канала. Например, если значение альфа-канала равно нулю, то значения RGB-каналов также равны нулю независимо от их значений до умножения. Потеря данных может вызвать проблемы при выполнении операций. Все методы BitmapData принимают и возвращают неумноженные значения. Перед тем как возвращать значение, внутреннее представление пикселя преобразуется из предварительно умноженного в неумноженное. Во время операции настройки, значение пикселя предварительно умножается, и только после этого настраивается необработанный пиксель изображения.</p>
     
     <p><b>Примечание.</b> Для повышения производительности при многократном использовании метода <code>setPixel()</code> или <code>setPixel32()</code> вызовите метод <code>lock()</code> перед тем, как вызывать <code>setPixel()</code> или <code>setPixel32()</code>, а по завершении внесения изменений в пиксели, вызовите метод <code>unlock()</code>. Эта процедура не позволяет объектам, ссылающимся на данный экземпляр BitmapData, обновляться, пока не будет завершено изменение пикселей.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Положение по оси <i>x</i> пикселей, значение которого меняется.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Положение по оси <i>y</i> пикселя, значение которого меняется.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Полученный ARGB-цвет пикселя. Если растровое изображение непрозрачное, то альфа-составляющая значения цвета игнорируется.
     
     </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере с помощью метода <code>setPixel32()</code> рисуется прозрачная красная линия в объекте BitmapData (значение альфа-канала = 0х60).
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Преобразует массив байтов в прямоугольный участок пиксельных данных. Для каждого пикселя вызывается метод <code>ByteArray.readUnsignedInt()</code> и записывается возвращаемое значение. Если массив байтов заканчивается, прежде чем будет заполнен весь прямоугольник, функция возвращает исключение. Массив байтов должен содержать 32-разрядные ARGB-значения пикселей. Перед считыванием пикселей и после него поиск по массиву байтов не выполняется.  
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Задает прямоугольную область объекта BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Объект ByteArray состоит из 32-разрядных неумноженных пиксельных значений, которые должны использоваться в прямоугольной области.
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; Объект <code>inputByteArray</code> не содержит достаточно данных для заполнения области прямоугольника <code>rect</code>. Метод заполняет максимально возможное количество пикселей, а затем выдает исключение.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты rect и inputByteArray имеют значение null.
      
      </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере методы <code>getPixels()</code> и <code>setPixels()</code> используются для копирования пикселей из одного объекта BitmapData в другой.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Преобразует вектор в прямоугольную область пиксельных данных. Для каждого пикселя элемент вектора считывается и записывается в пиксель BitmapData. Ожидается, что данные в векторе являются 32-разрядными ARGB-значениями пикселей. 
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Задает прямоугольную область объекта BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Векторный объект состоит из 32-разрядных неумноженных пиксельных значений, используемых в прямоугольной области  
     
     </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Векторный массив недостаточно большой для чтения всех пиксельных данных.
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Сопоставляет пиксельные значения в изображении с заданным пороговым значением и присваивает пикселям, прошедшим проверку, новые цветовые значения. С помощью метода <code>threshold()</code> можно изолировать и заменить диапазоны в изображении и выполнить другие логические операции над пикселями изображения. 
     
     <p>Проверка метода <code>threshold()</code> имеет следующую логику:</p> 
     
     <ol><li>если <code>((pixelValue & mask) operation (threshold & mask))</code>, то установите <code>color</code> для пикселя;</li><li>В противном случае, если <code>copySource == true</code>, то пиксель получает соответствующее значение из <code>sourceBitmap</code>.</li></ol>
     
     <p>Параметр <code>operation</code> задает оператор сравнения, используемый при пороговой проверке. Например, используя «==» в качестве параметра <code>operation</code> можно изолировать конкретное цветовое значение в изображении. Или с помощью операции <code>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</code> можно сделать все целевые пиксели полностью прозрачными, если альфа-значение пикселя исходного изображения меньше 0x7F. Этот прием можно использовать для анимированных переходов и других эффектов.</p>
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Вводное растровое изображение для использования. Исходным изображением может быть другой объект BitmapData, или оно может ссылаться на текущий экземпляр BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, определяющий область исходного изображения, которое будет использоваться для ввода.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Точка в целевом изображении (текущем экземпляре BitmapData), соответствующая правому левому углу исходного прямоугольника.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; В качестве строки String передается один из следующих операторов сравнения: "&lt;", "&lt;=", ">", ">=", "==", "!="
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Значение, с которым сопоставляется каждый пиксель, чтобы узнать, больше он или равен порогу.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Значение цвета, которое получает пиксель при успешном прохождении пороговой проверки. Значение по умолчанию &mdash; 0x00000000.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; Маска используется с целью изоляции компонента цвета. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; При значении <code>true</code> пиксельные значения из исходного изображения копируются в целевое, если пиксель не проходит пороговый тест. При значении <code>false</code> исходное изображение не копируется, если пиксель не проходит пороговую проверку. 
     
     </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Число измененных пикселей.
     </td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Объекты sourceBitmapData, sourceRect, destPoint или operation имеют значение null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Строка operation не является допустимой операцией. 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере используется метод <code>perlinNoise()</code> для добавления сине-красного рисунка в объект BitmapData, а затем вызывается метод <code>threshold()</code>, чтобы скопировать эти пиксели из первого объекта BitmapData во второй, заменяя пиксели, в которых значение красного больше 0x80 (50%), пикселями с прозрачным красным цветом(0x20FF0000).
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Разблокирует изображение, чтобы любые объекты, ссылающиеся на объект BitmapData, например объекты Bitmap, обновлялись при изменении данного объекта BitmapData. Чтобы повысить производительность, используйте этот метод вместе с методом <code>lock()</code> до или после многочисленных вызовов метода <code>setPixel()</code> или <code>setPixel32()</code>.
     
     </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Измененная область объекта BitmapData. Если не задать значения для данного параметра, измененной считается вся область объекта BitmapData. Для использования этого параметра требуется проигрыватель Flash Player версии 9.0.115.0 или более поздней.
     
     </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере создается объект BitmapData на базе свойства <code>bitmapData</code> объекта Bitmap с именем <code>picture</code>. Затем вызывается метод <code>lock()</code> перед вызовом сложной пользовательской функции, <code>complexTransformation()</code>, изменяющей объект BitmapData. (Объект <code>picture</code> и функция <code>complexTransformation()</code> в этом примере не определяются.) Даже если функция <code>complexTransformation()</code> обновляет свойство <code>bitmapData</code> объекта <code>picture</code>, изменения не отображаются, пока код не вызовет метод <code>unlock()</code> объекта <code>bitmapData</code>.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Примеры<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> В следующем примере класс BitmapDataExample используется для загрузки изображения Image.gif в объект DisplayObject в месте по умолчанию (0, 0). Затем копия Image.gif помещается справа от оригинала, в котором применяются новые цвета к пикселям, тестируемым с помощью метода <code>threshold()</code>. Это можно сделать, выполнив следующие действия.
 <ol><li>Создается свойство <code>url</code>, описывающее местоположение и имя файла изображения.</li><li>Конструктор класса создает объект Loader, который затем создает экземпляр прослушивателя событий, отправляемых по завершении обработки изображения методом <code>completeHandler()</code>.</li><li>Затем объект URLRequest с именем <code>request</code> передается методу <code>loader.load()</code>, который загружает изображение в память с помощью экранного объекта.</li><li>После этого изображение добавляется в список отображения, который отображает изображение на экране в положении с координатами <i>x = 0, y = 0</i>.</li><li>Затем метод <code>completeHandler()</code> выполняет следующие действия. 
     <ul><li>Создает второй объект Loader и инициализированный вместе с ним объект Bitmap.</li><li>Создает второй объект Bitmap, <code>duplicate</code>, который в свою очередь вызывает метод <code>duplicateImage()</code>, создающий дубликат исходного изображения. </li><li>Создает объект BitmapData, который назначается объекту BitmapData объекта <code>duplicate</code>.</li><li>Создает новый объект Rectangle, инициализированный с теми же координатами, шириной и высотой, что и исходное изображение.</li><li>Создает новый объект Point с координатами по умолчанию: <i>x = 0, y = 0</i>.</li><li>Создает следующие переменные:
         <ul><li><code>operation</code> &mdash; Использует новый цвет при пороговом значении, которое больше или равно исходному значению.</li><li><code>threshold</code> &mdash; Значение, с которым сравнивается каждый пиксель (в данном примере это светло-серый цвет со значением альфа-канала 0xCC). </li><li><code>color</code> &mdash; Цвет, указанный для пикселей, проходящих пороговый тест; в данном случае это желтый цвет.</li><li><code>mask</code> &mdash; Диаметрально противоположный цвет (прозрачный синий).</li><li><code>copySource</code> &mdash; Установлено на значение <code>false</code>, указывающее на то, что значения пикселей не копируются в том случае, если они не проходят пороговое значение. Это значение не имеет смысла, потому что изображение продублировано и изменяются только пиксели, прошедшие пороговый тест.</li></ul></li><li>Вызывает метод <code>threshold()</code> с использованием предшествующих переменных. В результате мы получаем уравнение порога: <code>if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00</code>. </li></ul></li></ol>
 <p> <b>Примечания.</b>
 <ul><li>SWF-файл потребуется откомпилировать с установленным для параметра «Безопасность локального воспроизведения» режимом «Доступ только к локальным файлам».
 </li><li>Данный пример требует, чтобы файл с именем Image.gif находился в том же каталоге, что и SWF-файл.
 </li><li>Рекомендуется использовать изображение с шириной не больше 80 пикселей. </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:34 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ru_RU/legalnotices/index.html">Юридическая информация</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Политика конфиденциальности онлайн</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Почему по-английски?</span>
				</div>
				<div class="white_content_body">
					<b>Содержимое Справочника ActionScript 3.0 отображается на английском языке</b><br><br>
					Не все части Справочника ActionScript 3.0 переводятся на все языки. Если какой-то текстовый элемент не переведен, он отображается на английском языке. Например, компонент ga.controls.HelpBox не переведен ни на один из языков. Это значит, что в русской версии справки компонент ga.controls.HelpBox будет отображаться на английском языке.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:34 AM Z  -->
