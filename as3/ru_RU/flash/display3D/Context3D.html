<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Справочник по ActionScript&reg; 3.0 для платформы Adobe&reg; Flash&reg;  "><meta name="lang" content="ru-ru"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:11"><meta name="runtime" content="air"><meta name="runtimever" content="air:3"><meta name="product" content="flash player"><meta name="productver" content="flash player:11"><meta name="product" content="air"><meta name="productver" content="air:3"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="Context3D,flash.display3D.Context3D,backBufferHeight,backBufferWidth,driverInfo,enableErrorChecking,maxBackBufferHeight,maxBackBufferWidth,profile,supportsVideoTexture,totalGPUMemory,clear,configureBackBuffer,createCubeTexture,createIndexBuffer,createProgram,createRectangleTexture,createTexture,createVertexBuffer,createVertexBufferForInstances,createVideoTexture,dispose,drawToBitmapData,drawTriangles,drawTrianglesInstanced,present,setBlendFactors,setColorMask,setCulling,setDepthTest,setFillMode,setProgram,setProgramConstantsFromByteArray,setProgramConstantsFromMatrix,setProgramConstantsFromVector,setRenderToBackBuffer,setRenderToTexture,setSamplerStateAt,setScissorRectangle,setStencilActions,setStencilReferenceValue,setTextureAt,setVertexBufferAt"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>Context3D - Adobe ActionScript&reg; 3 (AS3 )</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Среды выполнения";
			var productsLabel = "Продукты";
			var noneLabel = "Не задан";
			var qsearchBoxLabel = "Быстрый поиск";
			var qsearchText = "Термин не найден";
			var ajaxErrorMsg="Ошибка при загрузке страницы";
			var ajaxErrorTryMsg="Повторите попытку";
			var ajaxLoadingMsg="Загрузка еще не завершена";
			var cancelMsg = "Отмена";
			var classesText = "Классы";
			var strJiveReply = "Этот вопрос был задан по поводу следующей статьи: "
			var showFilters = "Показать фильтры";
			var hideFilters = "Скрыть фильтры";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Справочник по ActionScript<sup>&reg;</sup> 3.0 для платформы Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Домашняя страница </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="Context3D.html#top" style="display:">Показать список пакетов и классов</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="Context3D.html#top" style="display:none">Скрыть список пакетов и классов</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Пакеты </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Классы </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Что нового </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Указатель </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Приложения </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Почему по-английски?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ru_RU/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Фильтры:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Получение данных с сервера...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Получение данных с сервера...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="Context3D.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display3D&nbsp;</a><br>
								<h1 id="classProductName">Context3D&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="Context3D.html#propertySummary" style="display:none"> Свойства </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Свойства </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Конструктор </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="Context3D.html#methodSummary" style="display:none"> Методы </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="Context3D.html#constantSummary" style="display:none"> Глобальные константы </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="Context3D.html#eventSummary" style="display:none"> События </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="Context3D.html#styleSummary" style="display:none"> Стили </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="Context3D.html#SkinPartSummary" style="display:none"> Компоненты темы оформления </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="Context3D.html#SkinStateSummary" style="display:none"> Состояния тем оформления </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="Context3D.html#effectSummary" style="display:none"> Эффекты </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="Context3D.html#constantSummary" style="display:none"> Константы </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="Context3D.html#methodSummary" style="display:none"> Глобальные функции </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="Context3D.html#methodSummary" style="display:none">Функции</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="Context3D.html#interfaceSummary" style="display:none"> Интерфейсы </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="Context3D.html#classSummary" style="display:none"> Классы </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="Context3D.html#includeExamplesSummary" style="display:none"> Примеры </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="Context3D.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Классы
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Пакет</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display3D</a></td></tr><tr><td class="classHeaderTableLabel">Класс</td><td class="classSignature">public final   class  Context3D</td></tr><tr><td class="classHeaderTableLabel">Наследование</td><td class="inheritanceList">Context3D  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../events/EventDispatcher.html">EventDispatcher</a> <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p></p>
     Класс Context3D обеспечивает контекст для визуализации геометрически определенной графики.
     
     <p>Контекст визуализации включает поверхность рисунка, а также связанные с ней ресурсы и состояние. Когда это возможно, контекст визуализации использует аппаратный графический процессор. В противном случае используется программное обеспечение. (Если платформа не поддерживает визуализацию через Context3D, свойство <code>stage3Ds</code> объекта Stage содержит пустой список.)</p>
     
               <p>Контекст визуализации Context3D &mdash; это программируемый канал, который очень похож на OpenGL ES 2, но является абстрактным, что делает его совместимым с разными интерфейсами оборудования и графических процессоров. Хотя канал визуализации разработан для 3D-графики, визуализация не обязательно должна быть трехмерной. Таким образом можно создать 2D-визуализатор, предоставив соответствующие программы вершинных и пиксельных фрагментных шейдеров. И при 3D-, и при 2D-визуализации единственным поддерживаемым геометрическим примитивом является треугольник.</p>
     
               <p>Получите экземпляр класса Context3D, вызвав метод <code>requestContext3D()</code> для объекта Stage3D. В одной рабочей области может существовать ограниченное число объектов Context3D; по одному для каждого объекта Stage3D в списке <code>Stage.stage3Ds</code>. Когда создается контекст, объект Stage3D отправляет событие <code>context3DCreate</code>. Контекст визуализации можно в любое время уничтожать и воссоздавать, например, когда фокус получает другое приложение, использующее графический процессор. В коде необходимо предусмотреть получение нескольких событий <code>context3DCreate</code>. Расположите область визуализации в рабочей области с использованием свойств <code>x</code> и <code>y</code> связанного экземпляра Stage3D.</p>  
     
     
     
     
               <p>Чтобы визуализировать и отобразить сцену (после получения объекта Context3D), обычно требуется выполнить следующие действия.</p>
               <ol>
                  <li>Настройте атрибуты буфера главного дисплея, вызвав метод <code>configureBackBuffer()</code>.</li>
                  <li>Создайте и инициализируйте ресурсы визуализации, включая:
      <ul>
                        <li>буферы вершин и индексов, определяющие геометрию сцены;</li>
                        <li>вершинные и пиксельные программы (шейдеры) для визуализации сцены;</li>
                        <li>текстуры;</li>
                     </ul>
                  </li>
                  <li>Визуализируйте кадр.
      <ul>
                        <li>Задайте необходимое состояние средства визуализации для объекта или коллекции объектов в сцене.</li>
                        <li>Вызовите метод <code>drawTriangles()</code> для визуализации набора треугольников.</li>
                        <li>Измените состояние визуализации для следующей группы объектов.</li>
                        <li>Вызовите метод <code>drawTriangles()</code> для отрисовки треугольников, определяющих объекты.</li>
                        <li>Повторяйте эти действия, пока сцена не будет визуализирована полностью.</li>
                        <li>Вызовите метод <code>present()</code> для отображения визуализированной сцены на рабочей области.</li>
                     </ul>
                  </li>
               </ol>
     
               <p>При визуализации применяются перечисленные ниже ограничения.</p>
               <p>Ограничение ресурсов:
      <table class="innertable" ><tr><th>Ресурс</th><th>Разрешенное число</th><th>Общая память</th></tr><tr><td>
                                 <code>Vertex buffers</code>
                              </td><td>4096</td><td>256 МБ</td></tr><tr><td>
                                 <code>Index buffers</code>
                              </td><td>4096</td><td>128 МБ</td></tr><tr><td>
                                 <code>Programs</code>
                              </td><td>4096</td><td>16 МБ</td></tr><tr><td>
                                 <code>Textures</code>
                              </td><td>4096</td><td>128 МБ</td></tr><tr><td>
                                 <code>Cube textures</code>
                              </td><td>4096</td><td>256 МБ</td></tr></table>
               </p>
               <p>Ограничения AGAL: 200 кодов операций на программу.</p>
     
               <p>Ограничение вызова методов рисования: 32 768 вызовов метода <code>drawTriangles()</code> на каждый вызов <code>present()</code>.</p>
               <p>К текстурам применяются перечисленные ниже ограничения.</p>
               <p>Ограничения текстур для 32-разрядной версии AIR:
      <table class="innertable" ><tr><th>Текстура</th><th>Максимальный размер</th><th>Общая память графического процессора</th></tr><tr><td>
                                 <code>Обычная текстура (ниже базового расширенного профиля)</code>
                              </td><td>2048&nbsp;x&nbsp;2048</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Обычная текстура (базовый расширенный профиль и профиль более высокого уровня)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Прямоугольная текстура (ниже базового расширенного профиля)</code>
                              </td><td>2048&nbsp;x&nbsp;2048</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Прямоугольная текстура (базовый расширенный профиль и профиль более высокого уровня)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Кубическая текстура</code>
                              </td><td>1024 x 1024</td><td>256 МБ</td></tr></table>
	              </p> 
	              <p>Ограничения текстур для 64-разрядной версии AIR (настольный ПК):
      <table class="innertable" ><tr><th>Текстура</th><th>Максимальный размер</th><th>Общая память графического процессора</th></tr><tr><td>
                                 <code>Обычная текстура (ниже базового расширенного профиля)</code>
                              </td><td>2048&nbsp;x&nbsp;2048</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Обычная текстура (от базового расширенного профиля до стандартного)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Обычная текстура (расширенный стандартный профиль и профиль более высокого уровня)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>2048&nbsp;МБ</td></tr><tr><td>
                                 <code>Прямоугольная текстура (ниже базового расширенного профиля)</code>
                              </td><td>2048&nbsp;x&nbsp;2048</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Прямоугольная текстура (от базового расширенного профиля до стандартного)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>512&nbsp;МБ</td></tr><tr><td>
                                 <code>Прямоугольная текстура (стандартный расширенный профиль и профиль более высокого уровня)</code>
                              </td><td>4096&nbsp;x&nbsp;4096</td><td>2048&nbsp;МБ</td></tr><tr><td>
                                 <code>Кубическая текстура</code>
                              </td><td>1024 x 1024</td><td>256 МБ</td></tr></table>
	              </p>
               <p>512&nbsp;MБ &mdash; это абсолютный предел для текстур, включая память текстур, необходимую для множественных отображений. Однако для граней кубической текстуры, ограничение памяти составляет 256&nbsp;МБ.</p>
     
               <p>Нельзя создавать объекты Context3D с помощью конструктора Context3D. Он создается и становится доступным в качестве свойства экземпляра Stage3D. Класс Context3D может использоваться в Flash Player и в AIR на компьютерах и мобильных устройствах.</p>
         
            <p></p><p><a href="Context3D.html#includeExamplesSummary">Посмотреть примеры</a></p><p><span class="classHeaderTableLabel">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a><br/><a href="Context3DClearMask.html" target="">Context3DClearMask</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DProgramType.html" target="">Context3DProgramType</a><br/><a href="Context3DRenderMode.html" target="">Context3DRenderMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="textures/CubeTexture.html" target="">flash.display3D.textures.CubeTexture</a><br/><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a><br/><a href="../geom/Matrix3D.html" target="">flash.geom.Matrix3D</a><br/><a href="Program3D.html" target="">Program3D</a><br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a><br/><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Общедоступные свойства</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Скрыть унаследованные общедоступные свойства</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Показать унаследованные общедоступные свойства</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Свойство</th><th>Определено</th></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferHeight" class="signatureLink">backBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[только для чтения]  
        Определяет высоту заднего буфера, которая может быть изменена с помощью успешного вызова метода configureBackBuffer().</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferWidth" class="signatureLink">backBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[только для чтения]  
        Определяет ширину заднего буфера, которая может быть изменена с помощью успешного вызова метода configureBackBuffer().</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Ссылка на объект класса или функцию конструктора для данного экземпляра объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#driverInfo" class="signatureLink">driverInfo</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[только для чтения]  
         Тип драйвера графической библиотеки, используемой этим контекстом визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#enableErrorChecking" class="signatureLink">enableErrorChecking</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription"> 
         Указывает, передается ли приложению отчет об ошибках, обнаруженных программой визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferHeight" class="signatureLink">maxBackBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        Определяет максимальную высоту заднего буфера.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferWidth" class="signatureLink">maxBackBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        Определяет максимальную ширину заднего буфера.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::12##AIR::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#profile" class="signatureLink">profile</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[только для чтения] 
		Профиль поддержки функций, используемый данным объектом Context3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#supportsVideoTexture" class="signatureLink">supportsVideoTexture</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[статические] [только для чтения] 
          Определяет, поддерживает ли эффект Context3D видеотекстуру.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::21##AIR::21##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#totalGPUMemory" class="signatureLink">totalGPUMemory</a> : <a href="../../Number.html">Number</a><div class="summaryTableDescription">[только для чтения]  
         Возвращает общую память графического процессора, выделенную структурой данных Stage3D приложения. Когда ресурсный объект графического процессора создан, использованная память хранится в Context3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Общедоступные методы </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Скрыть унаследованные общедоступные методы</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Показать унаследованные общедоступные методы</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Метод</th><th>Определено</th></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#addEventListener()" class="signatureLink">addEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false, priority:<a href="../../int.html">int</a> = 0, useWeakReference:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	Регистрирует объект прослушивателя события на объекте EventDispatcher для получения прослушивателем уведомления о событии.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#clear()" class="signatureLink">clear</a>(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Очищает буферы цвета, глубины и трафарета, связанные с данным объектом Context3D, и заполняет их указанными значениями.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#configureBackBuffer()" class="signatureLink">configureBackBuffer</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает размеры области просмотра и другие атрибуты буфера визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createCubeTexture()" class="signatureLink">createCubeTexture</a>(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></div><div class="summaryTableDescription">
         Создается объект CubeTexture.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createIndexBuffer()" class="signatureLink">createIndexBuffer</a>(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></div><div class="summaryTableDescription">
         Создается объект IndexBuffer3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createProgram()" class="signatureLink">createProgram</a>():<a href="Program3D.html">Program3D</a></div><div class="summaryTableDescription">
         Создается объект Program3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.8##AIR::3.8##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createRectangleTexture()" class="signatureLink">createRectangleTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></div><div class="summaryTableDescription">
         Создает объект Rectangle Texture.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createTexture()" class="signatureLink">createTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></div><div class="summaryTableDescription">
         Создается объект Texture.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVertexBuffer()" class="signatureLink">createVertexBuffer</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         Создается объект VertexBuffer3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#createVertexBufferForInstances()" class="signatureLink">createVertexBufferForInstances</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         Создается объект VertexBuffer3D для данных экземпляров.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVideoTexture()" class="signatureLink">createVideoTexture</a>():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></div><div class="summaryTableDescription">
         Создает объект VideoTexture.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#dispatchEvent()" class="signatureLink">dispatchEvent</a>(event:<a href="../events/Event.html">Event</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Посылает событие в поток событий.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#dispose()" class="signatureLink">dispose</a>(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Освобождает все ресурсы и внутреннее хранилище, связанные с данным объектом Context3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawToBitmapData()" class="signatureLink">drawToBitmapData</a>(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Отрисовка текущего буфера визуализации в растровом изображении.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#drawTriangles()" class="signatureLink">drawTriangles</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Указанные треугольники визуализируются с использованием текущих буферов и состояния данного объекта Context3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawTrianglesInstanced()" class="signatureLink">drawTrianglesInstanced</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Указанные экземпляры треугольников визуализируются с использованием текущих буферов и состояния данного объекта Context3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#hasEventListener()" class="signatureLink">hasEventListener</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Проверяет, имеет ли объект EventDispatcher прослушиватели, зарегистрированные для определенного типа события.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает, определено ли заданное свойство для объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает, есть ли экземпляр класса Object в цепи прототипов объекта, заданного в качестве параметра.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#present()" class="signatureLink">present</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Отображает задний буфер визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Показывает наличие заданного свойства и его перечисляемость.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#removeEventListener()" class="signatureLink">removeEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	Удаляет прослушиватель из объекта EventDispatcher.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setBlendFactors()" class="signatureLink">setBlendFactors</a>(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Указывает коэффициенты, используемые для наложения цвета вывода операции рисования на существующий цвет.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setColorMask()" class="signatureLink">setColorMask</a>(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Устанавливает маску, используемую при записи цветов в буфер визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setCulling()" class="signatureLink">setCulling</a>(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает режим отбора треугольников.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setDepthTest()" class="signatureLink">setDepthTest</a>(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает тип сравнения, используемый для тестирования глубины.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::16##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#setFillMode()" class="signatureLink">setFillMode</a>(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
		Задает режим заливки, используемый для визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgram()" class="signatureLink">setProgram</a>(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает вершинные и фрагментные шейдерные программы для использования в ходе последующей визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.1##AIR::3.1##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromByteArray()" class="signatureLink">setProgramConstantsFromByteArray</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает константы для использования шейдерными программами с применением параметров, хранящихся в объекте ByteArray.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromMatrix()" class="signatureLink">setProgramConstantsFromMatrix</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает константы для использования шейдерными программами с применением значений, хранящихся в объекте Matrix3D.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromVector()" class="signatureLink">setProgramConstantsFromVector</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает входные данные констант для шейдерных программ.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Задает доступность динамического свойства для операций цикла.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToBackBuffer()" class="signatureLink">setRenderToBackBuffer</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает задний буфер визуализации в качестве цели визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToTexture()" class="signatureLink">setRenderToTexture</a>(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает указанную текстуру в качестве цели визуализации.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.6##AIR::3.6##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setSamplerStateAt()" class="signatureLink">setSamplerStateAt</a>(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Ручная перезапись состояния образца текстуры.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setScissorRectangle()" class="signatureLink">setScissorRectangle</a>(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает прямоугольник вырезания, который является типом маски рисования.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilActions()" class="signatureLink">setStencilActions</a>(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает режим трафаретов и операцию.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilReferenceValue()" class="signatureLink">setStencilReferenceValue</a>(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
         Задает значение сравнения трафаретов, используемое для проверок трафаретов.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setTextureAt()" class="signatureLink">setTextureAt</a>(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Задает текстуру, которая будет использоваться в качестве регистра входной текстуры фрагментной программы.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setVertexBufferAt()" class="signatureLink">setVertexBufferAt</a>(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Указывает, какие компоненты данных вершин соответствуют одному вводу данных в шейдерную вершинную программу.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Возвращает строковое представление этого объекта, отформатированного в соответствии со стандартами, принятыми для данной локали.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Возвращает строковое представление заданного объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Возвращает элементарное значение заданного объекта.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#willTrigger()" class="signatureLink">willTrigger</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Проверяет, зарегистрирован ли прослушиватель события для указанного типа события с данным объектом EventDispatcher или любым его предшественником.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="eventSummary" id="eventSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">События</div><div class="showHideLinks"><a href="http://help.adobe.com/ru_RU/Flex/4.6/UsingSDK/WS2db454920e96a9e51e63e3d11c0bf69084-7ee9.html" target="_blank">Дополнительные сведения о событиях</a></div><div class="showHideLinks"><div id="hideInheritedEvent" class="hideInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(false,'Event');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Скрыть унаследованные события</a></div><div id="showInheritedEvent" class="showInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(true,'Event');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Показать унаследованные события</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable hideInheritedEvent" id="summaryTableEvent"><tr><th>&nbsp;</th><th colspan="2">Событие</th><th> Сводка </th><th>Определено</th></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:activate" class="signatureLink">activate</a></div></td><td class="summaryTableDescription summaryTableCol">[многоадресное событие] Отправляется, когда проигрыватель Flash Player или приложение AIR перемещается в фокус операционной системы и становится активным.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:deactivate" class="signatureLink">deactivate</a></div></td><td class="summaryTableDescription summaryTableCol">[многоадресное событие] Отправляется, когда проигрыватель Flash Player или приложение AIR теряет фокус системы и становится неактивным.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Сведения о свойстве</div><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferHeight" id="backBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferHeight</h3></td><td class="detailHeaderType">свойство</td></tr></table><div class="detailBody"><code>backBufferHeight:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Определяет высоту заднего буфера, которая может быть изменена с помощью успешного вызова метода <code>configureBackBuffer()</code>. Высота может изменяться при изменении коэффициента масштабирования браузера, если в последнем успешном вызове метода <code>configureBackBuffer()</code> для <code>wantsBestResolutionOnBrowserZoom</code> установлено значение <code>true</code>. Изменение высоты можно определить, зарегистрировав прослушиватель событий для изменения масштаба браузера.
        
        </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferHeight():<a href="../../int.html">int</a></code><br/><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferWidth" id="backBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferWidth</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>backBufferWidth:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Определяет ширину заднего буфера, которая может быть изменена с помощью успешного вызова метода <code>configureBackBuffer()</code>. Ширина может изменяться при изменении коэффициента масштабирования браузера, если в последнем успешном вызове метода <code>configureBackBuffer()</code> для <code>wantsBestResolutionOnBrowserZoom</code> установлено значение <code>true</code>. Изменение ширины можно определить, зарегистрировав прослушиватель событий для изменения масштаба браузера.
		
		</p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferWidth():<a href="../../int.html">int</a></code><br/><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="driverInfo" id="driverInfo"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>driverInfo</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>driverInfo:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Тип драйвера графической библиотеки, используемой этим контекстом визуализации. Показывает, выполняется ли визуализации с использованием программного обеспечения, драйвера DirectX или драйвера OpenGL. Также показывает, не произошел ли сбой при аппаратной визуализации. При сбое аппаратной визуализации Flash Player запускает программную визуализацию для объекта Stage3D, а объект <code>driverInfo</code> содержит одно из следующих значений:
         <ul><li>"Software Hw_disabled=userDisabled". В настройках Adobe Flash Player не установлен флажок «Включить аппаратное ускорение».</li><li>"Software Hw_disabled=oldDriver". Существуют известные проблемы с драйвером графики аппаратных средств. Эту проблему можно решить обновлением графического драйвера.</li><li>"Software Hw_disabled=unavailable". Известные проблемы с драйвером графики аппаратных средств или сбой инициализации графического адаптера.</li><li>"Software Hw_disabled=explicit". Содержимое явно запросило программную визуализацию с помощью события requestContext3D.</li><li>"Software Hw_disabled=domainMemory" &mdash; в содержимом используется параметр domainMemory, для которого требуется лицензия при использовании с аппаратной визуализацией Stage3D. Перейдите по адресу <a href="http://www.adobe.com/go/fpl" target="_new">adobe.com/go/fpl_ru</a>.</li></ul>
         
         </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get driverInfo():<a href="../../String.html">String</a></code><br/></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="enableErrorChecking" id="enableErrorChecking"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>enableErrorChecking</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>enableErrorChecking:<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Указывает, передается ли приложению отчет об ошибках, обнаруженных программой визуализации.
          
         <p>Когда <code>enableErrorChecking</code> имеет значение <code>true</code>, методы <code>clear()</code> и <code>drawTriangles()</code> выполняются синхронно и могут выдать ошибки. Когда <code>enableErrorChecking</code> имеет значение <code>false</code> (по умолчанию), методы <code>clear()</code> и <code>drawTriangles()</code> выполняются асинхронно, сообщения об ошибках не выдаются. Активация проверки на наличие ошибок снижает производительность визуализации. Проверку ошибок следует включать только при отладке.</p>
         
         </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get enableErrorChecking():<a href="../../Boolean.html">Boolean</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set enableErrorChecking(value:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><br/><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferHeight" id="maxBackBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferHeight</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferHeight:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Определяет максимальную высоту заднего буфера. Изначальное значение соответствует системному ограничению платформы. Свойству можно задать значение, меньшее или равное системному ограничению, но не превышающее его. Свойству можно задать значение, большее или равное минимальному ограничению, но не меньше его. Минимальное ограничение является постоянным значением, равным 32, когда задний буфер не настроен. Минимальное ограничение соответствует значению параметра высоты в последнем успешном вызове метода <code>configureBackBuffer()</code> после настройки заднего буфера.
        
        </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferHeight():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferHeight(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferWidth" id="maxBackBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferWidth</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferWidth:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Определяет максимальную ширину заднего буфера. Изначальное значение соответствует системному ограничению платформы. Свойству можно задать значение, меньшее или равное системному ограничению, но не превышающее его. Свойству можно задать значение, большее или равное минимальному ограничению, но не меньше его. Минимальное ограничение является постоянным значением, равным 32, когда задний буфер не настроен. Минимальное ограничение соответствует значению параметра ширины в последнем успешном вызове метода <code>configureBackBuffer()</code> после настройки заднего буфера.
		
        </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferWidth():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferWidth(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::12##AIR::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="profile" id="profile"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>profile</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>profile:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 12, AIR 4</td></tr></table><p></p><p></p><p>
		Профиль поддержки функций, используемый данным объектом Context3D.
		</p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get profile():<a href="../../String.html">String</a></code><br/><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DProfile.html" target="">Context3DProfile</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="propertyDetail" id="propertyDetail"></a><a name="supportsVideoTexture" id="supportsVideoTexture"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>supportsVideoTexture</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>supportsVideoTexture:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
          Определяет, поддерживает ли эффект Context3D видеотекстуру.
         
          </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public static function get supportsVideoTexture():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::21##AIR::21##"><a name="propertyDetail" id="propertyDetail"></a><a name="totalGPUMemory" id="totalGPUMemory"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>totalGPUMemory</h3></td><td class="detailHeaderType">свойство</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>totalGPUMemory:<a href="../../Number.html">Number</a></code>&nbsp;&nbsp;[только для чтения] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 21, AIR 21</td></tr></table><p></p><p></p><p> 
         <p>Возвращает общую память графического процессора, выделенную структурой данных Stage3D приложения.</p>
		 <p>Когда ресурсный объект графического процессора создан, использованная память хранится в Context3D. Эта память включает в себя буферы индексов, буферы вершин, текстуры (за исключением текстур видео) и программы, созданные при помощи этого объекта Context3D.</p>
		 <p>API-интерфейс<code>totalGPUMemory</code> возвращает пользователю общий объем памяти, использованной вышеперечисленными ресурсами. Возвращенное значение по умолчанию равно 0. Общий объем возвращенной памяти графического процессора измеряется в байтах. Информация предоставляется только в режиме direct на мобильных устройствах и в режимах direct и GPU на настольных компьютерах (на настольных компьютерах при выборе режима <code>&lt;renderMode&gt;gpu&lt;/renderMode&gt;</code> будет автоматически использоваться режим <code>&lt;renderMode&gt;direct&lt;/renderMode&gt;</code>). </p>
		 
         Этот API-интерфейс можно использовать, когда SWF имеет версию 32 или более позднюю.
         
         
         </p><br/><br/><span class="label"> Реализация </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get totalGPUMemory():<a href="../../Number.html">Number</a></code><br/></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Сведения о методе</div><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="clear()" id="clear()"></a><a name="clear(Number,Number,Number,Number,Number,uint,uint)" id="clear(Number,Number,Number,Number,Number,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clear</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td></tr></table><div class="detailBody"><code> public function clear(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Очищает буферы цвета, глубины и трафарета, связанные с данным объектом Context3D, и заполняет их указанными значениями.
         
         <p>Задайте параметр <code>mask</code>, чтобы указать, какие буферы требуется очистить. Используйте константы, определенные в классе Context3DClearMask, чтобы установить параметр <code>mask</code>. Используйте побитовый оператор OR (ИЛИ), «|», для добавления нескольких буферов в маску (или используйте <code>Context3DClearMask.ALL</code>). При визуализации в заднем буфере метод <code>configureBackBuffer()</code> должен вызываться перед любыми вызовами метода <code>clear()</code>.</p>
         
         <p><b>Примечание.</b> Если для параметра задается значение за пределами разрешенного диапазона, числовые значения параметра ограничиваются до диапазона от 0 до 1 (без уведомления). Подобным образом, если значение <code>stencil</code> больше 0xff, задается это значение. </p> 
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; красный компонент цвета, с использованием которого требуется очистить буфер цвета, в диапазоне от 0 до 1.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; зеленый компонент цвета, с использованием которого требуется очистить буфер цвета, в диапазоне от 0 до 1.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; синий компонент цвета, с использованием которого требуется очистить буфер цвета, в диапазоне от 0 до 1.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; альфа-компонент цвета, с использованием которого требуется очистить буфер цвета, в диапазоне от 0 до 1. Альфа-компонент не используется для наложения. Он записывается напрямую в буфер альфа.        
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">depth</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; значение, с использованием которого требуется очистить буфер глубины, в диапазоне от 0 до 1.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stencil</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 8-битовое значение, с использованием которого требуется очистить буфер трафаретов в диапазоне от 0x00 до 0xff.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xffffffff</code>)<code></code> &mdash; указывает, какой буфер очистить.
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DClearMask.html" target="">Context3DClearMask</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="configureBackBuffer()" id="configureBackBuffer()"></a><a name="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)" id="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>configureBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function configureBackBuffer(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает размеры области просмотра и другие атрибуты буфера визуализации.
         
         <p>Визуализация выполняется с двойной буферизацией. Задний буфер переключается на видимый передний буфер, когда вызывается метод <code>present()</code>. Минимальный размер буфера составляет 32x32 пикселя. Максимальный размер буфера невидимых поверхностей ограничен емкостью устройства, и пользователь может задать его с помощью свойств <code>maxBackBufferWidth</code> и <code>maxBackBufferHeight</code>. Настройка буфера является трудоемкой операцией. Старайтесь не изменять атрибуты и размер буфера для обычных операций визуализации.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; ширина буфера в пикселях.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; высота буфера в пикселях.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> &mdash; целое значение, указывающее запрошенное качество сглаживания. Значение сопоставляется с числом подвыборок, используемых при сглаживании. Для использования большего числа подвыборок требуется выполнять вычисления, хотя относительное влияние на производительность зависит от конкретных аппаратных средств визуализации. Тип сглаживания и выполнение самого сглаживания зависят от устройства и режима визуализации. Сглаживание не поддерживается программным контекстом визуализации.
         
         <table class="+ topic/table adobe-d/adobetable " ><tr><td>0</td><td>Без сглаживания.</td></tr><tr><td>2</td><td>Минимальное сглаживание.</td></tr><tr><td>4</td><td>Сглаживание высокого качества.</td></tr><tr><td>16</td><td>Сглаживание очень высокого качества.</td></tr></table>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; <code>false</code> указывает, что буфер глубины или трафаретов не создан, <code>true</code> создает буфер глубины и трафаретов. Для приложения AIR 3.2 или более поздней версии, скомпилированного с использованием SWF 15 или более поздней версии: если значение элемента <code>renderMode</code> в файле дескриптора приложения равно <code>direct</code>, то значение элемента <code>depthAndStencil</code> в файле дескриптора приложения должно совпадать со значением данного аргумента. По умолчанию значение элемента <code>depthAndStencil</code> равно <code>false</code>.
		 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolution</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code> обозначает, что в случае, если устройство поддерживает экраны HiDPI, оно попытается выделить более крупный задний буфер, для которого указаны параметры ширины и высоты. Так как это значение добавляет больше пикселей и может изменить результат операций шейдера, оно выключено по умолчанию. Используйте Stage.contentsScaleFactor, чтобы определить, насколько был расширен встроенный задний буфер.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolutionOnBrowserZoom</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Значение <code>true</code> указывает, что размер заднего буфера должен увеличиваться пропорционально увеличению коэффициенту масштабирования браузера. Это значение не изменяется при изменении масштаба браузера. По умолчанию параметр имеет значение <code>false</code>. Воспользуйтесь свойствами <code>maxBackBufferWidth</code> и <code>maxBackBufferHeight</code>, чтобы ограничить увеличение размера заднего буфера. Свойства <code>backBufferWidth</code> и <code>backBufferHeight</code> помогут определить текущий размер заднего буфера.
		 
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Неверный размер ввода: ширины или высоты меньше, чем минимально допустимого размера буфера невидимых поверхностей или больше его максимально допустимого размера.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3709: значение флага <code>depthAndStencil</code> в дескрипторе приложения должно совпадать с булевым значением параметра <code>enableDepthAndStencil</code>, переданным в метод <code>configureBackBuffer()</code> объекта Context3D.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createCubeTexture()" id="createCubeTexture()"></a><a name="createCubeTexture(int,String,Boolean,int)" id="createCubeTexture(int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createCubeTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createCubeTexture(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Создается объект CubeTexture.
         
         <p>Используйте объект CubeTexture для загрузки растровых изображений кубических текстур в контекст визуализации и для ссылки на кубическую текстуру во время визуализации. Кубическая текстура состоит из шести равных по размеру квадратных текстур, упорядоченных в кубической топологии; они используются для описания окрестных наложений.</p>
           
         <p>Нельзя создавать объекты CubeTexture с использованием конструктора CubeTexture; для этого используется этот метод. После создания объекта CubeTexture загрузите данные растровых изображений текстуры с использованием методов <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> или <code>uploadCompressedTextureFromByteArray()</code> объекта CubeTexture.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">size</span>:<a href="../../int.html">int</a></code> &mdash; Длина краев текстуры в текстурных пикселях.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Формат текстурного пикселя списка перечисления Context3DTextureFormat.
         <p> Благодаря сжатию текстур можно хранить изображения текстур в сжатом формате непосредственно в графическом процессоре, тем самым экономя память графического процессора и пропускную способность памяти. Как правило, сжатые текстуры сжимаются в автономном режиме и загружаются в графический процессор в сжатой форме с помощью метода Texture.uploadCompressedTextureFromByteArray. В средах Flash Player 11.4 и AIR 3.4 на настольных платформах появилась поддержка сжатия текстур во время выполнения, что может быть удобно в некоторых случаях, например при визуализации динамических текстур из векторной графики. Обратите внимание, что эта функция в настоящее время недоступна на мобильных платформах и при попытке её использования будет возникать исключение ArgumentError (Несоответствие формата текстуры). Для использования сжатия текстур во время выполнения необходимо выполнить следующее. 1. Создайте объект текстуры. Для этого вызовите метод Context3D.createCubeTexture(), передав flash.display3D.Context3DTextureFormat.COMPRESSED или flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA в качестве параметра формата. 2. Используя экземпляр flash.display3D.textures.Texture, возвращенный методом createCubeTexture(), вызовите либо flash.display3D.textures.CubeTexture.uploadFromBitmapData(), либо flash.display3D.textures.CubeTexture.uploadFromByteArray() для одновременной загрузки и сжатия текстуры.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Задайте значение <code>true</code>, если текстура, скорее всего, будет использоваться в качестве цели визуализации.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Уровень множественных отображений, который должен быть загружен перед визуализацией изображения. Потоковая передача текстур дает возможность загрузить и отобразить вначале наименьшие уровни, а затем, по мере загрузки текстур, отображать все более качественные изображения. Конечные пользователи могут просматривать в приложении изображения более низкого качества, пока загружаются более качественные изображения.
         <p>По умолчанию значение streamingLevels&nbsp;&mdash; 0, то есть перед визуализацией изображения должно загрузиться изображение самого высокого качества во множественном отображении. Этот параметр был добавлен в версиях Flash Player 11.3 и AIR 3.3. Его значение по умолчанию соответствует поведению предыдущих версий Flash Player и AIR. 
         </p>
         <p>Установите для <code>streamingLevels</code> значение от 1 до количества изображений во множественном отображении для включения потоковой передачи текстуры. Например, при наличии множественного отображения, включающего главное изображение самого высокого качества размером 64x64 пикселей. Изображения более низкого качества во множественном отображении могут иметь размер 32x32, 16x16, 8x8, 4x4, 2x2 и 1x1 пикселей (всего 7 изображений или 7 уровней). Уровень 0 &mdash; это изображение самого высокого качества. Максимальным значением этого свойства является log2(min(ширина,высота)). Поэтому для главного изображения размером 64x64 пикселя максимальное значение <code>streamingLevels</code> равно 7. Установите для этого свойства значение 3 для визуализации изображения после загрузки изображения 8x8 пикселей.</p>
         
         <p><b>Примечание.</b> Установка для этого свойства значения больше 0 может влиять на интенсивность использования памяти и производительность. </p>
         
         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов Texture или превышен объем выделенной для текстур памяти.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Текстура глубины не реализована: если предпринимается попытка создать текстуру глубины.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Размер текстуры равен нулю: если параметр <code>size</code> не больше нуля.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Текстура не равна степени двойки: если параметр <code>size</code> не равен степени двойки.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большая текстура: если параметр <code>size</code> больше 1024.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Не удалось создать текстуру: если контексту визуализации не удалось создать объект CubeTexture (но информация о причине недоступна).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Недопустимый потоковый уровень: если значение <code>streamingLevels</code> больше или равно log2(размер).
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createIndexBuffer()" id="createIndexBuffer()"></a><a name="createIndexBuffer(int,String)" id="createIndexBuffer(int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createIndexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createIndexBuffer(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Создается объект IndexBuffer3D.
         
         <p>Используйте объект IndexBuffer3D для загрузки набора индексов треугольника в контекст визуализации и для создания ссылки на этот набор индексов для визуализации. Каждый индекс в буфере индексов ссылается на соответствующую вершину в буфере вершин. Каждый набор из трех индексов определяет треугольник. Передайте объект IndexBuffer3D в метод <code>drawTriangles()</code> для визуализации одного или нескольких треугольников из буфера индексов.</p>
         
         <p>Нельзя создавать объекты IndexBuffer3D с использованием конструктора классов IndexBuffer3D, для этого используется этот метод. После создания объекта IndexBuffer3D загрузите индексы с использованием методов <code>uploadFromVector()</code> или <code>uploadFromByteArray()</code> объекта IndexBuffer3D.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numIndices</span>:<a href="../../int.html">int</a></code> &mdash; количество вершин, которое будет храниться в буфере. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; прогнозируемая интенсивность использования буфера. Используйте одну из констант, определенных в <code>Context3DBufferUsage</code>. Драйвер оборудования может, при правильной настройке, провести соответствующую оптимизацию. Этот параметр доступен только в версиях позднее Flash 12/AIR 4.
 
         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="IndexBuffer3D.html">IndexBuffer3D</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много буферов индексов или превышен объем выделенной для буферов индексов памяти.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большой буфер: когда значение <code>numIndices</code> больше или равно 0xf0000. 
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createProgram()" id="createProgram()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createProgram():<a href="Program3D.html">Program3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Создается объект Program3D.
         
         <p>Используйте объект Program3D для загрузки шейдерных программ в контекст визуализации и для создания ссылки на загруженные программы во время визуализации. В объекте Program3D хранятся две программы: вершинная программа и фрагментная программа (которая также называется пиксельной программой). Программы пишутся на бинарном языке сборки шейдера.</p>
         
         <p>Нельзя создавать объекты Program3D с использованием конструктора Program3D; для этого используется этот метод. После создания объекта Program3D загрузите программы с использованием метода <code>upload()</code> объекта Program3D.</p>
         
         </p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Program3D.html">Program3D</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Общее число программ превышает 4096 или общий объем памяти превышает 16 МБ (используйте метод <code>dispose</code> для освобождения ресурсов объекта Program3D).
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Program3D.html" target="">Program3D</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Этот пример демонстрирует создание, загрузку и активацию пары вершин и пиксельных программ для контекста визуализации. Обратите внимание, что объект <code>renderContext</code> является экземпляром класса Context3D. Программы в примере записаны на языке Adobe Graphics Assembly Language (AGAL). 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.8##AIR::3.8##"><a name="createRectangleTexture()" id="createRectangleTexture()"></a><a name="createRectangleTexture(int,int,String,Boolean)" id="createRectangleTexture(int,int,String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createRectangleTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createRectangleTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.8, AIR 3.8</td></tr></table><p></p><p></p><p>
         Создает объект Rectangle Texture.
         
         <p>Используйте объект RectangleTexture для загрузки растровых изображений текстур в контекст визуализации и для ссылки на текстуру во время визуализации.</p>
         
         <p>Нельзя создавать объекты RectangleTexture с использованием конструктора RectangleTexture; для этого используется данный метод. После создания объекта RectangleTexture загрузите данные растровых изображений текстуры с использованием методов <code>uploadFromBitmapData()</code> или <code>uploadFromByteArray()</code> объекта Texture.</p>
         
         <p>Обратите внимание, что 32-разрядные целочисленные текстуры хранятся в упакованном формате BGRA для соответствия формату <code>BitmapData</code> среды Flash. В текстурах с плавающей запятой используется общепринятый RGBA. </p>
         
         <p> Прямоугольные текстуры отличаются от обычных двумерных текстур тем, что их ширина и высота могут не равняться степени двойки. Кроме того, они не содержат множественные отображения. Наиболее полезно их использовать при визуализации в текстуру. Если прямоугольная текстура используется с образцом, в котором применяется фильтрация множественного отображения или повторяющееся завертывание, произойдет сбой вызова drawTriangles. Прямоугольная текстура также не допускает потоковую передачу. Прямоугольные текстуры поддерживают только форматы текстур BGRA, BGR_PACKED, BGRA_PACKED. Форматы сжатых текстур не поддерживаются прямоугольными текстурами.
         </p>
                 
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Ширина текстуры в текстурных пикселях.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Высота текстуры в текстурных пикселях.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Формат текстурного пикселя списка перечисления Context3DTextureFormat.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Задайте значение <code>true</code>, если текстура, скорее всего, будет использоваться в качестве цели визуализации.                 
                                   
         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов Texture или превышен объем выделенной для текстур памяти.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Размер текстуры равен нулю: если оба параметра <code>width</code> и <code>height</code> не больше нуля.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большая текстура: если любой из параметров <code>width</code> или <code>height</code> больше 2048.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Не удалось создать текстуру: если контексту визуализации не удалось создать объект Texture (но информация о причине недоступна).  
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Требуется базовый профиль или его расширенная версия: если прямоугольная текстура создается с ограниченным базовым профилем.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createTexture()" id="createTexture()"></a><a name="createTexture(int,int,String,Boolean,int)" id="createTexture(int,int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Создается объект Texture.
         
         <p>Используйте объект Texture для загрузки растровых изображений текстур в контекст визуализации и для ссылки на текстуру во время визуализации.</p>
         
         <p>Нельзя создавать объекты Texture с использованием конструктора Texture. Для этого используется данный метод. После создания объекта Texture загрузите данные растровых изображений текстуры с использованием методов <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> или <code>uploadCompressedTextureFromByteArray()</code> объекта Texture.</p>
         
         <p>Обратите внимание, что 32-разрядные целочисленные текстуры хранятся в упакованном формате BGRA для соответствия формату <code>BitmapData</code> среды Flash. В текстурах с плавающей запятой используется общепринятый RGBA. </p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Ширина текстуры в текстурных пикселях.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Высота текстуры в текстурных пикселях.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Формат текстурного пикселя списка перечисления Context3DTextureFormat.
         <p> Благодаря сжатию текстур можно хранить изображения текстур в сжатом формате непосредственно в графическом процессоре, тем самым экономя память графического процессора и пропускную способность памяти. Как правило, сжатые текстуры сжимаются в автономном режиме и загружаются в графический процессор в сжатой форме с помощью метода Texture.uploadCompressedTextureFromByteArray. В средах Flash Player 11.4 и AIR 3.4 на настольных платформах появилась поддержка сжатия текстур во время выполнения, что может быть удобно в некоторых случаях, например при визуализации динамических текстур из векторной графики. Обратите внимание, что эта функция в настоящее время недоступна на мобильных платформах и при попытке её использования будет возникать исключение ArgumentError (Несоответствие формата текстуры). Для использования сжатия текстур во время выполнения необходимо выполнить следующее. 1. Создайте объект текстуры. Для этого вызовите метод Context3D.createTexture(), передав flash.display3D.Context3DTextureFormat.COMPRESSED или flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA в качестве параметра формата. 2. Используя экземпляр flash.display3D.textures.Texture, возвращенный методом createTexture(), вызовите либо flash.display3D.textures.Texture.uploadFromBitmapData(), либо flash.display3D.textures.Texture.uploadFromByteArray() для одновременной загрузки и сжатия текстуры.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Задайте значение <code>true</code>, если текстура, скорее всего, будет использоваться в качестве цели визуализации.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Уровень множественных отображений, который должен быть загружен перед визуализацией изображения. Потоковая передача текстур дает возможность загрузить и отобразить вначале наименьшие уровни, а затем, по мере загрузки текстур, отображать все более качественные изображения. Конечные пользователи могут просматривать в приложении изображения более низкого качества, пока загружаются более качественные изображения.
         <p>По умолчанию значение streamingLevels&nbsp;&mdash; 0, то есть перед визуализацией изображения должно загрузиться изображение самого высокого качества во множественном отображении. Этот параметр был добавлен в версиях Flash Player 11.3 и AIR 3.3. Его значение по умолчанию соответствует поведению предыдущих версий Flash Player и AIR. 
         </p>
         <p>Установите для <code>streamingLevels</code> значение от 1 до количества изображений во множественном отображении для включения потоковой передачи текстуры. Например, при наличии множественного отображения, включающего главное изображение самого высокого качества размером 64x64 пикселей. Изображения более низкого качества во множественном отображении могут иметь размер 32x32, 16x16, 8x8, 4x4, 2x2 и 1x1 пикселей (всего 7 изображений или 7 уровней). Уровень 0 &mdash; это изображение самого высокого качества. Максимальным значением этого свойства является log2(min(ширина,высота)). Поэтому для главного изображения размером 64x64 пикселя максимальное значение <code>streamingLevels</code> равно 7. Установите для этого свойства значение 3 для визуализации изображения после загрузки изображения 8x8 пикселей.</p>
         
         <p><b>Примечание.</b> Установка для этого свойства значения больше 0 может влиять на интенсивность использования памяти и производительность. </p>
         
         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/Texture.html">flash.display3D.textures:Texture</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов Texture или превышен объем выделенной для текстур памяти.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Текстура глубины не реализована: если предпринимается попытка создать текстуру глубины.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Размер текстуры равен нулю: если оба параметра <code>width</code> и <code>height</code> не больше нуля.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Текстура не равна степени двойки: если оба параметра <code>width</code> и <code>height</code> не равны степени двойки.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большая текстура: если любой из параметров <code>width</code> или <code>height</code> больше 2048 для базового и ограниченного базового профиля, или если любой из параметров <code>width</code> и <code>height</code> больше 4096 для базового расширенного профиля или профиля более высокого уровня.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Не удалось создать текстуру: если контексту визуализации не удалось создать объект Texture (но информация о причине недоступна).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Недопустимый потоковый уровень: если значение <code>streamingLevels</code> больше или равно log2(min(ширина,высота)).
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createVertexBuffer()" id="createVertexBuffer()"></a><a name="createVertexBuffer(int,int,String)" id="createVertexBuffer(int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVertexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBuffer(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Создается объект VertexBuffer3D.
         
         <p>Используйте объект VertexBuffer3D для загрузки набора данных вершин в контекст визуализации. В буфере вершин содержатся данные, необходимые для визуализации каждой точки в геометрии сцены. Атрибуты данных, связанные с каждой вершиной, как правило, включают положение, цвет и координаты текстуры и используются в качестве входных данных для вершинной шейдерной программы. Определите значения данных, соответствующие одному из входных значений вершинной программы, с помощью метода <code>setVertexBufferAt()</code>. Можно указать до шестидесяти четырех 32-разрядных значений для каждой вершины.</p>
         
         <p>Нельзя создавать объекты VertexBuffer3D с использованием конструктора VertexBuffer3D; для этого используется данный метод. После создания объекта IndexBuffer3D загрузите индексы с использованием методов <code>uploadFromVector()</code> или <code>uploadFromByteArray()</code> объекта IndexBuffer3D.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; количество вершин, которое будет храниться в буфере. Максимальное количество вершин в отдельном буфере равно 65535. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; количество 32-разрядных (4-байтовых) значений данных, связанных с каждой вершиной. Максимальное количество элементов 32-разрядных данных для каждой вершины равно 64 (или 256 байтам). Обратите внимание, что только восемь регистров атрибутов единовременно доступны вершинной шейдерной программе. Используйте метод <code>SetVertextBufferAt()</code> для выбора атрибутов из буфера вершин.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; прогнозируемая интенсивность использования буфера. Используйте одну из констант, определенных в <code>Context3DBufferUsage</code>. Драйвер оборудования может, при правильной настройке, провести соответствующую оптимизацию. Этот параметр доступен только в версиях позднее Flash 12/AIR 4.

         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов буферов вершин или превышен объем выделенной для буферов вершин памяти.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большой буфер: если <code>numVertices</code> больше 0x10000 или <code>data32PerVertex</code> больше 64.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Буфер имеет нулевой размер: если значение <code>numVertices</code> или <code>data32PerVertex</code> равно нулю.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Не удалось создать буфер: если контексту визуализации не удалось создать объект VertexBuffer3D (но дополнительная информация о причине недоступна). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий пример демонстрирует создание и загрузку буфера данных вершин. Буфер в примере содержит два типа данных для каждой вершины: положение (в виде координат x, y, z) и цвет (в виде компонентов RGB). После создания буфера метод <code>setVertexBufferAt()</code> вызывается для указания того, что первые три точки данных передаются в вершинную программу в качестве 3 значений с плавающей точкой в va0 и вторые три точки данных передаются в качестве va1. Вершинная программа поддерживает до 8 определенных подобным образом входных значений, которые также называются регистрами атрибутов.
<div class="listing"><pre>
const dataPerVertex:int = 6;
var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
    [
      // x, y, z    r, g, b format
         0, 0, 0,   1, 1, 1,
        -1, 1, 0,   0, 0,.5,
         1, 1, 0,   0, 0, 1,
         1,-1, 0,  .5, 0, 0,
        -1,-1, 0,   1, 0, 0
    ]
);
var vertexes:VertexBuffer3D = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
//Identify vertex data inputs for vertex program
renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va0 as the position data
renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va1 as the color data
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="createVertexBufferForInstances()" id="createVertexBufferForInstances()"></a><a name="createVertexBufferForInstances(int,int,int,String)" id="createVertexBufferForInstances(int,int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;createVertexBufferForInstances</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBufferForInstances(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         Создается объект VertexBuffer3D для данных экземпляров.
         
         <p>Используйте объект VertexBuffer3D для загрузки набора данных экземпляров в контекст визуализации. В буфере вершин содержатся данные, необходимые для визуализации каждого экземпляра в геометрии сцены. Буферы вершин с данными экземпляров предоставляют атрибуты, которые являются общими для всех вершин экземпляра. и используются в качестве входных данных для вершинной шейдерной программы. Определите значения данных, соответствующие одному из входных значений вершинной программы, с помощью метода <code>setVertexBufferAt()</code>. Можно указать до шестидесяти четырех 32-разрядных значений для каждого элемента буфера вершин.</p>
         
         <p>Нельзя создавать объекты VertexBuffer3D с использованием конструктора VertexBuffer3D; для этого используется данный метод. После создания объекта IndexBuffer3D загрузите индексы с использованием методов <code>uploadFromVector()</code> или <code>uploadFromByteArray()</code> объекта IndexBuffer3D.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; количество элементов, которое будет храниться в буфере. Максимальное количество элементов в отдельном буфере равно 65535. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; количество 32-разрядных (4-байтовых) значений данных, связанных с каждым элементом. Максимальное количество элементов 32-разрядных данных для каждой вершины равно 64 (или 256 байтам).
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">instancesPerElement</span>:<a href="../../int.html">int</a></code> &mdash; количество экземпляров, которое будет использовать один элемент буфера вершин.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; прогнозируемая интенсивность использования буфера. Используйте одну из констант, определенных в <code>Context3DBufferUsage</code>. Драйвер оборудования может, при правильной настройке, провести соответствующую оптимизацию. Этот параметр доступен только в версиях позднее Flash 12/AIR 4.
         
         </td></tr></table></p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов буферов вершин или превышен объем выделенной для буферов вершин памяти.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Слишком большой буфер: если <code>numVertices</code> больше 0x10000 или <code>data32PerVertex</code> больше 64.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Буфер имеет нулевой размер: если значение <code>numVertices</code> или <code>data32PerVertex</code> равно нулю.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Не удалось создать буфер: если контексту визуализации не удалось создать объект VertexBuffer3D (но дополнительная информация о причине недоступна). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Требуется стандартный расширенный профиль или более высокого уровня: если этот метод вызывается, когда запрашивается профиль, уровень которого ниже стандартного расширенного.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимое количество экземпляров для элемента: если instancesPerElement не больше нуля.
         
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="createVideoTexture()" id="createVideoTexture()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVideoTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVideoTexture():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
         Создает объект VideoTexture.
         
         <p>Используйте объект VideoTexture для получения видеокадров в качестве текстуры из объекта NetStream или Camera и для загрузки отдельных видеокадров в контекст визуализации.</p>
         
         <p>Невозможно создать объект VideoTexture с помощью конструктора VideoTexture. Используйте этот метод. После создания объекта VideoTexture, привяжите объект NetStream или Camera для получения видеокадров с помощью метода <code>attachNetStream()</code> или <code>attachCamera()</code>.</p>
         
         <p>Обратите внимание этот метод возвращает значение «null», если система не поддерживает эту функцию. </p>
         
         <p> Объект VideoTexture не содержит множественные отображения. Если объект VideoTexture используется с образцом, в котором применяется фильтрация множественного отображения или повторяющееся завертывание, произойдет сбой вызова drawTriangles. Объект VideoTexture можно обрабатывать шейдерами как текстуру BGRA. <b>Создать экземпляр объекта VideoTexture не удастся, если эффект Context3D был запрошен в режиме визуализации с помощью ПО.</b> 
         </p>
         
         <p> Для каждого экземпляра Context3D доступно не более четырех объектов VideoTexture. На мобильных устройствах фактическое количество поддерживаемых объектов VideoTexture может быть меньше четырех из-за ограничений платформы. </p>
                                   
         </p><p></p><span class="label">Возвращает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code></td></tr></table><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Превышен лимит ресурсов: если создано слишком много объектов Texture или превышен объем выделенной для текстур памяти.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Не удалось создать текстуру: контексту визуализации не удалось создать объект Texture (но информация о причине недоступна).  
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="dispose()" id="dispose()"></a><a name="dispose(Boolean)" id="dispose(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Освобождает все ресурсы и внутреннее хранилище, связанные с данным объектом Context3D.
          
         <p>Все буферы индексов, буферы вершин, текстуры и программы, созданные посредством этого объекта Context3D, очищаются аналогично вызову для каждого из этих элементов метода <code>dispose()</code>. Кроме того, очищается сам объект Context3D, освобождая все временные буферы и предшествующий буфер. Вызов методов configureBackBuffer(), clear(), drawTriangles(), createCubeTexture(), createTexture(), createProgram(), createIndexBuffer(), createVertexBuffer() или drawToBitmapData() после вызова метода dispose() приведет к созданию исключения.</p>                   
         
         <p><b>Внимание!</b> При вызове метода dispose() для объекта Context3D, когда еще существует прослушиватель события Events.CONTEXT3D_CREATE для связанного объекта Stage3D, симулируется потеря устройства. В результате создается новый объект Context3D для Stage3D и повторно отправляется событие Events.CONTEXT3D_CREATE. Если такое поведение нежелательно, следует удалить прослушиватель события у объекта Stage3D перед вызовом dispose(), либо задать параметру recreate значение false.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">recreate</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code></td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso">Stage3D<br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a></div></div></span><span id="pageFilter" runtime="AIR::3##"><a name="drawToBitmapData()" id="drawToBitmapData()"></a><a name="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)" id="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawToBitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawToBitmapData(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 3</td></tr></table><p></p><p></p><p>
         Отрисовка текущего буфера визуализации в растровом изображении.
         
         <p>Текущее содержимое заднего буфера визуализации копируется в объект BitmapData. Потенциально это очень медленная операция, выполнение которой может занять около секунды. Используйте с осторожностью. Обратите внимание, что эта функция копирует не передний буфер визуализации (отображаемый в рабочей области), а тот, в котором выполняется отрисовка. Чтобы захватить визуализированное изображение в том виде, в котором оно отображается в рабочей области, вызовите метод <code>drawToBitmapData()</code> непосредственно перед вызовом метода <code>present()</code>.</p>
         
		 
         <p>Начиная с AIR 25 в API-интерфейс добавлено два новых параметра <code>drawToBitmapData()</code>. Этот API-интерфейс теперь принимает три параметра. Во-первых, это существующий параметр <code>destination:BitmapData</code>. Во-вторых, это параметр <code>srcRect:Rectangle</code>, который является целевым прямоугольником в рабочей области stage3D. В-третьих, это параметр <code>destPoint:Point</code>, который является координатой целевого растрового изображения. Параметры srcRect и destPoint не являются обязательными, по умолчанию для них используются значения (0,0,bitmapWidth,bitmapHeight) и (0,0), соответственно.</p>
         
         <p>При отрисовке изображение не масштабируется по размеру растрового изображения. Вместо этого содержимое обрезается по размеру целевого растрового изображения.</p>
         
         <p>В объектах Flash BitmapData хранятся цвета, которые уже умножены на альфа-компонент. Например, если компонентами «чистых» цветов RGB являются (0x0A, 0x12, 0xBB), а альфа-компонентом является 0x7F (0,5), пиксель сохраняется в объекте BitmapData со следующими значениями rgba: (0x05, 0x09, 0x5D, 0x7F). Можно настроить коэффициенты наложения, чтобы цвета, визуализированные в буфере, умножались на значение альфа, или можно выполнить эту операцию во фрагментном шейдере. Контекст визуализации не проверяет, хранятся ли данные в предварительно умноженном формате. </p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">destination</span>:<a href="../display/BitmapData.html">BitmapData</a></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">srcRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code></td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3802: если параметр <code>destPoint:Point</code> или <code>srcRect:Rectangle</code> находится за пределами связки координат растрового изображения/рабочей области 3D или если в качестве ввода переданы нечисловые значения.
		 
         </td></tr></table><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> В следующем примере выполняется визуализация двух треугольников в обычный буфер визуализации и объект BitmapData. Объект BitmapData отображается с использованием объекта Bitmap, добавленного в обычный список отображения. Фильтр тени применен к визуализации растрового изображения. 
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.filters.DropShadowFilter;
    
    public class Context3D_drawToBitmapData extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var bitmap:Bitmap;
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawToBitmapData()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 0;
            stage3D.y = 0;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            var renderedBitmapData:BitmapData = new BitmapData( viewWidth, viewHeight, true );
            renderContext.drawToBitmapData( renderedBitmapData );
            
            renderContext.present();
            
            //Add to stage
            bitmap = new Bitmap( renderedBitmapData );
            this.addChild( bitmap );
            bitmap.x = 55;
            bitmap.y = 25;
            bitmap.filters = [new DropShadowFilter( 8, 235, .4 )];
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="drawTriangles()" id="drawTriangles()"></a><a name="drawTriangles(flash.display3D.IndexBuffer3D,int,int)" id="drawTriangles(flash.display3D.IndexBuffer3D,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawTriangles</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTriangles(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Указанные треугольники визуализируются с использованием текущих буферов и состояния данного объекта Context3D.
         
         <p>Для каждого треугольника вершины обрабатываются программой вершинного шейдера, а поверхность &mdash; программой пиксельного шейдера. Цвет вывода пиксельной программы для каждого пикселя отрисовывается на целевом объекте визуализации в зависимости от операций трафарета, теста глубины, исходного и целевого альфа-значения, а также текущего режима наложения. Целью визуализации может быть главный буфер визуализации или текстура.</p>
         
         <p>Если включен отбор (с помощью метода <code>setCulling()</code>), то треугольники могут убираться из сцены до запуска пиксельной программы. Если включен трафарет и тестирование глубины, то пиксели вывода из пиксельного шейдера могут отбрасываться без обновления целевого объекта визуализации. Кроме того, пиксельный шейдер может принять решение не выводить цвет для пикселя.</p>
         
         <p>Визуализированные треугольники не отображаются в области просмотра, пока не вызван метод <code>present()</code>. После каждого вызова метода <code>present()</code> необходимо вызвать метод <code>clear()</code> перед первым вызовом <code>drawTriangles()</code>, в противном случае произойдет сбой визуализации.</p>

         <p>Когда <code>enableErrorChecking</code> имеет значение <code>false</code>, эта функция возвращает ответ немедленно, не ожидая результатов, и выдает исключение, только если экземпляр Context3D утилизирован или выполнено слишком много вызовов методов рисования. Если контекст визуализации недействителен, визуализация завершается ошибкой без уведомления. Когда свойство <code>enableErrorChecking</code> имеет значение <code>true</code>, эта функция возвращает ответ после отрисовки треугольников и выдает исключение в случае ошибок отрисовки или недопустимого состояния контекста.</p> 
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; набор индексов вершин, ссылающихся на вершины, которые следует визуализировать.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; индекс первой вершины для визуализации. По умолчанию 0.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; Число треугольников для визуализации. Каждый треугольник использует три индекса. Передайте -1 для визуализации всех треугольников в буфере индексов. По умолчанию -1.  
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Если выполняется слишком много вызовов этого метода между вызовами метода <code>present()</code>. Максимальное количество вызовов &mdash; 32&nbsp;768. 
         
         <p>Следующие ошибки возникают, только когда для свойства <code>enableErrorChecking</code> установлено значение <code>true</code>:</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Необходимо выполнить очистку перед отрисовкой: если буфер не очищался с момента последнего вызова <code>present()</code>.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Если действительный объект Program3D не задан.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Действительный буфер индексов не задан: если объект IndexBuffer3D не задан.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Сбой проверки допустимости параметров: когда число треугольников для отрисовки или значение <code>firstIndex</code> превышает допустимые значения.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Недостаточно индексов в этом буфере: когда в буфере содержится недостаточное число индексов для определения числа треугольников для отрисовки.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с текстурой, которая также связана с визуализацией: когда целью визуализации является текстура и эта текстура, определена в качестве входных данных текущей фрагментной программы.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с недопустимой текстурой: недопустимая текстура указана в качестве входных данных для текущей фрагментной программы.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Формат образца не соответствует формату текстуры: когда текстура, определенная в качестве входных данных для текущей фрагментной программы, имеет формат, отличный от указанного для регистра образца. Например, двумерная текстура назначена образцу кубической текстуры.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с неопределенной текстурой: текущая фрагментная программа получает доступ к регистру текстуры, который не задан (с использованием метода <code>setTextureAt()</code>).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Для одной и той же текстуры необходимы одинаковые параметры образца: если текстура используется для нескольких регистров образцов, все образцы должны иметь одинаковые параметры. Например, нельзя задавать один образец для фиксации, а другой для оболочки.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Текстура задана, но не используется: текстура задана в качестве входных данных шейдера, но при этом не используется.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток не используется: буфер вершин назначен входным данным атрибутов вершин, но вершинная программа не ссылается на соответствующий регистр.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток недопустим: объект VertexBuffer3D, назначенный в качестве входных данных вершинной программы, не является допустимым объектом.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Поток имеет недостаточное количество вершин: в буфере вершин, который поставляет данные для рисования указанных треугольников, недостаточно данных.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Смешение вершины потока выходит за границы: смещение, указанное в вызове <code>setVertexBufferAt()</code>, является отрицательным значением или выходит за границы буфера.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток прочитан, но не задан: атрибут вершины, используемый текущей вершинной программой, не задан (с использованием метода <code>setVertexBufferAt()</code>).
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий класс отрисовывает два треугольника в области просмотра Stage3D в рабочей области. Треугольники имеют одну общую вершину, которая расположена в исходной точке (0,0,0).
 
 <p>Треугольники определены с использованием буфера вершин и буфера индексов. Буфер вершины содержит информацию положении и цвете для каждой вершины треугольника. Буфер индексов содержит индексы для буфера вершин. Три индекса определяют треугольник. Например, треугольник, который состоял из первых трех точек в буфере вершин, обозначается как «0,1,2» в буфере индексов.</p>
 
 <p>В этом простом примере не выполняется 3D-преобразование. На экран выводятся только объекты в канонической области просмотра (единичный объем 2x2x1), и координаты треугольников определяются в пределах этой области. Однако при визуализации типичной 3D-сцены выполняется перспективная или ортогональная проекция объектов для визуализации из мировой системы координат в этой области просмотра.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_drawTriangles extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawTriangles()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="drawTrianglesInstanced()" id="drawTrianglesInstanced()"></a><a name="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)" id="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawTrianglesInstanced</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTrianglesInstanced(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         Указанные экземпляры треугольников визуализируются с использованием текущих буферов и состояния данного объекта Context3D.
         
         <p>Для каждого треугольника каждого экземпляра вершины обрабатываются программой вершинного шейдера, а поверхность &mdash; программой пиксельного шейдера. Цвет вывода пиксельной программы для каждого пикселя отрисовывается на целевом объекте визуализации в зависимости от операций трафарета, теста глубины, исходного и целевого альфа-значения, а также текущего режима наложения. Целью визуализации может быть главный буфер визуализации или текстура.</p>
         
         <p>Если включен отбор (с помощью метода <code>setCulling()</code>), то треугольники могут убираться из сцены до запуска пиксельной программы. Если включен трафарет и тестирование глубины, то пиксели вывода из пиксельного шейдера могут отбрасываться без обновления целевого объекта визуализации. Кроме того, пиксельный шейдер может принять решение не выводить цвет для пикселя.</p>
         
         <p>Полученные в ходе рендеринга экземпляры треугольников не отображаются в области просмотра, пока не вызван метод <code>present()</code>. После каждого вызова метода <code>present()</code> необходимо вызвать метод <code>clear()</code> перед первым вызовом <code>drawTrianglesInstanced()</code>, в противном случае произойдет сбой визуализации</p>

         <p>Когда <code>enableErrorChecking</code> имеет значение <code>false</code>, эта функция возвращает ответ немедленно, не ожидая результатов, и выдает исключение, только если экземпляр Context3D утилизирован или выполнено слишком много вызовов методов рисования. Если контекст визуализации недействителен, визуализация завершается ошибкой без уведомления. Когда свойство <code>enableErrorChecking</code> имеет значение <code>true</code>, эта функция возвращает ответ после отрисовки треугольников и выдает исключение в случае ошибок отрисовки или недопустимого состояния контекста.</p>
		 
		 <p>Этот метод может выдать исключение, если созданный экземпляр буфера неправильно упорядочен с помощью <code>SetVertexAt()</code>. Например, с помощью Direct 3D&nbsp;9 индексированные данные геометрии и количество экземпляров для отрисовки должны всегда задаваться в потоке&nbsp;0 с помощью API-интерфейса <code>SetStreamSourceFreq()</code>.</p>
		 
		 <p>Это означает, что буфер вершин, созданный с помощью <code>CreateVertexBufferForInstance()</code>, не должен размещаться с минимальным значением индекса при использовании <code>SetVertexBufferAt()</code> в качестве ввода в программу шейдера вершин. Буфер вершин, созданный с помощью <code>CreateVertexBuffer()</code>, должен размещаться со значением индекса, которое меньше индекса буфера, созданного с использованием <code>CreateVertexBufferForInstance()</code>. Как правило, данные геометрии должны размещаться раньше данных экземпляров с помощью <code>SetVertexBufferAt()</code>.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; набор индексов вершин, ссылающихся на вершины, которые следует визуализировать.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numInstances</span>:<a href="../../int.html">int</a></code> &mdash; количество экземпляров для рендеринга.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; индекс первой вершины для визуализации. По умолчанию 0.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; Число треугольников для визуализации. Каждый треугольник использует три индекса. Передайте -1 для визуализации всех треугольников в буфере индексов. По умолчанию -1.  
		 
		 </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Если выполняется слишком много вызовов этого метода между вызовами метода <code>present()</code>. Максимальное количество вызовов &mdash; 32&nbsp;768. 
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Требуется стандартный расширенный профиль или более высокого уровня: если этот метод вызывается, когда запрашивается профиль, уровень которого ниже стандартного расширенного.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Если метод вызывается при отрицательном значении numInstances.
         
         <p>Следующие ошибки возникают, только когда для свойства <code>enableErrorChecking</code> установлено значение <code>true</code>:</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Необходимо выполнить очистку перед отрисовкой: если буфер не очищался с момента последнего вызова <code>present()</code>.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Если действительный объект Program3D не задан.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Действительный буфер индексов не задан: если объект IndexBuffer3D не задан.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Сбой проверки допустимости параметров: когда число треугольников для отрисовки или значение <code>firstIndex</code> превышает допустимые значения.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Недостаточно индексов в этом буфере: когда в буфере содержится недостаточное число индексов для определения числа треугольников для отрисовки.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с текстурой, которая также связана с визуализацией: когда целью визуализации является текстура и эта текстура, определена в качестве входных данных текущей фрагментной программы.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с недопустимой текстурой: недопустимая текстура указана в качестве входных данных для текущей фрагментной программы.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Формат образца не соответствует формату текстуры: когда текстура, определенная в качестве входных данных для текущей фрагментной программы, имеет формат, отличный от указанного для регистра образца. Например, двумерная текстура назначена образцу кубической текстуры.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Образец связан с неопределенной текстурой: текущая фрагментная программа получает доступ к регистру текстуры, который не задан (с использованием метода <code>setTextureAt()</code>).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Для одной и той же текстуры необходимы одинаковые параметры образца: если текстура используется для нескольких регистров образцов, все образцы должны иметь одинаковые параметры. Например, нельзя задавать один образец для фиксации, а другой для оболочки.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Текстура задана, но не используется: текстура задана в качестве входных данных шейдера, но при этом не используется.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток не используется: буфер вершин назначен входным данным атрибутов вершин, но вершинная программа не ссылается на соответствующий регистр.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток недопустим: объект VertexBuffer3D, назначенный в качестве входных данных вершинной программы, не является допустимым объектом.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Поток имеет недостаточное количество вершин: в буфере вершин, который поставляет данные для рисования указанных треугольников, недостаточно данных.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Смешение вершины потока выходит за границы: смещение, указанное в вызове <code>setVertexBufferAt()</code>, является отрицательным значением или выходит за границы буфера.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток прочитан, но не задан: атрибут вершины, используемый текущей вершинной программой, не задан (с использованием метода <code>setVertexBufferAt()</code>).
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток буфера вершин не содержит достаточного количества элементов для экземпляров: если поток буфера вершин содержит недостаточно элементов для количества экземпляров.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Поток буфера вершин для экземпляров неправильно задан с использованием минимального регистра атрибутов минимальных индексов: если буфер вершин, созданный с использованием <code>CreateVertexBuffer()</code>, получает большее значение индекса, чем значение для буфера вершин, созданного с использованием <code>CreateVertexBufferForInstance()</code>.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий класс отрисовывает три треугольника, используя функцию рисования экземпляров, которая позволяет использовать один вызов метода рисования вместо нескольких.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstancedDrawing extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstancedDrawing()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //The vertex shader code runs for every vertex of each instance.
            //The vertex buffers uploaded for instance data (va1,va2) are used when the vertex shader for that particular instance is being executed.
            code += "add vt0, va0, va2\n";
            code += "mov op, vt0\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span><span id="pageFilter"><br/><div class="detailBody"> Следующий класс отрисовывает три треугольника, используя функцию рисования экземпляров, которая позволяет использовать один вызов метода рисования вместо нескольких.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstanceIdRegister extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstanceIdRegister()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            //Note : for instance id support , use the latest AgalMiniAssembler from github - https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/v3/AGALMiniAssembler.as
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //the vertex shader code will run for every vertex of every instance , 
            //the vertex buffers uploaded for instance data (va1,va2) will be used when vertex shader for that particular instance is being executed 
            //the vertex shader code below indexes the program constants matrix using iid.x. iid is a new register introduced in vertex shader for instanced drawing
            //it is a read only register , iid.x gives the current instance id whose shader is being executed
            code += "add vt0, va0, va2\n";
            code += "mul vt1, vt0, vc[iid.x]\n"
            code += "mov op, vt1\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code, 3);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code, 3);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            var instanceScalingData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 1.0, 1.0, 1.0,     // - 1st instance x,y,z,w
                1.4, 1.4, 1.4, 1.0,        // - 2nd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0,        // - 3rd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0
            ]);
            var m:Matrix3D = new Matrix3D();
            m.copyRawDataFrom(instanceScalingData);
            renderContext.setProgramConstantsFromMatrix("vertex",0,m,false);
            
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="present()" id="present()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>present</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function present():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Отображает задний буфер визуализации. 
         
         <p>При вызове метода <code>present()</code> результаты всех операций визуализации с момента последнего вызова <code>present()</code> делаются видимыми и запускается новый цикл визуализации. После вызова метода <code>present</code> необходимо вызвать метод <code>clear()</code> перед созданием еще одного вызова <code>drawTriangles()</code>. Иначе эта функция будет поочередно очищать буфер визуализации для желтого и зеленого цветов или, если для <code>enableErrorChecking</code> установлено значение <code>true</code>, создается исключение.</p>
         
         <p>При вызове <code>present()</code> также сбрасывается цель визуализации, как и при вызове <code>setRenderToBackBuffer()</code>. </p>  
         
         </p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Необходимо очистить перед отрисовкой: если метод <code>clear()</code> не вызван после предыдущего вызова <code>present()</code>. (Два последовательных вызова метода <code>present()</code> недопустимы, если между ними не вызывается метод <code>clear()</code>.)
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: API-интерфейс <code>Stage3D</code> не может использоваться во время выполнения в фоновом режиме.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setBlendFactors()" id="setBlendFactors()"></a><a name="setBlendFactors(String,String)" id="setBlendFactors(String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setBlendFactors</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setBlendFactors(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Указывает коэффициенты, используемые для наложения цвета вывода операции рисования на существующий цвет.
         
         <p>Цвет вывода (исходный цвет) программы пиксельного шейдера объединяется с существующим цветом (целевым цветом) этого пикселя согласно следующей формуле:</p> 
         <p><code>result color = (source color * sourceFactor) + (destination color * destinationFactor)</code></p>
         <p>Целевой цвет &mdash; это текущий цвет в буфере визуализации для этого пикселя. Другими словами, это результат самого последнего вызова метода <code>clear()</code> и любых промежуточных вызовов метода <code>drawTriangles()</code>. </p>
          
         <p>Используйте метод <code>setBlendFactors()</code>, чтобы задать коэффициенты, используемые для умножения исходных и целевых цветов перед наложением. По умолчанию используются коэффициенты наложения <code>sourceFactor = Context3DBlendFactor.ONE</code> и <code>destinationFactor = Context3DBlendFactor.ZERO</code>, которые приводят к тому, что исходный цвет перезаписывает целевой цвет (другими словами, наложения двух цветов не происходит). Для нормального наложения альфа-канала используйте <code>sourceFactor = Context3DBlendFactor.SOURCE_ALPHA</code> и <code>destinationFactor = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA</code>. 
         </p>
         
         <p>Используйте константы, определенные в классе Context3DBlendFactor, чтобы установить параметры этой функции.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceFactor</span>:<a href="../../String.html">String</a></code> &mdash; Коэффициент, на который умножается исходный цвет. Значение по умолчанию &mdash; <code>Context3DBlendFactor.ONE</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destinationFactor</span>:<a href="../../String.html">String</a></code> &mdash; Коэффициент, на который умножается целевой цвет. Значение по умолчанию &mdash; <code>Context3DBlendFactor.ZERO</code>.
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимое перечисление: когда <code>sourceFactor</code> или <code>destinationFactor</code> не является одним из распознаваемых значений, которые определены в классе Context3DBlendFactor.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий класс показывает различные коэффициенты наложения. В примере четыре прямоугольника разных цветов отрисовываются в буфере визуализации. Этот набор прямоугольников является «целью» наложения. После этого устанавливаются режимы наложения источника и цели, и отрисовывается больший по размеру прямоугольник, «источник наложения». Используйте клавиши 1 и 2 для циклического переключения режимов наложения источника. Используйте клавиши 3 и 4 для циклического переключения режимов наложения цели.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.ui.Keyboard;
    
    public class Context3D_setBlendMode extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var sourceFactor:int = 6;
        private var destinationFactor:int = 4;
        private var blendFactors:Array = [Context3DBlendFactor.DESTINATION_ALPHA,
                                          Context3DBlendFactor.DESTINATION_COLOR,
                                          Context3DBlendFactor.ONE,
                                          Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR,
                                          Context3DBlendFactor.SOURCE_ALPHA,
                                          Context3DBlendFactor.SOURCE_COLOR,
                                          Context3DBlendFactor.ZERO];
            
        public function Context3D_setBlendMode()
        {
            this.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyHandler );
            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3,
                                                            6, 4, 5,
                                                            5, 7, 6,
                                                            10, 8, 9,
                                                            9, 11, 10,
                                                            12, 15, 14,
                                                            12, 13, 15,
                                                            16, 17, 19,
                                                            16, 19, 18
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 7;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format
                    -1, 1, 0,   1, 1, 1, .5,
                     0, 1, 0,   1, 1, 1, .5,
                    -1, 0, 0,   1, 1, 1, .5,
                     0, 0, 0,   1, 1, 1, .5,
                     
                     0, 1, 0,  .8,.8,.8, .6,
                     1, 1, 0,  .8,.8,.8, .6,
                     0, 0, 0,  .8,.8,.8, .6,
                     1, 0, 0,  .8,.8,.8, .6,
                     
                    -1, 0, 0,   1, 0, 0, .5,
                     0, 0, 0,   0, 1, 0, .5,
                    -1,-1, 0,   0, 0, 1, .5,
                     0,-1, 0,   1, 0, 1, .5,
                     
                     0, 0, 0,   0, 0, 0, .5,
                     1, 0, 0,   0, 0, 0, .5,
                     0,-1, 0,   0, 0, 0, .5,
                     1,-1, 0,   0, 0, 0, .5,
                     
                   -.8,.8, 0,  .6,.4,.2,.4,
                    .8,.8, 0,  .6,.4,.2,.4,
                  -.8,-.8, 0,  .6,.4,.2,.4,
                   .8,-.8, 0,  .6,.4,.2,.4
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_4 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear( 1, 1, 1, 1 );
            //Draw the back triangles
            renderContext.setBlendFactors( Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO ); //No blending
            renderContext.drawTriangles( indexList, 0, 8 );

            //Set blend
            renderContext.setBlendFactors( blendFactors[sourceFactor], blendFactors[destinationFactor] );
            
            //Draw the front triangles
            renderContext.drawTriangles( indexList, 24, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
        
        private function keyHandler( event:KeyboardEvent ):void
        {
            switch ( event.keyCode )
            {
                case Keyboard.NUMBER_1:
                    if( --sourceFactor &lt; 0 ) sourceFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_2:
                    if( ++sourceFactor &gt; blendFactors.length - 1) sourceFactor = 0;
                    break;
                case Keyboard.NUMBER_3:
                    if( --destinationFactor &lt; 0 ) destinationFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_4:
                    if( ++destinationFactor &gt; blendFactors.length - 1) destinationFactor = 0;
                    break;
            }
            trace( "Source blend factor: " + blendFactors[sourceFactor] + ", destination blend factor: " + blendFactors[destinationFactor] );
            render();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setColorMask()" id="setColorMask()"></a><a name="setColorMask(Boolean,Boolean,Boolean,Boolean)" id="setColorMask(Boolean,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setColorMask</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setColorMask(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Устанавливает маску, используемую при записи цветов в буфер визуализации.
         
         <p>При записи цвета в буфер визуализации обновляются только те компоненты цвета, для которых соответствующий параметр маски цвета имеет значение <code>true</code>. Например, если вызывается метод <code>setColorMask( true, false, false, false )</code>, в буфер визуализации записывается только красный компонент цвета, пока маска цвета не будет изменена снова. Маска цвета не влияет на поведение метода <code>clear()</code>.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Значение <code>false</code> задается, чтобы предотвратить изменение красного канала.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Значение <code>false</code> задается, чтобы предотвратить изменение зеленого канала.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Значение <code>false</code> задается, чтобы предотвратить изменение синего канала.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Значение <code>false</code> задается, чтобы предотвратить изменение альфа-канала.
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий пример демонстрирует эффект настройки маски цвета. В примере два треугольника отрисовываются одним цветом. Первый треугольник отрисован до установки маски, поэтому он визуализируется как белый. Нижний треугольник отрисован после установки маски для всех каналов, кроме красного. Поскольку для обновления доступен только красный канал, белый треугольник визуализируется как красный.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_setColorMask extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_setColorMask()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   1, 1, 1,
                     1, 1, 0,   1, 1, 1,
                     1,-1, 0,   1, 1, 1,
                    -1,-1, 0,   1, 1, 1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            renderContext.clear( .3,.3,.3,1 );
            renderContext.drawTriangles( indexList, 0, 1 ); //Top triangle draws all colors, so is white
            renderContext.setColorMask( true, false, false, false ); //Mask all but red channel            
            renderContext.drawTriangles( indexList, 3, 1 ); //Bottom triangle only updates red
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setCulling()" id="setCulling()"></a><a name="setCulling(String)" id="setCulling(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setCulling</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setCulling(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает режим отбора треугольников.
         
         <p>Треугольники могут быть исключены из сцены раньше в конвейере визуализации на основе их ориентации относительно плоскости просмотра. Для правильного отбора указывайте порядок вершин последовательно (по часовой или против часовой стрелки), как видится со стороны модели.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFaceToCull</span>:<a href="../../String.html">String</a></code> &mdash; режим отбора. Используйте одну из констант, определенных в классе Context3DTriangleFace.
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимая ошибка перечисления: когда <code>triangleFaceToCull</code> не принимает одно из значений, определенных в классе Context3DTriangleFace.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setDepthTest()" id="setDepthTest()"></a><a name="setDepthTest(Boolean,String)" id="setDepthTest(Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setDepthTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setDepthTest(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает тип сравнения, используемый для тестирования глубины.
         
         <p>Глубина вывода исходного пикселя из программы пиксельного шейдера сравнивается с текущим значением в буфере глубины. Если сравнение дает результат <code>false</code>, то исходный пиксель не учитывается. Если возвращается <code>true</code>, то исходный пиксель обрабатывается на следующем этапе визуализации, то есть в ходе проверки трафарета. Кроме того, буфер глубины обновляется в соответствии с глубиной исходного пикселя, если параметру <code>depthMask</code> задано значение <code>true</code>.</p>
         
         <p>Задает тест, используемый для сравнения значений глубин для исходных и целевых пикселей. Исходный пиксель объединяется с целевым пикселем, если после сравнения устанавливается значение true. Оператор сравнения применяется в качестве инфиксного оператора, который вставляется между значениями исходного и целевого пикселей в указанном порядке.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">depthMask</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; значение целевой глубины будет обновлено из исходного пикселя, если значение равно true.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">passCompareMode</span>:<a href="../../String.html">String</a></code> &mdash; операция теста сравнения глубин. Одно из значений Context3DCompareMode.
         
         </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a></div></div></span><span id="pageFilter" runtime="AIR::16##"><a name="setFillMode()" id="setFillMode()"></a><a name="setFillMode(String)" id="setFillMode(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Доступно только во время выполнения AIR">&nbsp;&nbsp;&nbsp;</span>&nbsp;setFillMode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setFillMode(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>AIR 16</td></tr></table><p></p><p></p><p> 
		Задает режим заливки, используемый для визуализации. Интерфейс доступен только в версии AIR для компьютеров.
		
		</p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">fillMode</span>:<a href="../../String.html">String</a></code> &mdash; Если выбрано значение WIREFRAME, то для отображения объекта будет применяться сетка из базовых линий. Если выбрано значение SOLID, то для отображения объекта будут применяться полигоны со сплошной заливкой.
		
		</td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DFillMode.html" target="">Context3DFillMode</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgram()" id="setProgram()"></a><a name="setProgram(flash.display3D.Program3D)" id="setProgram(flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgram(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает вершинные и фрагментные шейдерные программы для использования в ходе последующей визуализации.
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">program</span>:<a href="Program3D.html">Program3D</a></code> &mdash; объект Program3D, представляющий вершинную и фрагментную программы для использования. 
         
         </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Этот пример демонстрирует создание, загрузку и активацию пары вершин и пиксельных программ для контекста визуализации. Обратите внимание, что объект <code>renderContext</code> является экземпляром класса Context3D. Программы в примере записаны на языке Adobe Graphics Assembly Language (AGAL). 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.1##AIR::3.1##"><a name="setProgramConstantsFromByteArray()" id="setProgramConstantsFromByteArray()"></a><a name="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)" id="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromByteArray(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.1, AIR 3.1</td></tr></table><p></p><p></p><p>
         Задает константы для использования шейдерными программами с применением значений, хранящихся в объекте <code>ByteArray</code>. 
         
         <p>Задает константы, доступ к которым можно получить из программы вершин или фрагментов.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; один из Context3DProgramType.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; индекс первой задаваемой константы программы затенения. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> &mdash; количество задаваемых регистров. Каждый регистр считывается в формате четырех значений с плавающей запятой. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; исходный объект ByteArray
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArrayOffset</span>:<a href="../../uint.html">uint</a></code> &mdash; смещение в объекте ByteArray для чтения данных
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; kNullPointerError, если значение <code>data</code> равно null.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; kConstantRegisterOutOfBounds, если попытаться задать больше, чем максимальное количество констант затенения.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; kBadInputSize, если значение <code>byteArrayOffset</code> больше или равно длине архива <code>data</code> или если количество элементов в массиве <code>data</code> минус <code>byteArrayOffset</code> меньше <code>numRegisters</code>*16
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromMatrix()" id="setProgramConstantsFromMatrix()"></a><a name="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)" id="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromMatrix</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromMatrix(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает константы для использования шейдерными программами с применением значений, хранящихся в объекте <code>Matrix3D</code>. 
         
         <p>Используйте эту функцию для передачи матрицы в шейдерную программу. Функция задает 4 регистра констант, используемых вершинной или фрагментной программой. Матрица назначается регистрам построчно. Первый регистр констант назначается верхней строке матрицы. Можно задать 128 регистров для вершинной программы и 28 регистров для фрагментной программы.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; Тип шейдерной программы: <code>Context3DProgramType.VERTEX</code> или <code>Context3DProgramType.FRAGMENT</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; индекс первого регистра констант, который необходимо задать. Поскольку объект Matrix3D имеет 16 значений, задаются четыре регистра.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix3D.html">Matrix3D</a></code> &mdash; матрица, содержащая значения констант.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transposedMatrix</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; если значение равно <code>true</code>, значения матрицы копируются в регистры в транспонированном порядке. Значение по умолчанию <code>false</code>.
            
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Ошибка пустого указателя: когда <code>matrix</code> имеет нулевое значение.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Регистр констант выходит за границы: при попытке установить значение, превышающее максимальное число регистров констант шейдера.
         
         </td></tr></table><p id="learnMore"><span class="label">Дополнительно</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_ru</a></div><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromVector()" id="setProgramConstantsFromVector()"></a><a name="setProgramConstantsFromVector(String,int,Vector$Number,int)" id="setProgramConstantsFromVector(String,int,Vector$Number,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromVector(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает входные данные констант для шейдерных программ.
         
         <p>Задает массив констант, к которым получает доступ программа затенения вершин или фрагментов. Программы затенения получают доступ к константам, заданным в объекте Program3D, как к регистрам констант. Каждый регистр констант состоит из 4 значений с плавающими запятыми (x, y, z, w). Поэтому каждый регистр нуждается в четырех записях вектора данных. Количество реестров, которое можно задать для вершинной программы и фрагментной программы, зависит от <code>Context3DProfile</code>.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; Тип шейдерной программы: <code>Context3DProgramType.VERTEX</code> или <code>Context3DProgramType.FRAGMENT</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; индекс первого регистра констант, который необходимо задать.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; значения констант с плавающей запятой. В массиве <code>data</code> должно содержаться не менее 4 элементов <code>numRegisters</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; количество задаваемых констант. Укажите значение -1 (значение по умолчанию), чтобы задать достаточное число регистров для использования всех доступных данных.
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Ошибка пустого указателя: когда <code>data</code> имеет значение <code>null</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Регистр констант выходит за границы: при попытке установить значение, превышающее максимальное число регистров констант шейдера.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Элементов в массиве <code>data</code> минус byteArrayOffset меньше <code>numRegisters</code>*4
         
         </td></tr></table><p id="learnMore"><span class="label">Дополнительно</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_ru</a></div><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToBackBuffer()" id="setRenderToBackBuffer()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToBackBuffer():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает задний буфер визуализации в качестве цели визуализации. Последующие вызовы методов <code>drawTriangles()</code> и <code>clear()</code> приведут к обновлениям заднего буфера. Используйте этот метод, чтобы восстановить обычную визуализацию после использования метода <code>setRenderToTexture()</code>. 
         
         
         </p></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToTexture()" id="setRenderToTexture()"></a><a name="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)" id="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToTexture(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает указанную текстуру в качестве цели визуализации.  
         
         <p>Последующие вызовы методов <code>drawTriangles()</code> и <code>clear()</code> приводят к обновлению указанной текстуры, а не заднего буфера. Множественные отображения создаются автоматически. Используйте метод <code>setRenderToBackBuffer()</code> для восстановления обычной визуализации в заднем буфере.</p>
         
         <p>Перед рисованием очистка не требуется. Если очистка не выполняется, содержимое визуализации будет сохранено. также будут очищены буферы глубины и трафаретов. При первом рисовании происходит принудительная очистка. При вызове метода <code>present()</code> в качестве цели восстанавливается задний буфер.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; целевая текстура для визуализации. Задайте значение <code>null</code>, чтобы возобновить визуализацию в заднем буфере (<code>setRenderToBackBuffer()</code> и <code>present</code> также восстанавливают в качестве цели задний буфер).       
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Если установлено значение <code>true</code>, возможно тестирование глубины и трафарета. Если установлено значение <code>false</code>, все состояния глубины и трафаретов игнорируются в последующих операциях отрисовки. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Качество сглаживания. Используйте значение 0, чтобы отключить сглаживание; более высокие значения позволяют повысить качество сглаживания, но требуют большего количества вычислений. В настоящее время значение игнорируется мобильной платформой и контекстом программной визуализации. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">surfaceSelector</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Указывает, какой элемент текстуры необходимо обновить. Объекты Texture имеют одну поверхность, поэтому необходимо указать значение 0 (значение по умолчанию). Объекты CubeTexture имеют шесть поверхностей, поэтому необходимо указать целое число от 0 до 5.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorOutputIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Регистр цвета вывода. Должен иметь значение 0 для ограниченного режима или режима по базовой линии. В противном случае указывает регистр цвета вывода. 
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; для несоответствующего параметра <code>surfaceSelector</code>. Значение должно быть равно 0 для двумерных текстур и 0–5 для кубических карт. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Значение <code>texture</code> не извлекается из класса TextureBase (классов Texture или CubeTexture).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Значение <code>colorOutputIndex</code> должно быть целым числом от 0 до 3.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; для этого вызова требуется контекст <code>Context3D</code>, создаваемый с помощью стандартного профиля или его расширенных версий.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#configureBackBuffer()" target="">configureBackBuffer()</a><br/><a href="textures/CubeTexture.html#uploadFromByteArray()" target="">flash.display3D.textures.CubeTexture.uploadFromByteArray()</a></div></div></span><span id="pageFilter" runtime="Flash::11.6##AIR::3.6##"><a name="setSamplerStateAt()" id="setSamplerStateAt()"></a><a name="setSamplerStateAt(int,String,String,String)" id="setSamplerStateAt(int,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setSamplerStateAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setSamplerStateAt(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11.6, AIR 3.6</td></tr></table><p></p><p></p><p>
         Ручная перезапись состояния образца текстуры.
         
         <p>Состояние образца текстуры обычно задается во время вызова <code>setProgram</code>. Однако состояние образца текстуры можно заменить при помощи этой функции. Если вы не хотите, чтобы программа изменила состояние образца, задайте бит <code>ignoresamnpler</code> в AGAL и используйте эту функцию.          
         </p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; образец Регистр образца для применения. Сопоставляется с регистром образца в AGAL. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wrap</span>:<a href="../../String.html">String</a></code> &mdash; Режим обтекания. Определен в <code>Context3DWrapMode</code>. По умолчанию используется значение repeat. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../../String.html">String</a></code> &mdash; Режим фильтрования текстуры. Определен в <code>Context3DTextureFilter</code>. По умолчанию используется значение nearest. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mipfilter</span>:<a href="../../String.html">String</a></code> &mdash; Фильтр множественного отображения. Определен в <code>Context3DMipFilter</code>. По умолчанию используется значение none.          
                  
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; образец вне диапазона
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; обтекание, фильтр, ошибка bad enum фильтра mip 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Объект удален: если этот объект Context3D был удален путем вызова метода <code>dispose()</code> или из-за потери связи с базовым аппаратным обеспечением визуализации.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DWrapMode.html" target="">Context3DWrapMode</a><br/><a href="Context3DTextureFilter.html" target="">Context3DTextureFilter</a><br/><a href="Context3DMipFilter.html" target="">Context3DMipFilter</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setScissorRectangle()" id="setScissorRectangle()"></a><a name="setScissorRectangle(flash.geom.Rectangle)" id="setScissorRectangle(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setScissorRectangle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setScissorRectangle(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает прямоугольник вырезания, который является типом маски рисования. Средство визуализации отрисовывает только область внутри прямоугольника вырезания. Вырезание не влияет на операции очистки. 
         
         <p>Передайте значение <code>null</code>, чтобы выключить вырезание.</p>     
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rectangle</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Прямоугольник, в котором необходимо выполнить отрисовку. Укажите положение и размеры прямоугольника в пикселях. Начало системы координат находится в верхнем левом углу области просмотра, а положительные значения увеличиваются вниз и вправо (аналогично стандартной экранной системе координат Flash). 
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий класс отрисовывает два треугольника в видовом экране 640x480 пикселей на рабочей области. Треугольники имеют одну общую вершину, которая расположена в исходной точке (0,0,0).
 
 <p>Треугольники определены с использованием буфера вершин и буфера индексов. Буфер вершины содержит информацию положении и цвете для каждой вершины треугольника. Буфер индексов содержит индексы для буфера вершин. Три индекса определяют треугольник. Например, треугольник, который состоял из первых трех точек в буфере вершин, обозначается как «0,1,2» в буфере индексов.</p>
 
 <p>В этом простом примере не выполняется 3D-преобразование. На экран выводятся только объекты в канонической области просмотра (кубический объем 2x2x2 с центром в исходной точке). Однако при визуализации типичной 3D-сцены выполняется перспективная или ортогональная проекция объектов для визуализации в этой области просмотра.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_ScissorRectangle extends Sprite
    {
        public const viewWidth:Number = 640;
        public const viewHeight:Number = 480;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var scissorOn:Boolean = false;
        private var toggler:Timer = new Timer( 750 );
        
        public function Context3D_ScissorRectangle()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
            
            //Set up timer to turn scissoring on and off
            toggler.addEventListener( TimerEvent.TIMER, toggleScissor );
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
            toggler.start();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear();

            //Sciss a region excluding the outer 100 pixels of the viewport
            var scissor:Rectangle = new Rectangle( 100, 100, viewWidth - 200, viewHeight - 200 );
            if( scissorOn )    renderContext.setScissorRectangle( scissor ); //on
            else renderContext.setScissorRectangle( null ); //off

            //Draw the triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function toggleScissor( event:Event ):void
        {
            scissorOn = !scissorOn;
            render();
        }
        
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilActions()" id="setStencilActions()"></a><a name="setStencilActions(String,String,String,String,String)" id="setStencilActions(String,String,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilActions</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilActions(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает режим трафаретов и операцию.
         
         <p>8-битное значение ссылки на трафарет может быть связано с каждым вызовом отрисовки. Во время визуализации значение ссылки может быть протестировано относительно значений, ранее сохраненных в буфере кадров. Результат теста может влиять на действие отрисовки, а также на необходимость и способ обновления сохраненного значения трафарета. Кроме того, тестирование глубин определяет необходимость тестирования трафаретов. Тест глубин, завершившийся со сбоем, может также использоваться для управления действием, выполняемым буфером трафаретов.</p>
         
         <p>В конвейере обработки пикселей в первую очередь выполняется тестирование глубин. Если тестирование глубин завершается с ошибкой, может быть выполнено обновление буфера трафаретов, но дальнейшая оценка значения буфера трафаретов недопустима. Если тестирование глубин завершается успешно, выполняется тестирование трафаретов. В зависимости от результатов тестирования трафаретов могут быть предприняты альтернативные действия.  </p>
         
         <p>Значение ссылки на трафарет задается с использованием метода <code>setStencilReferenceValue()</code>. </p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFace</span>:<a href="../../String.html">String</a></code> (default = "<code>frontAndBack</code>")<code></code> &mdash; ориентации треугольников, которые влияют на операцию с трафаретами. Один из Context3DTriangleFace.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compareMode</span>:<a href="../../String.html">String</a></code> (default = "<code>always</code>")<code></code> &mdash; оператор тестирования, используемый для сравнения текущего значения ссылки на трафарет и значения трафарета целевого пикселя. Обновление цвета и глубины целевого пикселя выполняется, если значение после сравнения равно true. Действия с трафаретами выполняются по требованию в следующих параметрах действий. Оператор сравнения применяется как инфиксный оператор между текущим и целевым значениями ссылок в указанном порядке: (в псевдокоде: <code>if stencilReference OPERATOR stencilBuffer then pass</code>). Используйте одну из констант, определенных в классе Context3DCompareMode.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnBothPass</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; действие, которое будет предпринято, если успешно выполняются сравнения глубин и трафаретов. Используйте одну из констант, определенных в классе Context3DStencilAction.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; действие, которое будет выполняться, если сравнение глубин завершится со сбоем. Используйте одну из констант, определенных в классе Context3DStencilAction.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthPassStencilFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; действие, которое будет выполняться, если сравнение глубин будет выполнено успешно, а сравнение трафаретов &mdash; со сбоем. Используйте одну из констант, определенных в классе Context3DStencilAction.
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимая ошибка перечисления: когда <code>triangleFace</code> не принимает одно из значений, определенных в классе Context3DTriangleFace.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимая ошибка перечисления: когда <code>compareMode</code> не принимает одно из значений, определенных в классе Context3DCompareMode.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимая ошибка перечисления: когда <code>actionOnBothPass</code>, <code>actionOnDepthFail</code> или <code>actionOnDepthPassStencilFail</code> не принимает одно из значений, определенных в классе Context3DStencilAction.
         
         </td></tr></table><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3D.html#setStencilReferenceValue()" target="">setStencilReferenceValue()</a></div><span id="pageFilter"><br/><span class="label"> Пример &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span>)
            </span><br/><br/><div class="detailBody"> Следующий класс демонстрирует отрисовку трафарета, который применяется в качестве маски для последующих операций отрисовки. Выполняются следующие действия.
 <ul><li>Очистка буфера трафарета до 0.</li><li>Задание увеличения действия трафарета после прохождения проверки трафарета.</li><li>Установка для трафарета значения ссылки 0.</li><li>Отрисовка треугольной маски. При отрисовке треугольника выполняется проверка трафарета, поскольку буфер трафарета был очищен до 0 и значение ссылки равно 0. В результате значение буфера трафарета увеличивается на 1 при отрисовке треугольной маски.</li><li>Установка сохранения действия трафарета, чтобы последующие операции отрисовки не изменяли буфер трафарета.</li><li>Отрисовка прямоугольника во весь экран (многоцветный). Поскольку значение ссылки трафарета по-прежнему равно 0, происходит сбой проверки трафарета в маскированной области. Поэтому треугольник отрисовывается везде, за исключением маскированной области.</li><li>Установка значения ссылки трафарета, равного 1.</li><li>Отрисовка еще одного прямоугольника (красного) во весь экран. Теперь сбой проверки трафарета происходит везде, за исключением маскированной области, значение которой увеличено на 1. Поэтому прямоугольник отрисовывается только в маскированной области.</li></ul>
 <p>Наведите курсор мыши на пример для просмотра последовательности основных действий.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DCompareMode;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DStencilAction;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_Stencil extends Sprite
    {
        public const viewWidth:Number = 350;
        public const viewHeight:Number = 240;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
                
        public function Context3D_Stencil()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
        
            non3DSetup();
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, true );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3, 2, 
                                                            0, 1, 3,
                                                            4, 7, 6,
                                                            4, 5, 7,
                                                            8, 9, 10
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  //x, y, z  r,g,b format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1,

                   -1, 1, 0,  .5,0,0,
                    1, 1, 0,  .5,0,0,
                   -1,-1, 0,  .5,0,0,
                    1,-1, 0,  .5,0,0,
                    
                    0, .7,.1, 0,0,0,
                  -.7,-.7,.1, 0,0,0,
                   .7,-.7,.1, 0,0,0
                ]);
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            render();
        }
        private function render():void
        {
            //Clear, setting stencil to 0
            renderContext.clear( .3, .3, .3, 1, 1, 0 );
            
            //Draw stencil, incrementing the stencil buffer value
            renderContext.setStencilReferenceValue( 0 );
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.INCREMENT_SATURATE );            
            if( state &gt; 0 ) renderContext.drawTriangles( indexList, 12, 1 );

            //Change stencil action when stencil passes so stencil buffer is not changed
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.KEEP );
            
            //Draw quad -- doesn't draw where stencil has already drawn
            if( state &gt; 1 ) renderContext.drawTriangles( indexList, 0, 2 );
            
            //Change the reference to 1 so this quad only draws into stenciled area
            renderContext.setStencilReferenceValue( 1 );
            if( state &gt; 2 ) renderContext.drawTriangles( indexList, 6, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        //The rest of the code is for the example UI and timer 
        private function doState( event:TimerEvent ):void
        {
            switch (state)
            {
                case 0:
                    description.text = "Draw triangle with stencil action == increment";
                    state = 1;
                    break;
                case 1:
                    description.text = "Draw the first plane where stencil == 0";
                    state = 2;
                    break;
                case 2:
                    description.text = "Draw second plane where stencil == 1";
                    state = 3;
                    break;
                case 3:
                    description.text = "Clear, setting stencil to 0";
                    state = 0;
                    break;

                default:
                    description.text = "";
                    state = 0;        
            }
            render();
        }

        private var state:int = 3;
        private var stateTimer:Timer = new Timer( 1250 );
        private var description:TextField = new TextField();
        
        private function non3DSetup():void
        {
            //Setup timer to animate the stages of drawing the scene
            stateTimer.addEventListener( TimerEvent.TIMER, doState );
            this.stage.addEventListener( MouseEvent.MOUSE_OVER, function(event:Event):void{stateTimer.start()} );
            this.stage.addEventListener( MouseEvent.MOUSE_OUT, function(event:Event):void{stateTimer.stop()} );
            
            description.height = 30;
            description.width = viewWidth;
            this.addChild( description );
            description.y = viewHeight + 15;
            description.defaultTextFormat = new TextFormat( null, 18, 0xffffff );
            description.text = "Mouse over to view.";
            
            //Allows mouse-over events
            var coverSprite:Sprite = new Sprite();
            coverSprite.graphics.beginFill( 0, .01 )
            coverSprite.graphics.lineTo( stage.stageWidth, 0 );
            coverSprite.graphics.lineTo( stage.stageWidth, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, 0 );
            this.addChild( coverSprite );            
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilReferenceValue()" id="setStencilReferenceValue()"></a><a name="setStencilReferenceValue(uint,uint,uint)" id="setStencilReferenceValue(uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilReferenceValue</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilReferenceValue(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Задает значение сравнения трафаретов, используемое для проверок трафаретов. 
         
         <p>Используются только нижние 8 бит эталонного значения. Значение из буфера трафарета также имеет длину 8 бит. Используйте <code>readMask</code> и <code>writeMask</code>, чтобы применить буфер трафарета в качестве битового поля.</p>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">referenceValue</span>:<a href="../../uint.html">uint</a></code> &mdash; 8-битное значение ссылки, используемое в тестах сравнения значений ссылок.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">readMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 8-битная маска, которая должна применяться и к текущему значению из буфера трафарета, и к эталонному значению перед сравнением.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">writeMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 8-битная маска, применяемая к эталонному значению перед обновлением буфера трафарета.
         
         </td></tr></table></p><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3D.html#setStencilActions()" target="">setStencilActions()</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setTextureAt()" id="setTextureAt()"></a><a name="setTextureAt(int,flash.display3D.textures.TextureBase)" id="setTextureAt(int,flash.display3D.textures.TextureBase)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setTextureAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setTextureAt(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Задает текстуру, которая будет использоваться в качестве регистра входной текстуры фрагментной программы.
         
         <p>Фрагментная программа может считывать данные не более чем из восьми объектов текстур. Используйте эту функцию для назначения объекта Texture или CubeTexture одному из регистров образца, используемых фрагментной программой. </p>
         
         <p><b>Примечание.</b> Если активная фрагментная программа заменяется (с использованием метода <code>setProgram</code>) шейдером, в котором используется меньшее количество текстур, установите для неиспользуемых регистров значение <code>null</code>:</p>
         <div class="listing"><pre>
         setTextureAt( 7, null );
         </pre></div>
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; индекс регистра образца: значение от 0 до 7.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; объект текстуры, который необходимо сделать доступным: экземпляр Texture или оCubeTexture.
         
         </td></tr></table></p><p id="learnMore"><span class="label">Дополнительно</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_ru</a></div><p><span class="label">Связанные элементы API</span></p><div class="seeAlso">Texture<br/>CubeTexture</div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setVertexBufferAt()" id="setVertexBufferAt()"></a><a name="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)" id="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVertexBufferAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">метод</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVertexBufferAt(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Язык версии:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Версии среды выполнения:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Указывает, какие компоненты данных вершин соответствуют одному вводу данных в шейдерную вершинную программу.
         
         <p>Используйте метод <code>setVertexBufferAt</code> для определения принадлежности компонентов данных, определенных для каждой вершины в буфере VertexBuffer3D, входным данным вершинной программы. Разработчик программы вершин определяет, сколько данных требуется для каждой вершины. Данные сопоставляются из одного или нескольких потоков <code>VertexBuffer3D</code> в регистры атрибутов вершинной шейдерной программы.</p>
         
         <p>Самая малая единица данных, используемая программой затенения вершин, равна 32 битам. Смещения в потоке вершин кратны 32 битам.</p>
         
         Например, программист может определить каждую вершину с использованием следующих данных:
<pre>
position:  x    float32
           y    float32
           z    float32
color:     r    unsigned byte
           g    unsigned byte
           b    unsigned byte
           a    unsigned byte
</pre>            
         Предположим, вершина была определена в объекте VertexBuffer3D с именем <code>buffer</code>; ее можно передать в вершинный шейдер с помощью следующего кода:
<pre>
setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
</pre>
         
         
         </p><p><span class="label"> Параметры </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">index</span>:<a href="../../int.html">int</a></code> &mdash; индекс регистра атрибутов в вершинном шейдере (от 0 до 7).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">buffer</span>:<a href="VertexBuffer3D.html">VertexBuffer3D</a></code> &mdash; буфер, содержащий данные исходной вершины, которые будут переданы в вершинный шейдер.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferOffset</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; смещение относительно начала данных для одной вершины, с которым необходимо начать чтение этого атрибута. В примере выше данные о положении имеют смещение, равное 0, поскольку это первый атрибут; цвет имеет смещение, равное 3, поскольку атрибут цвета следует за 32-разрядными значениями положения. Смещение указывается с шагом 32 бита.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> (default = "<code>float4</code>")<code></code> &mdash; значение из класса Context3DVertexBufferFormat, указывающее тип данных этого атрибута.  
         
         </td></tr></table></p><br/><span class="label">Выдает</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Недопустимое перечисление: когда формат не принимает одно из значений, определенных в классе Context3DVertexBufferFormat.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Регистр атрибутов выходит за пределы: когда параметр <code>index</code> не попадает в диапазон от 0 до 7. (В шейдере можно использовать не более восьми регистров атрибутов вершин.)
         
         </td></tr></table><p id="learnMore"><span class="label">Дополнительно</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_ru</a></div><p><span class="label">Связанные элементы API</span></p><div class="seeAlso"><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Примеры<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_ru"> Использование этого примера </a></span></div><span id="pageFilter"><div class="exampleHeader">Context3DExample.as</div><br/><div class="detailBody"> Следующий класс отрисовывает вращающийся куб с использованием проекции перспективы.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    import com.adobe.utils.PerspectiveMatrix3D;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.geom.Vector3D;
    
    public class Context3DExample extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        public const zNear:Number = 1;
        public const zFar:Number = 500;
        
        public const fov:Number = 45;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private var projection:PerspectiveMatrix3D = new PerspectiveMatrix3D();
        private var model:Matrix3D = new Matrix3D();
        private var view:Matrix3D = new Matrix3D();
        private var finalTransform:Matrix3D = new Matrix3D();
        
        //For rotating the cube
        private const pivot:Vector3D = new Vector3D();
        
        private const VERTEX_SHADER:String =
            "m44 op, va0, vc0    \n" +    // 4x4 matrix transform 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3DExample()
        {
            this.stage.scaleMode = StageScaleMode.NO_SCALE;
            this.stage.align = StageAlign.TOP_LEFT;
            this.stage.nativeWindow.activate(); //AIR only
                         
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextCreationError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
                renderContext = Stage3D( event.target ).context3D;
                trace( "3D driver: " + renderContext.driverInfo );
                setupScene();
        }
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //Create vertex index list for the triangles forming a cube
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 
                2,1,0, //front face
                3,2,0,
                4,7,5, //bottom face
                7,6,5,
                8,11,9, //back face
                9,11,10,
                12,15,13, //top face
                13,15,14,
                16,19,17, //left face
                17,19,18,
                20,23,21, //right face
                21,23,22
            ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes - cube faces do not share vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                    // x,y,z r,g,b format
                    0,0,0, 1,0,0, //front face
                    0,1,0, 1,0,0,
                    1,1,0, 1,0,0,
                    1,0,0, 1,0,0,
                    
                    0,0,0, 0,1,0, //bottom face
                    1,0,0, 0,1,0,
                    1,0,1, 0,1,0,
                    0,0,1, 0,1,0,
                    
                    0,0,1, 1,0,0, //back face
                    1,0,1, 1,0,0,
                    1,1,1, 1,0,0,
                    0,1,1, 1,0,0,
                    
                    0,1,1, 0,1,0, //top face
                    1,1,1, 0,1,0,
                    1,1,0, 0,1,0,
                    0,1,0, 0,1,0,
                    
                    0,1,1, 0,0,1, //left face
                    0,1,0, 0,0,1,
                    0,0,0, 0,0,1,
                    0,0,1, 0,0,1,
                    
                    1,1,0, 0,0,1, //right face
                    1,1,1, 0,0,1,
                    1,0,1, 0,0,1,
                    1,0,0, 0,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Set up 3D transforms
            projection.perspectiveFieldOfViewRH( fov, viewWidth/viewHeight, zNear, zFar );            
            view.appendTranslation( 0, 0, -2 );    //Move view back
            model.appendTranslation( -.5, -.5, -.5 ); //center cube on origin
            this.stage.addEventListener( Event.ENTER_FRAME, render );
        }
        
        private function render( event:Event ):void
        {
            //Rotate model on each frame
            model.appendRotation( .5, Vector3D.Z_AXIS, pivot );
            model.appendRotation( .5, Vector3D.Y_AXIS, pivot );
            model.appendRotation( .5, Vector3D.X_AXIS, pivot );
            
            //Combine transforms
            finalTransform.identity();
            finalTransform.append( model );
            finalTransform.append( view );
            finalTransform.append( projection );
            
            //Pass the final transform to the vertex shader as program constant, vc0
            renderContext.setProgramConstantsFromMatrix( Context3DProgramType.VERTEX, 0, finalTransform, true );
            
            //Clear is required before drawTriangles on each frame
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 12 triangles that make up the cube
            renderContext.drawTriangles( indexList, 0, 12 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextCreationError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
    }
}
</pre></div></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,true,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:34 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ru_RU/legalnotices/index.html">Юридическая информация</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Политика конфиденциальности онлайн</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Почему по-английски?</span>
				</div>
				<div class="white_content_body">
					<b>Содержимое Справочника ActionScript 3.0 отображается на английском языке</b><br><br>
					Не все части Справочника ActionScript 3.0 переводятся на все языки. Если какой-то текстовый элемент не переведен, он отображается на английском языке. Например, компонент ga.controls.HelpBox не переведен ни на один из языков. Это значит, что в русской версии справки компонент ga.controls.HelpBox будет отображаться на английском языке.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 11:34 AM Z  -->
