<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 Referenzhandbuch für die Adobe&reg; Flash&reg;-Plattform"><meta name="lang" content="de-de"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:11"><meta name="runtime" content="air"><meta name="runtimever" content="air:3"><meta name="product" content="flash player"><meta name="productver" content="flash player:11"><meta name="product" content="air"><meta name="productver" content="air:3"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="Context3D,flash.display3D.Context3D,backBufferHeight,backBufferWidth,driverInfo,enableErrorChecking,maxBackBufferHeight,maxBackBufferWidth,profile,supportsVideoTexture,totalGPUMemory,clear,configureBackBuffer,createCubeTexture,createIndexBuffer,createProgram,createRectangleTexture,createTexture,createVertexBuffer,createVertexBufferForInstances,createVideoTexture,dispose,drawToBitmapData,drawTriangles,drawTrianglesInstanced,present,setBlendFactors,setColorMask,setCulling,setDepthTest,setFillMode,setProgram,setProgramConstantsFromByteArray,setProgramConstantsFromMatrix,setProgramConstantsFromVector,setRenderToBackBuffer,setRenderToTexture,setSamplerStateAt,setScissorRectangle,setStencilActions,setStencilReferenceValue,setTextureAt,setVertexBufferAt"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>Context3D - Adobe ActionScript&reg; 3 (AS3 ) API-Referenz</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Laufzeitumgebungen";
			var productsLabel = "Produkte";
			var noneLabel = "Keine";
			var qsearchBoxLabel = "Schnellsuche";
			var qsearchText = "Begriff nicht gefunden";
			var ajaxErrorMsg="Fehler beim Laden der Seite";
			var ajaxErrorTryMsg="Wiederholen";
			var ajaxLoadingMsg="Ladevorgang läuft noch";
			var cancelMsg = "Abbrechen";
			var classesText = "Klassen";
			var strJiveReply = "Diese Frage wurde zu folgendem Artikel gestellt: "
			var showFilters = "Filter anzeigen";
			var hideFilters = "Filter ausblenden";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 Referenzhandbuch für die Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>-Plattform<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Home </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="Context3D.html#top" style="display:">Liste der Pakete und Klassen einblenden</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="Context3D.html#top" style="display:none">Liste der Pakete und Klassen ausblenden</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Pakete </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Klassen </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Neue Funktionen </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Stichwortverzeichnis </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Anhänge </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Warum auf Englisch?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/de_DE/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filter:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Daten werden vom Server abgerufen...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Daten werden vom Server abgerufen...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="Context3D.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display3D&nbsp;</a><br>
								<h1 id="classProductName">Context3D&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="Context3D.html#propertySummary" style="display:none"> Eigenschaften </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Eigenschaften </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="Context3D.html#methodSummary" style="display:none"> Methoden </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="Context3D.html#constantSummary" style="display:none"> Globale Konstanten </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="Context3D.html#eventSummary" style="display:none"> Ereignisse </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="Context3D.html#styleSummary" style="display:none"> Stile </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="Context3D.html#SkinPartSummary" style="display:none"> Skinteile </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="Context3D.html#SkinStateSummary" style="display:none"> Skinstatus </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="Context3D.html#effectSummary" style="display:none"> Effekte </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="Context3D.html#constantSummary" style="display:none"> Konstanten </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="Context3D.html#methodSummary" style="display:none"> Globale Funktionen </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="Context3D.html#methodSummary" style="display:none">Funktionen</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="Context3D.html#interfaceSummary" style="display:none"> Schnittstellen </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="Context3D.html#classSummary" style="display:none"> Klassen </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="Context3D.html#includeExamplesSummary" style="display:none"> Beispiele </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="Context3D.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klassen
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Paket</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display3D</a></td></tr><tr><td class="classHeaderTableLabel">Klasse</td><td class="classSignature">public final   class  Context3D</td></tr><tr><td class="classHeaderTableLabel">Vererbung</td><td class="inheritanceList">Context3D  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../events/EventDispatcher.html">EventDispatcher</a> <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p></p>
     Die Context3D-Klasse stellt einen Kontext für das Rendering geometrisch definierter Grafiken bereit.
     
     <p>Ein Renderingkontext beinhaltet eine Zeichenoberfläche und deren zugeordnete Ressourcen und Zustände. Der Renderingkontext verwendet nach Möglichkeit die Hardware-GPU (Grafikprozessor). Andernfalls verwendet der Renderingkontext Software. (Wenn das Rendering durch Context3D auf einer Plattform nicht unterstützt wird, enthält die <code>stage3Ds</code>-Eigenschaft des Stage-Objekts eine leere Liste.)</p>
     
               <p>Der Context3D-Renderingkontext ist eine programmierbare Pipeline, die große Ähnlichkeit mit OpenGL ES 2 hat, allerdings abstrahiert ist, sodass sie mit einer Reihe von Hardware- und GPU-Schnittstellen vergleichbar ist. Obwohl sie für 3D-Grafiken entwickelt wurde, schreibt die Renderingpipeline nicht vor, dass das Rendering dreidimensional ist. Deshalb können Sie einen 2D-Renderer erstellen, indem Sie die entsprechenden Vertex- und Pixelfragmentprogramme bereitstellen. Sowohl für 3D als auch 2D wird als einzige geometrische Grundform das Dreieck unterstützt.</p>
     
               <p>Ruft eine Instanz der Context3D-Klasse ab, indem die <code>requestContext3D()</code>-Methode eines Stage3D-Objekts aufgerufen wird. Eine begrenzte Anzahl von Context3D-Objekten kann pro Bühne vorhanden sein; eine für jedes Stage3D-Objekt in der <code>Stage.stage3Ds</code>-Liste. Wenn der Kontext erstellt wird, setze das Stage3D-Objekt ein <code>context3DCreate</code>-Ereignis ab. Ein Renderingkontext kann jederzeit zerstört und neu erstellt werden, zum Beispiel wenn eine andere Anwendung, die die GPU verwendet, den Fokus erhält. Sie sollten den Empfang mehrerer <code>context3DCreate</code>-Ereignisse einkalkulieren. Positionieren Sie den Renderbereich auf der Bühne, indem Sie die <code>x</code>- und <code>y</code>-Eigenschaften der zugeordneten Stage3D-Instanz verwenden.</p>  
     
     
     
     
               <p>Zum Rendern und Anzeigen einer Szene (nach dem Abrufen eines Context3D-Objekts) sind die folgenden Schritte typisch:</p>
               <ol>
                  <li>Konfigurieren Sie die Attribute des Hauptanzeigepuffers durch den Aufruf von <code>configureBackBuffer()</code>.</li>
                  <li>Erstellen und initialisieren Sie Ihre Renderingressourcen, darunter:
      <ul>
                        <li>Vertex- und Indexpuffer, die die Szenengeometrie definieren</li>
                        <li>Vertex- und Pixelprogramme (Shader) zum Rendern der Szene</li>
                        <li>Texturen</li>
                     </ul>
                  </li>
                  <li>Rendern eines Bildes:
      <ul>
                        <li>Legen Sie den Renderzustand für ein Objekt oder eine Gruppe von Objekten in der Szene fest.</li>
                        <li>Rufen Sie die <code>drawTriangles()</code>-Methode auf, um eine Gruppe von Dreiecken zu rendern.</li>
                        <li>Ändern Sie den Renderingzustand für die nächste Gruppe von Objekten.</li>
                        <li>Rufen Sie <code>drawTriangles()</code> auf, um Dreiecke zu zeichnen, die die Objekte definieren.</li>
                        <li>Wiederholen Sie den Vorgang, bis die gesamte Szene gerendert wurde.</li>
                        <li>Rufen Sie die <code>present()</code>-Methode auf, um die gerenderte Szene auf der Bühne anzuzeigen.</li>
                     </ul>
                  </li>
               </ol>
     
               <p>Für das Rendering gelten die folgenden Einschränkungen:</p>
               <p>Ressourceneinschränkungen:
      <table class="innertable" ><tr><th>Ressource</th><th>Zulässige Anzahl</th><th>Gesamtspeicher</th></tr><tr><td>
                                 <code>Vertexbuffer</code>
                              </td><td>4096</td><td>256 MB</td></tr><tr><td>
                                 <code>Indexbuffer</code>
                              </td><td>4096</td><td>128 MB</td></tr><tr><td>
                                 <code>Programme</code>
                              </td><td>4096</td><td>16 MB</td></tr><tr><td>
                                 <code>Texturen</code>
                              </td><td>4096</td><td>128 MB</td></tr><tr><td>
                                 <code>Würfeltexturen</code>
                              </td><td>4096</td><td>256 MB</td></tr></table>
               </p>
               <p>AGAL-Limits: 200 Opcodes pro Programm.</p>
     
               <p>Zeichenaufruf-Limits: 32.768 Aufrufe von <code>drawTriangles()</code> für jeden <code>present()</code>-Aufruf.</p>
               <p>Für Texturen gelten die folgenden Einschränkungen:</p>
               <p>Texturenbeschränkungen für AIR&nbsp;32-Bit:
      <table class="innertable" ><tr><th>Texture</th><th>Maximale Größe</th><th>GPU-Gesamtspeicher</th></tr><tr><td>
                                 <code>Normale Textur (unterhalb der erweiterten Baseline)</code>
                              </td><td>2048 x 2048</td><td>512 MB</td></tr><tr><td>
                                 <code>Normale Textur (erweiterte Baseline und darüber)</code>
                              </td><td>4096 x 4096</td><td>512 MB</td></tr><tr><td>
                                 <code>Rechteckige Textur (unterhalb der erweiterten Baseline)</code>
                              </td><td>2048 x 2048</td><td>512 MB</td></tr><tr><td>
                                 <code>Rechteckige Textur (erweiterte Baseline und darüber)</code>
                              </td><td>4096 x 4096</td><td>512 MB</td></tr><tr><td>
                                 <code>Würfeltextur</code>
                              </td><td>1024 x 1024</td><td>256 MB</td></tr></table>
	              </p> 
	              <p>Texturenbeschränkungen für AIR&nbsp;64-Bit (Desktop):
      <table class="innertable" ><tr><th>Texture</th><th>Maximale Größe</th><th>GPU-Gesamtspeicher</th></tr><tr><td>
                                 <code>Normale Textur (unterhalb der erweiterten Baseline)</code>
                              </td><td>2048 x 2048</td><td>512 MB</td></tr><tr><td>
                                 <code>Normale Textur (erweiterte Baseline bis Standard)</code>
                              </td><td>4096 x 4096</td><td>512 MB</td></tr><tr><td>
                                 <code>Normale Textur (Standard erweitert und darüber)</code>
                              </td><td>4096 x 4096</td><td>2048 MB</td></tr><tr><td>
                                 <code>Rechteckige Textur (unterhalb der erweiterten Baseline)</code>
                              </td><td>2048 x 2048</td><td>512 MB</td></tr><tr><td>
                                 <code>Rechteckige Textur (erweiterte Baseline bis Standard)</code>
                              </td><td>4096 x 4096</td><td>512 MB</td></tr><tr><td>
                                 <code>Rechteckige Textur (Standard erweitert und darüber)</code>
                              </td><td>4096 x 4096</td><td>2048 MB</td></tr><tr><td>
                                 <code>Würfeltextur</code>
                              </td><td>1024 x 1024</td><td>256 MB</td></tr></table>
	              </p>
               <p>512 MB ist das absolute Limit für Texturen, einschließlich des Texturspeichers, der für Mipmaps benötigt wird. Für Würfeltexturen beträgt die maximale Speicherkapazität hingegen 256 MB.</p>
     
               <p>Sie können Context3D-Objekte nicht mit dem Context3D-Konstruktor erstellen. Es wird als Eigenschaft einer Stage3D-Instanz konstruiert und ist als solche verfügbar. Die Context3D-Klasse kann sowohl auf Desktop- als auch auf mobilen Plattformen verwendet werden; dies gilt für die Ausführung in Flash Player und in AIR.</p>
         
            <p></p><p><a href="Context3D.html#includeExamplesSummary">Beispiele anzeigen</a></p><p><span class="classHeaderTableLabel">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a><br/><a href="Context3DClearMask.html" target="">Context3DClearMask</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DProgramType.html" target="">Context3DProgramType</a><br/><a href="Context3DRenderMode.html" target="">Context3DRenderMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="textures/CubeTexture.html" target="">flash.display3D.textures.CubeTexture</a><br/><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a><br/><a href="../geom/Matrix3D.html" target="">flash.geom.Matrix3D</a><br/><a href="Program3D.html" target="">Program3D</a><br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a><br/><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Öffentliche Eigenschaften</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Vererbte öffentliche Eigenschaften ausblenden</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Vererbte öffentliche Eigenschaften anzeigen</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Eigenschaft</th><th>Definiert von</th></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferHeight" class="signatureLink">backBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[schreibgeschützt]  
        Gibt die Höhe des Hintergrundpuffers an. Dies kann durch einen erfolgreichen Aufruf der configureBackBuffer()-Methode geändert werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferWidth" class="signatureLink">backBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[schreibgeschützt]  
        Gibt die Breite des Hintergrundpuffers an. Dies kann durch einen erfolgreichen Aufruf der configureBackBuffer()-Methode geändert werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Ein Verweis auf das Klassenobjekt oder die Konstruktorfunktion für eine angegebene Objektinstanz.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#driverInfo" class="signatureLink">driverInfo</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[schreibgeschützt]  
         Der Typ des Grafikbibliothekstreibers, der von diesem Renderingkontext verwendet wird.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#enableErrorChecking" class="signatureLink">enableErrorChecking</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription"> 
         Gibt an, ob vom Renderer gefundene Fehler der Anwendung gemeldet werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferHeight" class="signatureLink">maxBackBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        Legt die maximale Höhe des Hintergrundpuffers fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferWidth" class="signatureLink">maxBackBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        Gibt die maximale Breite des Hintergrundpuffers an.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::12##AIR::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#profile" class="signatureLink">profile</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[schreibgeschützt] 
		Das funktionsunterstützte Profil wird von diesem Context3D-Objekt verwendet.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#supportsVideoTexture" class="signatureLink">supportsVideoTexture</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[statisch] [schreibgeschützt] 
          Gibt an, ob Context3D Videotextur unterstützt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::21##AIR::21##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#totalGPUMemory" class="signatureLink">totalGPUMemory</a> : <a href="../../Number.html">Number</a><div class="summaryTableDescription">[schreibgeschützt]  
         Gibt den Gesamt-GPU-Speicher zurück, der von den Stage3D-Datenstrukturen einer Anwendung zugeordnet wurde. Wenn ein GPU-Ressourcenobjekt erstellt wird, wird der verwendete Speicher in Context3D gespeichert.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Öffentliche Methoden </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Vererbte öffentliche Methoden ausblenden</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Vererbte öffentliche Methoden anzeigen</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Methode</th><th>Definiert von</th></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#addEventListener()" class="signatureLink">addEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false, priority:<a href="../../int.html">int</a> = 0, useWeakReference:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	Registriert ein Ereignis-Listener-Objekt bei einem EventDispatcher-Objekt, sodass der Listener über ein Ereignis benachrichtigt wird.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#clear()" class="signatureLink">clear</a>(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Löscht die Farb-, Tiefen- und Schablonenbuffer, die diesem Context3D-Objekt zugeordnet sind, und füllt sie mit den angegebenen Werten.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#configureBackBuffer()" class="signatureLink">configureBackBuffer</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt die Viewportabmessungen und andere Attribute des Renderpuffers fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createCubeTexture()" class="signatureLink">createCubeTexture</a>(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></div><div class="summaryTableDescription">
         Erstellt ein CubeTexture-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createIndexBuffer()" class="signatureLink">createIndexBuffer</a>(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></div><div class="summaryTableDescription">
         Erstellt ein IndexBuffer3D-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createProgram()" class="signatureLink">createProgram</a>():<a href="Program3D.html">Program3D</a></div><div class="summaryTableDescription">
         Erstellt ein Program3D-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.8##AIR::3.8##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createRectangleTexture()" class="signatureLink">createRectangleTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></div><div class="summaryTableDescription">
         Erstellt ein RectangleTexture-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createTexture()" class="signatureLink">createTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></div><div class="summaryTableDescription">
         Erstellt ein Texture-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVertexBuffer()" class="signatureLink">createVertexBuffer</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         Erstellt ein VertexBuffer3D-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#createVertexBufferForInstances()" class="signatureLink">createVertexBufferForInstances</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         Erstellt ein VertexBuffer3D-Objekt für Instanzdaten.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVideoTexture()" class="signatureLink">createVideoTexture</a>():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></div><div class="summaryTableDescription">
         Erstellt ein VideoTexture-Objekt.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#dispatchEvent()" class="signatureLink">dispatchEvent</a>(event:<a href="../events/Event.html">Event</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Sendet ein Ereignis in den Ereignisablauf.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#dispose()" class="signatureLink">dispose</a>(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Macht alle Ressourcen und internen Speicher frei, die/der mit diesem Context3D-Objekt verknüpft sind.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawToBitmapData()" class="signatureLink">drawToBitmapData</a>(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Zeichnet den aktuellen Renderpuffer in eine Bitmap.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#drawTriangles()" class="signatureLink">drawTriangles</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Rendert die angegebenen Dreiecke mit den aktuellen Puffern und dem Zustand dieses Context3D-Objekts.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawTrianglesInstanced()" class="signatureLink">drawTrianglesInstanced</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Rendert die angegebenen Dreiecke mit den aktuellen Puffern und dem Zustand dieses Context3D-Objekts.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#hasEventListener()" class="signatureLink">hasEventListener</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Überprüft, ob das EventDispatcher-Objekt Listener für einen bestimmten Ereignistyp registriert hat.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob für ein Objekt eine bestimmte Eigenschaft definiert wurde.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob eine Instanz der Object-Klasse in der Prototypkette des Objekts vorhanden ist, das als Parameter angegeben wurde.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#present()" class="signatureLink">present</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Zeigt den Hintergrund-Renderpuffer an.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob die angegebene Eigenschaft vorhanden ist und durchlaufen werden kann.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#removeEventListener()" class="signatureLink">removeEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	Entfernt einen Listener aus dem EventDispatcher-Objekt.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setBlendFactors()" class="signatureLink">setBlendFactors</a>(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt die Faktoren fest, die zum Mischen der Ausgabefarbe eines Zeichenvorgangs mit der vorhandenen Farbe verwendet werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setColorMask()" class="signatureLink">setColorMask</a>(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt die Maske fest, die beim Schreiben der Farben in den Renderbuffer verwendet wird.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setCulling()" class="signatureLink">setCulling</a>(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt den Dreieckcullingmodus fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setDepthTest()" class="signatureLink">setDepthTest</a>(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt den Vergleichstyp fest, der für Tiefentests verwendet wird.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::16##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#setFillMode()" class="signatureLink">setFillMode</a>(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
		Füllmodus für das Rendern festlegen.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgram()" class="signatureLink">setProgram</a>(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt Vertex- und Fragmentshaderprogramme fest, die für das nachfolgende Rendern verwendet werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.1##AIR::3.1##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromByteArray()" class="signatureLink">setProgramConstantsFromByteArray</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt Konstanten für die Verwendung durch Shader-Programme fest, indem in einem ByteArray-Objekt gespeicherte Werte verwendet werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromMatrix()" class="signatureLink">setProgramConstantsFromMatrix</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt Konstanten für die Verwendung durch Shader-Programme fest, indem in einem Matrix3D-Objekt gespeicherte Werte verwendet werden.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromVector()" class="signatureLink">setProgramConstantsFromVector</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt die Konstanteneingaben für die Shaderprogramme fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Legt die Verfügbarkeit einer dynamischen Eigenschaft für Schleifenoperationen fest.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToBackBuffer()" class="signatureLink">setRenderToBackBuffer</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt den Hintergrund-Renderpuffer als Renderziel fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToTexture()" class="signatureLink">setRenderToTexture</a>(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt die angegebene Textur als Renderziel fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.6##AIR::3.6##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setSamplerStateAt()" class="signatureLink">setSamplerStateAt</a>(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Textursamplerstatus manuell überschreiben.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setScissorRectangle()" class="signatureLink">setScissorRectangle</a>(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt ein Scherenrechteck fest, was eine Art von Zeichenmaske ist.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilActions()" class="signatureLink">setStencilActions</a>(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Legt den Schablonenmodus und -vorgang fest.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilReferenceValue()" class="signatureLink">setStencilReferenceValue</a>(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
         Legt den Schablonenvergleichswert fest, der für Schablonentests verwendet wird.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setTextureAt()" class="signatureLink">setTextureAt</a>(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Gibt die Textur an, die für ein Textureingaberegister eines Fragmentprogramms verwendet werden soll.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setVertexBufferAt()" class="signatureLink">setVertexBufferAt</a>(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Gibt an, welche Vertexdatenkomponenten einer einzelnen Vertexshaderprogrammeingabe entsprechen.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Gibt die Stringdarstellung dieses Objekts zurück, formatiert entsprechend den Konventionen des Gebietsschemas.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Gibt das angegebene Objekt als String zurück.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Gibt den Grundwert des angegebenen Objekts zurück.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#willTrigger()" class="signatureLink">willTrigger</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	Überprüft, ob bei diesem EventDispatcher-Objekt oder bei einem seiner Vorgänger ein Ereignis-Listener für einen bestimmten Ereignistyp registriert ist.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="eventSummary" id="eventSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Ereignisse</div><div class="showHideLinks"><a href="http://help.adobe.com/de_DE/Flex/4.6/UsingSDK/WS2db454920e96a9e51e63e3d11c0bf69084-7ee9.html" target="_blank">Klicken Sie, um weitere Informationen zu Ereignissen zu erhalten.</a></div><div class="showHideLinks"><div id="hideInheritedEvent" class="hideInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(false,'Event');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Vererbte Ereignisse ausblenden</a></div><div id="showInheritedEvent" class="showInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(true,'Event');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Vererbte Ereignisse anzeigen</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable hideInheritedEvent" id="summaryTableEvent"><tr><th>&nbsp;</th><th colspan="2">Ereignis</th><th> Übersicht </th><th>Definiert von</th></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:activate" class="signatureLink">activate</a></div></td><td class="summaryTableDescription summaryTableCol">[broadcast event] Wird ausgelöst, wenn Flash Player oder eine AIR-Anwendung den Betriebssystemfokus erhält und aktiv wird.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:deactivate" class="signatureLink">deactivate</a></div></td><td class="summaryTableDescription summaryTableCol">[broadcast event] Wird ausgelöst, wenn Flash Player- oder die AIR-Anwendung den Fokus verliert und inaktiv wird.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Eigenschaftendetails</div><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferHeight" id="backBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferHeight</h3></td><td class="detailHeaderType">Eigenschaft</td></tr></table><div class="detailBody"><code>backBufferHeight:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Gibt die Höhe des Hintergrundpuffers an. Dies kann durch einen erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode geändert werden. Die Höhe kann bei einer Änderung des Browser-Zoomfaktors geändert werden, wenn für <code>wantsBestResolutionOnBrowserZoom</code> der Wert <code>true</code> im letzten erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode festgelegt wurde. Die Änderung der Höhe kann erkannt werden, indem ein Ereignis-Listener für die Änderung des Browser-Zooms registriert wird.
        
        </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferHeight():<a href="../../int.html">int</a></code><br/><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferWidth" id="backBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferWidth</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>backBufferWidth:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Gibt die Breite des Hintergrundpuffers an. Dies kann durch einen erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode geändert werden. Die Breite kann bei einer Änderung des Browser-Zoomfaktors geändert werden, wenn für <code>wantsBestResolutionOnBrowserZoom</code> der Wert <code>true</code> im letzten erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode festgelegt wurde. Die Änderung der Breite kann erkannt werden, indem ein Ereignis-Listener für die Änderung des Browser-Zooms registriert wird.
		
		</p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferWidth():<a href="../../int.html">int</a></code><br/><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="driverInfo" id="driverInfo"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>driverInfo</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>driverInfo:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Der Typ des Grafikbibliothekstreibers, der von diesem Renderingkontext verwendet wird. Gibt an, ob für das Rendering Software, ein DirectX-Treiber oder ein OpenGL-Treiber verwendet wird. Gibt auch an, ob das Hardwarerendern fehlgeschlagen ist. Wenn das Hardwarerendern fehlschlägt, verwendet Flash Player Softwarerendern für Stage3D, und <code>driverinfo</code> enthält einen der folgenden Werte:
         <ul><li>"Software Hw_disabled=userDisabled" - Das Kontrollkästchen „Hardwarebeschleunigung aktivieren“ in den Einstellungen von Adobe Flash Player wurde nicht ausgewählt.</li><li>"Software Hw_disabled=oldDriver" - Es gibt bekannte Probleme mit dem Hardwaregrafiktreiber. Möglicherweise kann das Problem durch eine Aktualisierung des Grafiktreibers behoben werden.</li><li>"Software Hw_disabled=unavailable" - Bekannte Probleme mit dem Hardwaregrafiktreiber oder Initialisierungsfehler mit der Grafikhardware.</li><li>"Software Hw_disabled=explicit" - Der Inhalt hat über requestContext3D ausdrücklich das Softwarerendern angefordert.</li><li>"Software Hw_disabled=domainMemory" - Der Inhalt verwendet domainMemory, wofür im Fall der Verwendung mit Stage3D-Hardwarerendering eine Lizenz erforderlich ist. Besuchen Sie <a href="http://www.adobe.com/go/fpl" target="_new">adobe.com/go/fpl_de</a>.</li></ul>
         
         </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get driverInfo():<a href="../../String.html">String</a></code><br/></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="enableErrorChecking" id="enableErrorChecking"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>enableErrorChecking</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>enableErrorChecking:<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Gibt an, ob vom Renderer gefundene Fehler der Anwendung gemeldet werden.
          
         <p>Wenn <code>enableErrorChecking</code> den Wert <code>true</code> hat, sind die <code>clear()</code>- und <code>drawTriangles()</code>-Methoden synchron und können Fehler ausgeben. Wenn <code>enableErrorChecking</code> den Wert <code>false</code> hat, was die Standardeinstellung ist, sind die <code>clear()</code>- und <code>drawTriangles()</code>-Methoden asynchron und es werden keine Fehler gemeldet. Durch die Aktivierung der Fehlerüberprüfung wird die Renderingleistung beeinträchtigt. Sie sollten die Fehlerüberprüfung nur beim Debugging aktivieren.</p>
         
         </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get enableErrorChecking():<a href="../../Boolean.html">Boolean</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set enableErrorChecking(value:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><br/><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferHeight" id="maxBackBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferHeight</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferHeight:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Legt die maximale Höhe des Hintergrundpuffers fest. Der Anfangswert ist der Systemgrenzwert der Plattform. Für diese Eigenschaft kann ein Wert festgelegt werden, der kleiner oder gleich der Systemgrenze ist, er kann diese jedoch nicht überschreiten. Für diese Eigenschaft kann ein Wert festgelegt werden, der größer oder gleich dem unteren Grenzwert ist, er kann diesen jedoch nicht unterschreiten. Der untere Grenzwert ist der konstante Wert 32, wenn der Hintergrundpuffer nicht konfiguriert ist. Der untere Grenzwert ist der Wert des Parameters für die Höhe im letzten erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode, nachdem der Hintergrundpuffer konfiguriert wurde.
        
        </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferHeight():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferHeight(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferWidth" id="maxBackBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferWidth</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferWidth:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        Gibt die maximale Breite des Hintergrundpuffers an. Der Anfangswert ist der Systemgrenzwert der Plattform. Für diese Eigenschaft kann ein Wert festgelegt werden, der kleiner oder gleich der Systemgrenze ist, er kann diese jedoch nicht überschreiten. Für diese Eigenschaft kann ein Wert festgelegt werden, der größer oder gleich dem unteren Grenzwert ist, er kann diesen jedoch nicht unterschreiten. Der untere Grenzwert ist der konstante Wert 32, wenn der Hintergrundpuffer nicht konfiguriert ist. Der untere Grenzwert ist der Wert des Parameters für die Breite im letzten erfolgreichen Aufruf der <code>configureBackBuffer()</code>-Methode, nachdem der Hintergrundpuffer konfiguriert wurde.
		
        </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferWidth():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferWidth(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::12##AIR::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="profile" id="profile"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>profile</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>profile:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 12, AIR 4</td></tr></table><p></p><p></p><p>
		Das funktionsunterstützte Profil wird von diesem Context3D-Objekt verwendet.
		</p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get profile():<a href="../../String.html">String</a></code><br/><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DProfile.html" target="">Context3DProfile</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="propertyDetail" id="propertyDetail"></a><a name="supportsVideoTexture" id="supportsVideoTexture"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>supportsVideoTexture</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>supportsVideoTexture:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
          Gibt an, ob Context3D Videotextur unterstützt.
         
          </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public static function get supportsVideoTexture():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::21##AIR::21##"><a name="propertyDetail" id="propertyDetail"></a><a name="totalGPUMemory" id="totalGPUMemory"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>totalGPUMemory</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>totalGPUMemory:<a href="../../Number.html">Number</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 21, AIR 21</td></tr></table><p></p><p></p><p> 
         <p>Gibt den Gesamt-GPU-Speicher zurück, der von den Stage3D-Datenstrukturen einer Anwendung zugeordnet wurde.</p>
		 <p>Wenn ein GPU-Ressourcenobjekt erstellt wird, wird der verwendete Speicher in Context3D gespeichert. Dieser Arbeitsspeicher enthält Indexpuffer, Vertexpuffer, Texturen (ohne Videotextur) und Programme, die über dieses Context3D-Objekt erstellt wurden.</p>
		 <p>API <code> totalGPUMemory</code> gibt den Gesamtspeicher an den Benutzer zurück, der von den oben genannten Ressourcen verbraucht wurde. Der zurückgegebene Standardwert ist 0. Der zurückgegebene Gesamtspeicher ist in Bytes. Die Informationen werden nur auf dem Mobilgerät im direkten Modus und im direkten und GPU-Modus auf dem Desktop bereitgestellt. (Wenn auf dem Desktop <code>&lt;renderMode&gt;gpu&lt;/renderMode&gt;</code> fällt zurück auf <code>&lt;renderMode&gt;direct&lt;/renderMode&gt;</code> verwendet wird) </p>
		 
         Diese API kann verwendet werden, wenn die SWF-Version 32 oder höher ist.
         
         
         </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get totalGPUMemory():<a href="../../Number.html">Number</a></code><br/></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Methodendetails</div><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="clear()" id="clear()"></a><a name="clear(Number,Number,Number,Number,Number,uint,uint)" id="clear(Number,Number,Number,Number,Number,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clear</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td></tr></table><div class="detailBody"><code> public function clear(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Löscht die Farb-, Tiefen- und Schablonenbuffer, die diesem Context3D-Objekt zugeordnet sind, und füllt sie mit den angegebenen Werten.
         
         <p>Legen Sie den <code>mask</code>-Parameter fest, um die zu löschenden Buffer anzugeben. Verwenden Sie die in der Context3DClearMask-Klasse definierten Konstanten, um den <code>mask</code>-Parameter festzulegen. Verwenden Sie den bitweisen OR-Operator, „|“, um mehrere Puffer zur Maske hinzuzufügen (oder verwenden Sie <code>Context3DClearMask.ALL</code>). Beim Rendern in den Hintergrundpuffer muss die <code>configureBackBuffer()</code>-Methode vor allen Aufrufen von <code>clear()</code> aufgerufen werden.</p>
         
         <p><b>Hinweise:</b> Wenn Sie einen Parameterwert außerhalb des zulässigen Bereichs festlegen, werden numerische Parameterwerte ohne Meldung an den Bereich null bis eins gehängt. Wenn <code>stencil</code> größer als 0xff ist, wird es auf 0xff gesetzt. </p> 
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; die rote Komponente der Farbe, mit der der Farbbuffer gelöscht wird, im Bereich null bis eins.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; die grüne Komponente der Farbe, mit der der Farbbuffer gelöscht wird, im Bereich null bis eins.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; die blaue Komponente der Farbe, mit der der Farbbuffer gelöscht wird, im Bereich null bis eins.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; die Alpha-Komponente der Farbe, mit der der Farbbuffer gelöscht wird, im Bereich null bis eins. Die Alpha-Komponenten wird nicht zum Mischen verwendet. Sie wird direkt in den Puffer-Alpha geschrieben.        
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">depth</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; der Wert, mit dem der Tiefenbuffer gelöscht wird, im Bereich null bis eins.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stencil</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; der 8-Bit-Wert, mit dem der Schablonenbuffer gelöscht wird, in einem Bereich von 0x00 bis 0xff.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xffffffff</code>)<code></code> &mdash; gibt an, welche Buffer gelöscht werden sollen.
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DClearMask.html" target="">Context3DClearMask</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="configureBackBuffer()" id="configureBackBuffer()"></a><a name="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)" id="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>configureBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function configureBackBuffer(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt die Viewportabmessungen und andere Attribute des Renderpuffers fest.
         
         <p>Rendering wird doppelt gepuffert. Der Backbuffer wird mit dem sichtbaren Frontbuffer getauscht, wenn die <code>present()</code>-Methode aufgerufen wird. Die Mindestgröße des Puffers ist 32x32 Pixel. Die maximale Hintergrundpuffergröße wird von den Gerätefunktionen eingeschränkt und kann außerdem vom Benutzer über die Eigenschaften <code>maxBackBufferWidth</code> und <code>maxBackBufferHeight</code> festgelegt werden. Die Pufferkonfiguration ist ein langsamer Vorgang. Vermeiden Sie das Ändern der Puffergröße oder -attribute während normaler Renderingvorgänge.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Breite des Puffers in Pixel.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Höhe des Puffers in Pixel.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> &mdash; ein ganzzahliger Wert, der die angeforderte Anti-Alias-Qualität angibt. Der Wert korreliert mit der Anzahl der Subsamples, die beim Antialiasing verwendet werden. Bei Verwendung von mehr Subsamples müssen mehr Berechnungen ausgeführt werden, obwohl die relative Leistungsbeeinträchtigung von der jeweiligen Renderinghardware abhängig ist. Der Antialiasingtyp und ob Antialiasing überhaupt ausgeführt wird, ist vom Gerät und vom Rendermodus abhängig. Antialiasing wird vom Softwarerenderkontext nicht unterstützt.
         
         <table class="+ topic/table adobe-d/adobetable " ><tr><td>0</td><td>Kein Antialiasing</td></tr><tr><td>2</td><td>Minimales Antialiasing.</td></tr><tr><td>4</td><td>Antialiasing hoher Qualität.</td></tr><tr><td>16</td><td>Antialiasing sehr hoher Qualität.</td></tr></table>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; <code>false</code> zeigt an, dass kein Tiefen- oder Schablonenpuffer erstellt wird, mit <code>true</code> wird ein Tiefen- und Schablonenpuffer erstellt. Für AIR-Anwendungen mit AIR-Version 3.2 oder höher, die mit SWF-Version 15 oder höher kompiliert werden, und deren <code>renderMode</code>-Element in der Anwendungsdeskriptordatei den Wert<code>direct</code> hat, muss das <code>depthAndStencil</code>-Element in der Anwendungsdeskriptordatei denselben Wert wie dieses Argument haben. Standardmäßig hat das <code>depthAndStencil</code>-Element den Wert <code>false</code>.
		 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolution</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code> gibt an, dass, wenn das Gerät HiDPI-Bildschirme unterstützt, versucht wird, einen größeren Hintergrundpuffer zuzuordnen, als mit den width- und height-Parametern angegeben ist. Da hierbei mehr Pixel hinzugefügt werden und das Ergebnis der Shadervorgänge geändert werden kann, ist dies standardmäßig deaktiviert. Verwenden Sie Stage.contentsScaleFactor, um festzulegen, wie weit der native Hintergrundpuffer heraufskaliert wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolutionOnBrowserZoom</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code> gibt an, dass der Hintergrundpuffer proportional zum Browser-Zoomfaktor vergrößert werden soll. Die Einstellung dieses Werts ist für mehrere Browser-Zoomvorgänge persistent. Der Standardwert des Parameters ist <code>false</code>. Legen Sie die Eigenschaften <code>maxBackBufferWidth</code> und <code>maxBackBufferHeight</code> fest, um die Vergrößerung des Hintergrundpuffers zu beschränken. Verwenden Sie <code>backBufferWidth</code> und <code>backBufferHeight</code>, um die aktuelle Größe des Hintergrundpuffers zu bestimmen.
		 
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehlerhafte Eingabegröße: Der Breiten- oder Höhen-Parameter ist entweder kleiner als die zulässige minimale Hintergrundpuffergröße oder größer als die maximale Hintergrundpuffergröße.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3709: Das <code>depthAndStencil</code>-Flag im Anwendungsdeskriptor muss mit dem booleschen <code>enableDepthAndStencil</code>-Wert übereinstimmen, der an <code>configureBackBuffer()</code> im Context3D-Objekt übergeben wurde.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createCubeTexture()" id="createCubeTexture()"></a><a name="createCubeTexture(int,String,Boolean,int)" id="createCubeTexture(int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createCubeTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createCubeTexture(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Erstellt ein CubeTexture-Objekt.
         
         <p>Verwenden Sie ein CubeTexture-Objekt, um Würfeltexturbitmaps in den Renderkontext hochzuladen und während des Rendervorgangs auf eine Würfeltextur zu verweisen. Eine Würfeltextur besteht aus sechs quadratischen Texturen gleicher Größe, die würfelförmig angeordnet sind und beim Beschreiben von Umgebungsmaps hilfreich sind.</p>
           
         <p>Sie können CubeTexture-Objekte nicht mit einem CubeTexture-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein CubeTexture-Objekt erstellt haben, laden Sie die Texturbitmapdaten mit der CubeTexture-Methode <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> oder <code>uploadCompressedTextureFromByteArray()</code> hoch.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">size</span>:<a href="../../int.html">int</a></code> &mdash; Die Länge der Texturkante in Texel.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Das Texelformat der von Context3DTextureFormat aufgezählten Liste.
         <p> Mithilfe der Texturkomprimierung können Sie Texturbilder im komprimierten Format direkt auf der GPU speichern, wodurch GPU-Speicher und Speicherbrandbreite eingespart werden können. Normalerweise werden komprimierte Texturen offline komprimiert und auf die GPU in komprimierter Form mithilfe der Methode „Texture.uploadCompressedTextureFromByteArray“ hochgeladen. Flash Player 11.4 und AIR 3.4 auf Desktopplattformen unterstützen Laufzeittexturkomprimierung, was in bestimmten Situationen hilfreich sein kann, zum Beispiel, wenn dynamische Texturen von Vektorbildern dargestellt werden sollen. Beachten Sie, dass diese Funktion derzeit nicht auf mobilen Plattformen verfügbar ist und ein ArgumentError (Texturformatdiskrepanz) stattdessen ausgegeben wird. Führen Sie die folgenden Schritte aus, um die Texturkomprimierung zur Laufzeit zu verwenden. 1. Erstellen Sie das Texturobjekt, indem Sie die Methode „Context3D.createCubeTexture()“ aufrufen und dabei entweder „flash.display3D.Context3DTextureFormat.COMPRESSED“ oder „flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA“ als Formatparameter übergeben. 2. Mithilfe der Instanz „flash.display3D.textures.Texture“, die von „createCubeTexture()“ zurückgegeben wurde, rufen Sie entweder „flash.display3D.textures.CubeTexture.uploadFromBitmapData()“ oder „flash.display3D.textures.CubeTexture.uploadFromByteArray()“ auf, um die Textur mit einem Schritt hochzuladen und zu komprimieren.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Hat den Wert <code>true</code>, wenn die Textur wahrscheinlich als Renderziel verwendet wird.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Das MIP-Map-Level, das geladen sein muss, bevor das Bild gerendert wird. Texturstreaming bietet die Möglichkeit die kleinsten MIP-Level zuerst zu laden und anzuzeigen, wobei beim Laden der Testuren schrittweise Bilder mit besserer Qualität angezeigt werden. Endbenutzer können qualitativ schlechtere Bilder in einer Anwendung anzeigen, während die Bilder mit besserer Qualität geladen werden.
         <p>Der Standardwert für streamingLevels ist 0, was bedeutet, dass das Bild mit der höchsten Qualität in der MIP-Map geladen sein muss, bevor das Bild dargestellt wird. Dieser Parameter wurde für Flash Player 11.3 und AIR 3.3 hinzugefügt. Wenn Sie den Standardwert verwenden, wird das Verhalten früherer Versionen von Flash Player und AIR beibehalten. 
         </p>
         <p>Stellen Sie <code>streamingLevels</code> auf einen Wert zwischen 1 und der Anzahl der Bilder in der MIP-Map ein, um Texturstreaming zu ermöglichen. Beispiel: Sie haben eine MIP-Map, die ein Hauptbild mit der höchsten Qualität von 64x64 Pixel enthält. Bilder mit geringerer Qualität in der MIP-Map haben die Auflösung 32x32, 16x16, 8x8, 4x4, 2x2 und 1x1 Pixel für insgesamt 7 Bilder oder 7 Ebenen. Ebene 0 enthält das Bild mit der höchsten Qualität. Der Höchstwert für diese Eigenschaft ist log2(min(width,height)). Deshalb hat für ein Hauptbild mit der Auflösung 64x64 Pixel <code>streamingLevels</code> den Höchstwert 7. Stellen Sie diese Eigenschaft auf 3 ein, um das Bild zu rendern, nachdem das Bild mit der Auflösung 8x8 Pixel geladen wurde.</p>
         
         <p><b>Hinweis: </b>Das Einstellen dieser Eigenschaft auf einen Wert > 0 kann Speicherauslastung und Leistung beeinträchtigen. </p>
         
         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Texture-Objekte erstellt werden oder wenn der Speicher, der Texturen zugewiesen wurde, überschritten wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Tiefentextur nicht implementiert: wenn Sie versuchen, eine Tiefentextur zu erstellen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Texturgröße ist null: wenn der <code>size</code>-Parameter nicht größer als null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Textur keine Zweierpotenz: wenn der <code>size</code>-Parameter keine Zweierpotenz ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Textur zu groß: wenn der <code>size</code>-Parameter größer als 1024 ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur konnte nicht erstellt werden: wenn das CubeTexture-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine Informationen über den Grund verfügbar sind).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Ungültiges Streaming: wenn <code>streamingLevels</code> größer oder gleich log2(size) ist.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createIndexBuffer()" id="createIndexBuffer()"></a><a name="createIndexBuffer(int,String)" id="createIndexBuffer(int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createIndexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createIndexBuffer(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Erstellt ein IndexBuffer3D-Objekt.
         
         <p>Verwenden Sie ein IndexBuffer3D-Objekt, um einen Satz Dreieckindizes in den Renderkontext hochzuladen und für das Rendern auf diesen Indexsatz zu verweisen. Jeder Index im Indexpuffer verweist auf einen entsprechenden Vertex im Vertexpuffer. Jeder Satz aus drei Indizes stellt ein Dreieck dar. Übergeben Sie das IndexBuffer3D-Objekt an die <code>drawTriangles()</code>-Methode, um eines oder mehrere der im Indexpuffer definierten Dreiecke zu rendern.</p>
         
         <p>Sie können IndexBuffer3D-Objekte nicht mit dem IndexBuffer3D-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein IndexBuffer3D-Objekt erstellt haben, laden Sie die Indizes mithilfe der IndexBuffer3D-Methoden <code>uploadFromVector()</code> oder <code>uploadFromByteArray()</code> hoch.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numIndices</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl der Scheitelpunkte, die im Puffer gespeichert werden. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; die erwartete Pufferverwendung. Verwenden Sie eine der Konstanten, die in <code>Context3DBufferUsage</code> definiert ist. Der Hardwaretreiber kann die entsprechende Optimierung vornehmen, wenn Sie ihn richtig festlegen. Dieser Parameter ist nur nach Flash 12/AIR 4 verfügbar.
 
         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="IndexBuffer3D.html">IndexBuffer3D</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Indexpuffer erstellt werden oder wenn der Speicher, der Indexpuffern zugewiesen wurde, überschritten wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer zu groß: Wenn <code>numIndices</code> größer als oder gleich 0xf0000 ist. 
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createProgram()" id="createProgram()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createProgram():<a href="Program3D.html">Program3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Erstellt ein Program3D-Objekt.
         
         <p>Verwenden Sie ein Program3D-Objekt, um Shaderprogramme in den Renderkontext hochzuladen und während des Rendervorgangs auf die hochgeladenen Programme zu verweisen. Ein Program3D-Objekt speichert zwei Programme, ein Vertexprogramm und ein Fragmentprogramm (auch Pixelprogramm genannt). Die Programme werden in einer binären Shader-Aufbausprache geschrieben. </p>
         
         <p>Sie können Program3D-Objekte nicht mit dem Program3D-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein Program3D-Objekt erstellt haben, laden Sie die Programme mithilfe der Program3D-Methode <code>upload()</code> hoch.</p>
         
         </p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Program3D.html">Program3D</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Die Anzahl der Programme übersteigt 4096 oder die Gesamtspeichergröße übersteigt 16&nbsp;MB (verwenden Sie <code>dispose</code>, um Program3D-Ressourcen freizugeben).
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Program3D.html" target="">Program3D</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Dieses Beispiel veranschaulicht, wie ein Paar von Vertex- und Pixelprogrammen für einen Renderingkontext erstellt, hochgeladen und aktiviert wird. Beachten Sie, dass das Objekt, <code>renderContext</code>, eine Instanz der Context3D-Klasse ist. Die Programme in diesem Beispiel sind in Adobe Graphics Assembly Language (AGAL) geschrieben. 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.8##AIR::3.8##"><a name="createRectangleTexture()" id="createRectangleTexture()"></a><a name="createRectangleTexture(int,int,String,Boolean)" id="createRectangleTexture(int,int,String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createRectangleTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createRectangleTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.8, AIR 3.8</td></tr></table><p></p><p></p><p>
         Erstellt ein RectangleTexture-Objekt.
         
         <p>Verwenden Sie ein RectangleTexture-Objekt, um Texturbitmaps in den Renderkontext hochzuladen und während des Rendervorgangs auf eine Textur zu verweisen.</p>
         
         <p>Sie können RectangleTexture-Objekte nicht mit dem RectangleTexture-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein RectangleTexture-Objekt erstellt haben, laden Sie die Texturbitmaps mit der Texture-Methode <code>uploadFromBitmapData()</code> oder <code>uploadFromByteArray()</code> hoch.</p>
         
         <p>Beachten Sie, dass 32-Bit-Ganzzahltexturen in einem komprimierten BGRA-Format gespeichert werden, damit sie dem Flash-<code>BitmapData</code>-Format entsprechen. Gleitkommatexturen verwenden ein konventionelles RGBA-Format. </p>
         
         <p> Rechtecktexturen unterscheiden sich dadurch von regulären 2D-Texturen, dass die Breite und Höhe keine Zweierpotenzen sein müssen. Außerdem enthalten sie keine Mipmaps. Sie sind am hilfreichsten beim Rendern in Texturen. Wenn eine Rechtecktextur mit einem Sampler verwendet wird, der Mipmapfilterung oder Repeat-Wrapping verwendet, schlägt der Aufruf von drawTriangles fehl. Rechtecktexturen lassen auch kein Streaming zu. Die einzigen Texturformate, die von Rechtecktexturen unterstützt werden, sind BGRA, BGR_PACKED, BGRA PACKED. Die komprimierten Texturformate werden nicht von Rechtecktexturen unterstützt.
         </p>
                 
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Die Breite der Textur in Pixel.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Die Höhe der Textur in Pixel.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Das Texelformat der von Context3DTextureFormat aufgezählten Liste.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Hat den Wert <code>true</code>, wenn die Textur wahrscheinlich als Renderziel verwendet wird.                 
                                   
         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Texture-Objekte erstellt werden oder wenn der Speicher, der Texturen zugewiesen wurde, überschritten wird.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Texturgröße ist null: wenn weder der <code>width</code>- noch der <code>height</code>-Parameter größer als null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Textur zu groß: wenn entweder der <code>width</code>- oder der <code>height</code>-Parameter größer als 2048 ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur konnte nicht erstellt werden: wenn das Texture-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine Informationen über den Grund verfügbar sind).  
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Erfordert Baseline-Profil oder höher: Wenn rechteckige Textur mit eingeschränktem Baseline-Profil erstellt wird.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createTexture()" id="createTexture()"></a><a name="createTexture(int,int,String,Boolean,int)" id="createTexture(int,int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Erstellt ein Texture-Objekt.
         
         <p>Verwenden Sie ein Texture-Objekt, um Texturbitmaps in den Renderkontext hochzuladen und während des Rendervorgangs auf eine Textur zu verweisen.</p>
         
         <p>Sie können Texture-Objekte nicht mit einem Texture-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein Texture-Objekt erstellt haben, laden Sie die Texturbitmaps mit der Texture-Methode <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> oder <code>uploadCompressedTextureFromByteArray()</code> hoch.</p>
         
         <p>Beachten Sie, dass 32-Bit-Ganzzahltexturen in einem komprimierten BGRA-Format gespeichert werden, damit sie dem Flash-<code>BitmapData</code>-Format entsprechen. Gleitkommatexturen verwenden ein konventionelles RGBA-Format. </p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Die Breite der Textur in Pixel.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Die Höhe der Textur in Pixel.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Das Texelformat der von Context3DTextureFormat aufgezählten Liste.
         <p> Mithilfe der Texturkomprimierung können Sie Texturbilder im komprimierten Format direkt auf der GPU speichern, wodurch GPU-Speicher und Speicherbrandbreite eingespart werden können. Normalerweise werden komprimierte Texturen offline komprimiert und auf die GPU in komprimierter Form mithilfe der Methode „Texture.uploadCompressedTextureFromByteArray“ hochgeladen. Flash Player 11.4 und AIR 3.4 auf Desktopplattformen unterstützen Laufzeittexturkomprimierung, was in bestimmten Situationen hilfreich sein kann, zum Beispiel, wenn dynamische Texturen von Vektorbildern dargestellt werden sollen. Beachten Sie, dass diese Funktion derzeit nicht auf mobilen Plattformen verfügbar ist und ein ArgumentError (Texturformatdiskrepanz) stattdessen ausgegeben wird. Führen Sie die folgenden Schritte aus, um die Texturkomprimierung zur Laufzeit zu verwenden. 1. Erstellen Sie das Texturobjekt, indem Sie die Methode „Context3D.createTexture()“ aufrufen und dabei entweder „flash.display3D.Context3DTextureFormat.COMPRESSED“ oder „flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA“ als Formatparameter übergeben. 2. Mithilfe der Instanz „flash.display3D.textures.Texture“ die von „createTexture()“ zurückgegeben wurde, rufen Sie entweder „flash.display3D.textures.Texture.uploadFromBitmapData()“ oder „flash.display3D.textures.Texture.uploadFromByteArray()“ auf, um die Textur mit einem Schritt hochzuladen und zu komprimieren.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Hat den Wert <code>true</code>, wenn die Textur wahrscheinlich als Renderziel verwendet wird.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Das MIP-Map-Level, das geladen sein muss, bevor das Bild gerendert wird. Texturstreaming bietet die Möglichkeit die kleinsten MIP-Level zuerst zu laden und anzuzeigen, wobei beim Laden der Testuren schrittweise Bilder mit besserer Qualität angezeigt werden. Endbenutzer können qualitativ schlechtere Bilder in einer Anwendung anzeigen, während die Bilder mit besserer Qualität geladen werden.
         <p>Der Standardwert für streamingLevels ist 0, was bedeutet, dass das Bild mit der höchsten Qualität in der MIP-Map geladen sein muss, bevor das Bild dargestellt wird. Dieser Parameter wurde für Flash Player 11.3 und AIR 3.3 hinzugefügt. Wenn Sie den Standardwert verwenden, wird das Verhalten früherer Versionen von Flash Player und AIR beibehalten. 
         </p>
         <p>Stellen Sie <code>streamingLevels</code> auf einen Wert zwischen 1 und der Anzahl der Bilder in der MIP-Map ein, um Texturstreaming zu ermöglichen. Beispiel: Sie haben eine MIP-Map, die ein Hauptbild mit der höchsten Qualität von 64x64 Pixel enthält. Bilder mit geringerer Qualität in der MIP-Map haben die Auflösung 32x32, 16x16, 8x8, 4x4, 2x2 und 1x1 Pixel für insgesamt 7 Bilder oder 7 Ebenen. Ebene 0 enthält das Bild mit der höchsten Qualität. Der Höchstwert für diese Eigenschaft ist log2(min(width,height)). Deshalb hat für ein Hauptbild mit der Auflösung 64x64 Pixel <code>streamingLevels</code> den Höchstwert 7. Stellen Sie diese Eigenschaft auf 3 ein, um das Bild zu rendern, nachdem das Bild mit der Auflösung 8x8 Pixel geladen wurde.</p>
         
         <p><b>Hinweis: </b>Das Einstellen dieser Eigenschaft auf einen Wert > 0 kann Speicherauslastung und Leistung beeinträchtigen. </p>
         
         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/Texture.html">flash.display3D.textures:Texture</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Texture-Objekte erstellt werden oder wenn der Speicher, der Texturen zugewiesen wurde, überschritten wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Tiefentextur nicht implementiert: wenn Sie versuchen, eine Tiefentextur zu erstellen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Texturgröße ist null: wenn weder der <code>width</code>- noch der <code>height</code>-Parameter größer als null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Textur keine Zweierpotenz: wenn weder der <code>width</code>- noch der <code>height</code>-Parameter eine Zweierpotenz ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Textur zu groß: Wenn <code>width</code>- oder <code>height</code>-Parameter größer ist als 2048 für Baseline und eingeschränktes Baseline-Profil sind oder wenn entweder <code>width</code>- oder<code>height</code>-Parameter größer als 4096 und mehr für das erweiterte Baseline-Profil ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur konnte nicht erstellt werden: wenn das Texture-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine Informationen über den Grund verfügbar sind).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Ungültiges Streaming: wenn <code>streamingLevels</code> größer oder gleich log2(min(width,height)) ist.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createVertexBuffer()" id="createVertexBuffer()"></a><a name="createVertexBuffer(int,int,String)" id="createVertexBuffer(int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVertexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBuffer(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Erstellt ein VertexBuffer3D-Objekt.
         
         <p>Verwenden Sie ein VertexBuffer3D-Objekt, um einen Satz von Vertexdaten in den Renderkontext hochzuladen. Ein Vertexpuffer enthält die Daten, die zum Rendern der einzelnen Punkte in der Szenengeometrie erforderlich sind. Die Datenattribute, die den einzelnen Vertizes zugeordnet sind, umfassen normalerweise Koordinaten für Position, Farbe und Textur und dienen als Eingabe für das Vertexshaderprogramm. Identifizieren Sie die Datenwerte, die einer der Eingaben in das Vertexprogramm entsprechen, indem Sie die <code>setVertexBufferAt()</code>-Methode verwenden. Sie können für jeden Vertex bis zu 64 32-Bit-Werte angeben.</p>
         
         <p>Sie können VertexBuffer3D-Objekte nicht mit dem VertexBuffer3D-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein VertexBuffer3D-Objekt erstellt haben, laden Sie die Vertexdaten mithilfe der VertexBuffer3D-Methoden <code>uploadFromVector()</code> oder <code>uploadFromByteArray()</code> hoch.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl der Scheitelpunkte, die im Puffer gespeichert werden. Die maximale Anzahl von Scheitelpunkten in einem einzelnen Puffer ist 65535. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl von 32-Bit (4-Byte)-Datenwerten, die jedem Vertex zugeordnet sind. Die maximale Anzahl von 32-Bit-Datenelementen pro Vertex ist 64 (oder 256 Bytes). Beachten Sie, dass von einem Vertexshaderprogramm jeweils nur auf acht Attributregister zugegriffen werden kann. Verwenden Sie <code>SetVertextBufferAt()</code>, um Attribute aus einem Vertexpuffer heraus auszuwählen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; die erwartete Pufferverwendung. Verwenden Sie eine der Konstanten, die in <code>Context3DBufferUsage</code> definiert ist. Der Hardwaretreiber kann die entsprechende Optimierung vornehmen, wenn Sie ihn richtig festlegen. Dieser Parameter ist nur nach Flash 12/AIR 4 verfügbar.

         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Vertexpuffer erstellt werden oder wenn der Speicher, der Vertexpuffern zugeteilt wurde, überschritten wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer zu groß: wenn <code>numVertices</code> größer als 0x10000 oder <code>data32PerVertex</code> größer als 64 ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer hat Nullgröße: wenn <code>numVertices</code> oder <code>data32PerVertex</code> null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer konnte nicht erstellt werden: wenn das VertexBuffer3D-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine weiteren Informationen über den Grund verfügbar sind). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel veranschaulicht das Erstellen und Laden eines Vertexdatenpuffers. Der Puffer in diesem Beispiel enthält zwei Datentypen für jeden Vertex: die Position als Koordinaten x, y, z; und die Farbe als rgb-Komponenten. Nachdem der Vertexpuffer erstellt wurde, ruft der Beispielcode die <code>setVertexBufferAt()</code>-Methode auf, um festzulegen, dass die ersten drei Datenpunkte als 3 Gleitkommawerte in va0 und die zweiten drei Datenpunkte als va1 übergeben werden. Für ein Vertexprogramm können auf diese Weise bis zu 8 Eingaben, auch als Vertexattributregister bezeichnet, definiert werden.
<div class="listing"><pre>
const dataPerVertex:int = 6;
var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
    [
      // x, y, z    r, g, b format
         0, 0, 0,   1, 1, 1,
        -1, 1, 0,   0, 0,.5,
         1, 1, 0,   0, 0, 1,
         1,-1, 0,  .5, 0, 0,
        -1,-1, 0,   1, 0, 0
    ]
);
var vertexes:VertexBuffer3D = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
//Identify vertex data inputs for vertex program
renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va0 as the position data
renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va1 as the color data
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="createVertexBufferForInstances()" id="createVertexBufferForInstances()"></a><a name="createVertexBufferForInstances(int,int,int,String)" id="createVertexBufferForInstances(int,int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;createVertexBufferForInstances</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBufferForInstances(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         Erstellt ein VertexBuffer3D-Objekt für Instanzdaten.
         
         <p>Verwenden Sie ein VertexBuffer3D-Objekt, um einen Satz von Instanzdaten in den Renderkontext hochzuladen. Der Vertex-Puffer enthält die Daten, die zum Rendern der einzelnen Instanzen in der Szenengeometrie erforderlich sind. Vertex-Puffer mit Instanzdaten bieten Attribute, die alle Scheitelpunkte einer Instanz gemeinsam haben. und dienen als Eingabe für das Vertex-Shader-Programm. Identifizieren Sie die Datenwerte, die einer der Eingaben in das Vertexprogramm entsprechen, indem Sie die <code>setVertexBufferAt()</code>-Methode verwenden. Sie können für jeden Vertex-Puffer bis zu 64 32-Bit-Werte angeben.</p>
         
         <p>Sie können VertexBuffer3D-Objekte nicht mit dem VertexBuffer3D-Konstruktor erstellen; verwenden Sie stattdessen diese Methode. Nachdem Sie ein VertexBuffer3D-Objekt erstellt haben, laden Sie die Vertexdaten mithilfe der VertexBuffer3D-Methoden <code>uploadFromVector()</code> oder <code>uploadFromByteArray()</code> hoch.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl von Elementen, die im Puffer gespeichert werden. Die maximale Anzahl von Elementen in einem einzelnen Puffer ist 65535. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl von 32-Bit (4-Byte)-Datenwerten, die jedem Element zugeordnet sind. Die maximale Anzahl von 32-Bit-Datenelementen pro Vertex ist 64 (oder 256 Bytes).
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">instancesPerElement</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl der Instanzen, die ein Element des Vertex-Puffers verwendet.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; die erwartete Pufferverwendung. Verwenden Sie eine der Konstanten, die in <code>Context3DBufferUsage</code> definiert ist. Der Hardwaretreiber kann die entsprechende Optimierung vornehmen, wenn Sie ihn richtig festlegen. Dieser Parameter ist nur nach Flash 12/AIR 4 verfügbar.
         
         </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Vertexpuffer erstellt werden oder wenn der Speicher, der Vertexpuffern zugeteilt wurde, überschritten wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer zu groß: wenn <code>numVertices</code> größer als 0x10000 oder <code>data32PerVertex</code> größer als 64 ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer hat Nullgröße: wenn <code>numVertices</code> oder <code>data32PerVertex</code> null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Puffer konnte nicht erstellt werden: wenn das VertexBuffer3D-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine weiteren Informationen über den Grund verfügbar sind). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Erfordert erweitertes Standardprofile oder höher: Wenn diese Methode aufgerufen wird, wenn das angeforderte Profil kleiner als das erweiterte Standardprofil ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ungültige Instanzen pro Element: Wenn das instancesPerElement nicht größer als null ist.
         
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="createVideoTexture()" id="createVideoTexture()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVideoTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVideoTexture():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
         Erstellt ein VideoTexture-Objekt.
         
         <p>Verwenden Sie ein VideoTexture-Objekt, um Videobilder als Textur vom NetStream-Objekt oder Camera-Objekt zu erhalten und die Videobilder in den Renderkontext hochzuladen.</p>
         
         <p>Das VideoTexture-Objekt kann nicht mit dem VideoTexture-Konstruktor erstellt werden; verwenden Sie stattdessen diese Methode. Hängen Sie nach dem Erstellen eines VideoTexture-Objekts ein NetStream-Objekt oder Camera-Objekt an, um die Videobilder mit den VideoTexture-Methoden <code>attachNetStream()</code> oder <code>attachCamera()</code> abzurufen.</p>
         
         <p>Beachten Sie, dass diese Methode null zurückgibt, wenn das System diese Funktion nicht unterstützt. </p>
         
         <p> VideoTexture enthält keine Mipmaps. Wenn VideoTexture mit einem Sampler genutzt wird, der Mipmapfilterung oder Repeat-Wrapping verwendet, schlägt der Aufruf von drawTriangles fehl. VideoTexture kann von Shadern als BGRA-Textur behandelt werden. <b>Der Versuch, das VideoTexture-Objekt zu instanziieren, schlägt fehl, wenn Context3D mit dem softwarebasierten Rendermodus angefordert wurde.</b> 
         </p>
         
         <p> Pro Context3D-Instanz sind maximal 4 VideoTexture-Objekte verfügbar. Auf mobilen Geräten kann die tatsächliche Anzahl der unterstützten VideoTexture-Geräte aufgrund von Plattformbeschränkungen niedriger als 4 sein. </p>
                                   
         </p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code></td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ressourcenlimit überschritten: wenn zu viele Texture-Objekte erstellt werden oder wenn der Speicher, der Texturen zugewiesen wurde, überschritten wird.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur konnte nicht erstellt werden: wenn das Texture-Objekt nicht vom Renderingkontext erstellt werden konnte (aber keine Informationen über den Grund verfügbar sind).  
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="dispose()" id="dispose()"></a><a name="dispose(Boolean)" id="dispose(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Macht alle Ressourcen und internen Speicher frei, die/der mit diesem Context3D-Objekt verknüpft sind.
          
         <p>Alle Indexpuffer, Vertexpuffer, Texturen und Programme, die über dieses Context3D-Objekt erstellt wurden, werden entfernt, als ob Sie jeweils <code>dispose()</code> aufrufen. Zusätzlich wird das Context3D-Objekt selbst entfernt, wobei alle temporären Puffer sowie der Hintergrundpuffer freigegeben werden. Beim Aufruf von configureBackBuffer(), clear(), drawTriangles(), createCubeTexture(), createTexture(), createProgram(), createIndexBuffer(), createVertexBuffer() oder drawToBitmapData() nach dem Aufruf von dispose() wird eine Ausnahme ausgegeben.</p>                   
         
         <p><b>Warnung</b>: Bei einem Aufruf von dispose() für ein Context3D-Objekt, während es noch einen Ereignis-Listener für Events.CONTEXT3D_CREATE am zugeordneten Stage3D-Objekt gibt, simuliert der dispose()-Aufruf einen Geräteverlust. Damit wird ein neues Context3D-Objekt am Stage3D-Objekt erstellt und das Events.CONTEXT3D_CREATE-Ereignis erneut abgesetzt. Falls dies nicht erwünscht ist, entfernen Sie den Ereignis-Listener vom Stage3D-Objekt, bevor Sie dispose() aufrufen, oder setzen Sie den Parameter auf „false“.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">recreate</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code></td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso">Stage3D<br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a></div></div></span><span id="pageFilter" runtime="AIR::3##"><a name="drawToBitmapData()" id="drawToBitmapData()"></a><a name="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)" id="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawToBitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawToBitmapData(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 3</td></tr></table><p></p><p></p><p>
         Zeichnet den aktuellen Renderpuffer in eine Bitmap.
         
         <p>Der aktuelle Inhalt des Hintergrund-Renderpuffers wird in ein BitmapData-Objekt kopiert. Dies ist ein potenziell langsamer Vorgang, der bis zu eine Sekunde dauern kann. Gehen Sie mit Vorsicht vor. Beachten Sie, dass diese Funktion nicht den Frontpuffer (der auf der Bühne gezeigt wird) kopiert, sondern den Puffer, in den gezeichnet wird. Um das gerenderte Bild zu erfassen, wie es auf der Bühne erscheint, rufen Sie <code>drawToBitmapData()</code> direkt vor dem Aufruf von <code>present()</code> auf.</p>
         
		 
         <p>Ab AIR 25 sind zwei neue Parameter in der API <code>drawToBitmapData()</code> vorhanden. Diese API umfasst jetzt drei Parameter. Der erste ist der bereits vorhandene Parameter <code>destination:BitmapData</code>. Der zweite Parameter ist <code>srcRect:Rectangle</code>, ein Rechteck in Stage3D. Der dritte Parameter ist <code>destPoint:Point</code>, die Koordinate im Ziel-Bitmap. Die Parameter srcRect und destPoint sind optional und nehmen die Standardwerte (0,0,bitmapWidth,bitmapHeight) bzw. (0,0) an.</p>
         
         <p>Wenn das Bild gezeichnet wird, wird es nicht an die Größe der Bitmap angepasst. Die Inhalte werden stattdessen auf die Größe der Zielbitmap zugeschnitten.</p>
         
         <p>Flash-BitmapData-Objekte speichern Farben, die bereits von der Alphakomponente multipliziert wurden. Wenn zum Beispiel die reinen RGB-Farbkomponenten eines Pixels (0x0A, 0x12, 0xBB) sind und die Alphakomponente 0x7F (.5) ist, wird das Pixel mit den folgenden rgba-Werten im BitmapData-Objekt gespeichert: (0x05, 0x09, 0x5D, 0x7F). Sie können die Mischfaktoren so einstellen, dass die in den Puffer gerenderten Farben mit Alpha multipliziert werden, oder die Operation im Fragmentshader ausführen. Der Renderkontext überprüft nicht, ob die Farben im vorab multiplizierten Format gespeichert werden. </p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">destination</span>:<a href="../display/BitmapData.html">BitmapData</a></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">srcRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code></td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3802: Wenn einer der Parameter <code>destPoint:Point</code> bzw. <code>srcRect:Rectangle</code> außerhalb der Koordinatengrenze „bitmap/stage3D“ liegt oder wenn nicht-numerische Werte (NaN) als Eingabe weitergeleitet werden.
		 
         </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel werden zwei Dreiecke sowohl in den normalen Renderpuffer als auch in ein BitmapData-Objekt gerendert. Das BitmapData-Objekt wird angezeigt, indem ein Bitmap-Objekt der normalen Anzeigeliste hinzugefügt wird. Auf das Bitmaprendering wird ein Schlagschattenfilter angewendet. 
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.filters.DropShadowFilter;
    
    public class Context3D_drawToBitmapData extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var bitmap:Bitmap;
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawToBitmapData()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 0;
            stage3D.y = 0;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            var renderedBitmapData:BitmapData = new BitmapData( viewWidth, viewHeight, true );
            renderContext.drawToBitmapData( renderedBitmapData );
            
            renderContext.present();
            
            //Add to stage
            bitmap = new Bitmap( renderedBitmapData );
            this.addChild( bitmap );
            bitmap.x = 55;
            bitmap.y = 25;
            bitmap.filters = [new DropShadowFilter( 8, 235, .4 )];
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="drawTriangles()" id="drawTriangles()"></a><a name="drawTriangles(flash.display3D.IndexBuffer3D,int,int)" id="drawTriangles(flash.display3D.IndexBuffer3D,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawTriangles</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTriangles(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Rendert die angegebenen Dreiecke mit den aktuellen Puffern und dem Zustand dieses Context3D-Objekts.
         
         <p>Für jedes Dreieck werden die Dreieckvertices vom Vertex-Shader-Programm und die Dreieckoberfläche vom Pixel-Shader-Programm verarbeitet. Die Ausgabefarbe aus dem Pixelprogramm für die einzelnen Pixel wird in das Renderziel gezeichnet, abhängig von Schablonenoperationen, Tiefentest, Quell- und Ziel-Alpha sowie aktueller Füllmethode. Das Renderziel kann der Hauptrenderpuffer oder eine Textur sein.</p>
         
         <p>Wenn Culling aktiviert ist (mit der <code>setCulling()</code>-Methode), können Dreiecke aus der Szene entfernt werden, bevor das Pixelprogramm ausgeführt wird. Wenn Schablonen- und Tiefentests aktiviert sind, können die Ausgabepixel aus dem Pixelprogramm verworfen werden, ohne dass das Renderziel aktualisiert werden muss. Zusätzlich kann das Pixelprogramm festlegen, für ein Pixel keine Farbe auszugeben.</p>
         
         <p>Die gerenderten Dreiecke werden im Viewport nicht angezeigt, bis Sie die <code>present()</code>-Methode aufrufen. Nach jedem Aufruf von <code>present()</code> muss die <code>clear()</code>-Methode vor dem ersten Aufruf von <code>drawTriangles()</code> aufgerufen werden, andernfalls schlägt das Rendern fehl.</p>

         <p>Wenn <code>enableErrorChecking</code> den Wert <code>false</code> hat, gibt diese Funktion sofort Werte zurück, wartet nicht auf Ergebnisse und gibt Ausnahmen nur dann aus, wenn diese Context3D-Instanz verworfen wurde oder wenn es zu viele Zeichenaufrufe gibt. Wenn der Zustand des Renderingkontextes ungültig ist, schlägt das Rendering ohne weitere Meldung fehl. Wenn die <code>enableErrorChecking</code>-Eigenschaft den Wert <code>true</code> hat, gibt diese Funktion Werte zurück, nachdem die Dreiecke gezeichnet wurden, und gibt Ausnahmen für alle Zeichenfehler oder ungültige Kontextzustände zurück.</p> 
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; ein Satz von Scheitelpunktindizes, die auf die zu rendernden Scheitelpunkte verweisen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; der Index des ersten zum Rendern ausgewählten Scheitelpunktindex. Standardwert ist 0.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; die Anzahl der zu rendernden Dreiecke. Jedes Dreieck verbraucht drei Indizes. Übergeben Sie -1, um alle Dreiecke im Indexpuffer zu zeichnen. Standardwert ist -1.  
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Wenn diese Methode zu viele Male zwischen Aufrufen von <code>present()</code> aufgerufen wurde. Die maximale Anzahl von Aufrufen ist 32.768. 
         
         <p>Die folgenden Fehler werden nur dann ausgegeben, wenn die <code>enableErrorChecking</code>-Eigenschaft den Wert <code>true</code> hat:</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Vor dem Zeichnen Löschen erforderlich: Wenn der Puffer seit dem letzten Aufruf von <code>present()</code> nicht geleert wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Wenn kein gültiges Program3D-Objekt festgelegt wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Kein gültiger Indexpuffer festgelegt: Wenn kein IndexBuffer3D-Objekt festgelegt wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sanity Check für Parameter fehlgeschlagen: wenn die Anzahl der zu zeichnenden Dreiecke oder <code>firstIndex</code> die zulässigen Werte übersteigt.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Nicht genügend Indizes in diesem Puffer: wenn der Puffer nicht genug Indizes enthält, um die Anzahl der zu zeichnenden Dreiecke zu definieren.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet Textur, die auch an Renderer gebunden ist: wenn das Renderziel eine Textur ist und diese Textur einer Textureingabe des aktuellen Fragmentprogramm zugewiesen ist.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet ungültige Textur: Es wurde eine ungültige Textur als Eingabe für das aktuelle Fragmentprogramm eingegeben.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Samplerformat stimmt nicht mit Texturformat überein: wenn die als Eingabe für das aktuelle Fragmentprogramm zugewiesene Textur ein anderes Format hat als das dem Samplerregister zugewiesene. Beispiel: eine 2D-Textur wurde einem Würfeltextursampler zugewiesen.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet nicht definierte Textur: Das aktuelle Fragmentprogramm greift auf ein Texturregister zu, das nicht festgelegt wurde (mit <code>setTextureAt()</code>).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Dieselbe Textur benötigt dieselben Samplerparameter: Wenn eine Textur für mehrere Samplerregister verwendet wird, müssen alle Sampler dieselben Einstellungen verwenden. Sie können zum Beispiel nicht für einen Sampler die Fortführung der Randfarben („clamp“) und für den anderen die Kachelung („wrap“) verwenden.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur gebunden, aber nicht verwendet: Eine Textur ist als Shadereingabe festgelegt, wird jedoch nicht verwendet.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream wird nicht verwendet: Ein Vertexpuffer ist einer Vertexattributeingabe zugewiesen, das Vertexprogramm verweist jedoch nicht auf das entsprechende Register.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream ist ungültig: Ein VertexBuffer3D-Objekt, das einer Vertexprogrammeingabe zugewiesen ist, ist kein gültiges Objekt.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Stream hat nicht genügend Vertizes: Ein Vertexpuffer, der Daten für die angegebenen Dreiecke bereitstellt, hat nicht genügend Daten.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Streamvertexoffset außerhalb des gültigen Bereichs: Der in einem Aufruf von <code>setVertexBufferAt()</code> angegebene Offset ist negativ oder nach dem Ende des Puffers.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream gelesen, aber nicht festgelegt: Ein Vertexattribut, das vom aktuellen Vertexprogramm gelesen wird, wurde nicht festgelegt (mit <code>setVertexBufferAt()</code>).
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Die folgende Klasse zeichnet zwei Dreiecke in einen Stage3D-Viewport auf der Bühne. Die Dreiecke haben einen gemeinsamen Vertex, der sich am Ursprung (0,0,0) befindet.
 
 <p>Die Dreiecke werden mithilfe des Vertexbuffers und des Indexbuffers definiert. Der Vertexbuffer enthält die Informationen zu Position und Farbe für jeden Vertex des Dreiecks. Der Indexbuffer enthält Indizes für den Vertexbuffer. Drei Indizes definieren ein Dreieck. Zum Beispiel wird ein Dreieck, das aus den ersten drei Punkten im Vertexbuffer besteht, im Indexbuffer als 0,1,2 aufgeführt.</p>
 
 <p>In diesem einfachen Beispiel wird keine 3D-Transformation ausgeführt. Es können nur Objekte innerhalb des kanonischen Anzeigebereichs (mit dem Volumen 2x2x1) angezeigt werden und die Koordinaten der Dreiecke müssen innerhalb dieses Bereichs definiert werden. Beim Rendern einer typischen 3D-Szene projizieren Sie die Objekte jedoch für das Rendering aus dem Weltkoordinatensystem in diesen Ansichtsbereich, indem Sie entweder eine perspektivische oder orthografische Projektion verwenden.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_drawTriangles extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawTriangles()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="drawTrianglesInstanced()" id="drawTrianglesInstanced()"></a><a name="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)" id="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawTrianglesInstanced</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTrianglesInstanced(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         Rendert die angegebenen Dreiecke mit den aktuellen Puffern und dem Zustand dieses Context3D-Objekts.
         
         <p>Für jedes Dreieck jeder Instanz werden die Dreieckscheitelpunkte vom Vertex-Shader-Programm und die Dreiecksoberfläche vom Pixel-Shader-Programm verarbeitet. Die Ausgabefarbe aus dem Pixelprogramm für die einzelnen Pixel wird in das Renderziel gezeichnet, abhängig von Schablonenoperationen, Tiefentest, Quell- und Ziel-Alpha sowie aktueller Füllmethode. Das Renderziel kann der Hauptrenderpuffer oder eine Textur sein.</p>
         
         <p>Wenn Culling aktiviert ist (mit der <code>setCulling()</code>-Methode), können Dreiecke aus der Szene entfernt werden, bevor das Pixelprogramm ausgeführt wird. Wenn Schablonen- und Tiefentests aktiviert sind, können die Ausgabepixel aus dem Pixelprogramm verworfen werden, ohne dass das Renderziel aktualisiert werden muss. Zusätzlich kann das Pixelprogramm festlegen, für ein Pixel keine Farbe auszugeben.</p>
         
         <p>Die gerenderten Instanzdreiecke werden im Viewport nicht angezeigt, bis Sie die <code>present()</code>-Methode aufrufen. Nach jedem Aufruf von <code>present()</code>, muss die <code>clear()</code>-Methode vor dem ersten Aufruf von <code>drawTrianglesInstanced()</code> aufgerufen werden, andernfalls schlägt das Rendern fehl.</p>

         <p>Wenn <code>enableErrorChecking</code> den Wert <code>false</code> hat, gibt diese Funktion sofort Werte zurück, wartet nicht auf Ergebnisse und gibt Ausnahmen nur dann aus, wenn diese Context3D-Instanz verworfen wurde oder wenn es zu viele Zeichenaufrufe gibt. Wenn der Zustand des Renderingkontextes ungültig ist, schlägt das Rendering ohne weitere Meldung fehl. Wenn die <code>enableErrorChecking</code>-Eigenschaft den Wert <code>true</code> hat, gibt diese Funktion Werte zurück, nachdem die Dreiecke gezeichnet wurden, und gibt Ausnahmen für alle Zeichenfehler oder ungültige Kontextzustände zurück.</p>
		 
		 <p>Diese Methode gibt eine Ausnahme aus, wenn der Instanz-Puffer inkorrekt mit <code>SetVertexAt()</code> sequenziert ist. Mit Direct 3D 9 müssen z. B. die indizierten Geometriedaten und die Anzahl der zu zeichnenden Instanzen immer in Stream null mit der API <code>SetStreamSourceFreq()</code> eingerichtet sein.</p>
		 
		 <p>Dies bedeutet, dass der mit <code>CreateVertexBufferForInstance()</code> erstellte Vertex-Puffer nicht mit der Mindest-Indexnummer platziert werden darf, wenn er mit <code>SetVertexBufferAt()</code> als Eingabe für das Vertex-Shader-Programm angeordnet ist. Der mit <code>CreateVertexBuffer()</code> erstellte Vertex-Puffer muss mit einer niedrigeren Indexnummer als jener von <code>CreateVertexBufferForInstance()</code> platziert werden. Im Allgemeinen müssen die Geometriedaten mit <code>SetVertexBufferAt()</code> vor Instanzdaten platziert werden.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; ein Satz von Scheitelpunktindizes, die auf die zu rendernden Scheitelpunkte verweisen.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numInstances</span>:<a href="../../int.html">int</a></code> &mdash; Anzahl von zu rendernden Instanzen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; der Index des ersten zum Rendern ausgewählten Scheitelpunktindex. Standardwert ist 0.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; die Anzahl der zu rendernden Dreiecke. Jedes Dreieck verbraucht drei Indizes. Übergeben Sie -1, um alle Dreiecke im Indexpuffer zu zeichnen. Standardwert ist -1.  
		 
		 </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Wenn diese Methode zu viele Male zwischen Aufrufen von <code>present()</code> aufgerufen wurde. Die maximale Anzahl von Aufrufen ist 32.768. 
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Erfordert erweitertes Standardprofile oder höher: Wenn diese Methode aufgerufen wird, wenn das angeforderte Profil kleiner als das erweiterte Standardprofil ist.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Wenn diese Methode mit negativen numInstances aufgerufen wird.
         
         <p>Die folgenden Fehler werden nur dann ausgegeben, wenn die <code>enableErrorChecking</code>-Eigenschaft den Wert <code>true</code> hat:</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Vor dem Zeichnen Löschen erforderlich: Wenn der Puffer seit dem letzten Aufruf von <code>present()</code> nicht geleert wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Wenn kein gültiges Program3D-Objekt festgelegt wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Kein gültiger Indexpuffer festgelegt: Wenn kein IndexBuffer3D-Objekt festgelegt wurde.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sanity Check für Parameter fehlgeschlagen: wenn die Anzahl der zu zeichnenden Dreiecke oder <code>firstIndex</code> die zulässigen Werte übersteigt.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Nicht genügend Indizes in diesem Puffer: wenn der Puffer nicht genug Indizes enthält, um die Anzahl der zu zeichnenden Dreiecke zu definieren.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet Textur, die auch an Renderer gebunden ist: wenn das Renderziel eine Textur ist und diese Textur einer Textureingabe des aktuellen Fragmentprogramm zugewiesen ist.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet ungültige Textur: Es wurde eine ungültige Textur als Eingabe für das aktuelle Fragmentprogramm eingegeben.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Samplerformat stimmt nicht mit Texturformat überein: wenn die als Eingabe für das aktuelle Fragmentprogramm zugewiesene Textur ein anderes Format hat als das dem Samplerregister zugewiesene. Beispiel: eine 2D-Textur wurde einem Würfeltextursampler zugewiesen.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sample bindet nicht definierte Textur: Das aktuelle Fragmentprogramm greift auf ein Texturregister zu, das nicht festgelegt wurde (mit <code>setTextureAt()</code>).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Dieselbe Textur benötigt dieselben Samplerparameter: Wenn eine Textur für mehrere Samplerregister verwendet wird, müssen alle Sampler dieselben Einstellungen verwenden. Sie können zum Beispiel nicht für einen Sampler die Fortführung der Randfarben („clamp“) und für den anderen die Kachelung („wrap“) verwenden.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Textur gebunden, aber nicht verwendet: Eine Textur ist als Shadereingabe festgelegt, wird jedoch nicht verwendet.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream wird nicht verwendet: Ein Vertexpuffer ist einer Vertexattributeingabe zugewiesen, das Vertexprogramm verweist jedoch nicht auf das entsprechende Register.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream ist ungültig: Ein VertexBuffer3D-Objekt, das einer Vertexprogrammeingabe zugewiesen ist, ist kein gültiges Objekt.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Stream hat nicht genügend Vertizes: Ein Vertexpuffer, der Daten für die angegebenen Dreiecke bereitstellt, hat nicht genügend Daten.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Streamvertexoffset außerhalb des gültigen Bereichs: Der in einem Aufruf von <code>setVertexBufferAt()</code> angegebene Offset ist negativ oder nach dem Ende des Puffers.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Stream gelesen, aber nicht festgelegt: Ein Vertexattribut, das vom aktuellen Vertexprogramm gelesen wird, wurde nicht festgelegt (mit <code>setVertexBufferAt()</code>).
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Vertex-Puffer-Stream enthält nicht genügend Elemente für Instanzen: Wenn ein Vertex-Puffer-Stream nicht genug Elemente für die Anzahl der Instanzen enthält.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Vertex-Puffer-Stream für Instanzen ist unzureichend mit dem Mindestindex-Attributregister eingerichtet: Wenn der mit <code>CreateVertexBuffer()</code> erstellte Vertex-Puffer eine höhere Indexnummer erhält als der mit <code>CreateVertexBufferForInstance()</code> erstellte Vertex-Puffer.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Die folgende Klasse zeichnet drei Dreiecke mit der instanzierten Zeichnung der Funktion mithilfe eines einzelnen Zeichnenaufrufs anstelle mehrerer Zeichenaufrufe.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstancedDrawing extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstancedDrawing()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //The vertex shader code runs for every vertex of each instance.
            //The vertex buffers uploaded for instance data (va1,va2) are used when the vertex shader for that particular instance is being executed.
            code += "add vt0, va0, va2\n";
            code += "mov op, vt0\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span><span id="pageFilter"><br/><div class="detailBody"> Die folgende Klasse zeichnet drei Dreiecke mit der instanzierten Zeichnung der Funktion mithilfe eines einzelnen Zeichnenaufrufs anstelle mehrerer Zeichenaufrufe.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstanceIdRegister extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstanceIdRegister()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            //Note : for instance id support , use the latest AgalMiniAssembler from github - https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/v3/AGALMiniAssembler.as
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //the vertex shader code will run for every vertex of every instance , 
            //the vertex buffers uploaded for instance data (va1,va2) will be used when vertex shader for that particular instance is being executed 
            //the vertex shader code below indexes the program constants matrix using iid.x. iid is a new register introduced in vertex shader for instanced drawing
            //it is a read only register , iid.x gives the current instance id whose shader is being executed
            code += "add vt0, va0, va2\n";
            code += "mul vt1, vt0, vc[iid.x]\n"
            code += "mov op, vt1\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code, 3);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code, 3);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            var instanceScalingData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 1.0, 1.0, 1.0,     // - 1st instance x,y,z,w
                1.4, 1.4, 1.4, 1.0,        // - 2nd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0,        // - 3rd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0
            ]);
            var m:Matrix3D = new Matrix3D();
            m.copyRawDataFrom(instanceScalingData);
            renderContext.setProgramConstantsFromMatrix("vertex",0,m,false);
            
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="present()" id="present()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>present</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function present():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Zeigt den Hintergrund-Renderpuffer an. 
         
         <p>Der Aufruf der <code>present()</code>-Methode macht die Ergebnisse aller Rendervorgänge seit dem letzten Aufruf von <code>present()</code> sichtbar und startet einen neuen Renderzyklus. Nachdem Sie <code>present</code> aufgerufen haben, müssen Sie <code>clear()</code> aufrufen, bevor Sie einen weiteren Aufruf von <code>drawTriangles()</code> ausführen. Andernfalls leert diese Funktion den Renderpuffer abwechselnd zu gelb und grün, oder, falls <code>enableErrorChecking</code> den Wert <code>true</code> hat, es wird eine Ausnahme ausgelöst.</p>
         
         <p>Mit dem Aufruf von <code>present()</code> wird auch das Renderziel zurückgesetzt, genau wie beim Aufruf von <code>setRenderToBackBuffer()</code>. </p>  
         
         </p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Vor dem Zeichnen Löschen erforderlich: Wenn <code>clear()</code> seit dem vorherigen Aufruf von <code>present()</code> nicht aufgerufen wurde. (Zwei aufeinander folgende Aufrufe von <code>present()</code> sind nicht zulässig, ohne dazwischen <code>clear()</code> aufzurufen.)
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: Das<code>Stage3D</code> -API darf nicht bei der Ausführung im Hintergrund verwendet werden.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setBlendFactors()" id="setBlendFactors()"></a><a name="setBlendFactors(String,String)" id="setBlendFactors(String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setBlendFactors</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setBlendFactors(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt die Faktoren fest, die zum Mischen der Ausgabefarbe eines Zeichenvorgangs mit der vorhandenen Farbe verwendet werden.
         
         <p>Die Ausgabefarbe (Ausgangsfarbe) des Pixel-Shader-Programms wird mit der vorhandenen Farbe (Zielfarbe) an diesem Pixel gemäß der folgenden Formel kombiniert:</p> 
         <p><code>Ergebnisfarbe = (Ausgangsfarbe * sourceFactor) + (Zielfarbe * destinationFactor)</code></p>
         <p>Die Zielfarbe ist die derzeit im Renderbuffer vorhandene Farbe für dieses Pixel. Somit ist sie das Ergebnis des letzten Aufrufs von <code>clear()</code> und der Aufrufe von <code>drawTriangles()</code>. </p>
          
         <p>Verwenden Sie <code>setBlendFactors()</code>, um die Faktoren festzulegen, mit denen die Ausgangs- und Zielfarbe vor dem Addieren multipliziert werden. Die Standardmischfaktoren sind <code>sourceFactor = Context3DBlendFactor.ONE</code> und <code>destinationFactor = Context3DBlendFactor.ZERO</code>, was dazu führt, dass die Ausgangsfarbe die Zielfarbe überschreibt (anders ausgedrückt findet kein Mischen der beiden Farben statt). Verwenden Sie für das normale Alpha-Mischen <code>sourceFactor = Context3DBlendFactor.SOURCE_ALPHA</code> und <code>destinationFactor = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA</code>. 
         </p>
         
         <p>Legen Sie die Parameter dieser Funktion mithilfe der Konstanten fest, die in der Context3DBlendFactor-Klasse definiert sind.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceFactor</span>:<a href="../../String.html">String</a></code> &mdash; Der Faktor, mit dem die Ausgangsfarbe multipliziert wird. Die Standardvorgabe ist <code>Context3DBlendFactor.ONE</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destinationFactor</span>:<a href="../../String.html">String</a></code> &mdash; Der Faktor, mit dem die Zielfarbe multipliziert wird. Die Standardvorgabe ist <code>Context3DBlendFactor.ZERO</code>.
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ungültige Aufzählung: wenn <code>sourceFactor</code> oder <code>destinationFactor</code> keiner der anerkannten Werte ist, die in der Context3DBlendFactor-Klasse definiert sind.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Die folgende Klasse veranschaulicht die verschiedenen Mischfaktoren. Das Beispiel zeichnet vier unterschiedlich gefärbte Rechtecke in den Renderpuffer. Diese Gruppe von Rechtecken ist das Misch-„Ziel“. Als Nächstes werden die Quell- und Zielmischmodi festgelegt und ein größeres Rechteck, die Misch-„Quelle“, wird gezeichnet. Verwenden Sie die Tasten „1“ und „2“, um durch die Quellmischmodi zu schalten. Verwenden Sie die Tasten „3“ und „4“, um durch die Zielmischmodi zu schalten.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.ui.Keyboard;
    
    public class Context3D_setBlendMode extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var sourceFactor:int = 6;
        private var destinationFactor:int = 4;
        private var blendFactors:Array = [Context3DBlendFactor.DESTINATION_ALPHA,
                                          Context3DBlendFactor.DESTINATION_COLOR,
                                          Context3DBlendFactor.ONE,
                                          Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR,
                                          Context3DBlendFactor.SOURCE_ALPHA,
                                          Context3DBlendFactor.SOURCE_COLOR,
                                          Context3DBlendFactor.ZERO];
            
        public function Context3D_setBlendMode()
        {
            this.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyHandler );
            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3,
                                                            6, 4, 5,
                                                            5, 7, 6,
                                                            10, 8, 9,
                                                            9, 11, 10,
                                                            12, 15, 14,
                                                            12, 13, 15,
                                                            16, 17, 19,
                                                            16, 19, 18
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 7;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format
                    -1, 1, 0,   1, 1, 1, .5,
                     0, 1, 0,   1, 1, 1, .5,
                    -1, 0, 0,   1, 1, 1, .5,
                     0, 0, 0,   1, 1, 1, .5,
                     
                     0, 1, 0,  .8,.8,.8, .6,
                     1, 1, 0,  .8,.8,.8, .6,
                     0, 0, 0,  .8,.8,.8, .6,
                     1, 0, 0,  .8,.8,.8, .6,
                     
                    -1, 0, 0,   1, 0, 0, .5,
                     0, 0, 0,   0, 1, 0, .5,
                    -1,-1, 0,   0, 0, 1, .5,
                     0,-1, 0,   1, 0, 1, .5,
                     
                     0, 0, 0,   0, 0, 0, .5,
                     1, 0, 0,   0, 0, 0, .5,
                     0,-1, 0,   0, 0, 0, .5,
                     1,-1, 0,   0, 0, 0, .5,
                     
                   -.8,.8, 0,  .6,.4,.2,.4,
                    .8,.8, 0,  .6,.4,.2,.4,
                  -.8,-.8, 0,  .6,.4,.2,.4,
                   .8,-.8, 0,  .6,.4,.2,.4
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_4 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear( 1, 1, 1, 1 );
            //Draw the back triangles
            renderContext.setBlendFactors( Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO ); //No blending
            renderContext.drawTriangles( indexList, 0, 8 );

            //Set blend
            renderContext.setBlendFactors( blendFactors[sourceFactor], blendFactors[destinationFactor] );
            
            //Draw the front triangles
            renderContext.drawTriangles( indexList, 24, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
        
        private function keyHandler( event:KeyboardEvent ):void
        {
            switch ( event.keyCode )
            {
                case Keyboard.NUMBER_1:
                    if( --sourceFactor &lt; 0 ) sourceFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_2:
                    if( ++sourceFactor &gt; blendFactors.length - 1) sourceFactor = 0;
                    break;
                case Keyboard.NUMBER_3:
                    if( --destinationFactor &lt; 0 ) destinationFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_4:
                    if( ++destinationFactor &gt; blendFactors.length - 1) destinationFactor = 0;
                    break;
            }
            trace( "Source blend factor: " + blendFactors[sourceFactor] + ", destination blend factor: " + blendFactors[destinationFactor] );
            render();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setColorMask()" id="setColorMask()"></a><a name="setColorMask(Boolean,Boolean,Boolean,Boolean)" id="setColorMask(Boolean,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setColorMask</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setColorMask(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt die Maske fest, die beim Schreiben der Farben in den Renderbuffer verwendet wird.
         
         <p>Nur Farbkomponenten, für die der entsprechende Parameter der Farbmaske auf <code>true</code> gesetzt ist, werden aktualisiert, wenn eine Farbe in den Renderbuffer geschrieben wird. Wenn Sie zum Beispiel <code>setColorMask( true, false, false, false )</code> aufrufen, wird nur die rote Komponente einer Farbe in den Puffer geschrieben, bis Sie die Farbmaske wieder ändern. Die Farbmaske wirkt sich nicht auf das Verhalten der <code>clear()</code>-Methode aus.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; mit <code>false</code> werden Änderungen am roten Kanal blockiert.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; mit <code>false</code> werden Änderungen am grünen Kanal blockiert.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; mit <code>false</code> werden Änderungen am blauen Kanal blockiert.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; mit <code>false</code> werden Änderungen am Alpha-Kanal blockiert.
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird der Effekt des Festlegens der Farbmaske veranschaulicht. Der Beispielcode zeichnet zwei Dreiecke von derselben Farbe. Das obere Dreieck wird vor dem Festlegen der Maske gezeichnet und wird deshalb weiß gerendert. Das untere Dreieck wird gezeichnet, nachdem alle Kanäle mit Ausnahme des roten maskiert wurden. Da nur der rote Kanal aktualisiert werden kann, wird das weiße Dreieck rot gerendert.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_setColorMask extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_setColorMask()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   1, 1, 1,
                     1, 1, 0,   1, 1, 1,
                     1,-1, 0,   1, 1, 1,
                    -1,-1, 0,   1, 1, 1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            renderContext.clear( .3,.3,.3,1 );
            renderContext.drawTriangles( indexList, 0, 1 ); //Top triangle draws all colors, so is white
            renderContext.setColorMask( true, false, false, false ); //Mask all but red channel            
            renderContext.drawTriangles( indexList, 3, 1 ); //Bottom triangle only updates red
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setCulling()" id="setCulling()"></a><a name="setCulling(String)" id="setCulling(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setCulling</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setCulling(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt den Dreieckcullingmodus fest.
         
         <p>Dreiecke können basierend auf ihrer Ausrichtung relativ zur Sichtebene früh in der Renderingpipeline von der Szene ausgeschlossen werden. Gibt die Vertexreihenfolge konsistent an (im Uhrzeigersinn oder gegen den Uhrzeigersinn) wie von außerhalb des Modells aus gesehen, um ein korrektes Culling auszuführen.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFaceToCull</span>:<a href="../../String.html">String</a></code> &mdash; der Cullingmodus. Verwenden Sie eine der Konstanten, die in der Context3DTriangleFace-Klasse definiert sind.
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehler wegen ungültiger Aufzählung: wenn <code>triangleFaceToCull</code> nicht einer der in der Context3DTriangleFace-Klasse definierten Werte ist.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setDepthTest()" id="setDepthTest()"></a><a name="setDepthTest(Boolean,String)" id="setDepthTest(Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setDepthTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setDepthTest(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt den Vergleichstyp fest, der für Tiefentests verwendet wird.
         
         <p>Die Tiefe der Ausgangspixelausgabe vom Pixel-Shader-Programm wird mit dem aktuellen Wert im Tiefenpuffer verglichen. Wenn der Vergleich <code>false</code> ergibt, wird das Ausgangspixel verworfen. Bei dem Wert <code>true</code> wird das Ausgangspixel vom nächsten Schritt in der Renderingpipeline, dem Schablonentest, verarbeitet. Außerdem wird der Tiefenpuffer mit der Tiefe des Ausgangspixels aktualisiert, solange der Parameter <code>depthMask</code> den Wert <code>true</code> hat.</p>
         
         <p>Legt den Test fest, der zum Vergleich der Tiefenwerte für Quell- und Zielpixel verwendet wird. Das Quellpixel wird mit dem Zielpixel zusammengesetzt, wenn „comparison“ den Wert „true“ hat. Der Vergleichsoperator wird als Infix-Operator zwischen den Quell- und Zielpixelwerten verwendet, in dieser Reihenfolge.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">depthMask</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; bei der Einstellung „true“ wird der Zieltiefenwert aus dem Quellpixel aktualisiert.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">passCompareMode</span>:<a href="../../String.html">String</a></code> &mdash; der Tiefenvergleichstestvorgang. Einer der Werte von Context3DCompareMode.
         
         </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a></div></div></span><span id="pageFilter" runtime="AIR::16##"><a name="setFillMode()" id="setFillMode()"></a><a name="setFillMode(String)" id="setFillMode(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="Nur verfügbar in der AIR-Laufzeitumgebung">&nbsp;&nbsp;&nbsp;</span>&nbsp;setFillMode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setFillMode(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>AIR 16</td></tr></table><p></p><p></p><p> 
		Füllmodus für das Rendern festlegen. Die Benutzeroberfläche ist nur in AIR-Desktop verfügbar.
		
		</p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">fillMode</span>:<a href="../../String.html">String</a></code> &mdash; wenn der Wert WIREFRAME ist, wird das Objekt in einem Gitter von Linien angezeigt. wenn der Wert SOLID ist, wird das Objekt in fest schattierten Polygonen angezeigt.
		
		</td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DFillMode.html" target="">Context3DFillMode</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgram()" id="setProgram()"></a><a name="setProgram(flash.display3D.Program3D)" id="setProgram(flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgram(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt Vertex- und Fragmentshaderprogramme fest, die für das nachfolgende Rendern verwendet werden.
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">program</span>:<a href="Program3D.html">Program3D</a></code> &mdash; das Program3D-Objekt, das die zu verwendenden Vertex- und Fragmentprogramme darstellt. 
         
         </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Dieses Beispiel veranschaulicht, wie ein Paar von Vertex- und Pixelprogrammen für einen Renderingkontext erstellt, hochgeladen und aktiviert wird. Beachten Sie, dass das Objekt, <code>renderContext</code>, eine Instanz der Context3D-Klasse ist. Die Programme in diesem Beispiel sind in Adobe Graphics Assembly Language (AGAL) geschrieben. 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.1##AIR::3.1##"><a name="setProgramConstantsFromByteArray()" id="setProgramConstantsFromByteArray()"></a><a name="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)" id="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromByteArray(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.1, AIR 3.1</td></tr></table><p></p><p></p><p>
         Legt Konstanten für die Verwendung durch Shader-Programme fest, indem in einem <code>ByteArray</code>-Objekt gespeicherte Werte verwendet werden. 
         
         <p>Legt Konstanten fest, auf die das Vertex- oder Fragmentprogramm zugreifen kann.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; einer der Werte von Context3DProgramType.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; der Index der ersten festzulegenden Shader-Programmkonstante.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> &mdash; die Anzahl der festzulegenden Register. Jedes Register wird als vier Gleitkommawerte gelesen. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; das ByteArray-Quellobjekt
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArrayOffset</span>:<a href="../../uint.html">uint</a></code> &mdash; ein Offset für das Lesen im ByteArray
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; kNullPointerError, wenn <code>data</code> null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; kConstantRegisterOutOfBounds, wenn versucht wird, mehr als die maximal zulässige Anzahl von Shader-Konstanten festzulegen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; kBadInputSize, wenn <code>byteArrayOffset</code> größer oder gleich der Länge von <code> data</code> ist. von Elementen in <code>data</code> - <code> byteArrayOffset</code> kleiner als <code>numRegisters</code> * 16
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromMatrix()" id="setProgramConstantsFromMatrix()"></a><a name="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)" id="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromMatrix</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromMatrix(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt Konstanten für die Verwendung durch Shader-Programme fest, indem in einem <code>Matrix3D</code>-Objekt gespeicherte Werte verwendet werden. 
         
         <p>Verwenden Sie diese Funktion, um eine Matrix an ein Shaderprogramm zu übergeben. Die Funktion legt vier Konstantenregister fest, die vom Vertex- oder Fragmentprogramm verwendet. Die Matrix wird Zeile für Zeile Registern zugewiesen. Das erste Konstantenregister ist der obersten Zeile der Matrix zugewiesen. Sie können 128 Register für ein Vertexprogramm und 28 für ein Fragmentprogramm festlegen.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; Der Typ des Shaderprogramms, entweder <code>Context3DProgramType.VERTEX</code> oder <code>Context3DProgramType.FRAGMENT</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; der Index des ersten Konstantenregisters, das festgelegt werden soll. Da ein Matrix3D-Objekt 16 Werte hat, werden vier Register festgelegt.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix3D.html">Matrix3D</a></code> &mdash; die Matrix, die die Konstantenwerte enthält. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transposedMatrix</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; bei der Einstellung <code>true</code> werden die Matrixeinträge in der transponierten Reihenfolge in Register kopiert. Der Standardwert ist <code>false</code>.
            
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Nullzeigerfehler: wenn <code>matrix</code> null ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Konstantenregister außerhalb des gültigen Bereichs: wenn versucht wird, mehr Shaderkonstantenregister festzulegen als zulässig.
         
         </td></tr></table><p id="learnMore"><span class="label">Weitere Informationen</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_de</a></div><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromVector()" id="setProgramConstantsFromVector()"></a><a name="setProgramConstantsFromVector(String,int,Vector$Number,int)" id="setProgramConstantsFromVector(String,int,Vector$Number,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromVector(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt die Konstanteneingaben für die Shaderprogramme fest.
         
         <p>Legt ein Array von Konstanten fest, auf das von einem Vertex- oder Fragmentprogramm zugegriffen werden kann. Auf Konstanten, die in Programm3D festgelegt werden, wird in den Shader-Programmen als Konstantenregister zugegriffen. Jedes Konstantenregister besteht aus 4 Gleitkommawerten (x, y, z, w). Deshalb benötigt jedes Register 4 Einträge im data-Vektor. Die Anzahl der Registrierungen für Scheitelpunkt- und Fragmentprogramm, die Sie festlegen können, hängt vom <code>Context3DProfile</code> ab.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; Der Typ des Shaderprogramms, entweder <code>Context3DProgramType.VERTEX</code> oder <code>Context3DProgramType.FRAGMENT</code>.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; der Index des ersten Konstantenregisters, das festgelegt werden soll. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; die Gleitkommakonstantenwerte. Es muss wenigstens 4 <code>numRegisters</code>-Elemente in <code>data</code> geben.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; die Anzahl der festzulegenden Konstanten. Geben Sie -1, den Standardwert, an, um genügend Register festzulegen, damit alle verfügbaren Daten verwendet werden.
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Nullzeigerfehler: wenn <code>data</code> den Wert <code>null</code> hat.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Konstantenregister außerhalb des gültigen Bereichs: wenn versucht wird, mehr Shaderkonstantenregister festzulegen als zulässig.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Fehlerhafte Eingabegröße: Wenn die Anzahl der Elemente in <code>data</code> kleiner als <code>numRegisters</code> ist *4
         
         </td></tr></table><p id="learnMore"><span class="label">Weitere Informationen</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_de</a></div><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToBackBuffer()" id="setRenderToBackBuffer()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToBackBuffer():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt den Hintergrund-Renderpuffer als Renderziel fest. Nachfolgende Aufrufe der <code>drawTriangles()</code>- und <code>clear()</code>-Methoden führen dazu, dass der Hintergrundpuffer aktualisiert wird. Verwenden Sie diese Methode, um das normale Rendern wiederaufzunehmen, nachdem die <code>setRenderToTexture()</code>-Methode verwendet wurde. 
         
         
         </p></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToTexture()" id="setRenderToTexture()"></a><a name="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)" id="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToTexture(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt die angegebene Textur als Renderziel fest.  
         
         <p>Nachfolgende Aufrufe der <code>drawTriangles()</code>- und <code>clear()</code>-Methoden aktualisieren die angegebene Textur statt des Backpuffers. Mipmaps werden automatisch erstellt. Verwenden Sie <code>setRenderToBackBuffer()</code>, um das normale Rendern in den Backpuffer fortzusetzen.</p>
         
         <p>Vor dem Zeichnen ist kein Löschvorgang erforderlich. Erfolgt kein Löschvorgang, bleibt der gerenderte Inhalt erhalten. Tiefenpuffer und Schablonenpuffer werden ebenfalls nicht gelöscht. Beim ersten Zeichenvorgang wird dies jedoch erzwungen. Der Aufruf von <code>present()</code> setzt das Ziel auf den Hintergrundpuffer zurück.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; die Zieltextur für das Rendern. Setzen Sie dies auf <code>null</code>, um das Rendern in den Backpuffer fortzusetzen (<code>setRenderToBackBuffer()</code> und <code>present</code> setzen das Ziel ebenfalls auf den Backpuffer zurück).       
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; bei der Einstellung <code>true</code> sind Tiefen- und Schablonentests verfügbar. Bei der Einstellung <code>false</code> wird der Tiefen- und Schablonenstatus für nachfolgende Zeichenvorgänge ignoriert. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; die Antialiasingqualität. Verwenden Sie 0, um Antialiasing zu deaktivieren; höhere Werte verbessern die Qualität des Antialiasing, erfordern jedoch mehr Rechenleistung. Der Wert wird zur Zeit nach Mobilplattform und Softwarerenderkontext ignoriert. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">surfaceSelector</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; legt fest, welches Element der Textur aktualisiert werden soll. Texture-Objekte haben eine Oberfläche, deshalb müssen Sie den Standardwert, 0, angeben. CubeTexture-Objekte haben sechs Oberflächen, deshalb können Sie eine Ganzzahl zwischen 0 und 5 angeben.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorOutputIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Das Ausgabefarbregister. Muss 0 sein für eingeschränkten oder Grundlinienmodus. Gibt andernfalls das Ausgabefarberegister an. 
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; für einen nicht passenden <code>surfaceSelector</code>-Parameter. Der Wert muss für 2D-Texturen 0 und für Cubemaps 0...5 sein. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>texture</code> wird nicht von der TextureBase-Klasse abgeleitet (entweder Texture- oder CubeTexture-Klassen).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>colorOutputIndex</code> muss eine Ganzzahl zwischen 0 und 3 sein.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; This call requires a Context3D that is created with profile baseline or above (Dieser Aufruf erfordert eine <code>Context3D</code>, die mit dem Standardprofil oder höher erstellt wird).
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#configureBackBuffer()" target="">configureBackBuffer()</a><br/><a href="textures/CubeTexture.html#uploadFromByteArray()" target="">flash.display3D.textures.CubeTexture.uploadFromByteArray()</a></div></div></span><span id="pageFilter" runtime="Flash::11.6##AIR::3.6##"><a name="setSamplerStateAt()" id="setSamplerStateAt()"></a><a name="setSamplerStateAt(int,String,String,String)" id="setSamplerStateAt(int,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setSamplerStateAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setSamplerStateAt(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.6, AIR 3.6</td></tr></table><p></p><p></p><p>
         Textursamplerstatus manuell überschreiben..
         
         <p>Textursamplerstatus wird beim Aufrufen von <code>setProgram</code> festgelegt. Sie können den Textursamplerstatus jedoch mit dieser Funktion überschreiben. Wenn Sie nicht möchten, dass das Programm den Samplerstatus ändert, setzen Sie das <code>ignoresamnpler</code>-Bit in AGAL und verwenden Sie diese Funktion.          
         </p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; sampler Das zu verwendende Samplerregister. Ist dem Samplerregister in AGAL zugeordnet. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wrap</span>:<a href="../../String.html">String</a></code> &mdash; Wrappingmodus. In <code>Context3DWrapMode</code> definiert. Der Standardwert ist „repeat“ (wiederholen). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../../String.html">String</a></code> &mdash; Texturfiltermodus. In <code>Context3DTextureFilter</code> definiert. Der Standardwert ist „nearest“ (nächster). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mipfilter</span>:<a href="../../String.html">String</a></code> &mdash; Mipmap-Filter. In <code>Context3DMipFilter</code> definiert. Der Standardwert ist „none“ (ohne).          
                  
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Sampler außerhalb des gültigen Bereichs
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehlerhafte Aufzählung Wrap, Filter, Mipfilter 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Objekt verworfen: Falls dieses Context3D-Objekt durch einen Aufruf von <code>dispose()</code> oder durch den Verlust der zu Grunde liegenden Renderhardware verworfen wurde.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DWrapMode.html" target="">Context3DWrapMode</a><br/><a href="Context3DTextureFilter.html" target="">Context3DTextureFilter</a><br/><a href="Context3DMipFilter.html" target="">Context3DMipFilter</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setScissorRectangle()" id="setScissorRectangle()"></a><a name="setScissorRectangle(flash.geom.Rectangle)" id="setScissorRectangle(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setScissorRectangle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setScissorRectangle(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt ein Scherenrechteck fest, was eine Art von Zeichenmaske ist. Der Renderer zeichnet nur in den Bereich innerhalb des Scherenrechtecks. Das Ausschneiden mit Schere hat keine Auswirkungen auf Löschvorgänge. 
         
         <p>Übergeben Sie <code>null</code>, um das Ausschneiden mit Schere auszuschalten.</p>     
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rectangle</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Das Rechteck, in das gezeichnet werden soll. Legt die Position und die Abmessungen des Rechtecks in Pixeln fest. Der Ursprung des Koordinatensystems befindet sich in der oberen linken Ecke des Viewports, mit positiven Werten, die nach unten und nach rechts zunehmen (wie beim normalen Flash-Koordinatensystem). 
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Die folgende Klasse zeichnet zwei Dreiecke in einen 640x480-Pixel-Viewport auf der Bühne. Die Dreiecke haben einen gemeinsamen Vertex, der sich am Ursprung (0,0,0) befindet.
 
 <p>Die Dreiecke werden mithilfe des Vertexbuffers und des Indexbuffers definiert. Der Vertexbuffer enthält die Informationen zu Position und Farbe für jeden Vertex des Dreiecks. Der Indexbuffer enthält Indizes für den Vertexbuffer. Drei Indizes definieren ein Dreieck. Zum Beispiel wird ein Dreieck, das aus den ersten drei Punkten im Vertexbuffer besteht, im Indexbuffer als 0,1,2 aufgeführt.</p>
 
 <p>In diesem einfachen Beispiel wird keine 3D-Transformation ausgeführt. Es werden nur Objekte innerhalb des kanonischen Ansichtsbereichs (ein 2x2x2-Würfelkörper am Ursprungspunkt) angezeigt. Beim Rendern einer typischen 3D-Szene projizieren Sie die Objekte jedoch für das Rendering in diesen Ansichtsbereich, indem Sie entweder eine perspektivische oder orthografische Projektion verwenden.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_ScissorRectangle extends Sprite
    {
        public const viewWidth:Number = 640;
        public const viewHeight:Number = 480;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var scissorOn:Boolean = false;
        private var toggler:Timer = new Timer( 750 );
        
        public function Context3D_ScissorRectangle()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
            
            //Set up timer to turn scissoring on and off
            toggler.addEventListener( TimerEvent.TIMER, toggleScissor );
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
            toggler.start();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear();

            //Sciss a region excluding the outer 100 pixels of the viewport
            var scissor:Rectangle = new Rectangle( 100, 100, viewWidth - 200, viewHeight - 200 );
            if( scissorOn )    renderContext.setScissorRectangle( scissor ); //on
            else renderContext.setScissorRectangle( null ); //off

            //Draw the triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function toggleScissor( event:Event ):void
        {
            scissorOn = !scissorOn;
            render();
        }
        
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilActions()" id="setStencilActions()"></a><a name="setStencilActions(String,String,String,String,String)" id="setStencilActions(String,String,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilActions</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilActions(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Legt den Schablonenmodus und -vorgang fest.
         
         <p>Ein 8-Bit-Schablonenreferenzwert kann mit jedem Aufruf von call verknüpft werden. Beim Rendering kann der Referenzwert anhand der zuvor im Bildpuffer gespeicherten Werte getestet werden. Das Ergebnis des Tests kann die Zeichenaktion steuern und bestimmen, ob und wie der gespeicherte Schablonenwert aktualisiert wird. Zusätzlich steuert der Tiefentest, ob Schablonentests ausgeführt werden. Ein fehlgeschlagener Tiefentest kann auch verwendet werden, um die Aktion, die für den Schablonenpuffer ausgeführt wird, zu steuern.</p>
         
         <p>In der Pixelverarbeitungspipeline werden zuerst Tiefentests ausgeführt. Wenn der Tiefentest fehlschlägt, kann eine Updateaktion für den Schablonenpuffer ausgeführt werden, eine weitere Evaluierung des Schablonenpufferwerts ist jedoch nicht möglich. Wenn der Tiefentest erfolgreich verläuft, wird der Schablonentest ausgeführt. Je nach Ergebnis des Schablonentests können verschiedene Aktionen ausgeführt werden.  </p>
         
         <p>Der Schablonenreferenzwert wird mithilfe von <code>setStencilReferenceValue()</code> festgelegt. </p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFace</span>:<a href="../../String.html">String</a></code> (default = "<code>frontAndBack</code>")<code></code> &mdash; die Dreieckausrichtungen, die zum Schablonenvorgang beitragen können. Eines von Context3DTriangleFace.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compareMode</span>:<a href="../../String.html">String</a></code> (default = "<code>always</code>")<code></code> &mdash; der Testoperator, der zum Vergleich des aktuellen Schablonenreferenzwerts und des Zielpixelschablonenwerts verwendet wird. Wenn der Vergleich „true“ ist, werden Zielpixelfarbe und -tiefe aktualisiert. Die Schablonenaktionen werden wie in den folgenden Aktionsparametern angefordert ausgeführt. Der Vergleichsoperator wird als ein Infixoperator zwischen dem aktuellen und dem Zielreferenzwert angewendet, in dieser Reihenfolge (in Pseudocode: <code>if stencilReference OPERATOR stencilbuffer then pass</code>). Verwenden Sie eine der Konstanten, die in der Context3DCompareMode-Klasse definiert sind.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnBothPass</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; Aktion, die ausgeführt wird, wenn sowohl Tiefen- als auch Schablonenvergleich bestanden werden. Verwenden Sie eine der Konstanten, die in der Context3DStencilAction-Klasse definiert sind.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; Aktion, die ausgeführt wird, wenn der Tiefenvergleich fehlschlägt. Verwenden Sie eine der Konstanten, die in der Context3DStencilAction-Klasse definiert sind.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthPassStencilFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; Aktion, die ausgeführt wird, wenn der Tiefenvergleich erfolgreich ist und der Schablonenvergleich fehlschlägt. Verwenden Sie eine der Konstanten, die in der Context3DStencilAction-Klasse definiert sind.
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehler wegen ungültiger Aufzählung: wenn <code>triangleFace</code> nicht einer der in der Context3DTriangleFace-Klasse definierten Werte ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehler wegen ungültiger Aufzählung: wenn <code>compareMode</code> nicht einer der in der Context3DCompareMode-Klasse definierten Werte ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Fehler wegen ungültiger Aufzählung: wenn <code>actionOnBothPass</code>, <code>actionOnDepthFail</code> oder <code>actionOnDepthPassStencilFail</code> nicht einer der in der Context3DStencilAction-Klasse definierten Werte ist.
         
         </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3D.html#setStencilReferenceValue()" target="">setStencilReferenceValue()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Die folgende Klasse veranschaulicht, wie eine Schablone gezeichnet wird und als Maske für nachfolgende Zeichenvorgänge verwendet wird. Das Beispiel führt die folgenden Schritte aus:
 <ul><li>Schablonenpuffer auf 0 leeren.</li><li>Schablonenaktion auf Inkrementieren bei erfolgreichem Schablonentest festlegen.</li><li>Schablonenreferenzwert auf 0 setzen.</li><li>Dreieckige Maske zeichnen. Unabhängig davon, wo das Dreieck gezeichnet wird, verläuft der Schablonentest erfolgreich, da der Schablonenpuffer auf 0 geleert wurde und der Referenzwert 0 ist. Deshalb wird der Schablonenpuffer auf 1 erhöht, wo die Dreiecksmaske gezeichnet wird.</li><li>Schablonenaktion auf „Beibehalten“ ändern, sodass nachfolgende Zeichenvorgänge den Schablonenpuffer nicht ändern.</li><li>Vollbildrechteck zeichnen (mehrfarbig). Da der Schablonenreferenzwert immer noch 0 ist, schlägt der Schablonentest im maskierten Bereich fehl. Deshalb wird das Rechteck überall mit Ausnahme des maskierten Bereichs gezeichnet.</li><li>Schablonenreferenzwert auf 1 ändern.</li><li>Ein weiteres Vollbildrechteck zeichnen (rot). Jetzt schlägt der Schablonentest überall fehl, nur nicht im maskierten Bereich, für den der Wert auf 1 erhöht wurde. Deshalb wird das Rechteck nur im maskierten Bereich gezeichnet.</li></ul>
 <p>Bewegen Sie die Maus über das Beispiel, um die Hauptschritte nacheinander zu sehen.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DCompareMode;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DStencilAction;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_Stencil extends Sprite
    {
        public const viewWidth:Number = 350;
        public const viewHeight:Number = 240;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
                
        public function Context3D_Stencil()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
        
            non3DSetup();
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, true );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3, 2, 
                                                            0, 1, 3,
                                                            4, 7, 6,
                                                            4, 5, 7,
                                                            8, 9, 10
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  //x, y, z  r,g,b format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1,

                   -1, 1, 0,  .5,0,0,
                    1, 1, 0,  .5,0,0,
                   -1,-1, 0,  .5,0,0,
                    1,-1, 0,  .5,0,0,
                    
                    0, .7,.1, 0,0,0,
                  -.7,-.7,.1, 0,0,0,
                   .7,-.7,.1, 0,0,0
                ]);
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            render();
        }
        private function render():void
        {
            //Clear, setting stencil to 0
            renderContext.clear( .3, .3, .3, 1, 1, 0 );
            
            //Draw stencil, incrementing the stencil buffer value
            renderContext.setStencilReferenceValue( 0 );
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.INCREMENT_SATURATE );            
            if( state &gt; 0 ) renderContext.drawTriangles( indexList, 12, 1 );

            //Change stencil action when stencil passes so stencil buffer is not changed
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.KEEP );
            
            //Draw quad -- doesn't draw where stencil has already drawn
            if( state &gt; 1 ) renderContext.drawTriangles( indexList, 0, 2 );
            
            //Change the reference to 1 so this quad only draws into stenciled area
            renderContext.setStencilReferenceValue( 1 );
            if( state &gt; 2 ) renderContext.drawTriangles( indexList, 6, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        //The rest of the code is for the example UI and timer 
        private function doState( event:TimerEvent ):void
        {
            switch (state)
            {
                case 0:
                    description.text = "Draw triangle with stencil action == increment";
                    state = 1;
                    break;
                case 1:
                    description.text = "Draw the first plane where stencil == 0";
                    state = 2;
                    break;
                case 2:
                    description.text = "Draw second plane where stencil == 1";
                    state = 3;
                    break;
                case 3:
                    description.text = "Clear, setting stencil to 0";
                    state = 0;
                    break;

                default:
                    description.text = "";
                    state = 0;        
            }
            render();
        }

        private var state:int = 3;
        private var stateTimer:Timer = new Timer( 1250 );
        private var description:TextField = new TextField();
        
        private function non3DSetup():void
        {
            //Setup timer to animate the stages of drawing the scene
            stateTimer.addEventListener( TimerEvent.TIMER, doState );
            this.stage.addEventListener( MouseEvent.MOUSE_OVER, function(event:Event):void{stateTimer.start()} );
            this.stage.addEventListener( MouseEvent.MOUSE_OUT, function(event:Event):void{stateTimer.stop()} );
            
            description.height = 30;
            description.width = viewWidth;
            this.addChild( description );
            description.y = viewHeight + 15;
            description.defaultTextFormat = new TextFormat( null, 18, 0xffffff );
            description.text = "Mouse over to view.";
            
            //Allows mouse-over events
            var coverSprite:Sprite = new Sprite();
            coverSprite.graphics.beginFill( 0, .01 )
            coverSprite.graphics.lineTo( stage.stageWidth, 0 );
            coverSprite.graphics.lineTo( stage.stageWidth, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, 0 );
            this.addChild( coverSprite );            
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilReferenceValue()" id="setStencilReferenceValue()"></a><a name="setStencilReferenceValue(uint,uint,uint)" id="setStencilReferenceValue(uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilReferenceValue</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilReferenceValue(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         Legt den Schablonenvergleichswert fest, der für Schablonentests verwendet wird. 
         
         <p>Es werden nur die unteren 8 Bits des Referenzwerts verwendet. Der Schablonenpufferwert ist ebenfalls 8 Bit lang. Verwenden Sie <code>readMask</code> und <code>writeMask</code>, um den Schablonenpuffer als Bitfeld zu verwenden.</p>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">referenceValue</span>:<a href="../../uint.html">uint</a></code> &mdash; ein 8-Bit-Referenzwert, der in Referenzwertvergleichstests verwendet wird.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">readMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; eine 8-Bit-Maske, die vor dem Vergleich auf den aktuellen Schablonenpufferwert und den Referenzwert angewendet wird.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">writeMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; eine 8-Bit-Maske, die vor dem Aktualisieren des Schablonenpuffers auf den Referenzwert angewendet wird.
         
         </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3D.html#setStencilActions()" target="">setStencilActions()</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setTextureAt()" id="setTextureAt()"></a><a name="setTextureAt(int,flash.display3D.textures.TextureBase)" id="setTextureAt(int,flash.display3D.textures.TextureBase)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setTextureAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setTextureAt(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Gibt die Textur an, die für ein Textureingaberegister eines Fragmentprogramms verwendet werden soll.
         
         <p>Ein Fragmentprogramm kann Informationen aus bis zu acht Texturobjekten lesen. Verwenden Sie diese Funktion, um ein Texture- oder CubeTexture-Objekt einem der vom Fragmentprogramm verwendeten Samplerregister zuzuweisen. </p>
         
         <p><b>Hinweis:</b> Wenn Sie das aktive Fragmentprogramm (mit <code>setProgram</code>) zu einem Shader ändern, der weniger Texturen verwendet, setzen Sie die nicht verwendeten Register auf <code>null</code>:</p>
         <div class="listing"><pre>
         setTextureAt( 7, null );
         </pre></div>
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; der Samplerregisterindex, ein Wert zwischen 0 und 7.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; das Texturobjekt, das verfügbar gemacht werden soll, entweder eine Texture- oder eine CubeTexture-Instanz.
         
         </td></tr></table></p><p id="learnMore"><span class="label">Weitere Informationen</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_de</a></div><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso">Texture<br/>CubeTexture</div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setVertexBufferAt()" id="setVertexBufferAt()"></a><a name="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)" id="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVertexBufferAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVertexBufferAt(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Gibt an, welche Vertexdatenkomponenten einer einzelnen Vertexshaderprogrammeingabe entsprechen.
         
         <p>Verwenden Sie die <code>setVertexBufferAt</code>-Methode, um festzustellen, welche Komponenten der für jeden Vertex in einem VertexBuffer3D-Puffer definierten Daten zu welchen Eingaben des Vertexprogramms gehören. Der Entwickler des Vertexprogramms bestimmt, wie viele Daten pro Vertex benötigt werden. Diese Daten werden von einem oder mehreren <code>VertexBuffer3D</code>-Streams den Attributregistern des Vertexprogramms zugeordnet.</p>
         
         <p>Die kleinste Einheit der vom Vertex-Shader verbrauchten Daten sind 32-Bit-Daten. Offsets im Vertexstream werden in Vielfachen von 32 Bits angegeben.</p>
         
         Beispiel: Ein Programmierer kann jeden Vertex mit den folgenden Daten definieren:
<pre>
position:  x    float32
           y    float32
           z    float32
color:     r    unsigned byte
           g    unsigned byte
           b    unsigned byte
           a    unsigned byte
</pre>            
         Angenommen, der Vertex wurde in einem VertexBuffer3D mit dem Namen <code>buffer</code> definiert, wird er mit dem folgenden Code einem Vertex-Shader zugewiesen:
<pre>
setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
</pre>
         
         
         </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">index</span>:<a href="../../int.html">int</a></code> &mdash; der Index des Attributregisters im Vertexshader (0 bis 7).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">buffer</span>:<a href="VertexBuffer3D.html">VertexBuffer3D</a></code> &mdash; der Puffer, der die Quellvertexdaten enthält, die in den Vertex-Shader eingegeben werden sollen.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferOffset</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; ein Offset vom Start der Daten für einen einzelnen Vertex, bei dem mit dem Lesen dieses Attributs begonnen werden soll. Im Beispiel oben haben die Positionsdaten einen Offset von 0, da es sich um das erste Attribut handelt; Farbe hat einen Offset von 3, da das color-Attribut den drei 32-Bit-Positionswerten folgt. Der Offset wird in Einheiten von 32 Bits angegeben.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> (default = "<code>float4</code>")<code></code> &mdash; ein Wert aus der Context3DVertexBufferFormat-Klasse, der den Datentyp dieses Attributs angibt.  
         
         </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; Ungültige Aufzählung: wenn das Format nicht einer der in der Context3DVertexBufferFormat-Klasse definierten Werte ist.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Attributregister außerhalb des gültigen Bereichs: wenn der <code>index</code>-Parameter außerhalb des Bereichs von 0 bis 7 liegt. (Von einem Shader können höchstens acht Vertexattribute verwendet werden.)
         
         </td></tr></table><p id="learnMore"><span class="label">Weitere Informationen</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_de</a></div><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Beispiele<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span></div><span id="pageFilter"><div class="exampleHeader">Context3DExample.as</div><br/><div class="detailBody"> Die folgende Klasse zeichnet einen sich drehenden Würfel mithilfe einer perspektivischen Projektion.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    import com.adobe.utils.PerspectiveMatrix3D;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.geom.Vector3D;
    
    public class Context3DExample extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        public const zNear:Number = 1;
        public const zFar:Number = 500;
        
        public const fov:Number = 45;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private var projection:PerspectiveMatrix3D = new PerspectiveMatrix3D();
        private var model:Matrix3D = new Matrix3D();
        private var view:Matrix3D = new Matrix3D();
        private var finalTransform:Matrix3D = new Matrix3D();
        
        //For rotating the cube
        private const pivot:Vector3D = new Vector3D();
        
        private const VERTEX_SHADER:String =
            "m44 op, va0, vc0    \n" +    // 4x4 matrix transform 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3DExample()
        {
            this.stage.scaleMode = StageScaleMode.NO_SCALE;
            this.stage.align = StageAlign.TOP_LEFT;
            this.stage.nativeWindow.activate(); //AIR only
                         
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextCreationError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
                renderContext = Stage3D( event.target ).context3D;
                trace( "3D driver: " + renderContext.driverInfo );
                setupScene();
        }
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //Create vertex index list for the triangles forming a cube
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 
                2,1,0, //front face
                3,2,0,
                4,7,5, //bottom face
                7,6,5,
                8,11,9, //back face
                9,11,10,
                12,15,13, //top face
                13,15,14,
                16,19,17, //left face
                17,19,18,
                20,23,21, //right face
                21,23,22
            ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes - cube faces do not share vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                    // x,y,z r,g,b format
                    0,0,0, 1,0,0, //front face
                    0,1,0, 1,0,0,
                    1,1,0, 1,0,0,
                    1,0,0, 1,0,0,
                    
                    0,0,0, 0,1,0, //bottom face
                    1,0,0, 0,1,0,
                    1,0,1, 0,1,0,
                    0,0,1, 0,1,0,
                    
                    0,0,1, 1,0,0, //back face
                    1,0,1, 1,0,0,
                    1,1,1, 1,0,0,
                    0,1,1, 1,0,0,
                    
                    0,1,1, 0,1,0, //top face
                    1,1,1, 0,1,0,
                    1,1,0, 0,1,0,
                    0,1,0, 0,1,0,
                    
                    0,1,1, 0,0,1, //left face
                    0,1,0, 0,0,1,
                    0,0,0, 0,0,1,
                    0,0,1, 0,0,1,
                    
                    1,1,0, 0,0,1, //right face
                    1,1,1, 0,0,1,
                    1,0,1, 0,0,1,
                    1,0,0, 0,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Set up 3D transforms
            projection.perspectiveFieldOfViewRH( fov, viewWidth/viewHeight, zNear, zFar );            
            view.appendTranslation( 0, 0, -2 );    //Move view back
            model.appendTranslation( -.5, -.5, -.5 ); //center cube on origin
            this.stage.addEventListener( Event.ENTER_FRAME, render );
        }
        
        private function render( event:Event ):void
        {
            //Rotate model on each frame
            model.appendRotation( .5, Vector3D.Z_AXIS, pivot );
            model.appendRotation( .5, Vector3D.Y_AXIS, pivot );
            model.appendRotation( .5, Vector3D.X_AXIS, pivot );
            
            //Combine transforms
            finalTransform.identity();
            finalTransform.append( model );
            finalTransform.append( view );
            finalTransform.append( projection );
            
            //Pass the final transform to the vertex shader as program constant, vc0
            renderContext.setProgramConstantsFromMatrix( Context3DProgramType.VERTEX, 0, finalTransform, true );
            
            //Clear is required before drawTriangles on each frame
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 12 triangles that make up the cube
            renderContext.drawTriangles( indexList, 0, 12 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextCreationError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
    }
}
</pre></div></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,true,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 10:04 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/de_DE/legalnotices/index.html">Rechtliche Hinweise</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Onlinedatenschutzerklärung</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Warum auf Englisch?</span>
				</div>
				<div class="white_content_body">
					<b>Inhalt des ActionScript 3.0-Referenzhandbuchs wird in englischer Sprache angezeigt</b><br><br>
					Nicht alle Teile des ActionScript 3.0-Referenzhandbuchs wurden in alle Sprachen übersetzt. Wenn der Text zu einem Sprachelement nicht übersetzt wurde, wird er auf Englisch angezeigt. Zum Beispiel wurden die Informationen zur ga.controls.HelpBox-Klasse nicht in andere Sprachen übersetzt. In der deutschen Version des Referenzhandbuchs erscheint der Abschnitt zur ga.controls.HelpBox-Klasse deshalb auf Englisch.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 10:04 AM Z  -->
