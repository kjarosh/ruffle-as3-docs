<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 Referenzhandbuch für die Adobe&reg; Flash&reg;-Plattform"><meta name="lang" content="de-de"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Adobe ActionScript&reg; 3 (AS3 ) API-Referenz</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Laufzeitumgebungen";
			var productsLabel = "Produkte";
			var noneLabel = "Keine";
			var qsearchBoxLabel = "Schnellsuche";
			var qsearchText = "Begriff nicht gefunden";
			var ajaxErrorMsg="Fehler beim Laden der Seite";
			var ajaxErrorTryMsg="Wiederholen";
			var ajaxLoadingMsg="Ladevorgang läuft noch";
			var cancelMsg = "Abbrechen";
			var classesText = "Klassen";
			var strJiveReply = "Diese Frage wurde zu folgendem Artikel gestellt: "
			var showFilters = "Filter anzeigen";
			var hideFilters = "Filter ausblenden";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 Referenzhandbuch für die Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>-Plattform<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Home </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">Liste der Pakete und Klassen einblenden</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">Liste der Pakete und Klassen ausblenden</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Pakete </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Klassen </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Neue Funktionen </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Stichwortverzeichnis </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Anhänge </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Warum auf Englisch?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/de_DE/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filter:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Daten werden vom Server abgerufen...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Daten werden vom Server abgerufen...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> Eigenschaften </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Eigenschaften </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> Methoden </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> Globale Konstanten </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> Ereignisse </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> Stile </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> Skinteile </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> Skinstatus </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> Effekte </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> Konstanten </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> Globale Funktionen </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">Funktionen</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> Schnittstellen </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> Klassen </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> Beispiele </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klassen
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Paket</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">Klasse</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">Vererbung</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">Implementiert</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 Die BitmapData-Klasse ermöglicht Ihnen die Arbeit mit den Daten (Pixeln) eines <span>Bitmap</span>-Objekts. Sie können die Methoden der BitmapData-Klasse verwenden, um transparente oder undurchsichtige Bitmaps mit beliebig festgelegter Größe zu erstellen und zur Laufzeit auf verschiedene Weise zu bearbeiten. <span>Sie können auch auf die Bitmap-Daten einer Bitmap zugreifen, die Sie mit der <code>flash.display.Loader</code>-Klasse laden.</span> 
 
               <p>Mit dieser Klasse können Sie Bitmap-Wiedergabeoperationen von den internen Anzeigeaktualisierungsroutinen von Flash Player trennen. Mit einer unmittelbaren Bearbeitung der BitmapData-Objekte können Sie komplexe Bilder erstellen, ohne bei jedem Bild den Aufwand für die ständig erneuerte Darstellung der Vektordaten berücksichtigen zu müssen.</p>
 
               <p>Die Methoden der BitmapData-Klasse unterstützen Effekte, die über die Filter für Nicht-Bitmap-Anzeigeobjekte nicht verfügbar sind.</p>
 
               <p>Ein BitmapData-Objekt enthält eine ganze Reihe von Pixeldaten. Diese Daten repräsentieren entweder eine vollständig transparente oder eine vollständig undurchsichtige Bitmap mit Alphakanaldaten. Jeder BitmapData-Objekttyp wird als Puffer mit 32-Bit-Ganzzahlen gespeichert. Dabei bestimmt jede 32-Bit-Ganzzahl die Eigenschaften eines Pixels in der Bitmap.</p>
 
               <p>Bei diesen Zahlen handelt es sich um eine Kombination von vier 8-Bit-Kanalwerten zwischen 0 und 255, mit denen die Alphatransparenz sowie die Werte für Rot, Grün und Blau (ARGB) des Pixels bezeichnet werden. (Für ARGB-Werte repräsentiert das höchstwertige Byte den Alphakanalwert, gefolgt von Rot, Grün und Blau.)</p>
 
               <p>Die vier Kanäle (Alpha, Rot, Grün und Blau) werden durch Zahlen repräsentiert, wenn Sie sie mit der <code>BitmapData.copyChannel()</code>-Methode oder den Eigenschaften <code>DisplacementMapFilter.componentX</code> und <code>DisplacementMapFilter.componentY</code> verwenden. Diese Zahlen werden in der BitmapDataChannel-Klasse durch die folgenden Konstanten repräsentiert:</p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>Sie können BitmapData-Objekte mit einem Bitmap-Objekt verbinden, indem Sie die <code>bitmapData</code>-Eigenschaft des Bitmap-Objekts verwenden.</p>
 
               <p>Sie können ein BitmapData-Objekt verwenden, um ein Graphics-Objekt zu füllen, indem Sie die <code>Graphics.beginBitmapFill()</code>-Methode verwenden.</p>
 
               <p>In der AIR-Laufzeitumgebung umfassen die DockIcon-, Icon-, InteractiveIcon- und SystemTrayIcon-Klassen eine <code>bitmaps</code>-Eigenschaft, bei der es sich um ein Array der BitmapData-Objekte handelt, die die Bitmapbilder für ein Symbol definieren.</p>
 
               <p>In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite eines BitmapData-Objekts 8.191&nbsp;Pixel, die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein BitmapData-Objekt also 8.191&nbsp;Pixel breit ist, darf es nur 2.048&nbsp;Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880&nbsp;Pixel Höhe und Breite.</p>
 
               <p>Beginnend mit AIR 3 und Flash Player 11 wurden die Größenbegrenzungen für BitmapData-Objekte entfernt. Die maximale Bitmapgröße wird jetzt durch das Betriebssystem festgelegt.</p>
 
               <p>Aufrufe von Methoden oder Eigenschaften eines BitmapData-Objekts lösen einen ArgumentError-Fehler aus, wenn das BitmapData-Objekt ungültig ist (wenn z.&nbsp;B. <code>height == 0</code> und <code>width == 0</code> ist) oder wenn es mithilfe von „dispose()“ entfernt worden ist. </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">Beispiele anzeigen</a></p><p><span class="classHeaderTableLabel">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Öffentliche Eigenschaften</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Vererbte öffentliche Eigenschaften ausblenden</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Vererbte öffentliche Eigenschaften anzeigen</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Eigenschaft</th><th>Definiert von</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Ein Verweis auf das Klassenobjekt oder die Konstruktorfunktion für eine angegebene Objektinstanz.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[schreibgeschützt] 
     Die Höhe der Bitmap in Pixel.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[schreibgeschützt] 
     Das Rechteck, das die Größe und Lage der Bitmap definiert.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[schreibgeschützt] 
     Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[schreibgeschützt] 
     Die Breite der Bitmap in Pixel.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Öffentliche Methoden </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Vererbte öffentliche Methoden ausblenden</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Vererbte öffentliche Methoden anzeigen</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Methode</th><th>Definiert von</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     Erstellt ein neues BitmapData-Objekt mit der angegebenen Breite und Höhe.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Erstellt anhand eines Quellbilds und eines filter-Objekts das gefilterte Bild.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     Gibt ein neues BitmapData-Objekt zurück, das ein Klon der ursprünglichen Instanz ist, mit einer exakten Kopie der enthaltenen Bitmap.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Passt die Farbwerte in einem angegebenen Bereich einer Bitmap mithilfe eines ColorTransform-Objekts an.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     Vergleicht zwei BitmapData-Objekte.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Überträgt Daten innerhalb des aktuellen BitmapData-Objekts aus einem Kanal in einen anderen bzw. überträgt Daten in einen Kanal des aktuellen BitmapData-Objekts, die aus einem Kanal eines anderen BitmapData-Objekts stammen.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Bietet eine schnelle Routine zur Bearbeitung von Pixeln zwischen Bildern ohne Dehnung, Drehung oder Farbeffekte.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Füllt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Gibt Speicher frei, der zum Speichern des BitmapData-Objekts verwendet wird.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Zeichnet das source-Anzeigeobjekt mithilfe des Vektorrenderers der Flash-Laufzeitumgebung auf das Bitmapbild.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Zeichnet das source-Anzeigeobjekt mithilfe des Vektorrenderers der Flash-Laufzeitumgebung auf das Bitmapbild.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Komprimiert dieses BitmapData-Objekt mit dem ausgewählten Komprimierungsalgorithmus und gibt ein neues ByteArray-Objekt zurück.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Füllt einen rechteckigen Pixelbereich mit der angegebenen ARGB-Farbe.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Führt für ein Bild ausgehend von einer (x, y)-Koordinate einen Flood-Fill-Vorgang mit einer bestimmten Farbe durch.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Bestimmt das Zielrechteck, auf das sich der Aufruf der applyFilter()-Methode auswirkt. Die Angaben beziehen sich auf ein BitmapData-Objekt, ein Quellrechteck und ein filter-Objekt.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Legt einen rechteckigen Bereich fest, der entweder innerhalb der Bitmap alle Pixel einer bestimmten Farbe vollständig umschließt (wenn der findColor-Parameter auf „true“ gesetzt ist) oder alle Pixel vollständig umschließt, die die angegebene Farbe nicht enthalten (wenn der findColor-Parameter auf „false“ gesetzt ist).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Gibt eine Ganzzahl zurück, die einen RGB-Pixelwert eines BitmapData-Objekts an einem bestimmten Punkt (x, y) darstellt.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Gibt einen ARGB-Farbwert zurück, der Alphakanal- und RGB-Daten enthält.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     Erzeugt ein Vektor-Array aus einem rechteckigen Bereich mit Pixeldaten.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob für ein Objekt eine bestimmte Eigenschaft definiert wurde.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     Berechnet ein Histogramm mit 256 Binärzahlwerten für ein BitmapData-Objekt.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     Führt zwischen einer Bitmap und einem Punkt, einem Rechteck oder einer anderen Bitmap eine Kollisionserkennung auf Pixelebene durch.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob eine Instanz der Object-Klasse in der Prototypkette des Objekts vorhanden ist, das als Parameter angegeben wurde.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Sperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z.&nbsp;B. Bitmap-Objekte, nicht aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Führt von einem Quellbild zu einem Zielbild eine Mischung pro Kanal durch.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Füllt ein Bild mit Pixeln, die zufällige Störungen darstellen.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ordnet die Farbkanalwerte in einem Bild mit maximal vier Arrays von Farbpalettendaten neu zu, wobei die einzelnen Arrays jeweils einen Kanal darstellen.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Erstellt ein Perlin-Störungsbild.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     Führt eine Pixelauflösung von einem Quellbild zu einem Zielbild oder anhand desselben Bilds durch.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Gibt an, ob die angegebene Eigenschaft vorhanden ist und durchlaufen werden kann.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Führt für ein Bild einen Bildlauf anhand eines bestimmten Pixelbetrags (x, y) durch.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Legt den Farbwert eines einzelnen Pixels eines BitmapData-Objekts fest.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Legt den Farb- und Alphatransparenzwert eines einzelnen Pixels eines BitmapData-Objekts fest.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Legt die Verfügbarkeit einer dynamischen Eigenschaft für Schleifenoperationen fest.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Konvertiert einen Vektor in einen rechteckigen Bereich mit Pixeldaten.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Prüft die Pixelwerte eines Bilds für einen angegebenen Schwellenwert und weist den Pixeln, die die Bedingung des Tests erfüllen, neue Farbwerte zu.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Gibt die Stringdarstellung dieses Objekts zurück, formatiert entsprechend den Konventionen des Gebietsschemas.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Gibt das angegebene Objekt als String zurück.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Entsperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z.&nbsp;B. Bitmap-Objekte, aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Gibt den Grundwert des angegebenen Objekts zurück.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Eigenschaftendetails</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">Eigenschaft</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Die Höhe der Bitmap in Pixel.
     
     </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Das Rechteck, das die Größe und Lage der Bitmap definiert. Der obere und linke Rand des Rechtecks liegen jeweils an der Position 0 (null). Die Werte für Breite und Höhe sind mit der Breite und Höhe des BitmapData-Objekts identisch.
     
     </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt. Sie können diesen Wert nur dann einstellen, wenn Sie beim Erstellen des BitmapData-Objekts den Wert <code>true</code> für den Parameter <code>transparent</code> des Konstruktors übergeben. Nachdem Sie ein BitmapData-Objekt erstellt haben, können Sie dieses Objekt auf die Unterstützung der Transparenz pro Pixel prüfen, indem Sie feststellen, ob die <code>transparent</code>-Eigenschaft auf <code>true</code> gesetzt ist.
     
     
     </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">Eigenschaft</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[schreibgeschützt] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Die Breite der Bitmap in Pixel.
     
     </p><br/><br/><span class="label"> Implementierung </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">Konstruktordetails</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Konstruktor</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     Erstellt ein neues BitmapData-Objekt mit der angegebenen Breite und Höhe. Wenn Sie einen Wert für den Parameter <code>fillColor</code> eingeben, wird jedes Pixel der Bitmap auf diese Farbe eingestellt.
     
     <p>In der Standardeinstellung wird die Bitmap als transparente Grafik erstellt, es sei denn, Sie übergeben für den Parameter <code>false</code> den Wert <code>transparent</code>. Eine als undurchsichtiges Bild erstellte Bitmap kann nicht mehr in eine transparente Bitmap umgewandelt werden. Jedes Pixel einer undurchsichtigen Bitmap verwendet nur 24 Bit der Farbkanaldaten. Wenn Sie eine Bitmap dagegen als transparent definieren, müssen für jedes Pixel, einschließlich der Alphatransparenzdaten, 32 Bit an Farbkanaldaten verwendet werden.</p>
     
     <p>In AIR 1.5 und Flash Player 10 beträgt die maximale Höhe oder Breite eines BitmapData-Objekts 8.191&nbsp;Pixel, die gesamte Pixelzahl darf 16.777.215 nicht übersteigen. (Wenn ein BitmapData-Objekt also 8.191&nbsp;Pixel breit ist, darf es nur 2.048&nbsp;Pixel hoch sein.) In Flash Player 9 und niedriger und AIR 1.1 und niedriger liegt die Grenze bei je 2.880&nbsp;Pixel Höhe und Breite. Falls Sie für „width“ oder „height“ höhere Werte als 2.880 angeben, wird keine neue Instanz erstellt.</p>
     
     </p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Die Breite der Bitmap in Pixel.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Die Höhe der Bitmap in Pixel.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Gibt an, ob die Bitmap Transparenz pro Pixel unterstützt. Der Standardwert lautet <code>true</code> (transparent). Um eine vollständig transparente Bitmap zu erstellen, setzen Sie den Wert des Parameters <code>transparent</code> auf <code>true</code> und den Wert des Parameters <code>fillColor</code> auf 0x00000000 (bzw. auf 0). Die Einstellung der <code>transparent</code>-Eigenschaft auf <code>false</code> kann eine leichte Verbesserung der Wiedergabe-Performance zur Folge haben. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; Ein 32-Bit-ARGB-Farbwert, der die Füllfarbe des Bitmap-Bereichs angibt. Der Standardwert lautet 0xFFFFFFFF (reines Weiß).
     
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Breite und/oder Höhe übersteigen die maximalen Abmessungen.
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Methodendetails</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Erstellt anhand eines Quellbilds und eines filter-Objekts das gefilterte Bild.
     
     <p>Diese Methode greift auf das Verhalten integrierter filter-Objekte zurück, mit deren Code das Zielrechteck bestimmt werden kann, das durch ein Eingabequellrechteck geändert wird.</p>
     
     <p>Nach dem Anwenden des Filters ist das Ergebnis unter Umständen größer als das Ausgangsbild. Wenn beispielsweise ein Eingabequellrechteck mit den Werten (50,50,100,100) und dem Zielpunkt (10,10) mithilfe einer BlurFilter-Klasse weichgezeichnet wird, wird der geänderte Bereich im Zielbild wegen der Weichzeichnung größer als (10,10,60,60). Dies geschieht intern während des Aufrufs von <code>applyFilter()</code>.</p>
     
     <p>Wenn der Parameter <code>sourceRect</code> des Parameters <code>sourceBitmapData</code> einen inneren Bereich wie (50,50,100,100) in einer Grafik der Größe 200 x 200 Pixel angibt, generiert der Filter das Zielrechteck anhand der Quellpixel außerhalb des Parameters <code>sourceRect</code>.</p>
     
     <p>Wenn es sich bei dem BitmapData-Objekt und dem als <code>sourceBitmapData</code>-Parameter festgelegten Objekt um dasselbe Objekt handelt, verwendet die Anwendung eine temporäre Kopie des Objekts, um den Filter anzuwenden. Die beste Performance erhalten Sie jedoch, wenn Sie diese Situation vermeiden.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Das filter-Objekt, mit dem die Filteroperation durchgeführt wird. Jeder Filtertyp hat bestimmte Grundvoraussetzungen, und zwar:
     
     <ul><li><b>BlurFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind. Sollten die Formate der Bilder nicht übereinstimmen, entspricht die Kopie des Quellbilds, die während der Filterung angelegt wird, dem Format des Zielbilds.</li><li><b>BevelFilter, DropShadowFilter, GlowFilter</b>: Das Zielbild dieser Filter muss ein transparentes Bild sein. Der Aufruf von „DropShadowFilter“ bzw. „GlowFilter“ erstellt ein Bild mit den Alphakanaldaten des Schlagschattens bzw. des Glühens. Er erstellt aber nicht den Schlagschatten auf dem Zielbild selbst. Werden diese Filter bei einem undurchsichtigen Zielbild angewendet, wird eine Ausnahme ausgelöst.</li><li><b>ConvolutionFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind.</li><li><b>ColorMatrixFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind.</li><li><b>DisplacementMapFilter</b>: Dieser Filter verwendet Quell- und Zielbilder, die entweder transparent oder undurchsichtig sind, aber die Formate der Quell- und Zielbilder müssen dabei identisch sein.</li></ul>
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“, „destPoint“ oder „filter“ haben den Wert null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; Die Transparenzwerte der BitmapData-Objekte sind nicht kompatibel mit der filter-Operation.
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus dem folgenden Beispiel geht hervor, wie Sie einen Weichzeichnungsfilter auf eine BitmapData-Instanz anwenden:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gibt ein neues BitmapData-Objekt zurück, das ein Klon der ursprünglichen Instanz ist, mit einer exakten Kopie der enthaltenen Bitmap.
     
     </p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; Ein mit dem Original identisches neues BitmapData-Objekt.
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt das Klonen einer BitmapData-Instanz. Außerdem zeigt es, dass sich das Original beim Ändern der geklonten BitmapData-Instanz nicht ändert:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Passt die Farbwerte in einem angegebenen Bereich einer Bitmap mithilfe eines <code>ColorTransform</code>-Objekts an. Falls das Rechteck mit den Begrenzungen der Bitmap übereinstimmt, wandelt diese Methode die Farbwerte des gesamten Bilds um.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteckobjekt, das den Bereich des Bilds definiert, auf den das ColorTransform-Objekt angewendet wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; Ein ColorTransform-Objekt, das die anzuwendenden Werte für die Farbtransformation beschreibt.
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „rect“ oder „colorTransform“ haben den Wert null.
      
      </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus dem folgenden Beispiel geht hervor, wie Sie eine Farbtransformation auf die linke Hälfte (Rechteck) eines BitmapData-Objekts anwenden:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     Vergleicht zwei BitmapData-Objekte. Besitzen die beiden BitmapData-Objekte dieselben Abmessungen (Breite und Höhe), gibt die Methode ein neues BitmapData-Objekt zurück, in dem jedes Pixel die „Differenz“ zwischen den Pixeln in den beiden Quellobjekten beschreibt:
     
     <ul><li>Sind zwei Pixel gleich, hat das Differenzpixel den Wert 0x00000000. </li><li>Besitzen zwei Pixel unterschiedliche RGB-Werte (ohne den Alphawert zu berücksichtigen), hat das Differenzpixel den Wert 0xRRGGBB, wobei RR/GG/BB die einzelnen Differenzwerte zwischen den Rot-, Grün- und Blaukanälen darstellen (Pixelwert im Quellobjekt minus Pixelwert im <code>otherBitmapData</code>-Objekt). Alphakanaldifferenzen werden in diesem Fall ignoriert. </li><li>Weist nur der Alphakanal einen anderen Wert auf, ist der Pixelwert 0x<i>ZZ</i>FFFFFF, wobei <i>ZZ</i> den Unterschied zwischen den Alphawerten darstellt (Alphawert im Quellobjekt minus Alphawert im <code>otherBitmapData</code>-Objekt).</li></ul>
     
     <p>Betrachten Sie beispielsweise die folgenden beiden BitmapData-Objekte:</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>Hinweis:</b> Die zum Füllen der beiden BitmapData-Objekte verwendeten Farben haben leicht abweichende RGB-Werte (0xFF0000 und 0xFFAA00). Das Ergebnis der <code>compare()</code>-Methode ist ein neues BitmapData-Objekt, in dem jedes Pixel die Abweichung zwischen den beiden Bitmaps in den RGB-Werten aufzeigt.</p>
     
     <p>Betrachten Sie die folgenden beiden BitmapData-Objekte, in denen die RGB-Farben gleich sind, der Alphawert aber unterschiedlich ist:</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p>Das Ergebnis der <code>compare()</code>-Methode ist ein neues BitmapData-Objekt, in dem jedes Pixel die Abweichung zwischen den beiden Bitmaps in den Alphawerten aufzeigt.</p>
     
     <p>Sind die beiden BitmapData-Objekte gleich (mit derselben Breite, Höhe und identischen Pixelwerten), gibt die Methode die Zahl 0 zurück.</p>
     
     <p>Wenn die Breiten der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -3 zurück. </p>
     
     <p>Ist die Höhe der beiden BitmapData-Objekte nicht gleich, dafür jedoch die Breite, gibt die Methode die Zahl -4 zurück.</p>
     
     <p>Das folgende Beispiel vergleicht zwei Bitmap-Objekte mit unterschiedlicher Breite (50 und 60):</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Das BitmapData-Objekt, das mit dem BitmapData-Quellobjekt verglichen werden soll.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; Besitzen die beiden BitmapData-Objekte dieselben Abmessungen (Breite und Höhe), gibt die Methode ein neues BitmapData-Objekt zurück, das den Unterschied zwischen den beiden Objekten enthält (siehe Hauptthema). Sind die BitmapData-Objekte gleich, gibt die Methode die Zahl 0 zurück. Wenn die Breiten der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -3 zurück. Wenn die Höhen der BitmapData-Objekte ungleich sind, gibt die Methode die Zahl -4 zurück. 
     
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „otherBitmapData“ hat den Wert null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt den Wert eines Pixels im BitmapData-Objekt, das sich aus dem Vergleich zweier BitmapData-Objekte mit gleichen Abmessungen ergibt:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Überträgt Daten innerhalb des aktuellen BitmapData-Objekts aus einem Kanal in einen anderen bzw. überträgt Daten in einen Kanal des aktuellen BitmapData-Objekts, die aus einem Kanal eines anderen BitmapData-Objekts stammen. Alle Daten der anderen Kanäle im BitmapData-Zielobjekt bleiben erhalten.
     
     <p>Die Einstellungen für den Quell- und Zielkanal können einen der folgenden Werte annehmen: </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf das aktuelle BitmapData-Objekt sein.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Das Quellrechteckobjekt. Um nur die Kanaldaten eines kleineren Bereichs innerhalb der Bitmap zu kopieren, geben Sie ein Quellrechteck an, das kleiner ist als das ganze BitmapData-Objekt. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Das Point-Zielobjekt, das die linke obere Ecke des Rechteckbereichs darstellt, in den die neuen Kanaldaten eingefügt werden. Um nur die Kanaldaten eines Bereichs im Zielbild in einen anderen Bereich dieses Zielbilds zu kopieren, geben Sie einen anderen Punkt als (0,0) an.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Der Quellkanal. Verwenden Sie einen Wert aus der BitmapDataChannel-Klasse (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Der Zielkanal. Verwenden Sie einen Wert aus der BitmapDataChannel-Klasse (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
      
      </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt, wie Sie den roten Kanal eines BitmapData-Objekts für einen Pixelbereich der Größe 20 x 20 in seinen blauen Kanal kopieren:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Bietet eine schnelle Routine zur Bearbeitung von Pixeln zwischen Bildern ohne Dehnung, Drehung oder Farbeffekte. Diese Methode kopiert einen Rechteckbereich eines Quellbilds in einen Rechteckbereich gleicher Größe an den Zielpunkt im BitmapData-Zielobjekt.
     
     <p>Wenn Sie auch die Parameter <code>alphaBitmap</code> und <code>alphaPoint</code> angeben, können Sie ein zweites Bild als Alphaquelle für das Quellbild verwenden. Verfügt auch das Quellbild über Alphadaten, werden die Alphadaten beider Bilder verwendet, um die Pixel des Quellbilds in das Zielbild zu projizieren. Der Parameter <code>alphaPoint</code> gibt dabei den Punkt innerhalb des Zielbilds an, der der linken oberen Ecke des Quellrechtecks entspricht. Sämtliche Pixel außerhalb des Überschneidungsbereichs von Quell- und Alphabild werden nicht in das Zielbild kopiert.</p>
     
     <p>Die <code>mergeAlpha</code>-Eigenschaft steuert, ob das Kopieren eines transparenten Bilds auf ein anderes transparentes Bild unter Berücksichtigung des Alphakanals durchgeführt wird. Um die Pixel mit Alphakanaldaten zu kopieren, setzen Sie die <code>mergeAlpha</code>-Eigenschaft auf <code>true</code>. In der Standardeinstellung hat die <code>mergeAlpha</code>-Eigenschaft den Wert <code>false</code>.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die Eingabe-Bitmap, aus der die Pixel kopiert werden sollen. Das Quellbild kann eine andere BitmapData-Instanz oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Zielpunkt, der die linke obere Ecke des Rechteckbereichs darstellt, in den die kopierten Pixel eingefügt werden.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; Ein zweites BitmapData-Objekt als Alphaquelle.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Der Punkt in der BitmapData-Objektquelle, der der linken oberen Ecke des <code>sourceRect</code>-Parameters entspricht.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Um den Alphakanal zu verwenden, setzen Sie den Wert auf <code>true</code>. Um die Pixel ohne Alphadaten zu kopieren, setzen Sie den Wert auf <code>false</code>.
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“, „destPoint“ haben den Wert null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt, wie Sie Pixel aus einem Pixelbereich der Größe 20 x 20 eines BitmapData-Objekts in ein anderes BitmapData-Objekt kopieren:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     Füllt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten. Beginnend beim <code>position</code>-Index des ByteArray, schreibt diese Methode für jedes Pixel eine vorzeichenlose Ganzzahl (einen nicht multiplizierten 32-Bit-Pixelwert) in das Bytearray. Falls erforderlich, wird die Größe des Bytearrays auf die erforderliche Anzahl Bytes erhöht, um alle Pixeldaten aufzunehmen.
           
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein rechteckiger Bereich im aktuellen BitmapData-Objekt
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; das ByteArray-Zielobjekt
     
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; wenn das <code>rect</code>-Argument <code>null</code> oder das <code>data</code>-Argument <code>null</code> ist
     
	 </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gibt Speicher frei, der zum Speichern des BitmapData-Objekts verwendet wird. 
     
     <p>Wenn die <code>dispose()</code>-Methode für ein Bild aufgerufen wird, werden Breite und Höhe des Bilds auf 0 gesetzt. Alle nachfolgenden Aufrufe von Methoden und Eigenschaften für diese BitmapData-Instanz schlagen fehl, und eine Ausnahme wird ausgelöst. </p>
     <p><code>BitmapData.dispose()</code> gibt den Arbeitsspeicher, der von den tatsächlichen Bitmapdaten belegt wird, sofort frei (ein Bitmap kann bis zu 64&nbsp;MB Arbeitsspeicher belegen). Nach der Verwendung von <code>BitmapData.dispose()</code> kann das BitmapData-Objekt nicht mehr verwendet werden und die Flash-Laufzeitumgebung gibt eine Ausnahme aus, wenn Sie Funktionen für das BitmapData-Objekt aufrufen. Mit <code>BitmapData.dispose()</code> wird jedoch nicht das BitmapData-Objekt (ca. 128 Byte) aus dem Speicher entfernt; der vom eigentlichen BitmapData-Objekt belegte Arbeitsspeicher wird frei, wenn das BitmapData-Objekt vom Garbage Collector aus dem Speicher entfernt wird.</p>
     
     </p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt, wie sich das Aufrufen einer Methode eines BitmapData-Objekts nach einem Aufruf der <code>dispose()</code>-Methode auswirkt (es wird eine Ausnahme ausgelöst):
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zeichnet das <code>source</code>-Anzeigeobjekt mithilfe des Vektorrenderers der Flash-Laufzeitumgebung auf das Bitmapbild. Sie können <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> und einen Zielparameter <code>clipRect</code> angeben, der steuert, wie das Rendern durchgeführt wird. Optional können Sie auch festlegen, ob die Bitmap beim Skalieren geglättet werden soll (dies funktioniert nur, wenn es sich beim Quellobjekt um ein BitmapData-Objekt handelt).
     
     <p><b>Hinweis: </b>Die <code>drawWithQuality()</code>-Methode funktioniert genauso wie die <code>draw()</code>-Methode, aber anstatt die <code>Stage.quality</code>-Eigenschaft zum Bestimmen der Qualität des Vektorrenderings zu verwenden, geben Sie den <code>quality</code>-Parameter für die <code>drawWithQuality()</code>-Methode an.</p>
      
     <p>Diese Methode entspricht der Einstellung des Zeichnungsverfahrens mithilfe des Standardvektorrenderers für Objekte in der Authoring-Umgebung.</p>
     
     <p>Das Quellanzeigeobjekt verwendet bei diesem Aufruf keines seiner angewendeten Transformationsverfahren. Es wird so verarbeitet, wie es in der Bibliothek oder Datei vorliegt. Dabei werden keine Matrix- oder Farbtransformationen durchgeführt und keine Mischmodi verwendet. Wenn Sie beim Zeichnen des Anzeigeobjekts (etwa eines Movieclips) seine eigenen Transformationseigenschaften verwenden möchten, können Sie das entsprechende <code>transform</code>-Eigenschaftsobjekt in die <code>transform</code>-Eigenschaft des Bitmap-Objekts kopieren, die das BitmapData-Objekt verwendet.</p>
     
     <p>Diese Methode wird in <span>Flash Player 9.0.115.0 und höher sowie in </span>Adobe AIR über RTMP unterstützt. Sie können den Zugriff auf Streams auf Flash Media Server in einem serverseitigen Skript steuern. Weitere Informationen finden Sie in den Abschnitten zu den Eigenschaften <code>Client.audioSampleAccess</code> und <code>Client.videoSampleAccess</code> in <a href="http://www.adobe.com/go/learn_flash_ss_as_de" target="external"> <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></a>.</p>
     
     <p>Wenn das source-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte nicht aus derselben Domäne wie der Aufrufer stammen oder sich nicht in Inhalt befinden, auf den der Aufrufer über einen Aufruf der <code>Security.allowDomain()</code>-Methode zugreifen kann, tritt bei einem Aufruf von <code>draw()</code> eine SecurityError-Ausnahme auf. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.</p>
     
     <p>Es gibt auch Beschränkungen für die Verwendung eines geladenen Bitmapbilds als <code>source</code>. Das Aufrufen der <code>draw()</code>-Methode ist erfolgreich, wenn das geladene Bild aus derselben Domäne stammt wie der Aufrufer. Des Weiteren kann eine domänenübergreifende Richtliniendatei auf dem Server des Bilds der Domäne des SWF-Inhalts, der die <code>draw()</code>-Methode aufruft, die Berechtigung erteilen. In diesem Fall setzen Sie die <code>checkPolicyFile</code>-Eigenschaft eines LoaderContext-Objekts und verwenden dieses Objekt als <code>context</code>-Parameter beim Aufrufen der <code>load()</code>-Methode des Loader-Objekts, das für das Laden des Bilds verwendet wird. Diese Sicherheitseinschränkungen gelten nicht für AIR-Inhalte in der Sicherheitssandbox der Anwendung.</p>
     
     <p>Unter Windows kann die <code>draw()</code>-Methode keinen SWF-Inhalt erfassen, der in einer HTML-Seite<span> in einem HTMLLoader-Objekt in Adobe AIR</span> eingebettet ist.</p>
     
     <p>Die <code>draw()</code>-Methode kann keinen PDF-Inhalt<span> in Adobe AIR</span> erfassen. Sie kann auch keinen in HTML eingebetteten SWF-Inhalt erfassen, bei dem das <code>wmode</code>-Attribut auf <code>"window"</code> gesetzt ist<span> in Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Das Anzeigeobjekt oder BitmapData-Objekt, das in das BitmapData-Objekt gezeichnet werden soll. (Die Klassen DisplayObject und BitmapData implementieren die IBitmapDrawable-Schnittstelle.)
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Matrix-Objekt, mit dem die Koordinaten der Bitmap skaliert, gedreht oder umgesetzt werden können. Wenn Sie auf das Bild keine Matrixtransformation anwenden möchten, setzen Sie diesen Parameter auf eine Identitätsmatrix, die mit dem Standardkonstruktor <code>new Matrix()</code> erstellt wurde, oder übergeben Sie einen <code>null</code>-Wert.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Ein ColorTransform-Objekt, mit dem die Farbwerte der Bitmap angepasst werden können. Falls kein Objekt vorhanden ist, findet keine Transformation der Bitmap-Farben statt. Wenn Sie diesen Parameter übergeben müssen, das Bild aber nicht transformieren möchten, setzen Sie diesen Parameter auf ein ColorTransform-Objekt, das mit dem Standardkonstruktor <code>new ColorTransform()</code> erstellt worden ist.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Ein String-Wert aus der flash.display.BlendMode-Klasse, der den Mischmodus festlegt, der auf die resultierende Bitmap angewendet werden soll. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Rechteckobjekt, das den Bereich des zu zeichnenden Quellobjekts definiert. Wenn Sie diesen Wert nicht angeben, wird das Bild nicht abgeschnitten, und das gesamte Quellobjekt wird gezeichnet.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Ein boolescher Wert, der festlegt, ob ein BitmapData-Objekt bei der Skalierung oder Drehung aufgrund einer Skalierung oder Drehung im Parameter <code>matrix</code> geglättet wird. Der Parameter <code>smoothing</code> ist nur anwendbar, wenn es sich beim Parameter <code>source</code> um ein BitmapData-Objekt handelt. Wenn <code>smoothing</code> auf <code>false</code> gesetzt ist, wirkt das gedrehte bzw. skalierte BitmapData-Bild grobkörnig oder ungeglättet. Die folgenden beiden Bilder verwenden z.&nbsp;B. beide das gleiche BitmapData-Objekt als <code>source</code>-Parameter, aber der Parameter <code>smoothing</code> ist links auf <code>true</code> und rechts auf <code>false</code> gesetzt:
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Zwei Bilder: das linke mit und das rechte ohne Glättung."></img></p>
     
     <p>Das Zeichnen einer Bitmap dauert länger, wenn <code>smoothing</code> auf <code>true</code> gesetzt ist, und geht schneller, wenn <code>smoothing</code> auf <code>false</code> gesetzt ist.</p>
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Beim <code>source</code>-Parameter handelt es sich nicht um ein BitmapData- oder DisplayObject-Objekt.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Das <code>source</code>-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte stammen nicht aus derselben Domäne wie der Aufrufer oder befinden sich nicht in Inhalt, auf den der Aufrufer über einen Aufruf der <code>Security.allowDomain()</code>-Methode zugreifen kann. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Die Quelle ist null oder kein zulässiges IBitmapDrawable-Objekt.
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus dem folgenden Beispiel geht hervor, wie Sie ein TextField-Objekt für ein BitmapData-Objekt zeichnen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Zeichnet das <code>source</code>-Anzeigeobjekt mithilfe des Vektorrenderers der Flash-Laufzeitumgebung auf das Bitmapbild. Sie können <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> und einen Zielparameter <code>clipRect</code> angeben, der steuert, wie das Rendern durchgeführt wird. Optional können Sie auch festlegen, ob die Bitmap beim Skalieren geglättet werden soll (dies funktioniert nur, wenn es sich beim Quellobjekt um ein BitmapData-Objekt handelt).
     
     <p><b>Hinweis: </b>Die <code>drawWithQuality()</code>-Methode funktioniert genauso wie die <code>draw()</code>-Methode, aber anstatt die <code>Stage.quality</code>-Eigenschaft zum Bestimmen der Qualität des Vektorrenderings zu verwenden, geben Sie den <code>quality</code>-Parameter für die <code>drawWithQuality()</code>-Methode an.</p>
      
     <p>Diese Methode entspricht der Einstellung des Zeichnungsverfahrens mithilfe des Standardvektorrenderers für Objekte in der Authoring-Umgebung.</p>
     
     <p>Das Quellanzeigeobjekt verwendet bei diesem Aufruf keines seiner angewendeten Transformationsverfahren. Es wird so verarbeitet, wie es in der Bibliothek oder Datei vorliegt. Dabei werden keine Matrix- oder Farbtransformationen durchgeführt und keine Mischmodi verwendet. Wenn Sie beim Zeichnen des Anzeigeobjekts (etwa eines Movieclips) seine eigenen Transformationseigenschaften verwenden möchten, können Sie das entsprechende <code>transform</code>-Eigenschaftsobjekt in die <code>transform</code>-Eigenschaft des Bitmap-Objekts kopieren, die das BitmapData-Objekt verwendet.</p>
     
     <p>Diese Methode wird in <span>Flash Player 9.0.115.0 und höher sowie in </span>Adobe AIR über RTMP unterstützt. Sie können den Zugriff auf Streams auf Flash Media Server in einem serverseitigen Skript steuern. Weitere Informationen finden Sie in den Abschnitten zu den Eigenschaften <code>Client.audioSampleAccess</code> und <code>Client.videoSampleAccess</code> in <a href="http://www.adobe.com/go/documentation_de" target="external"> <i>Server-Side ActionScript Language Reference for Adobe Flash Media Server</i></a>.</p>
     
     <p>Wenn das source-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte nicht aus derselben Domäne wie der Aufrufer stammen oder sich nicht in Inhalt befinden, auf den der Aufrufer über einen Aufruf der <code>Security.allowDomain()</code>-Methode zugreifen kann, tritt bei einem Aufruf von <code>drawWithQuality()</code> eine SecurityError-Ausnahme auf. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.</p>
     
     <p>Es gibt auch Beschränkungen für die Verwendung eines geladenen Bitmapbilds als <code>source</code>. Das Aufrufen der <code>drawWithQuality()</code>-Methode ist erfolgreich, wenn das geladene Bild aus derselben Domäne stammt wie der Aufrufer. Des Weiteren kann eine domänenübergreifende Richtliniendatei auf dem Server des Bilds der Domäne des SWF-Inhalts, der die <code>drawWithQuality()</code>-Methode aufruft, die Berechtigung erteilen. In diesem Fall setzen Sie die <code>checkPolicyFile</code>-Eigenschaft eines LoaderContext-Objekts und verwenden dieses Objekt als <code>context</code>-Parameter beim Aufrufen der <code>load()</code>-Methode des Loader-Objekts, das für das Laden des Bilds verwendet wird. Diese Sicherheitseinschränkungen gelten nicht für AIR-Inhalte in der Sicherheitssandbox der Anwendung.</p>
     
     <p>Unter Windows kann die <code>drawWithQuality()</code>-Methode keinen SWF-Inhalt erfassen, der in einer HTML-Seite<span> in einem HTMLLoader-Objekt in Adobe AIR</span> eingebettet ist.</p>
     
     <p>Die <code>drawWithQuality()</code>-Methode kann keinen PDF-Inhalt<span> in Adobe AIR</span> erfassen. Sie kann auch keinen in HTML eingebetteten SWF-Inhalt erfassen, bei dem das <code>wmode</code>-Attribut auf <code>"window"</code> gesetzt ist<span> in Adobe AIR</span>.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Das Anzeigeobjekt oder BitmapData-Objekt, das in das BitmapData-Objekt gezeichnet werden soll. (Die Klassen DisplayObject und BitmapData implementieren die IBitmapDrawable-Schnittstelle.)
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Matrix-Objekt, mit dem die Koordinaten der Bitmap skaliert, gedreht oder umgesetzt werden können. Wenn Sie auf das Bild keine Matrixtransformation anwenden möchten, setzen Sie diesen Parameter auf eine Identitätsmatrix, die mit dem Standardkonstruktor <code>new Matrix()</code> erstellt wurde, oder übergeben Sie einen <code>null</code>-Wert.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Ein ColorTransform-Objekt, mit dem die Farbwerte der Bitmap angepasst werden können. Falls kein Objekt vorhanden ist, findet keine Transformation der Bitmap-Farben statt. Wenn Sie diesen Parameter übergeben müssen, das Bild aber nicht transformieren möchten, setzen Sie diesen Parameter auf ein ColorTransform-Objekt, das mit dem Standardkonstruktor <code>new ColorTransform()</code> erstellt worden ist.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Ein String-Wert aus der flash.display.BlendMode-Klasse, der den Mischmodus festlegt, der auf die resultierende Bitmap angewendet werden soll. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Rechteckobjekt, das den Bereich des zu zeichnenden Quellobjekts definiert. Wenn Sie diesen Wert nicht angeben, wird das Bild nicht abgeschnitten, und das gesamte Quellobjekt wird gezeichnet.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Ein boolescher Wert, der festlegt, ob ein BitmapData-Objekt bei der Skalierung oder Drehung aufgrund einer Skalierung oder Drehung im Parameter <code>matrix</code> geglättet wird. Der Parameter <code>smoothing</code> ist nur anwendbar, wenn es sich beim Parameter <code>source</code> um ein BitmapData-Objekt handelt. Wenn <code>smoothing</code> auf <code>false</code> gesetzt ist, wirkt das gedrehte bzw. skalierte BitmapData-Bild grobkörnig oder ungeglättet. Die folgenden beiden Bilder verwenden z.&nbsp;B. beide das gleiche BitmapData-Objekt als <code>source</code>-Parameter, aber der Parameter <code>smoothing</code> ist links auf <code>true</code> und rechts auf <code>false</code> gesetzt:
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Zwei Bilder: das linke mit und das rechte ohne Glättung."></img></p>
     
     <p>Das Zeichnen einer Bitmap dauert länger, wenn <code>smoothing</code> auf <code>true</code> gesetzt ist, und geht schneller, wenn <code>smoothing</code> auf <code>false</code> gesetzt ist.</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Ein beliebiger Wert der StageQuality-Werte. Wählt die Anti-Aliasing-Qualität aus, die beim Zeichnen von Vektorgrafiken verwendet wird. 
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Beim <code>source</code>-Parameter handelt es sich nicht um ein BitmapData- oder DisplayObject-Objekt.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Das <code>source</code>-Objekt und (bei einem Sprite- oder MovieClip-Objekt) alle seine untergeordneten Objekte stammen nicht aus derselben Domäne wie der Aufrufer oder befinden sich nicht in Inhalt, auf den der Aufrufer über einen Aufruf der <code>Security.allowDomain()</code>-Methode zugreifen kann. Diese Einschränkung gilt nicht für AIR-Inhalt in der Sicherheits-Sandbox der Anwendung.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Die Quelle ist null oder kein zulässiges IBitmapDrawable-Objekt.
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus dem folgenden Beispiel geht hervor, wie Sie ein TextField-Objekt für ein BitmapData-Objekt zeichnen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Komprimiert dieses BitmapData-Objekt mit dem ausgewählten Komprimierungsalgorithmus und gibt ein neues ByteArray-Objekt zurück. Schreibt die resultierenden Daten optional in das angegebene ByteArray. Das <code>compressor</code>-Argument gibt den Kodierungsalgorithmus an und kann den Wert PNGEncoderOptions, JPEGEncoderOptions oder JPEGXREncoderOptions haben.
     
     <p>Im folgenden Beispiel wird ein BitmapData-Objekt unter Verwendung von JPEGEncoderOptions komprimiert:</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Der Bereich des BitmapData-Objekts, das komprimiert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; Der zu verwendende Komprimierungstyp. Gültige Werte sind: <code>flash.display.PNGEncoderOptions</code>, <code>flash.display.JPEGEncoderOptions</code> und <code>flash.display.JPEGXREncoderOptions</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; Das Ausgabe-ByteArray, das das kodierte Bild enthalten soll.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Ein ByteArray, das das kodierte Bild enthält.
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Füllt einen rechteckigen Pixelbereich mit der angegebenen ARGB-Farbe.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Der zu füllende rechteckige Bereich.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Der ARGB-Farbwert, mit dem der Bereich gefüllt werden soll. ARGB-Farben werden häufig in einem hexadezimalen Format dargestellt, z.&nbsp;B. 0xFF336699.
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „rect“ hat den Wert null.
      
      </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus dem folgenden Beispiel geht hervor, wie Sie einen rechteckigen Bereich eines BitmapData-Objekts blau füllen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Führt für ein Bild ausgehend von einer (<i>x</i>, <i>y</i>)-Koordinate einen Flood-Fill-Vorgang mit einer bestimmten Farbe durch. Die <code>floodFill()</code>-Methode ist mit dem Farbeimerwerkzeug verschiedener Mal- und Zeichenprogramme vergleichbar. Als Farbe wird eine ARGB-Farbe einschließlich Alpha- und Farbdaten angegeben.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>x</i>-Koordinate des Bilds.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>y</i>-Koordinate des Bilds.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Die ARGB-Farbe, die zum Füllen verwendet wird.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt, wie ein Bereich eines BitmapData-Objekts - also der Bereich, der die durch den Punkt <code>(10, 10)</code> definierten Pixel umgibt, in dem alle Farben mit der Farbe an diesem Punkt übereinstimmen - mit Rot gefüllt wird
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Bestimmt das Zielrechteck, auf das sich der Aufruf der <code>applyFilter()</code>-Methode auswirkt. Die Angaben beziehen sich auf ein BitmapData-Objekt, ein Quellrechteck und ein filter-Objekt.
     
     <p>So bezieht sich ein Weichzeichnungsfilter normalerweise auf einen Bereich, der größer als das ursprüngliche Bild ist. Ein 100 x 200 Pixel großes Bild, das mit einer normalen BlurFilter-Instanz mit dem Wert <code>blurX = blurY = 4</code> gefiltert wird, erzeugt ein Zielrechteck von <code>(-2,-2,104,204)</code>. Mit der <code>generateFilterRect()</code>-Methode können Sie die Größe des Zielrechtecks vorherbestimmen und die Größe des Zielbilds vor der Filterung entsprechend anpassen.</p>
     
     <p>Einige Filter schneiden das Zielrechteck entsprechend der Größe des Zielbilds aus. So wird beispielsweise bei einem inneren <code>DropShadow</code>-Objekt kein größeres Bild als das Quellbild erzeugt. In dieser API wird das BitmapData-Objekt als Quellbegrenzung und nicht als <code>rect</code>-Quellparameter verwendet.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Ein filter-Objekt, das zur Berechnung des Zielrechtecks verwendet wird.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Zielrechteck, das aus einem Bild, dem Parameter <code>sourceRect</code> und einem Filter berechnet wird.
     
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceRect“ oder „filter“ haben den Wert null.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Aus diesem Beispiel geht die Verwendung der <code>generateFilterRect()</code>-Methode hervor, mit der Sie den rechteckigen Bereich bestimmen, auf den sich ein Weichzeichnungsfilter auswirkt. Die Ergebnisse der <code>generateFilterRect()</code>-Methode werden über die <code>trace()</code>-Funktion ausgegeben:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> Beachten Sie, dass die <code>generateFilterRect()</code>-Methode den Filter nicht anwendet. Rufen Sie die <code>applyFilter()</code>-Methode auf, um den Filter anzuwenden. 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Legt einen rechteckigen Bereich fest, der entweder innerhalb der Bitmap alle Pixel einer bestimmten Farbe vollständig umschließt (wenn der Parameter <code>findColor</code> auf <code>true</code> gesetzt ist) oder alle Pixel vollständig umschließt, die die angegebene Farbe nicht enthalten (wenn der Parameter <code>findColor</code> auf <code>false</code> gesetzt ist). 
     
     <p>Wenn Sie beispielsweise mit einem Quellbild arbeiten und das Rechteck des Bilds bestimmen möchten, das Alphakanaldaten ungleich 0 (null) enthält, übergeben Sie <code>{mask: 0xFF000000, color: 0x00000000}</code> als Parameter. Ist der Parameter <code>findColor</code> auf <code>true</code> gesetzt, wird das gesamte Bild nach den Begrenzungen der Pixel durchsucht, für die <code>(value & mask) == color</code> gilt (wobei <code>value</code> dem Farbwert der Pixel entspricht). Ist der Parameter <code>findColor</code> auf <code>false</code> gesetzt, wird das gesamte Bild nach den Begrenzungen der Pixel durchsucht, für die <code>(value & mask) != color</code> gilt (wobei <code>value</code> dem Farbwert der Pixel entspricht). Wenn Sie also den weißen Bereich ermitteln möchten, der um ein Bild angeordnet ist, übergeben Sie <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code>, um nach der Begrenzung aller nicht-weißen Pixel zu suchen.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, der die Bits der zu berücksichtigenden ARGB-Farbe festlegt. Der Farbwert wird durch Verwendung des <code>&</code> (bitweises AND) mit diesem Hexadezimalwert kombiniert.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, der die ARGB-Farbe festlegt, die übereinstimmen soll (wenn <code>findColor</code> auf <code>true</code> gesetzt ist) bzw. <i>nicht</i> übereinstimmen soll (wenn <code>findColor</code> auf <code>false</code> gesetzt ist).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Wenn der Wert auf <code>true</code> gesetzt ist, werden die Begrenzungen eines bestimmten Farbwerts in einem Bild zurückgegeben. Wenn der Wert auf <code>false</code> gesetzt ist, werden die Begrenzungen der Bereiche zurückgegeben, in denen der betreffende Farbwert im Bild nicht vorkommt. 
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Der Bereich des Bilds, der die angegebene Farbe enthält. 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt erstellt, dessen Pixel in der oberen Hälfte rot sind. Als Nächstes wird die <code>getColorBoundsRect()</code>-Methode aufgerufen, um das Rechteck zu bestimmen, dessen Pixel rot sind (0xFF0000). Im nächsten Schritt wird dieselbe Methode aufgerufen, um das Rechteck zu bestimmen, dessen Pixel nicht rot sind (indem der Parameter <code>findColor</code> auf <code>false</code> gesetzt wird):
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gibt eine Ganzzahl zurück, die einen RGB-Pixelwert eines BitmapData-Objekts an einem bestimmten Punkt (<i>x</i>, <i>y</i>) darstellt. Die <code>getPixel()</code>-Methode gibt einen nicht multiplizierten Pixelwert zurück. Es werden keine Alphadaten zurückgegeben.
     
     <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>x</i>-Position eines Pixels.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>y</i>-Position eines Pixels.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Eine Zahl, die für den RGB-Pixelwert steht. Falls die <i>x</i>- und <i>y</i>-Koordinaten außerhalb der Bildbegrenzung liegen, gibt die Methode 0 (null) zurück. 
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt mit roter Füllung erstellt und anschließend die <code>getPixel()</code>-Methode verwendet, um den Farbwert des linken oberen Pixels zu bestimmen.
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Gibt einen ARGB-Farbwert zurück, der Alphakanal- und RGB-Daten enthält. Diese Methode ähnelt der <code>getPixel()</code>-Methode, die einen RGB-Farbwert ohne Alphakanaldaten zurückgibt.
     
     <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>x</i>-Position eines Pixels.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>y</i>-Position eines Pixels.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Eine Zahl, die einen ARGB-Pixelwert darstellt. Falls die <i>x</i>- und <i>y</i>-Koordinaten außerhalb der Bildbegrenzung liegen, wird 0 (null) zurückgegeben.
     
     </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt mit Farbfüllung erstellt und anschließend die <code>getPixel32()</code>-Methode verwendet, um den Farbwert des linken oberen Pixels zu bestimmen. Danach werden die hexadezimalen Werte für die einzelnen Farbkomponenten (Alpha, Rot, Grün und Blau) bestimmt:
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten. Schreibt eine vorzeichenlose Ganzzahl (ein nicht multiplizierter 32-Bit-Pixelwert) für jedes Pixel in das Byte-Array.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein rechteckiger Bereich im aktuellen BitmapData-Objekt.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Ein Byte-Array, das die Pixel im gegebenen Rechteck repräsentiert.
     
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „rect“ hat den Wert null.
      
      </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt mit zufälligen Störungspixeln erstellt und anschließend die <code>getPixels()</code>-Methode verwendet, um ein ByteArray-Objekt mit den Pixelwerten des BitmapData-Objekts zu füllen.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Erzeugt ein Vektor-Array aus einem rechteckigen Bereich mit Pixeldaten. Gibt ein Vector-Objekt aus vorzeichenlosen Ganzzahlen (ein nicht multiplizierter 32-Bit-Pixelwert) für das angegebene Rechteck zurück.
     
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein rechteckiger Bereich im aktuellen BitmapData-Objekt.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Ein Vektor, der das Rechteck darstellt.
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „rect“ hat den Wert null.
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Berechnet ein Histogramm mit 256 Binärzahlwerten für ein BitmapData-Objekt. Diese Methode gibt ein Vector-Objekt zurück, das vier Vector.&lt;Number>-Instanzen enthält (vier Vector-Objekte, die Number-Objekte enthalten). Die vier Vector-Instanzen stellen die rote, grüne, blaue und Alphakomponente in dieser Reihenfolge dar. Jede Vector-Instanz enthält 256 Werte, die die Zählung eines einzelnen Komponentenwerts zwischen 0 und 255 enthalten.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Der Bereich des BitmapData-Objekts, der verwendet wird.
      
      </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Führt zwischen einer Bitmap und einem Punkt, einem Rechteck oder einer anderen Bitmap eine Kollisionserkennung auf Pixelebene durch. Eine Kollision ist als Überlappung eines Punkts oder Rechtecks mit einem undurchsichtigen Pixel oder als Überlappung zweier undurchsichtiger Pixel definiert. Bei dieser Kollisionserkennung werden keine Dehnungen, Drehungen oder anderen Transformationen der Objekte berücksichtigt. 
     
     <p>Handelt es sich bei einem Bild um ein undurchsichtiges Bild, wird es bei dieser Methode als vollständig undurchsichtiges Rechteck betrachtet. Beide Bilder müssen transparent sein, damit eine Kollisionserkennung auf Pixelebene durchgeführt werden kann, bei der die Transparenz berücksichtigt wird. Wenn Sie zwei transparente Bilder testen, steuern die Parameter für die Alphaschwellen, welche Alphakanalwerte zwischen 0 und 255 als undurchsichtig betrachtet werden.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  Eine Position in der linken oberen Ecke des BitmapData-Bilds in einem beliebigen Koordinatenraum. Derselbe Koordinatenraum wird beim Definieren des Parameters <code>secondBitmapPoint</code> verwendet.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Der niedrigste Alphakanalwert, der für diese Kollisionserkennung als undurchsichtig gewertet wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Ein Rectangle-, Point-, Bitmap- oder BitmapData-Objekt.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Punkt, der die Position eines Pixels im zweiten BitmapData-Objekt angibt. Sie sollten diesen Parameter nur verwenden, wenn der Wert von <code>secondObject</code> ein BitmapData-Objekt ist.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; Der niedrigste Alphakanalwert, der im zweiten BitmapData-Objekt als undurchsichtig gewertet wird. Sie sollten diesen Parameter nur verwenden, wenn der Wert von <code>secondObject</code> ein BitmapData-Objekt ist und beide BitmapData-Objekte transparent sind.
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; Es gilt <code>true</code>, wenn eine Kollisionserkennung stattfindet, andernfalls gilt <code>false</code>.
        
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Der Parameter <code>secondObject</code> ist kein Point-, Rectangle-, Bitmap- oder BitmapData-Objekt.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „firstPoint“ hat den Wert null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt erstellt, das nur in einem rechteckigen Bereich (20, 20, 40, 40) undurchsichtig ist und die <code>hitTest()</code>-Methode mit einem Point-Objekt als <code>secondObject</code> aufruft. Beim ersten Aufruf definiert das Point-Objekt die obere linke Ecke des BitmapData-Objekts, die nicht undurchsichtig ist, und im zweiten Aufruf definiert das Point-Objekt den Mittelpunkt des BitmapData-Objekts, der undurchsichtig ist.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Sperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z.&nbsp;B. Bitmap-Objekte, nicht aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert. Um die Performance zu verbessern, verwenden Sie diese Methode zusammen mit der <code>unlock()</code>-Methode vor und nach mehreren Aufrufen der Methode <code>setPixel()</code> oder <code>setPixel32()</code>.
     
     </p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt basierend auf der <code>bitmapData</code>-Eigenschaft eines Bitmap-Objekts (<code>picture</code>) erstellt. Das Objekt ruft dann die <code>lock()</code>-Methode auf, bevor eine komplizierte benutzerdefinierte Funktion (<code>complexTransformation()</code>) aufgerufen wird, die das BitmapData-Objekt ändert. (Das <code>picture</code>-Objekt und die <code>complexTransformation()</code>-Funktion sind in diesem Beispiel nicht definiert.) Auch wenn die <code>complexTransformation()</code>-Funktion die <code>bitmapData</code>-Eigenschaft des <code>picture</code>-Objekts aktualisiert, werden die Änderungen erst wirksam, wenn der Code die <code>unlock()</code>-Methode des <code>bitmapData</code>-Objekts aufruft:
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Führt von einem Quellbild zu einem Zielbild eine Mischung pro Kanal durch. Für jeden Kanal und jedes Pixel wird ein neuer Wert berechnet. Dieser basiert auf den Kanalwerten der Quell- und Zielpixel. Im roten Kanal wird der neue Wert zum Beispiel wie folgt berechnet (wobei <code>redSrc</code> der Wert des roten Kanals für ein Pixel im Quellbild ist und <code>redDest</code> der Wert des roten Kanals für das entsprechende Pixel im Zielbild): 
     <p>
     <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p>Die Werte <code>redMultiplier</code>, <code>greenMultiplier</code>, <code>blueMultiplier</code> und <code>alphaMultiplier</code> sind die für die einzelnen Farbkanäle verwendeten Multiplikatoren. Verwenden Sie einen Hexadezimalwert zwischen <code>0</code> und <code>0x100</code> (256), wobei <code>0</code> festlegt, dass der volle Wert aus dem Ziel im Ergebnis verwendet wird, <code>0x100</code> festlegt, dass der volle Wert aus der Quelle verwendet wird, und Zahlen dazwischen festlegen, dass eine Mischung verwendet wird (zum Beispiel <code>0x80</code> für 50&nbsp;%).</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf das aktuelle BitmapData-Objekt sein.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, mit dem der Wert des Farbkanals Rot multipliziert wird. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, mit dem der Wert des Farbkanals Grün multipliziert wird. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, mit dem der Wert des Farbkanals Blau multipliziert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Ein Hexadezimalwert, mit dem der Alphatransparenzwert multipliziert wird.
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel werden zwei neue BitmapData-Objekte erstellt. Beide haben eine Größe von 100 x 80 Pixel. Das erste Objekt ist grün gefüllt, und das zweite Objekt ist rot gefüllt. Der Code ruft die <code>merge()</code>-Methode auf und führt die Pixel des zweiten BitmapData-Objekts mit den Pixeln des ersten BitmapData-Objekts zusammen. Dieser Schritt wird jedoch nur für einen angegebenen rechteckigen Bereich durchgeführt:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Füllt ein Bild mit Pixeln, die zufällige Störungen darstellen.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Der zu verwendende Anfangswert für den Zufallsgenerator. Wenn Sie alle anderen Parameter beibehalten, können Sie nur durch Änderung dieses Anfangswerts unterschiedliche pseudo-zufällige Ergebnisse erzielen. Bei der Störungsfunktion handelt es sich nicht um einen echten Zufallszahlengenerator, sondern eher um eine Zuordnungsfunktion, die mit gleich bleibendem Anfangswert immer dasselbe Ergebnis liefert.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Der niedrigste zu erzeugende Wert für jeden Kanal (0 bis 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; Der höchste zu erzeugende Wert für jeden Kanal (0 bis 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; Eine Zahl als beliebige Kombination der vier Farbkanalwerte (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> und <code>BitmapDataChannel.ALPHA</code>). Sie können die Kanalwerte auch mithilfe des logischen OR-Operators (<code>|</code>) kombinieren. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Ein boolescher Wert. Ist der Wert <code>true</code>, wird durch die Einstellung aller Farbkanäle auf den gleichen Wert ein Graustufenbild erstellt. Der Wert des Alphakanals ist von der Einstellung dieses Parameters auf <code>true</code> nicht betroffen. 
     
     </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel werden zwei BitmapData-Objekte erstellt, für die jeweils die <code>noise()</code>-Methode aufgerufen wird. Der Parameter <code>grayscale</code> wird jedoch auf <code>false</code> gesetzt, um den Aufruf der <code>noise()</code>-Methode des ersten Objekts durchzuführen, und er wird auf <code>true</code> gesetzt, um den Aufruf der <code>noise()</code>-Methode des zweiten Objekts durchzuführen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ordnet die Farbkanalwerte in einem Bild mit maximal vier Arrays von Farbpalettendaten neu zu, wobei die einzelnen Arrays jeweils einen Kanal darstellen. 
     
     <p>Flash-Laufzeitumgebungen verwenden die folgenden Schritte, um das resultierende Bild zu erzeugen:</p>
     
     <ol><li>Nach der Berechnung der einzelnen Werte für Rot, Grün, Blau und Alpha werden diese mithilfe einer standardisierten 32-Bit-Ganzzahlarithmetik addiert. </li><li>Die Kanalwerte jedes Pixels für Rot, Grün, Blau und Alpha werden in einzelne Werte zwischen 0 und 255 extrahiert. Mithilfe dieser Werte werden dann die neuen Farbwerte im entsprechenden Array ermittelt: <code>redArray</code>, <code>greenArray</code>, <code>blueArray</code> und <code>alphaArray</code>. Jedes dieser vier Arrays sollte 256 Werte enthalten. </li><li>Nach der Ermittlung der neuen Kanalwerte werden diese in einem ARGB-Standardwert zusammengefasst, der auf das Pixel angewendet wird.</li></ol>
     
     <p>Mit dieser Methode können auch kanalübergreifende Effekte unterstützt werden. Jedes Eingabe-Array kann dabei vollständige 32-Bit-Werte enthalten, und beim Addieren der Werte treten keine Verschiebungen auf. Allerdings unterstützt diese Routine keine Festsetzung pro Kanal. </p>
     
     <p>Wird für einen Kanal kein Array angegeben, wird der Farbkanal vom Quellbild in das Zielbild kopiert.</p>
     
     <p>Diese Methode kann für eine ganze Reihe von Effekten genutzt werden, wie zum Beispiel eine allgemeine Palettenzuordnung (Auswählen einzelner Kanäle und deren Umwandlung in ein Falschfarbenbild). Sie können diese Methode auch für eine Reihe von komplexen Farbänderungsalgorithmen verwenden, z.&nbsp;B. Gamma, Kurven, Ebenen und Quantisierung.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Punkt innerhalb des Zielbilds (das aktuelle BitmapData-Objekt), der der linken oberen Ecke des Quellrechtecks entspricht.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Wenn <code>redArray</code> nicht <code>null</code> ist, gilt <code>red = redArray[source red value] else red = source rect value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Wenn <code>greenArray</code> nicht <code>null</code> ist, gilt <code>green = greenArray[source green value] else green = source green value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Wenn <code>blueArray</code> nicht <code>null</code> ist, gilt <code>blue = blueArray[source blue value] else blue = source blue value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Wenn <code>alphaArray</code> nicht <code>null</code> ist, gilt <code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>.
     
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein grünes BitmapData-Objekt mit rotem Mittelquadrat erstellt und anschließend die <code>paletteMap()</code>-Methode verwendet, um in der unteren rechteckigen Hälfte des BitmapData-Objekts Rot durch Grün zu ersetzen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Erstellt ein Perlin-Störungsbild.
     
     <p>Der Perlin-Störungsalgorithmus interpoliert und kombiniert mehrere zufällige als Oktaven bezeichnete Störungsfunktionen in einer Funktion, die natürlicher wirkende Zufallsstörungen erzeugt. Genau wie in der Musik weist auch hier jede Oktavenfunktion die doppelte Frequenz der jeweils untergeordneten Oktave auf. Die Perlin-Störungen werden als „Fraktalsumme der Störungen“ bezeichnet, da sie mehrere Arten von Störungsdaten unterschiedlicher Detailstufen zusammenfassen.</p>
     
     <p>Durch Anwendung von Perlin-Störungsfunktionen können Naturphänomene und Landschaften simuliert werden, wie Holzmaserung, Wolken oder Bergketten. Zumeist werden die Ergebnisse einer Perlin-Störungsfunktion nicht direkt angezeigt, sondern dienen zur Optimierung anderer Bilder sowie zum Erzeugen von pseudo-zufälligen Variationen.</p>
     
     <p>Einfache digital-zufällige Störungsfunktionen produzieren häufig Bilder mit scharfen Kontrasten, die in der Natur aber nicht allzu häufig vorkommen. Der Perlin-Störungsalgorithmus arbeitet mit einer Überlagerung von mehreren Störungsfunktionen mit unterschiedlicher Detailstufe und erzielt damit glattere Werteänderungen bei benachbarten Pixeln.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; Häufigkeit der Verwendung in <i>x</i>-Richtung. Übergeben Sie zur Erstellung einer Störung für ein Bild der Größe 64 x 128 Pixel als <code>baseX</code>-Wert beispielsweise die Zahl 64. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; Häufigkeit der Verwendung in <i>y</i>-Richtung. Übergeben Sie zur Erstellung einer Störung für ein Bild der Größe 64 x 128 Pixel als <code>baseY</code>-Wert beispielsweise die Zahl 128. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; Anzahl der Oktaven bzw. einzelnen Störungsfunktionen die zur Erstellung der Störung kombiniert werden. Größere Anzahlen führen zur Erstellung von detaillierteren Bildern. Allerdings benötigen größere Oktavenanzahlen auch mehr Verarbeitungszeit.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Der zu verwendende Anfangswert für den Zufallsgenerator. Wenn Sie alle anderen Parameter beibehalten, können Sie nur durch Änderung dieses Anfangswerts unterschiedliche pseudo-zufällige Ergebnisse erzielen. Bei der Perlin-Störungsfunktion handelt es sich nicht um einen echten Zufallszahlengenerator, sondern eher um eine Zuordnungsfunktion, die mit gleich bleibendem Anfangswert immer dasselbe Ergebnis liefert.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Ein boolescher Wert. Ist der Wert <code>true</code>, werden die Übergänge des Bilds geglättet, um einen nahtlosen Texturenübergang für Füllmuster zu erstellen, mit denen Bitmaps gefüllt werden können.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Ein boolescher Wert. Ist der Wert <code>true</code>, wird eine fraktale Störung erzeugt, ansonsten eine Turbulenz. In einem Bild mit Turbulenzen gibt es sichtbare Bruchstellen in den Farbverläufen, die sich gut für scharf abgegrenzte visuelle Effekte eignen, wie Flammen oder Wellen.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  Eine Zahl als beliebige Kombination der vier Farbkanalwerte (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> und <code>BitmapDataChannel.ALPHA</code>). Sie können die Kanalwerte auch mithilfe des logischen OR-Operators (<code>|</code>) kombinieren.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Ein boolescher Wert. Ist der Wert <code>true</code>, wird durch die Einstellung aller Werte für Rot, Grün und Blau auf den gleichen Wert ein Graustufenbild erstellt. Der Wert von Alpha ist nicht betroffen, wenn dieser Wert auf <code>true</code> gesetzt ist.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Ein Array von Punkten, die dem <i>x</i>- und <i>y</i>-Offset jeder einzelnen Oktave entsprechen. Durch Änderung der Offset-Werte können Sie bei perlinNoise-Bildern glatte Ebenenübergänge erzielen. Jeder Punkt im Offset-Array bezieht sich auf eine bestimmte Oktavenstörfunktion.
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt der Größe 200 x 200 Pixel erstellt, das die <code>perlinNoise()</code>-Methode aufruft, um einen roten und blauen Wasserfarbeneffekt zu erzielen:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Führt eine Pixelauflösung von einem Quellbild zu einem Zielbild oder anhand desselben Bilds durch. Flash-Laufzeitumgebungen verwenden einen <code>randomSeed</code>-Wert, um eine zufällige Pixelauflösung zu erzeugen. Der Rückgabewert dieser Funktion muss bei nachfolgenden Aufrufen übergeben werden, um die Pixelauflösung bis zum Ende beizubehalten.
     
     <p>Stimmen Quell- und Zielbild nicht überein, werden die Pixel vom Quellbild mit all ihren Eigenschaften in das Zielbild kopiert. Dieser Vorgang ermöglicht das Anfüllen mit Pixeln von einem leeren Bild zu einem vollständig ausgefüllten Bild.</p>
     
     <p>Falls das Quell- und das Zielbild identisch sind, werden die Pixel mit dem Parameter <code>color</code> gefüllt. Dieser Vorgang ermöglicht ein Auflösen eines vollständig angefüllten Bilds. In diesem Modus wird der Zielparameter <code>point</code> ignoriert.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Der Anfangswert des Zufallsgenerators für die Pixelauflösung. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Der Standardwert beträgt 1/30 des Quellbereichs (Breite x Höhe).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Ein ARGB-Farbwert, mit dem Sie die Pixel anfüllen können, deren Quellwerte mit den Zielwerten übereinstimmen. 
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; Der neue Anfangswert für den Zufallsgenerator für nachfolgende Aufrufe.
     
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“ oder „destPoint“ haben den Wert null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Der Wert von „numPixels“ ist negativ.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird mithilfe der <code>pixelDissolve()</code>-Methode ein graues BitmapData-Objekt durch Auflösung in Schritten von je 40 Pixeln in ein rotes Objekt umgewandelt, bis die Farbe aller Pixel geändert wurde:
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Führt für ein Bild einen Bildlauf anhand eines bestimmten Pixelbetrags (<i>x</i>, <i>y</i>) durch. Die Randzonen außerhalb des Bildlaufbereichs bleiben unverändert.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Der Betrag, um den ein horizontaler Bildlauf durchgeführt werden soll.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Der Betrag, um den ein vertikaler Bildlauf durchgeführt werden soll.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Das folgende Beispiel zeigt die Auswirkung eines Bildlaufs für ein BitmapData-Objekt um 40 Pixel nach rechts:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Legt den Farbwert eines einzelnen Pixels eines BitmapData-Objekts fest. Der aktuelle Alphakanalwert des Bildpixels bleibt während dieses Vorgangs erhalten. Der Wert des RGB-Farbparameters wird als nicht multiplizierter Farbwert angesehen.
     
     <p><b>Hinweis:</b> Um die Performance zu verbessern, wenn Sie die Methode <code>setPixel()</code> oder <code>setPixel32()</code> wiederholt verwenden, rufen Sie die <code>lock()</code>-Methode auf, bevor Sie die Methode <code>setPixel()</code> oder <code>setPixel32()</code> aufrufen. Rufen Sie anschließend die <code>unlock()</code>-Methode auf, nachdem Sie alle Pixeländerungen vorgenommen haben. Dieser Vorgang verhindert, dass Objekte, die auf diese BitmapData-Instanz verweisen, erst aktualisiert werden, wenn Sie die Pixeländerungen abgeschlossen haben.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>x</i>-Position des Pixels, dessen Wert geändert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>y</i>-Position des Pixels, dessen Wert geändert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Die resultierende RGB-Farbe für das Pixel. 
     
     </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird mithilfe der <code>setPixel()</code>-Methode in einem BitmapData-Objekt eine rote Linie gezeichnet:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Legt den Farb- und Alphatransparenzwert eines einzelnen Pixels eines BitmapData-Objekts fest. Diese Methode ähnelt der <code>setPixel()</code>-Methode. Der Hauptunterschied besteht darin, dass die <code>setPixel32()</code>-Methode einen ARGB-Farbwert mit Alphakanaldaten als Eingabe benötigt.
     
     <p>Sämtliche Pixel eines BitmapData-Objekts werden als vormultiplizierte Farbwerte gespeichert. Bei diesen vormultiplizierten Bildpixeln sind die Farbkanalwerte für Rot, Grün und Blau bereits mit den Alphadaten multipliziert worden. Wenn also beispielsweise der Alphawert 0 (null) ist, lauten die Werte der RGB-Kanäle, unabhängig von ihren ursprünglichen Werten, ebenfalls 0 (null). Bei bestimmten Vorgängen kann dieser Datenverlust zu Problemen führen. Alle BitmapData-Methoden akzeptieren nicht multiplizierte Werte und geben diese auch zurück. Vor der Rückgabe der Werte wird die interne Pixeldarstellung von vormultipliziert in nicht multipliziert konvertiert. Vor dem Einstellen der Pixelrohdaten des Bilds wird der Pixelwert im Verlauf einer set-Operation vormultipliziert.</p>
     
     <p><b>Hinweis:</b> Um die Performance zu verbessern, wenn Sie die Methode <code>setPixel()</code> oder <code>setPixel32()</code> wiederholt verwenden, rufen Sie die <code>lock()</code>-Methode auf, bevor Sie die Methode <code>setPixel()</code> oder <code>setPixel32()</code> aufrufen. Rufen Sie anschließend die <code>unlock()</code>-Methode auf, nachdem Sie alle Pixeländerungen vorgenommen haben. Dieser Vorgang verhindert, dass Objekte, die auf diese BitmapData-Instanz verweisen, erst aktualisiert werden, wenn Sie die Pixeländerungen abgeschlossen haben.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>x</i>-Position des Pixels, dessen Wert geändert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Die <i>y</i>-Position des Pixels, dessen Wert geändert wird.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Die resultierende ARGB-Farbe für das Pixel. Ist die Bitmap undurchsichtig (also nicht transparent), wird der Alphatransparenzwert in diesem Farbwert ignoriert.
     
     </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird mithilfe der <code>setPixel32()</code>-Methode in einem BitmapData-Objekt eine transparente rote Linie gezeichnet (alpha == 0x60):
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Erzeugt ein Byte-Array aus einem rechteckigen Bereich mit Pixeldaten. Für jedes Pixel wird die <code>ByteArray.readUnsignedInt()</code>-Methode aufgerufen, und der Rückgabewert wird in das Pixel geschrieben. Endet das Byte-Array, bevor das gesamte Rechteck geschrieben ist, gibt die Funktion den Wert zurück. Im Byte-Array werden als Daten 32-Bit-ARGB-Pixelwerte erwartet. Bevor oder nachdem die Pixel gelesen werden, wird im Byte-Array keine Suche durchgeführt.  
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Legt den rechteckigen Bereich des BitmapData-Objekts fest.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Ein ByteArray-Objekt, das aus nicht multiplizierten 32-Bit-Pixelwerten besteht, die im rechteckigen Bereich verwendet werden sollen.
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; Das <code>inputByteArray</code>-Objekt enthält nicht genügend Daten, um den Bereich des <code>rect</code>-Rechtecks zu füllen. Die Methode füllt so viele Pixel wie möglich, bevor die Ausnahme ausgelöst wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „rect“ oder „inputByteArray“ haben den Wert null.
      
      </td></tr></table><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel werden mit den Methoden <code>getPixels()</code> und <code>setPixels()</code> Pixel aus einem BitmapData-Objekt in ein anderes kopiert:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Konvertiert einen Vektor in einen rechteckigen Bereich mit Pixeldaten. Pro Pixel wird ein Vector-Element gelesen und in das BitmapData-Pixel geschrieben. Im Vector werden als Daten 32-Bit-ARGB-Pixelwerte erwartet. 
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Legt den rechteckigen Bereich des BitmapData-Objekts fest.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Ein Vector-Objekt, das aus nicht multiplizierten 32-Bit-Pixelwerten besteht, die im rechteckigen Bereich verwendet werden.  
     
     </td></tr></table></p><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Das Vectorarray ist nicht groß genug, um alle Pixeldaten zu lesen.
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Prüft die Pixelwerte eines Bilds für einen angegebenen Schwellenwert und weist den Pixeln, die die Bedingung des Tests erfüllen, neue Farbwerte zu. Mithilfe der <code>threshold()</code>-Methode können Sie in einem Bild ganze Farbbereiche isolieren und ersetzen sowie andere logische Operationen auf Bildpixel anwenden. 
     
     <p>Die Testlogik der <code>threshold()</code>-Methode lautet wie folgt:</p> 
     
     <ol><li>Wenn <code>((pixelValue & mask) operation (threshold & mask))</code> gilt, wird das Pixel auf <code>color</code> gesetzt.</li><li>Wenn hingegen <code>copySource == true</code> gilt, wird das Pixel auf den entsprechenden Pixelwert aus <code>sourceBitmap</code> gesetzt.</li></ol>
     
     <p>Der Parameter <code>operation</code> gibt den Vergleichsoperator für den Schwellentest an. Wenn Sie beispielsweise „==“ als <code>operation</code>-Parameter eingeben, können Sie in einem Bild eine Farbe mit einem bestimmten Wert isolieren. Oder wenn Sie <code>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</code> verwenden, können Sie alle Pixel im Zielbild auf vollständig transparent einstellen, wenn der Alphawert des Quellbildpixels kleiner als 0x7F ist. Sie können dieses Verfahren für animierte Übergänge und andere Effekte verwenden.</p>
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Die als Eingabe verwendete Bitmap. Das Quellbild kann ein anderes BitmapData-Objekt oder ein Verweis auf die aktuelle BitmapData-Instanz sein.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Ein Rechteck, mit dem der Bereich des als Eingabe zu verwendenden Quellbilds definiert wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Der Punkt innerhalb des Zielbilds (die aktuelle BitmapData-Instanz), der der linken oberen Ecke des Quellrechtecks entspricht.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; Einer der folgenden Vergleichsoperatoren, der als String übergeben wird: „&lt;“, „&lt;=“, „>“, „>=“, „==“, „!=“
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Der Wert, auf den jedes Pixel geprüft wird, um festzustellen, ob der Schwellenwert eingehalten oder überschritten wird.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Der Farbwert, auf den ein Pixel gesetzt wird, falls der Schwellentest erfolgreich ist. Der Standardwert lautet 0x00000000.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; Die Maske, die zum Isolieren einer Farbkomponente verwendet wird. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Lautet der Wert <code>true</code>, werden Pixelwerte aus dem Quellbild auch in das Zielobjekt kopiert, wenn der Schwellentest fehlschlägt. Lautet der Wert <code>false</code>, wird das Quellbild nicht kopiert, wenn der Schwellentest fehlschlägt. 
     
     </td></tr></table></p><p></p><span class="label">Rückgabewerte</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Die Anzahl der geänderten Pixel.
     </td></tr></table><br/><span class="label">Auslöser</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; „sourceBitmapData“, „sourceRect“, „destPoint“ oder „operation“ haben den Wert null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Der operation-String ist keine zulässige Operation. 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird mithilfe der <code>perlinNoise()</code>-Methode einem BitmapData-Objekt ein blaues und rotes Muster hinzugefügt und anschließend die <code>threshold()</code>-Methode verwendet, um die entsprechenden Pixel aus dem ersten BitmapData-Objekt in ein zweites Objekt zu kopieren. Dabei werden die Pixel, bei denen der Rotwert größer als 0x80 (50&nbsp;%) ist, durch ein Pixel mit transparentem Rot (0x20FF0000) ersetzt:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Methode</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Sprachversion:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Laufzeitversionen:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Entsperrt ein Bild, sodass Objekte, die auf das BitmapData-Objekt verweisen, z.&nbsp;B. Bitmap-Objekte, aktualisiert werden, wenn sich dieses BitmapData-Objekt ändert. Um die Performance zu verbessern, verwenden Sie diese Methode zusammen mit der <code>lock()</code>-Methode vor und nach mehreren Aufrufen der Methode <code>setPixel()</code> oder <code>setPixel32()</code>.
     
     </p><p><span class="label"> Parameter </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Der Bereich des BitmapData-Objekts, der sich geändert hat. Wenn Sie für diesen Parameter keinen Wert angeben, wird der gesamte Bereich des BitmapData-Objekts als geändert betrachtet. Dieser Parameter erfordert Flash Player 9.0.115.0 oder höher.
     
     </td></tr></table></p><p><span class="label">Verwandte API-Elemente</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Beispiel &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span>)
            </span><br/><br/><div class="detailBody"> Im folgenden Beispiel wird ein BitmapData-Objekt basierend auf der <code>bitmapData</code>-Eigenschaft eines Bitmap-Objekts (<code>picture</code>) erstellt. Das Objekt ruft dann die <code>lock()</code>-Methode auf, bevor eine komplizierte benutzerdefinierte Funktion (<code>complexTransformation()</code>) aufgerufen wird, die das BitmapData-Objekt ändert. (Das <code>picture</code>-Objekt und die <code>complexTransformation()</code>-Funktion sind in diesem Beispiel nicht definiert.) Auch wenn die <code>complexTransformation()</code>-Funktion die <code>bitmapData</code>-Eigenschaft des <code>picture</code>-Objekts aktualisiert, werden die Änderungen erst wirksam, wenn der Code die <code>unlock()</code>-Methode des <code>bitmapData</code>-Objekts aufruft:
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Beispiele<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_de"> Verwendung dieses Beispiels </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> Im folgenden Beispiel wird die BitmapDataExample-Klasse verwendet, um die Grafik „Image.gif“ an der Standardposition (0, 0) in ein Anzeigeobjekt (DisplayObject) zu laden. Eine Kopie von „Image.gif“ wird rechts vom Original positioniert, für das neue Farben auf Pixel angewendet werden, die einen Test mit der <code>threshold()</code>-Methode bestanden haben. Dies wird in den folgenden Schritten erreicht:
 <ol><li>Es wird eine <code>url</code>-Eigenschaft erstellt, die den Speicherort und Namen der Grafikdatei angibt.</li><li>Der Klassenkonstruktor erstellt ein Loader-Objekt, das dann einen Ereignis-Listener instanziiert. Der Ereignis-Listener wird ausgelöst, wenn die <code>completeHandler()</code>-Methode die Bildbearbeitung abgeschlossen hat.</li><li>Anschließend wird das <code>request</code>-URLRequest-Objekt an <code>loader.load()</code> übergeben, um das Bild mit einem Anzeigeobjekt in den Speicher zu laden.</li><li>Das Bild wird in die Anzeigeliste eingefügt, die das Bild auf dem Bildschirm bei den Koordinaten <i>x = 0, y = 0</i> anzeigt.</li><li>Die <code>completeHandler()</code>-Methode führt dann Folgendes aus: 
     <ul><li>Sie erstellt zusammen mit einem Bitmap-Objekt einen zweiten „Loader“, der über das Loader-Objekt initialisiert wird.</li><li>Sie erstellt ein zweites Bitmap-Objekt, <code>duplicate</code>, das wiederum die <code>duplicateImage()</code>-Methode aufruft, die ein Duplikat des Originalbilds erzeugt. </li><li>Sie erstellt ein BitmapData-Objekt, das dem BitmapData-Objekt des <code>duplicate</code>-Objekts zugeordnet ist.</li><li>Sie erstellt ein neues Rechteckobjekt, das mit denselben Werten für Koordinaten, Breite und Höhe wie das Originalbild initialisiert wird.</li><li>Sie erstellt ein neues Point-Objekt mit der Standardeinstellung <i>x = 0, y = 0</i>.</li><li>Sie erstellt die folgenden Variablen:
         <ul><li><code>operation</code>: Wendet die neue Farbe an, wenn der Schwellenwert größer oder gleich dem Original ist.</li><li><code>threshold</code>: Der Wert, mit dem jedes Pixel verglichen wird (in diesem Beispiel Hellgrau mit einem Alphawert von 0xCC). </li><li><code>color</code>: Die Farbe, auf die die Pixel eingestellt sind, die den Schwellentest bestehen. In diesem Fall ist dies reines Gelb.</li><li><code>mask</code>: Die genau entgegengesetzte Farbe (durchsichtiges Blau).</li><li><code>copySource</code>: Ist auf <code>false</code> gesetzt, um anzuzeigen, dass die Pixelwerte nicht kopiert werden, wenn der Schwellenwert den Test nicht besteht. Dieser Wert hat keine Bedeutung, da das Bild dupliziert wird und nur Pixel geändert werden, die den Schwellenwerttest bestehen.</li></ul></li><li>Ruft mithilfe der vorherigen Variablen die <code>threshold()</code>-Methode auf. Es ergibt sich die folgende Schwellenwertgleichung: <code>if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00</code>. </li></ul></li></ol>
 <p> <b>Hinweise:</b>
 <ul><li>Für die Kompilierung der SWF-Datei müssen Sie die Option „Sicherheit bei lokaler Wiedergabe“ auf „Nur auf lokale Dateien zugreifen“ einstellen.
 </li><li>Zur Ausführung dieses Beispiels müssen Sie eine Datei mit dem Namen „Image.gif“ in dem Ordner ablegen, in dem sich die SWF-Datei befindet.
 </li><li>Es wird empfohlen, eine Grafik mit einer Breite von bis zu etwa 80 Pixel zu verwenden. </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 10:04 AM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/de_DE/legalnotices/index.html">Rechtliche Hinweise</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Onlinedatenschutzerklärung</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Warum auf Englisch?</span>
				</div>
				<div class="white_content_body">
					<b>Inhalt des ActionScript 3.0-Referenzhandbuchs wird in englischer Sprache angezeigt</b><br><br>
					Nicht alle Teile des ActionScript 3.0-Referenzhandbuchs wurden in alle Sprachen übersetzt. Wenn der Text zu einem Sprachelement nicht übersetzt wurde, wird er auf Englisch angezeigt. Zum Beispiel wurden die Informationen zur ga.controls.HelpBox-Klasse nicht in andere Sprachen übersetzt. In der deutschen Version des Referenzhandbuchs erscheint der Abschnitt zur ga.controls.HelpBox-Klasse deshalb auf Englisch.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 10:04 AM Z  -->
