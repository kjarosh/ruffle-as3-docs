<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="適用於 Adobe&reg; Flash&reg; Platform 的 ActionScript&reg; 3.0 參考"><meta name="lang" content="zh-tw"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Adobe ActionScript&reg; 3 (AS3  ) API 參考</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "執行階段";
			var productsLabel = "產品";
			var noneLabel = "無";
			var qsearchBoxLabel = "快速搜尋";
			var qsearchText = "找不到字詞";
			var ajaxErrorMsg="載入頁面時發生錯誤";
			var ajaxErrorTryMsg="再試一次";
			var ajaxLoadingMsg="仍在載入";
			var cancelMsg = "取消";
			var classesText = "類別";
			var strJiveReply = "張貼此問題是為回應下列文章： "
			var showFilters = "顯示篩選";
			var hideFilters = "隱藏篩選";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											適用於 Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform 的 ActionScript<sup>&reg;</sup> 3.0 參考<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> 首頁 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">顯示套件和類別清單</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">隱藏套件和類別清單</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> 套件 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> 類別 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> 新增內容 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> 索引 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> 附錄 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">為什麼顯示英文？</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/zh_TW/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>篩選：</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">從伺服器擷取資料...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">從伺服器擷取資料...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> 屬性 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 屬性 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 建構函式 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> 方法 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> 全域常數 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> 事件 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> 樣式 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> 外觀部件 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> 外觀狀態 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> 特效 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> 常數 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> 全域函數 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">函數</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> 介面 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> 類別 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> 範例 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								類別
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">套件</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">類別</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">繼承</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">實作</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 BitmapData 類別可讓您使用 Bitmap 物件的資料 (像素)。<span></span>您可以使用 BitmapData 類別的方法來建立任意調整大小的透明或不透明點陣圖影像，而且在執行階段中以各種方式操作。 <span>您也可以存取使用 <code>flash.display.Loader</code> 類別載入的點陣圖影像的 BitmapData。</span> 
 
               <p>此類別可讓您將點陣圖顯示和 Flash Player 的內部顯示更新程序分開。 藉由直接操作 BitmapData 物件，您可以建立複雜的影像，但是不會因為需要頻繁地重新繪製向量資料內容而產生對每個影格的工作負荷。</p>
 
               <p>BitmapData 類別方法支援一些特效，而這些特效無法透過非點陣圖顯示物件可用的濾鏡來使用。</p>
 
               <p>BitmapData 物件包含像素資料陣列。 此資料可代表完全不透明的點陣圖或是包含 Alpha 色版資料的透明點陣圖。 任一類型的 BitmapData 物件都是儲存成 32 位元整數的緩衝區。 每個 32 位元整數都會決定點陣圖中單一像素的屬性。</p>
 
               <p>每個 32 位元整數都是由四個 8 位元色版值 (從 0 到 255) 組合而成，分別描述像素的 Alpha 透明度、紅色、綠色以及藍色 (ARGB) 值。(關於 ARGB 值，最高位元組代表 Alpha 色版值，並緊接著紅色、綠色與藍色)。</p>
 
               <p>當您將這四個色版 (Alpha、紅色、綠色和藍色) 與 <code>BitmapData.copyChannel()</code> 方法或 <code>DisplacementMapFilter.componentX</code> 和 <code>DisplacementMapFilter.componentY</code> 屬性搭配使用時，這四個色版會以數字來表示，而這些數字會在 BitmapDataChannel 類別中以下列常數表示：</p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>您可以使用 Bitmap 物件的 <code>bitmapData</code> 屬性，將 BitmapData 物件附加至 Bitmap 物件。</p>
 
               <p>您可以利用 <code>Graphics.beginBitmapFill()</code> 方法，使用 BitmapData 物件來填滿 Graphics 物件。</p>
 
               <p>在 AIR 執行階段中，DockIcon、Icon、InteractiveIcon 和 SystemTrayIcon 類別都包含 <code>bitmaps</code> 屬性，此屬性為 BitmapData 物件的陣列，這些物件可定義圖示的點陣圖影像。</p>
 
               <p>在 AIR 1.5 和 Flash Player 10 中，BitmapData 物件的大小上限為 8,191 像素寬度或高度，且像素總計不得超過 16,777,215 像素 (因此，如果 BitmapData 物件的寬度為 8,191 像素，則其高度上限為 2,048 像素)。若為 Flash Player 9 和 AIR 1.1 及其更早版本，高度和寬度的上限都是 2,880 像素。</p>
 
               <p>從 AIR 3 和 Flash Player 11 開始，已經移除 BitmapData 物件的大小限制。點陣圖的大小上限現在取決於作業系統。</p>
 
               <p>如果 BitmapData 物件無效的話 (例如，如果 BitmapData 物件擁有 <code>height == 0</code> 與 <code>width == 0</code>)，或其已經透過 dispose() 加以處理，呼叫 BitmapData 物件的任何方法或屬性都會擲出 ArgumentError 錯誤。 </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">檢視範例</a></p><p><span class="classHeaderTableLabel">相關 API 元素</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">公用屬性</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 隱藏繼承公用屬性</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 顯示繼承公用屬性</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">屬性</th><th>定義自</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 類別物件的參照或是特定物件實體的建構函數。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[唯讀] 
     點陣圖影像的高度，以像素為單位。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[唯讀] 
     定義點陣圖影像大小和位置的矩形。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[唯讀] 
     定義點陣圖影像是否支援每個像素透明度。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[唯讀] 
     點陣圖影像的寬度，以像素為單位。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">公用方法 </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 隱藏繼承公用方法</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 顯示繼承公用方法</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">方法</th><th>定義自</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     以指定的寬度和高度來建立 BitmapData 物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     採用來源影像和濾鏡物件並產生已套用濾鏡的影像。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     傳回具有和內含點陣圖完全相同副本、且為原始實體副本的新 BitmapData 物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     使用 ColorTransform 物件調整點陣圖影像指定區域中的顏色值。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     比較兩個 BitmapData 物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     從另一個 BitmapData 物件或目前 BitmapData 物件的一個色版，將資料傳送到目前 BitmapData 物件的色版。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     在影像之間提供執行不含延伸、旋轉或顏色特效的像素處理快速程序。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     從像素資料的矩形區域中將位元組陣列填色。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     釋放用來儲存 BitmapData 物件的記憶體。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     使用 Flash 執行階段的向量描繪器，在點陣圖影像上繪製 source 顯示物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     使用 Flash 執行階段的向量描繪器，在點陣圖影像上繪製 source 顯示物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     使用選取的壓縮程式演算法壓縮這個 BitmapData 物件，並傳回新的 ByteArray 物件。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     以指定的 ARGB 顏色對像素的矩形區域填色。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     對於從 (x, y) 座標開始的影像，執行填色作業，並填入特定顏色。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     指定 BitmapData 物件、來源矩形以及濾鏡物件，來決定 applyFilter() 方法呼叫所影響的目標矩形。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     決定矩形區域，將位於點陣圖影像內所有指定顏色的像素全部封閉起來 (如果 findColor 參數設為 true)，或者將不包含指定顏色的所有像素封閉起來 (如果 findColor 參數設為 false)。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     傳回整數，代表 BitmapData 物件中特定點 (x, y) 的 RGB 像素值。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     傳回 ARGB 顏色數值，其中包含 Alpha 色版資料和 RGB 資料。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     從像素資料的矩形區域產生位元組陣列。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     從矩形區域的像素資料產生向量陣列。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出物件是否有已定義的指定屬性。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     計算 BitmapData 物件的 256 色二進位長條圖。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     在一個點陣圖影像和一個點、矩形或其它點陣圖影像之間，執行像素層級作用區域偵測。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出 Object 類別的實體是否位於指定為參數的物件原型鏈中。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     鎖定影像，以便當這個 BitmapData 物件變更時，其它參照此 BitmapData 物件 (例如 Bitmap 物件) 的任何物件不會跟著更新。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     執行從來源影像到目標影像的每個色版的混合。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     以呈現隨機雜點的像素來填色影像。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     重新對應影像 (最多具有四個顏色面板資料陣列) 中的顏色色版值，每個顏色色版值對應一個色版。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     產生 Perlin 雜點影像。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     執行從來源影像至目標影像，或使用相同影像的像素溶解效果。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出指定的屬性是否存在，以及是否可列舉。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     以一定的 (x, y) 像素量來捲動影像。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     設定 BitmapData 物件的單一像素。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     設定 BitmapData 物件單一像素的顏色和 Alpha 透明度值。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     將位元組陣列轉換為像素資料的矩形區域。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     為迴圈作業設定動態屬性的可用性。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     將向量轉換為像素資料的矩形區域。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     根據指定的臨界值來測試影像的像素值，並設定將測試傳遞至新顏色值的像素。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 傳回代表此物件的字串，根據地區特定慣例進行格式化。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 會傳回指定之物件的字串形式。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     解除鎖定影像，以便當這個 BitmapData 物件變更時，其它參照此 BitmapData 物件 (例如 Bitmap 物件) 的任何物件不會跟著更新。</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 會傳回指定之物件的基本值。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">屬性詳細資訊</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">屬性</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     點陣圖影像的高度，以像素為單位。
     
     </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     定義點陣圖影像大小和位置的矩形。 矩形的頂端和左側的位置都是 0；寬度和高度等於 BitmapData 物件的像素寬度和高度。
     
     </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     定義點陣圖影像是否支援每個像素透明度。 您只可以在建構 BitmapData 物件時設定此值，方法為將建構函式的 <code>transparent</code> 參數傳遞為 <code>true</code>。 接著，在您建立 BitmapData 物件之後，可以藉由判斷 <code>transparent</code> 屬性的值是否為 <code>true</code>，來檢查它是否支援每個像素透明度。
     
     
     </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     點陣圖影像的寬度，以像素為單位。
     
     </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">建構函式詳細資料</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">建構函式</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     以指定的寬度和高度來建立 BitmapData 物件。 如果指定 <code>fillColor</code> 參數的值，點陣圖中的每個像素都會設定為此顏色。
     
     <p>根據預設，建立的點陣圖為透明，除非您傳遞 <code>false</code> 值供 <code>transparent</code> 參數使用。 當您建立不透明的點陣圖時，就無法再變更為透明的點陣圖。 不透明點陣圖中的每個像素，僅使用 24 位元的顏色色版資訊。 如果將點陣圖定義為透明，每個像素會使用 32 位元的顏色色版資訊，包含 Alpha 透明度色版。</p>
     
     <p>在 AIR 1.5 和 Flash Player 10 中，BitmapData 物件的大小上限為 8,191 像素寬度或高度，且像素總計不得超過 16,777,215 像素 (因此，如果 BitmapData 物件的寬度為 8,191 像素，則其高度上限為 2,048 像素)。若為 Flash Player 9 和 AIR 1.1 及其更早版本，高度和寬度的上限都是 2,880 像素。如果指定的寬度或高度值大於 2880，就不會建立新實體。</p>
     
     </p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 點陣圖影像的寬度，以像素為單位。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 點陣圖影像的高度，以像素為單位。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; 指定點陣圖影像是否支援每個像素透明度。 預設值為 <code>true</code> (透明)。 若要建立完全透明點陣圖，將 <code>transparent</code> 參數值設為 <code>true</code>，並將 <code>fillColor</code> 參數值設為 0x00000000 (或 0)。 將 <code>transparent</code> 屬性設為 <code>false</code> 可以稍微改善顯示效能。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 您可以使用 32 位元 ARGB 顏色值對點陣圖影像區域進行填色。 預設值為 0xFFFFFFFF (純白)。
     
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 寬度和/或高度超出最大尺寸。
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">方法詳細資訊</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     採用來源影像和濾鏡物件並產生已套用濾鏡的影像。
     
     <p>此方法會依賴內建濾鏡物件的行為，該物件會決定受到輸入來源矩形影響的目標矩形。</p>
     
     <p>套用濾鏡之後，結果影像會比輸入影像大。 例如，如果使用 BlurFilter 類別來模糊化 (50,50,100,100) 的來源矩形以及 (10,10) 的目標點，目標影像中變更的區域將會因為模糊化而比 (10,10,60,60) 大。 這通常會在呼叫 <code>applyFilter()</code> 時，在內部發生。</p>
     
     <p>如果 <code>sourceBitmapData</code> 參數的 <code>sourceRect</code> 參數是一個內部區域，如在一個 200 x 200 影像的 (50,50,100,100) 中，濾鏡會使用 <code>sourceRect</code> 參數外部的來源像素來產生目標矩形。</p>
     
     <p>如果 BitmapData 物件與指定為 <code>sourceBitmapData</code> 參數的物件是同一個物件，則應用程式會使用物件的暫存副本來執行濾鏡操作。為了達到最佳效能，請避免這種情況發生。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 實體。

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標影像 (目前 BitmapData 實體) 內對應至來源矩形左上角的點。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; 用來執行濾鏡操作的濾鏡物件。 每種類型的濾鏡都有特定的需求，如下列所示：
     
     <ul><li><b>BlurFilter</b> &mdash; 這個濾鏡可以使用不透明或是透明的來源和目標影像。 如果影像的格式不符合，在套用濾鏡期間所產生的來源影像副本就會符合目標影像格式。</li><li><b>BevelFilter、DropShadowFilter、GlowFilter</b> &mdash; 這些濾鏡的目標影像必須是透明的影像。呼叫 DropShadowFilter 或 GlowFilter 會建立一個影像，其中包含投影或光暈的 Alpha 色版資料。 它不會將投影建立在目標影像上。 如果這些濾鏡之一用在不透明的目標影像上，就會擲回的例外。</li><li><b>ConvolutionFilter</b> &mdash; 這個濾鏡可以使用不透明或是透明的來源和目標影像。</li><li><b>ColorMatrixFilter</b> &mdash; 這個濾鏡可以使用不透明或是透明的來源和目標影像。</li><li><b>DisplacementMapFilter</b> &mdash; 這個濾鏡可以使用不透明或是透明的來源和目標影像，但是來源和目標影像的格式必須一樣。</li></ul>
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect、destPoint 或濾鏡都是 null。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; BitmapData 物件的透明度與濾鏡操作不相容。
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何將模糊濾鏡套用至 BitmapData 實體：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     傳回具有和內含點陣圖完全相同副本、且為原始實體副本的新 BitmapData 物件。
     
     </p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; 具有和原始物件完全相同的新 BitmapData 物件。
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何複製 BitmapData 實體，並顯示當您修改所複製的 BitmapData 實體時，原始物件並不會遭到修改：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     使用 <code>ColorTransform</code> 物件調整點陣圖影像指定區域中的顏色值。 如果矩形符合點陣圖影像的邊界，則此方法將會變化整個影像的顏色值。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義 ColorTransform 物件套用之影像區域的 Rectangle 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; 用來說明要套用之顏色轉換值的 ColorTransform 物件。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 或 colorTransform 都是 null。
      
      </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何將顏色轉換套用至 BitmapData 物件的左半邊 (矩形)。
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     比較兩個 BitmapData 物件。 如果兩個 BitmapData 物件都具有相同的尺寸 (寬度與高度)，則方法會傳回新的 BitmapData 物件，而且在兩個來源物件中的所有像素裡，每個像素就是其它像素的「色差」：
     
     <ul><li>如果兩個像素相等，則像素色差為 0x00000000。 </li><li>如果兩個像素具有不同的 RGB 值 (忽略 Alpha 值)，則像素色差為 0xRRGGBB，其中 RR/GG/BB 是紅色、綠色和藍色色版之間的個別色差 (來源物件中的像素值減去 <code>otherBitmapData</code> 物件中的像素值)。 在這裡 Alpha 色版的色差會被忽略。 </li><li>如果只有 Alpha 色版值不同， 像素值為 0x<i>ZZ</i>FFFFFF，當中的 <i>ZZ</i> 為 Alpha 值中的差異 (來源物件的 Alpha 值減去 <code>otherBitmapData</code> 物件中的 Alpha 值)。</li></ul>
     
     <p>例如，假設有下列兩個 BitmapData 物件：</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>注意：</b> 用來填滿兩個 BitmapData 物件的所有顏色在 RGB 值上都有些許的色差 (0xFF0000 與 0xFFAA00)。 <code>compare()</code> 方法的結果會產生新的 BitmapData 物件，其中每個像素在兩個點陣圖之中會有 RGB 值的色差。</p>
     
     <p>假設下列兩個 BitmapData 物件當中，RGB 顏色都一樣，但是 Alpha 值不同：</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p><code>compare()</code> 方法的結果會產生新的 BitmapData 物件，其中每個像素在兩個點陣圖之中會有 Alpha 值的色差。</p>
     
     <p>如果這些 BitmapData 物件都相等 (具有相同的寬度、高度以及相同的像素值)，則方法會傳回數字 0。</p>
     
     <p>如果 BitmapData 物件的寬度不相等，方法會傳回數字 -3。 </p>
     
     <p>如果這些 BitmapData 物件的高度不相等，但是寬度相等，則方法會傳回數字 -4。</p>
     
     <p>下列範例將使用不同的寬度 (50 與 60) 來比較兩個 Bitmap 物件：</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 與來源 BitmapData 物件比較的 BitmapData 物件。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; 如果兩個 BitmapData 物件都具有相同的尺寸 (寬度與高度)，則方法會傳回新的 BitmapData 物件，而且在兩個物件中都會存在色差 (請參閱主要討論內容)。 如果這兩個 BitmapData 物件相等，則此方法會傳回數字 0。 如果這兩個 BitmapData 物件的寬度不相等，則此方法會傳回數字 -3。 如果這兩個 BitmapData 物件的高度不相等，則此方法會傳回數字 -4。 
     
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; otherBitmapData 是 null。
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將顯示 BitmapData 物件中的像素值，該物件是藉由將相同尺寸的兩個 BitmapData 物件加以比較所產生：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     從另一個 BitmapData 物件或目前 BitmapData 物件的一個色版，將資料傳送到目前 BitmapData 物件的色版。 在目標 BitmapData 物件裡其它色版中的所有資料都會保留下來。
     
     <p>來源色版值和目標色版值可能為下列值的其中之一： </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 來源 Rectangle 物件。 如果您只想要複製點陣圖中較小區域的色版資料，請指定小於 BitmapData 物件整體大小的來源矩形。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標 Point 物件，代表將放置新色版資料的矩形區域之左上角。 如果您只想要將色版資料從某個區域複製到目標影像的不同區域上，請指定 (0,0) 以外的點。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; 來源色版。 使用來自 BitmapDataChannel 類別 (<code>BitmapDataChannel.RED</code>、<code>BitmapDataChannel.BLUE</code>、<code>BitmapDataChannel.GREEN</code>、<code>BitmapDataChannel.ALPHA</code>) 的值。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; 目標色版。 使用來自 BitmapDataChannel 類別 (<code>BitmapDataChannel.RED</code>、<code>BitmapDataChannel.BLUE</code>、<code>BitmapDataChannel.GREEN</code>、<code>BitmapDataChannel.ALPHA</code>) 的值。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect 或 destPoint 都是 null。
      
      </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何將 BitmapData 物件中的紅色色版複製到該物件的藍色色版，並置於 20 x 20 的像素區域中：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     在影像之間提供執行不含延伸、旋轉或顏色特效的像素處理快速程序。 這個方法會將來源影像的矩形區域，複製到目標 BitmapData 物件之目標點上相同大小的矩形區域中。
     
     <p>如果包含 <code>alphaBitmap</code> 和 <code>alphaPoint</code> 參數，則可以使用次要的影像當作來源影像的 Alpha 來源。 如果來源影像具有 Alpha 資料，則兩組 Alpha 資料都會用來將來源影像的像素合成至目標影像上。 <code>alphaPoint</code> 參數是 Alpha 影像對應至來源矩形左上角的點。 任何位於來源影像和 Alpha 影像交會點外的像素都不會複製到目標影像上。</p>
     
     <p><code>mergeAlpha</code> 屬性會控制當透明影像複製到另一個透明影像時，是否要使用 Alpha 色版。 若要複製包含 Alpha 色版資料的像素，請將 <code>mergeAlpha</code> 屬性設定為 <code>true</code>。 根據預設，<code>mergeAlpha</code> 屬性為 <code>false</code>。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要複製像素的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 實體，或者參照到目前的 BitmapData 實體。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標點，代表要放置新像素的矩形區域之左上角。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; 次要的 Alpha BitmapData 物件來源。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; 在 Alpha BitmapData 物件來源中對應至 <code>sourceRect</code> 參數左上角的點。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 若要使用 Alpha 色版，請將值設為 <code>true</code>。 若要複製像素 (不使用 Alpha 色版)，請將值設定為 <code>false</code>。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect 與 destPoint 都是 null。
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何從某個 BitmapData 物件的 20 x 20 像素區域中，將像素複製到另一個 BitmapData 物件：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     從像素資料的矩形區域中將位元組陣列填色。這個方法會從 ByteArray 的 <code>position</code> 索引開始，將每個像素的無正負號整數 (32 位元未相乘的像素值) 寫入位元組陣列中。必要時，位元組陣列的大小會增加到所需的位元組數目，以容納所有像素資料。
           
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 位於目前 BitmapData 物件的矩形區域
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 目標 ByteArray 物件
     
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; 因為 <code>rect</code> 引數為 <code>null</code>，或者 <code>data</code> 引數為 <code>null</code>
     
	 </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     釋放用來儲存 BitmapData 物件的記憶體。 
     
     <p>某個影像呼叫 <code>dispose()</code> 方法時，會將此影像的高度和寬度都設定為 0。 所有針對此 BitmapData 實體之方法或屬性的後續呼叫都會失敗，並擲回例外。 </p>
     <p><code>BitmapData.dispose()</code> 立即釋放實際點陣圖資料佔用的記憶體 (一個點陣圖會消耗 64 MB 的記憶體)。使用 <code>BitmapData.dispose()</code> 之後，BitmapData 物件再也無法使用，如果您在 BitmapData 物件上呼叫函數，則 Flash 執行階段會擲出例外。不過，<code>BitmapData.dispose()</code> 並不會對 BitmapData 物件 (大約 128 個位元組) 進行垃圾回收；垃圾回收程式收集 BitmapData 物件時，會釋放實際 BitmapData 物件佔用的記憶體。</p>
     
     </p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明在呼叫 <code>dispose()</code> 方法之後，再呼叫 BitmapData 物件之方法所產生的效果 (會擲回例外)：
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     使用 Flash 執行階期的向量描繪器，在點陣圖影像上繪製 <code>source</code> 顯示物件。您可以指定 <code>matrix</code>、<code>colorTransform</code>、<code>blendMode</code>，以及目標 <code>clipRect</code> 參數來控制顯示的執行方式。 或者，您也可以指定是否在點陣圖縮放時平滑化處理 (只有當來源物件是 BitmapData 物件才能這麼處理)。
     
     <p><b>注意：</b><code>drawWithQuality()</code> 方法的運作方式與 <code>draw()</code> 方法完全相同，只是它不會使用 <code>Stage.quality</code> 屬性來決定向量顯示的品質，請將 <code>quality</code> 參數指定給 <code>drawWithQuality()</code> 方法。</p>
      
     <p>這個方法會直接對應至編寫工具介面中使用物件標準向量描繪器來繪製物件的方式。</p>
     
     <p>來源顯示物件並不會針對此呼叫使用所套用的任何變形。 會將它當做存在於元件庫或檔案中，而且不具有矩陣變形、顏色轉換和混合模式。 若要藉由使用顯示物件的轉換屬性來加以繪製 (例如繪製影片片段)，可以將其 <code>transform</code> 屬性物件複製到使用 BitmapData 物件之 Bitmap 物件的 <code>transform</code> 屬性上。</p>
     
     <p><span>Flash Player 9.0.115.0 和更新版本以及 </span>Adobe AIR 透過 RTMP 支援此方法。您可以使用伺服器端指令碼控制 Flash Media Server 上串流的存取。如需詳細資訊，請參閱「<a href="http://www.adobe.com/go/learn_flash_ss_as_tw" target="external">Adobe Flash Media Server 伺服器端 ActionScript 語言參考</a>」中的 <code>Client.audioSampleAccess</code> 和 <code>Client.videoSampleAccess</code> 屬性。<i></i></p>
     
     <p>如果 source 物件及其所有子物件 (在 Sprite 或 MovieClip 物件的情況下) 不是來自與呼叫者相同的網域，也不是位於呼叫者可存取的內容中 (藉由呼叫 <code>Security.allowDomain()</code> 方法進行存取)，呼叫 <code>draw()</code> 會擲回 SecurityError 例外。應用程式安全執行程序中的 AIR 內容不受此限制。</p>
     
     <p>使用載入的點陣圖影像當做 <code>source</code> 還存有一些限制。如果載入的影像與呼叫端來自相同網域，呼叫 <code>draw()</code> 方法就會成功。再者，影像伺服器上的跨網域原則檔可能授與權限，允許 SWF 內容的網域呼叫 <code>draw()</code> 方法。在此情況下，您必須設定 LoaderContext 物件的 <code>checkPolicyFile</code> 屬性，並且使用該物件做為 <code>context</code> 參數來呼叫 Loader 物件的 <code>load()</code> 方法以載入影像。應用程式安全執行程序中的 AIR 內容不受這些限制。</p>
     
     <p>在 Windows 中，<code>draw()</code> 方法無法捕捉內嵌於 Adobe AIR 之 HTMLLoader 物件的 HTML 網頁內之 SWF 內容。<span></span></p>
     
     <p><code>draw()</code> 方法既無法捕捉 <span>Adobe AIR 中的</span> PDF 內容，也無法捕捉<span> Adobe AIR 中</span>內嵌於 <code>wmode</code> 特質設為 <code>"window"</code> 之 HTML 的 SWF 內容。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; 要繪製到 BitmapData 物件的顯示物件或 BitmapData 物件。(DisplayObject 與 BitmapData 類別會實作 IBitmapDrawable 介面)。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; 用來縮放、旋轉或轉移點陣圖之座標的 Matrix 物件。 如果您不想將矩陣變形套用到影像上，請使用預設的 <code>new Matrix()</code> 建構函式，或傳遞 <code>null</code> 值，將此參數設為單位矩陣。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; 用來調整點陣圖顏色值的 ColorTransform 物件。 如果沒有提供物件，點陣圖影像的顏色就不會變化。 如果您必須傳遞此參數，但又不想轉換影像，請將此參數設為以預設 <code>new ColorTransform()</code> 建構函式建立的 ColorTransform 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; 來自 flash.display.BlendMode 類別的字串值，可指定要套用至結果點陣圖的混合模式。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 用來定義要繪製的來源物件區域之 Rectangle 物件。 如果您沒有提供此值，就不會產生剪裁效果，並且會繪製整個來源物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Boolean 值，決定因 <code>matrix</code> 參數中指定的縮放或旋轉而縮放或旋轉 BitmapData 物件時是否要進行平滑化處理。只有當 <code>source</code> 參數是 BitmapData 物件的情況下，才能套用 <code>smoothing</code> 參數。將 <code>smoothing</code> 設定為 <code>false</code> 時，旋轉或縮放的 BitmapData 影像會呈現像素化或鋸齒狀。 例如，下列兩個影像都會使用相同的 BitmapData 物件做為 <code>source</code> 參數，但是左邊的影像是將 <code>smoothing</code> 參數設定為 <code>true</code>；而右邊的影像則是設定為 <code>false</code>。
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="兩個影像：左邊是平滑化的影像，右邊是未平滑化的影像。"></img></p>
     
     <p>在將 <code>smoothing</code> 設定為 <code>true</code> 的情況下，繪製點陣圖的時間會較將 <code>smoothing</code> 設定為 <code>false</code> 所花的繪製時間長。</p>
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>source</code> 參數不是一個 BitmapData 或 DisplayObject 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; <code>source</code> 物件及其所有子物件 (在 Sprite 或 MovieClip 物件的情況下) 不是來自與呼叫者相同的網域，也不是位於呼叫者可存取的內容中 (藉由呼叫 <code>Security.allowDomain()</code> 方法進行存取)。應用程式安全執行程序中的 AIR 內容不受此限制。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 來源若不是 null，就是無效的 IBitmapDrawable 物件。
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何在 BitmapData 物件上繪製 TextField 物件：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     使用 Flash 執行階期的向量描繪器，在點陣圖影像上繪製 <code>source</code> 顯示物件。您可以指定 <code>matrix</code>、<code>colorTransform</code>、<code>blendMode</code>，以及目標 <code>clipRect</code> 參數來控制顯示的執行方式。 或者，您也可以指定是否在點陣圖縮放時平滑化處理 (只有當來源物件是 BitmapData 物件才能這麼處理)。
     
     <p><b>注意：</b><code>drawWithQuality()</code> 方法的運作方式與 <code>draw()</code> 方法完全相同，只是它不會使用 <code>Stage.quality</code> 屬性來決定向量顯示的品質，請將 <code>quality</code> 參數指定給 <code>drawWithQuality()</code> 方法。</p>
      
     <p>這個方法會直接對應至編寫工具介面中使用物件標準向量描繪器來繪製物件的方式。</p>
     
     <p>來源顯示物件並不會針對此呼叫使用所套用的任何變形。 會將它當做存在於元件庫或檔案中，而且不具有矩陣變形、顏色轉換和混合模式。 若要藉由使用顯示物件的轉換屬性來加以繪製 (例如繪製影片片段)，可以將其 <code>transform</code> 屬性物件複製到使用 BitmapData 物件之 Bitmap 物件的 <code>transform</code> 屬性上。</p>
     
     <p><span>Flash Player 9.0.115.0 和更新版本以及 </span>Adobe AIR 透過 RTMP 支援此方法。您可以使用伺服器端指令碼控制 Flash Media Server 上串流的存取。如需詳細資訊，請參閱 <a href="http://www.adobe.com/go/documentation_tw" target="external">Adobe Flash Media Server 伺服器端 ActionScript 語言參考</a>中的 <code>Client.audioSampleAccess</code> 和 <code>Client.videoSampleAccess</code> 屬性。<i></i></p>
     
     <p>如果 source 物件及其所有子物件 (在 Sprite 或 MovieClip 物件的情況下) 不是來自與呼叫者相同的網域，也不是位於呼叫者可存取的內容中 (藉由呼叫 <code>Security.allowDomain()</code> 方法進行存取)，呼叫 <code>drawWithQuality()</code> 會擲回 SecurityError 例外。應用程式安全執行程序中的 AIR 內容不受此限制。</p>
     
     <p>使用載入的點陣圖影像當做 <code>source</code> 還存有一些限制。如果載入的影像與呼叫者來自相同網域，呼叫 <code>drawWithQuality()</code> 方法就會成功。再者，影像伺服器上的跨網域原則檔可能授與權限，允許 SWF 內容的網域呼叫 <code>drawWithQuality()</code> 方法。在此情況下，您必須設定 LoaderContext 物件的 <code>checkPolicyFile</code> 屬性，並且使用該物件做為 <code>context</code> 參數來呼叫 Loader 物件的 <code>load()</code> 方法以載入影像。應用程式安全執行程序中的 AIR 內容不受這些限制。</p>
     
     <p>在 Windows 中，<code>drawWithQuality()</code> 方法無法捕捉內嵌於 Adobe AIR HTMLLoader 物件中 HTML 網頁的 SWF 內容。<span></span></p>
     
     <p><code>drawWithQuality()</code> 方法既無法捕捉 <span>Adobe AIR 中的</span> PDF 內容，也無法捕捉<span> Adobe AIR 中</span>內嵌於 <code>wmode</code> 特質設為 <code>"window"</code> 之 HTML 的 SWF 內容。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; 要繪製到 BitmapData 物件的顯示物件或 BitmapData 物件。(DisplayObject 與 BitmapData 類別會實作 IBitmapDrawable 介面)。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; 用來縮放、旋轉或轉移點陣圖之座標的 Matrix 物件。 如果您不想將矩陣變形套用到影像上，請使用預設的 <code>new Matrix()</code> 建構函式，或傳遞 <code>null</code> 值，將此參數設為單位矩陣。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; 用來調整點陣圖顏色值的 ColorTransform 物件。 如果沒有提供物件，點陣圖影像的顏色就不會變化。 如果您必須傳遞此參數，但又不想轉換影像，請將此參數設為以預設 <code>new ColorTransform()</code> 建構函式建立的 ColorTransform 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; 來自 flash.display.BlendMode 類別的字串值，可指定要套用至結果點陣圖的混合模式。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 用來定義要繪製的來源物件區域之 Rectangle 物件。 如果您沒有提供此值，就不會產生剪裁效果，並且會繪製整個來源物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Boolean 值，決定因 <code>matrix</code> 參數中指定的縮放或旋轉而縮放或旋轉 BitmapData 物件時是否要進行平滑化處理。只有當 <code>source</code> 參數是 BitmapData 物件的情況下，才能套用 <code>smoothing</code> 參數。將 <code>smoothing</code> 設定為 <code>false</code> 時，旋轉或縮放的 BitmapData 影像會呈現像素化或鋸齒狀。 例如，下列兩個影像都會使用相同的 BitmapData 物件做為 <code>source</code> 參數，但是左邊的影像是將 <code>smoothing</code> 參數設定為 <code>true</code>；而右邊的影像則是設定為 <code>false</code>。
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="兩個影像：左邊是平滑化的影像，右邊是未平滑化的影像。"></img></p>
     
     <p>在將 <code>smoothing</code> 設定為 <code>true</code> 的情況下，繪製點陣圖的時間會較將 <code>smoothing</code> 設定為 <code>false</code> 所花的繪製時間長。</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; 任一 StageQuality 值。選取繪製向量圖形時要使用的消除鋸齒品質。 
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>source</code> 參數不是一個 BitmapData 或 DisplayObject 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; <code>source</code> 物件及其所有子物件 (在 Sprite 或 MovieClip 物件的情況下) 不是來自與呼叫者相同的網域，也不是位於呼叫者可存取的內容中 (藉由呼叫 <code>Security.allowDomain()</code> 方法進行存取)。應用程式安全執行程序中的 AIR 內容不受此限制。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 來源若不是 null，就是無效的 IBitmapDrawable 物件。
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何在 BitmapData 物件上繪製 TextField 物件：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     使用選取的壓縮程式演算法壓縮這個 BitmapData 物件，並傳回新的 ByteArray 物件。或者，將產生的資料寫入指定的 ByteArray。<code>compressor</code> 引數會指定編碼演算法，並且可以是 PNGEncoderOptions、JPEGEncoderOptions 或 JPEGXREncoderOptions。
     
     <p>下列範例使用 JPEGEncoderOptions 壓縮 BitmapData 物件：</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 要壓縮的 BitmapData 物件區域。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; 要使用的壓縮程式類型。有效值為 <code>flash.display.PNGEncoderOptions</code>、<code>flash.display.JPEGEncoderOptions</code> 和 <code>flash.display.JPEGXREncoderOptions</code>。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; 要保留編碼影像的輸出 ByteArray。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 包含編碼影像的 ByteArray。
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     以指定的 ARGB 顏色對像素的矩形區域填色。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 要填色的矩形區域。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 填滿區域的 ARGB 顏色值。 ARGB 顏色一般會以十六進位格式來指定，例如 0xFF336699。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 為 null。
      
      </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明如何在 BitmapData 物件的矩形區域上填滿藍色：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     對於從 (<i>x</i>, <i>y</i>) 座標開始的影像，執行填色作業，並填入特定顏色。 <code>floodFill()</code> 方法和多種繪圖程式裡的油漆桶工具類似。 顏色為 ARGB 顏色，其中包含 Alpha 資訊和顏色資訊。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 影像的 <i>x</i> 座標。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 影像的 <i>y</i> 座標。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 當做填色使用的 ARGB 顏色。
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將示範如何以顏色填滿 BitmapData 物件的某個區域，也就是圍繞 <code>(10, 10)</code> 點所定義之像素，而且其中所有顏色都符合該點之顏色的區域。
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     指定 BitmapData 物件、來源矩形以及濾鏡物件，來決定 <code>applyFilter()</code> 方法呼叫所影響的目標矩形。
     
     <p>例如，模糊濾鏡通常會影響大於來源影像大小的區域。 由預設 BlurFilter 實體所篩選的 100 x 200 像素影像，其中 <code>blurX = blurY = 4</code> 會產生 <code>(-2,-2,104,204)</code> 的目標矩形。 <code>generateFilterRect()</code> 方法可讓您預先找出此目標矩形的大小，因此您可以在執行濾鏡操作前適當調整目標影像的大小。</p>
     
     <p>有些濾鏡會依據來源影像大小來裁切其目標矩形。 例如，內部 <code>DropShadow</code> 不會產生大於來源影像的結果。 在此 API 中，BitmapData 物件是當做來源邊界來使用，而不是來源 <code>rect</code> 參數。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; 用來計算目標矩形的濾鏡物件。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 使用影像、<code>sourceRect</code> 參數和濾鏡來計算的目標矩形。
     
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceRect 或 filter 都是 null。
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明您如何能使用 <code>generateFilterRect()</code> 方法，決定模糊濾鏡的結果將佔用的矩形區域。 <code>generateFilterRect()</code> 方法的結果會透過 <code>trace()</code> 函數來輸出：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> 請注意，<code>generateFilterRect()</code> 方法無法套用這個濾鏡。 呼叫 <code>applyFilter()</code> 方法來套用該濾鏡。 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     決定矩形區域，將位於點陣圖影像內所有指定顏色的像素全部封閉起來 (如果 <code>findColor</code> 參數設為 <code>true</code>)，或者將不包含指定顏色的所有像素封閉起來 (如果 <code>findColor</code> 參數設為 <code>false</code>)。 
     
     <p>例如，如果您有一個來源影像，而且想要決定包含非零 Alpha 色版的影像矩形，請傳遞 <code>{mask: 0xFF000000, color: 0x00000000}</code> 做為參數。 如果 <code>findColor</code> 參數設為 <code>true</code>，則會搜尋整個影像，以找出 <code>(value & mask) == color</code> 的像素邊界 (其中 <code>value</code> 是指像素的顏色值)。 如果 <code>findColor</code> 參數設為 <code>false</code>，則會搜尋整個影像，以找出 <code>(value & mask) ! 的像素邊界= color</code> 的像素邊界 (其中 <code>value</code> 是指像素的顏色值)。 若要決定影像周圍的空白，請傳遞 <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code> 以尋找非白色像素的邊界。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位值，指定要考量的 ARGB 顏色的位元。 該顏色值是使用 <code>&</code> (位元 AND) 運算子，與此十六進位值相結合。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位值，用來指定要符合 (當 <code>findColor</code> 設為 <code>true</code>) 或<i>「不」</i>要符合 (當 <code>findColor</code> 設為 <code>false</code> 的 ARGB 顏色)。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; 如果值設定為 <code>true</code>，則傳回影像的顏色值邊界。 如果值設定為 <code>false</code>，則傳回影像中不存在此顏色的邊界。 
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 指定顏色的影像區域。 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立 BitmapData 物件，並在其像素上半部填滿紅色。 接著，它會呼叫 <code>getColorBoundsRect()</code> 方法來決定其中像素為紅色 (0xFF0000) 的矩形，然後再呼叫相同的方法，決定其中像素不是紅色的矩形 (藉由將 <code>findColor</code> 參數設為 <code>false</code>：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     傳回整數，代表在特定點 (<i>x</i>, <i>y</i>) 上 BitmapData 物件的 RGB 像素值。 <code>getPixel()</code> 方法會傳回未相乘的像素值。 不會傳回任何 Alpha 資訊。
     
     <p>BitmapData 物件裡的所有像素都會當作預先相乘的顏色值來儲存。 預先相乘的影像像素具有已和 Alpha 資料相乘的紅、綠和藍的顏色色版值。 例如，如果 Alpha 值為 0，則 RGB 色版的值也為 0，與未相乘的值無關。 這種資料遺失狀況可能導致執行操作時的一些問題。 所有的 BitmapData 方法都會採用並傳回未相乘的值。 內部像素形式在傳回數值之前會從預先相乘轉換為未相乘。 在集合操作中，像素值會在設定原始影像像素前會預先相乘。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 像素的 <i>x</i> 位置。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 像素的 <i>y</i> 位置。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; 代表 RGB 像素值的數字。 如果 (<i>x</i>, <i>y</i>) 座標位於影像的邊界外，則此方法會傳回 0。 
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立填滿紅色的 BitmapData 物件，然後使用 <code>getPixel()</code> 方法來決定左上角像素的顏色值：
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     傳回 ARGB 顏色數值，其中包含 Alpha 色版資料和 RGB 資料。 此方法和 <code>getPixel()</code> 方法類似，都會傳回不具 Alpha 色版資料的 RGB 顏色。
     
     <p>BitmapData 物件裡的所有像素都會當作預先相乘的顏色值來儲存。 預先相乘的影像像素具有已和 Alpha 資料相乘的紅、綠和藍的顏色色版值。 例如，如果 Alpha 值為 0，則 RGB 色版的值也為 0，與未相乘的值無關。 這種資料遺失狀況可能導致執行操作時的一些問題。 所有的 BitmapData 方法都會採用並傳回未相乘的值。 內部像素形式在傳回數值之前會從預先相乘轉換為未相乘。 在集合操作中，像素值會在設定原始影像像素前會預先相乘。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 像素的 <i>x</i> 位置。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 像素的 <i>y</i> 位置。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; 代表 ARGB 像素值的數字。 如果 (<i>x</i>, <i>y</i>) 座標位於影像的邊界外，則會傳回 0。
     
     </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立填滿某種顏色的 BitmapData 物件，然後使用 <code>getPixel32()</code> 方法來決定左上角像素的顏色值，接著再決定每個顏色組件 (Alpha、紅色、綠色與藍色) 的十六進位值：
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     從像素資料的矩形區域產生位元組陣列。 將每個像素的無正負號整數 (32 位元未相乘的像素值) 寫入位元組陣列中。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 位於目前 BitmapData 物件的矩形區域。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; ByteArray，代表指定之矩形中的像素。
     
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 為 null。
      
      </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立填滿隨機雜點像素的 BitmapData 物件，然後使用 <code>getPixels()</code>方法在 ByteArray 物件中填入 BitmapData 物件的像素值。
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     從矩形區域的像素資料產生向量陣列。傳回指定矩形的無正負號整數 (32 位元未相乘的像素值) Vector 物件。
     
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 位於目前 BitmapData 物件的矩形區域。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; 代表指定矩形的 Vector。
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 為 null。
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     計算 BitmapData 物件的 256 色二進位長條圖。這個方法會傳回包含 4 個 Vector 的 Vector 物件。&lt;Number> 實體 (4 個包含 Number 物件的 Vector 物件)。這 4 個 Vector 實體依序代表紅色、綠色、藍色和 Alpha 組件。每個 Vector 實體都包含 256 個值，分別代表個別組件值的填入次數 (從 0 至 255)。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; BitmapData 物件要使用的區域。
      
      </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     在一個點陣圖影像和一個點、矩形或其它點陣圖影像之間，執行像素層級作用區域偵測。 碰撞定義為某個點或矩形在一個不透明像素上重疊，或兩個重疊的不透明像素。在執行碰撞測試時，不會考慮任一個物件的延伸、旋轉或其它變化。 
     
     <p>如果影像是不透明影像，則此方法會將其視為完全不透明的矩形。 若要執行考量透明度的像素層級碰撞測試，兩個影像必須都為透明影像。 當您在測試兩個透明影像時，會將控制 Alpha 色版值 (從 0 到 255) 的 Alpha 臨界值參數視為不透明。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  在任意座標空間裡，BitmapData 影像的左上角位置。 相同的座標空間會用在 <code>secondBitmapPoint</code> 參數上。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; 此碰撞測試中被視為不透明的最小 Alpha 色版值。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Rectangle、Point、Bitmap 或 BitmapData 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; 用來定義第二個 BitmapData 物件之像素位置的點。 僅在 <code>secondObject</code> 的值為 BitmapData 物件時才使用此參數。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; 在第二個 BitmapData 物件中被視為不透明的最小 Alpha 色版值。僅在 <code>secondObject</code> 的值為 BitmapData 物件，且兩個 BitmapData 物件都為透明時才使用此參數。
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; 如果作用區域有感應，則為 <code>true</code> 值，否則為 <code>false</code>。
        
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>secondObject</code> 參數不是一個 Point、Rectangle、Bitmap，或 BitmapData 物件。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; firstPoint 為 null。
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立 BitmapData 物件，此物件只有在矩形區域 (20, 20, 40, 40) 中會不透明，並呼叫 <code>hitTest()</code> 方法 (將 Point 物件當做 <code>secondObject</code>)。 在第一次呼叫中，Point 物件會定義 BitmapData 物件的左上角 (此處為透明)；而在第二次呼叫中，Point 物件會定義 BitmapData 物件的中心處 (此處為不透明)。
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     鎖定影像，以便當這個 BitmapData 物件變更時，其它參照此 BitmapData 物件 (例如 Bitmap 物件) 的任何物件不會跟著更新。 若要改善效能，請在您多次呼叫 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法之前與之後，搭配使用這方法與 <code>unlock()</code> 方法。
     
     </p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會根據 Bitmap 物件 <code>picture</code> 的 <code>bitmapData</code> 屬性來建立 BitmapData 物件。 接著，它會先呼叫 <code>lock()</code> 方法，再呼叫複雜的自訂函數 <code>complexTransformation()</code>，這個自訂函數會修改 BitmapData 物件。 (<code>picture</code> 物件和 <code>complexTransformation()</code> 函數都尚未在此範例中定義)。 即使 <code>complexTransformation()</code> 函數更新了 <code>picture</code> 物件的 <code>bitmapData</code> 屬性，變更會一直等到程式碼呼叫 <code>bitmapData</code> 物件上的 <code>unlock()</code> 方法：
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     執行從來源影像到目標影像的每個色版的混合。 程式會根據來源和目標像素的色版值，為每個色版和每個像素計算新值。 例如，在紅色色版中，新值的計算方式如下 (其中 <code>redSrc</code> 是來源影像中像素的紅色色版值，而 <code>redDest</code> 則是目標影像中對應像素的紅色色版值)： 
     <p>
     <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p><code>redMultiplier</code>、<code>greenMultiplier</code>、<code>blueMultiplier</code> 和 <code>alphaMultiplier</code> 值都是每個顏色色版的倍數。 請使用介於 <code>0</code> 到 <code>0x100</code> (256) 之間的十六進位值，其中 <code>0</code> 指定在結果中使用來自目標的完整數值，<code>0x100</code> 指定使用來自來源的完整數值，中間的數字則指定使用混合 (例如 <code>0x80</code> 代表 50%)。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 物件。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標影像 (目前 BitmapData 實體) 內對應至來源矩形左上角的點。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位 uint 值，用來與紅色色版值相乘。 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位 uint 值，用來與綠色色版值相乘。 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位 uint 值，用來與藍色色版值相乘。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 十六進位 uint 值，用來與 Alpha 透明度值相乘。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect 或 destPoint 都是 null。
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立兩個 BitmapData 物件。 這兩個物件都是 100 x 80 的像素大小。 第一個物件會填滿為綠色，而第二個物件則會填滿為紅色。 程式碼會呼叫 <code>merge()</code> 方法，將第二個 BitmapData 像素合併至第一個 BitmapData 物件中，但僅限於指定的矩形區域：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     以呈現隨機雜點的像素來填色影像。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; 要使用的隨機種子數字。 如果您保持其它所有參數不變，就可以變化隨機種子值來產生不同的虛擬亂數結果。 雜點函數是一種對應函數，而不是真正的隨機數字產生函數，因此它每次都會從相同的隨機種子產生相同的結果。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 每個色版所能產生的最低值 (0 到 255)。 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 每個色版所能產生的最高值 (0 到 255)。 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; 可以是下列四個顏色色版之任何值組合的數字 (<code>BitmapDataChannel.RED</code>、<code>BitmapDataChannel.BLUE</code>、<code>BitmapDataChannel.GREEN</code> 和 <code>BitmapDataChannel.ALPHA</code>)。 您可以使用邏輯 OR 運算子 <code>|</code> 來合併色版值。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Boolean 值。 如果值為 <code>true</code>，則會將所有顏色色版設為相同值以建立灰階影像。 將此參數設為 <code>true</code> 不會影響所選取的 Alpha 色版。 
     
     </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立兩個 BitmapData 物件，並針對這兩個物件呼叫 <code>noise()</code> 方法。 不過，您需要將該 <code>grayscale</code> 參數設定為 <code>false</code> 以便呼叫第一個物件的 <code>noise()</code> 方法，而設定為 <code>true</code> 以便呼叫第二個物件的 <code>noise()</code> 方法：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     重新對應影像 (最多具有四個顏色面板資料陣列) 中的顏色色版值，每個顏色色版值對應一個色版。 
     
     <p>Flash 執行階段會使用下列步驟來產生結果影像：</p>
     
     <ol><li>在計算了紅、綠、藍和 Alpha 值之後，就會使用標準 32 位元整數數值將這些值加總起來。 </li><li>每個像素的紅、綠、藍和 Alpha 色版值會擷取至個別 0 至 255 的值。 這些值會用來查詢適當陣列中的新顏色值：<code>redArray</code>、<code>greenArray</code>、<code>blueArray</code> 和 <code>alphaArray</code>。 這四個陣列中的每一個都應該包含 256 個值。 </li><li>在全部擷取完這四種新色版值之後，會將這些值結合成標準的 ARGB 值以套用至像素中。</li></ol>
     
     <p>此方法可以支援跨色版特效。 每個輸入陣列可以包含完整的 32 位元值，而且當這些值加總在一起時不會進位。 這個程序不支援每個色版的固定。 </p>
     
     <p>如果沒有為色版指定陣列，則僅會將顏色色版從來源影像複製到目標影像。</p>
     
     <p>您可以使用這個方法產生各種不同的特效，如一般面板對應 (使用一個色版並將它轉換為 false 顏色影像)。 您也可以使用此方法來進行各種進階色彩操作演算法，如 Gamma、曲線、色階和量子化。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 實體。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標影像 (目前 BitmapData 物件) 內對應至來源矩形左上角的點。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 如果 <code>redArray</code> 不是 <code>null</code>，則 <code>red = redArray[source red value] else red = source rect value</code>。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 如果 <code>greenArray</code> 不是 <code>null</code>，則 <code>green = greenArray[source green value] else green = source green value.</code>。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 如果 <code>blueArray</code> 不是 <code>null</code>，則 <code>blue = blueArray[source blue value] else blue = source blue value</code>。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 如果 <code>alphaArray</code> 不是 <code>null</code>，則 <code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>。
     
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect 或 destPoint 都是 null。
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會建立綠色的 BitmapData 物件，該物件的正中央有個紅色方形，然後再使用 <code>paletteMap()</code> 方法，將 BitmapData 物件下半部矩形中的紅色替換為綠色：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     產生 Perlin 雜點影像。
     
     <p>Perlin 雜點產生演算法會插入並結合個別的隨機雜點函數 (稱為 octave) 為單一函數，以產生看起來更自然的隨機雜點。 就像音樂的八度音一樣，每個 octave 函數是前一個函數頻率的兩倍。 Perlin 雜點被描述為「雜點的不規則總和」，因為它結合了多組雜點資料和不同層級的細節。</p>
     
     <p>Perlin 雜點函數可以用來模擬自然現象和山水風情，如木紋、雲朵和山脈。 在大部分情況下，Perlin 雜點函數的輸出並不會直接顯示出來，而是用來加強其它影像與賦予這些影像虛擬亂數的變化。</p>
     
     <p>簡單的數位隨機雜點函數通常會產生具有粗大對比粒子的影像。 這樣的粗大對比在自然界是找不到的。 Perlin 雜點演算法會混合多個運作不同層級細節的雜點函數。 此演算法會讓相鄰像素值有較平滑的變化結果。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; 用在 <i>x</i> 方向的頻率。 例如，若要產生大小為 64 x 128 影像的雜點，需要傳遞的 <code>baseX</code> 值為 64。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; 用在<i>y</i> 方向的頻率。 例如，若要產生大小為 64 x 128 影像的雜點，需要傳遞的 <code>baseY</code> 值為 128。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; 建立此雜點所需結合的 octave 或是個別的雜點函數數量。 更多的 octave 會產生細節更豐富的影像。 更多的 octave 同時需要更長的處理時間。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; 要使用的隨機種子數字。 如果您保持其它所有參數不變，就可以變化隨機種子值來產生不同的虛擬亂數結果。 Perlin 雜點函數是一種對應函數，而不是真正的隨機數字產生函數，因此它每次都會從相同的隨機種子產生相同的結果。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Boolean 值。 如果值為 <code>true</code>，則方法會嘗試平滑化處理影像的轉換邊緣，以建立無接縫的拼貼底紋做為點陣圖填色。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Boolean 值。 如果值為 <code>true</code>，則方法會產生不規則雜點；否則會產生亂流。 帶有亂流的影像具有明顯不連續的漸層，可讓它產生較逼近、鮮明的視覺效果，例如火焰和海浪。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  可以是下列四個顏色色版之任何值組合的數字 (<code>BitmapDataChannel.RED</code>、<code>BitmapDataChannel.BLUE</code>、<code>BitmapDataChannel.GREEN</code> 和 <code>BitmapDataChannel.ALPHA</code>)。 您可以使用邏輯 OR 運算子 <code>|</code> 來合併色版值。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Boolean 值。 如果值為 <code>true</code>，則會將每個紅色、綠色和藍色的顏色色版設為相同值以建立灰階影像。 如果將此值設定為 <code>true</code>，將不會影響 Alpha 色版值。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 對應至每個 octave 之 <i>x</i> 和 <i>y</i> 偏移的點陣列。 藉由操作偏移值，您可以平滑地捲動 perlinNoise 影像的圖層。 在偏移陣列中的每個點會影響特定的 octave 雜點函數。
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將建立一個 200 x 200 像素的 BitmapData 物件，並呼叫 <code>perlinNoise()</code> 方法來產生紅色與藍色水彩效果：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     執行從來源影像至目標影像，或使用相同影像的像素溶解效果。 Flash 執行階段會使用 <code>randomSeed</code> 值來產生隨機像素溶解效果。函數的傳回值必須傳遞至後續的呼叫中，以持續進行像素溶解效果直到完成為止。
     
     <p>如果來源影像不等於目標影像，就會使用所有的屬性將像素由來源複製到目標。 這樣一來，就可讓空白影像經過溶解處理而產生一張完全填滿的影像。</p>
     
     <p>如果來源影像等於目標影像，則會以 <code>color</code> 參數對像素進行填色。 這樣一來，將會溶解為非完全填滿的影像。 在這種模式中，會忽略目標 <code>point</code> 參數。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 實體。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標影像 (目前 BitmapData 實體) 內對應至來源矩形左上角的點。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 用來開始像素溶解效果的隨機種子。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 預設值為來源區域的 1/30 (寬度 x 高度)。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 使用 ARGB 顏色值對來源值等於目標值的像素進行填色。 
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; 在後續的呼叫所使用的新隨機種子值。
     
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect 或 destPoint 都是 null。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; numPixels 值為負值。
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例使用 <code>pixelDissolve()</code> 方法將一個灰色 BitmapData 物件轉換成紅色的，一次會溶解 40 個像素直到所有像素都變更顏色為止：
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     以一定的 (<i>x</i>, <i>y</i>) 像素量來捲動影像。 捲動區域外圍的邊緣區域維持不變。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 水平捲動的量。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 垂直捲動的量。
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例將說明捲動右側 40 像素位置之 Bitmap 資料物件的效果：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     設定 BitmapData 物件的單一像素。 目前的影像像素 Alpha 色版值會在此作業期間保留下來。 RGB 顏色參數值會被視為未相乘的顏色值。
     
     <p><b>注意：</b>為了提升效能，當您重複使用 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法時，請先呼叫 <code>lock()</code> 方法，再呼叫 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法，然後在完成所有像素變更之後呼叫 <code>unlock()</code> 方法。 這個程序可預防參照此 BitmapData 實體的物件，在您尚未完成像素變更之前提早進行更新。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 數值會變更的像素 <i>x</i> 位置。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 數值會變更的像素 <i>y</i> 位置。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 像素的最後 RGB 顏色。 
     
     </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例使用 <code>setPixel()</code>方法，在 BitmapData 物件中繪製一條紅色線段：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     設定 BitmapData 物件單一像素的顏色和 Alpha 透明度值。 此方法近似於 <code>setPixel()</code> 方法；最大的不同在於 <code>setPixel32()</code> 方法採用了包含 Alpha 色版資訊的 ARGB 顏色值。
     
     <p>BitmapData 物件裡的所有像素都會當作預先相乘的顏色值來儲存。 預先相乘的影像像素具有已和 Alpha 資料相乘的紅、綠和藍的顏色色版值。 例如，如果 Alpha 值為 0，則 RGB 色版的值也為 0，與未相乘的值無關。 這種資料遺失狀況可能導致執行操作時的一些問題。 所有的 BitmapData 方法都會採用並傳回未相乘的值。 內部像素形式在傳回數值之前會從預先相乘轉換為未相乘。 在集合操作中，像素值會在設定原始影像像素前會預先相乘。</p>
     
     <p><b>注意：</b>為了提升效能，當您重複使用 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法時，請先呼叫 <code>lock()</code> 方法，再呼叫 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法，然後在完成所有像素變更之後呼叫 <code>unlock()</code> 方法。 這個程序可預防參照此 BitmapData 實體的物件，在您尚未完成像素變更之前提早進行更新。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 數值會變更的像素 <i>x</i> 位置。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 數值會變更的像素 <i>y</i> 位置。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 像素的最後 ARGB 顏色。 如果點陣圖不透明，則會忽略此顏色值的 Alpha 透明度部分。
     
     </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例使用 <code>setPixel32()</code> 方法，在 BitmapData 物件中繪製一條透明 (Alpha == 0x60) 紅色線段：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     將位元組陣列轉換為像素資料的矩形區域。 對於每個像素，會呼叫 <code>ByteArray.readUnsignedInt()</code> 方法，並將傳回值寫入像素中。 如果位元組陣列在寫入完整的矩形之前就結束，就會傳回函數。 位元組陣列中的資料預期將為 32 位元 ARGB 像素值。 無論像素是否讀取，都不會在位元組陣列上執行搜尋。  
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 指定 BitmapData 物件的矩形區域。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; ByteArray 物件，包含了 32 位元未相乘像素值，可用在矩形區域中。
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; <code>inputByteArray</code> 物件並未包含足夠的資料來填滿 <code>rect</code> 矩形區域。 此方法在擲回例外之前，會儘可能地對更多的像素填色。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 或 inputByteArray 都是 null。
      
      </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例使用 <code>getPixels()</code> 和 <code>setPixels()</code> 方法，將某個 BitmapData 物件的像素複製到另一個物件：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     將向量轉換為像素資料的矩形區域。對於每一個象素，讀取 Vector 元素並寫入 BitmapData 像素。Vector 中的資料預期將為 32 位元 ARGB 像素值。 
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 指定 BitmapData 物件的矩形區域。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Vector 物件，包含了 32 位元未相乘像素值，可用在矩形區域中。  
     
     </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 向量陣列不夠大，無法讀取所有像素資料。
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     根據指定的臨界值來測試影像的像素值，並設定將測試傳遞至新顏色值的像素。 使用 <code>threshold()</code> 方法，您可以獨立和取代影像的顏色範圍，並在影像像素上執行其它邏輯運算。 
     
     <p><code>threshold()</code> 方法的測試邏輯如下所示：</p> 
     
     <ol><li>如果 <code>((pixelValue & mask) operation (threshold & mask))</code>，則將像素設為 <code>color</code>；</li><li>否則，如果為 <code>copySource == true</code>，則將像素設為來自 <code>sourceBitmap</code> 的對應像素值。</li></ol>
     
     <p><code>operation</code> 參數會指定用於臨界值測試的比較運算子。 例如，您可以將 "==" 當作 <code>operation</code> 參數來使用，將影像中的特定顏色值獨立出來。 或使用 <code>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</code>，在來源影像像素的 Alpha 值小於 0x7F 時，將所有目標像素設定為完全透明。 您可以將這個技巧用於動畫般的轉換和其它特效。</p>
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 要使用的輸入點陣圖影像。 來源影像可以是不一樣的 BitmapData 物件，或者參照到目前的 BitmapData 實體。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 定義要用來做為輸入的來源影像區域之矩形。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 目標影像 (目前 BitmapData 實體) 內對應至來源矩形左上角的點。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; 將下列其中一個比較運算子當做「字串」傳遞： "&lt;", "&lt;=", ">", ">=", "==", "!="
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; 用來測試每個像素的數值，以檢視是否符合或超過臨界值。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 如果臨界值測試成功，所設定的像素顏色值。 預設值為 0x00000000。
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 用來將顏色組件獨立出來的遮色片。 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 如果值為 <code>true</code>，當臨界值測試失敗時，來源影像的像素值會複製到目標。 如果值為 <code>false</code>，當臨界值測試失敗時將不會複製來源影像。 
     
     </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; 變更的像素數目。
     </td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData、sourceRect、destPoint，或 operation 都是 null。
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 操作字串不是有效的操作。 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例使用 <code>perlinNoise()</code> 方法，將藍色與紅色圖樣加入至 BitmapData 物件中，接著使用 <code>threshold()</code> 方法，將這些像素從第一個 BitmapData 物件複製到第二個物件，並在像素設定為透明紅色 (0x20FF0000) 的情況下，取代其中紅色值大於 0x80 (50%) 的像素：
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     解除鎖定影像，以便當這個 BitmapData 物件變更時，其它參照此 BitmapData 物件 (例如 Bitmap 物件) 的任何物件不會跟著更新。 若要改善效能，請在您多次呼叫 <code>setPixel()</code> 或 <code>setPixel32()</code> 方法之前與之後，搭配使用這方法與 <code>lock()</code> 方法。
     
     </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 已經變更的 BitmapData 物件區域。 如果您沒有為這個參數指定一個值，則會將整個 BitmapData 物件區域視為已變更。這個參數需要 Flash Player 9.0.115.0 版或更新版本。
     
     </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會根據 Bitmap 物件 <code>picture</code> 的 <code>bitmapData</code> 屬性來建立 BitmapData 物件。 接著，它會先呼叫 <code>lock()</code> 方法，再呼叫複雜的自訂函數 <code>complexTransformation()</code>，這個自訂函數會修改 BitmapData 物件。 (<code>picture</code> 物件和 <code>complexTransformation()</code> 函數都尚未在此範例中定義)。 即使 <code>complexTransformation()</code> 函數更新了 <code>picture</code> 物件的 <code>bitmapData</code> 屬性，變更會一直等到程式碼呼叫 <code>bitmapData</code> 物件上的 <code>unlock()</code> 方法：
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">範例<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> 下列範例會使用 BitmapDataExample 類別，將 Image.gif 影像載入至 DisplayObject 中的預設位置 (0, 0)。 接著，再將此 Image.gif 的副本置於原影像的右方，此副本具有套用至使用 <code>threshold()</code> 方法將新顏色套用至已經通過測試的像素。 您可以執行下列步驟來完成這項工作：
 <ol><li>會建立 <code>url</code> 屬性，此屬性為影像檔的位置與名稱。</li><li>此類別建構函式會建立 Loader 物件，然後將事件偵聽程式實體化，並且在 <code>completeHandler()</code> 方法完成影像操作後傳送。</li><li>然後將 <code>request</code> URLRequest 物件傳送至 <code>loader.load()</code>，並使用顯示物件將影像載入記憶體。</li><li>影像接著會被放置到顯示清單中，並於螢幕上 <i>x = 0, y = 0</i> 的座標位置顯示該影像。</li><li>此 <code>completeHandler()</code> 方法接著會進行下列動作： 
     <ul><li>建立第二個 Loader 物件，並建立以此 Loader 物件初始化的 Bitmap 物件。</li><li>建立第二個點陣圖物件，<code>duplicate</code>，此物件會反過來呼叫 <code>duplicateImage()</code> 方法，以建立原始影像的副本。 </li><li>建立 BitmapData 物件並指定給 <code>duplicate</code> 物件的 BitmapData 物件。</li><li>建立新的 Rectangle 物件，並使用與原始影像相同的座標、寬度與高度。</li><li>建立新的 Point 物件，並將其座標預設為 <i>x = 0, y = 0</i>。</li><li>建立下列變數：
         <ul><li><code>operation</code> &mdash; 當臨界值大於或等於原始值時，就會套用新的顏色。</li><li><code>threshold</code> &mdash; 每個像素都會針對其進行比較的值 (在此範例中則是 Alpha 值為 0xCC 的淺灰色)。 </li><li><code>color</code> &mdash; 通過臨界值測試，而且為像素所設定的顏色 (在此範例中則是純黃色)。</li><li><code>mask</code> &mdash; 完全對比的顏色 (透明藍色)。</li><li><code>copySource</code> &mdash; 設為 <code>false</code>，表示如果臨界值並未通過，就不會複製像素值。由於影像會重製，並且只會變更通過臨界測試的像素，所以這個值並不具意義。</li></ul></li><li>使用上面的變數來呼叫 <code>threshold()</code> 方法。 產生的臨界值方程式如下：<code>if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00</code>。 </li></ul></li></ol>
 <p> <b>注意：</b>
 <ul><li>在編譯 SWF 檔時，您必須將「本機播放安全性」設定為「只存取本機檔案」。
 </li><li>在此範例中，您需要將名為 Image.gif 的檔案放在與 SWF 檔案所處的相同目錄中。
 </li><li>我們建議您使用寬度最多約為 80 像素的影像。 </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:47 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/zh_TW/legalnotices/index.html">法律聲明</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">線上隱私權政策</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">為什麼顯示英文？</span>
				</div>
				<div class="white_content_body">
					<b>「ActionScript 3.0 參考」的內容是以英文顯示</b><br><br>
					並非所有「ActionScript 3.0 參考」的內容都翻譯為所有語言。當語言元素未翻譯時，就會以英文顯示。例如，ga.controls.HelpBox 類別並沒有翻譯為任何語言。因此在參考的繁體中文版本中，ga.controls.HelpBox 類別就會以英文顯示。
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:47 PM Z  -->
