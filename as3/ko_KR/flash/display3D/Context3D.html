<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Adobe&reg; Flash&reg; Platform용 ActionScript&reg; 3.0 참조 설명서"><meta name="lang" content="ko-kr"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:11"><meta name="runtime" content="air"><meta name="runtimever" content="air:3"><meta name="product" content="flash player"><meta name="productver" content="flash player:11"><meta name="product" content="air"><meta name="productver" content="air:3"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="Context3D,flash.display3D.Context3D,backBufferHeight,backBufferWidth,driverInfo,enableErrorChecking,maxBackBufferHeight,maxBackBufferWidth,profile,supportsVideoTexture,totalGPUMemory,clear,configureBackBuffer,createCubeTexture,createIndexBuffer,createProgram,createRectangleTexture,createTexture,createVertexBuffer,createVertexBufferForInstances,createVideoTexture,dispose,drawToBitmapData,drawTriangles,drawTrianglesInstanced,present,setBlendFactors,setColorMask,setCulling,setDepthTest,setFillMode,setProgram,setProgramConstantsFromByteArray,setProgramConstantsFromMatrix,setProgramConstantsFromVector,setRenderToBackBuffer,setRenderToTexture,setSamplerStateAt,setScissorRectangle,setStencilActions,setStencilReferenceValue,setTextureAt,setVertexBufferAt"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>Context3D - Adobe ActionScript&reg; 3 (AS3  ) API 참조 설명서</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "런타임";
			var productsLabel = "제품";
			var noneLabel = "없음";
			var qsearchBoxLabel = "빠른 검색";
			var qsearchText = "찾을 수 없는 용어";
			var ajaxErrorMsg="페이지 불러오기 오류";
			var ajaxErrorTryMsg="다시 시도";
			var ajaxLoadingMsg="불러오는 중";
			var cancelMsg = "취소";
			var classesText = "클래스";
			var strJiveReply = "이 질문은 다음 문서에 대응하여 제출되었습니다. "
			var showFilters = "필터 표시";
			var hideFilters = "필터 숨기기";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform용 ActionScript<sup>&reg;</sup> 3.0 참조 설명서<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> 홈 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="Context3D.html#top" style="display:">패키지 및 클래스 목록 표시</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="Context3D.html#top" style="display:none">패키지 및 클래스 목록 숨기기</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> 패키지 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> 클래스 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> 새로운 내용 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> 색인 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> 부록 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">영어로 표시되는 이유</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ko_KR/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>필터:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="Context3D.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display3D&nbsp;</a><br>
								<h1 id="classProductName">Context3D&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="Context3D.html#propertySummary" style="display:none"> 속성 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 속성 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 생성자 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="Context3D.html#methodSummary" style="display:none"> 메서드 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="Context3D.html#constantSummary" style="display:none"> 전역 상수 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="Context3D.html#eventSummary" style="display:none"> 이벤트 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="Context3D.html#styleSummary" style="display:none"> 스타일 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="Context3D.html#SkinPartSummary" style="display:none"> 스킨 파트 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="Context3D.html#SkinStateSummary" style="display:none"> 스킨 상태 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="Context3D.html#effectSummary" style="display:none"> 효과 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="Context3D.html#constantSummary" style="display:none"> 상수 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="Context3D.html#methodSummary" style="display:none"> 전역 함수 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="Context3D.html#methodSummary" style="display:none">함수</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="Context3D.html#interfaceSummary" style="display:none"> 인터페이스 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="Context3D.html#classSummary" style="display:none"> 클래스 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="Context3D.html#includeExamplesSummary" style="display:none"> 예제 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="Context3D.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								클래스
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">패키지</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display3D</a></td></tr><tr><td class="classHeaderTableLabel">클래스</td><td class="classSignature">public final   class  Context3D</td></tr><tr><td class="classHeaderTableLabel">상속</td><td class="inheritanceList">Context3D  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../events/EventDispatcher.html">EventDispatcher</a> <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p></p>
     Context3D 클래스는 기하학적으로 정의된 그래픽의 렌더링에 대한 컨텍스트를 제공합니다.
     
     <p>렌더링 컨텍스트에는 드로잉 표면 및 관련 리소스와 상태가 포함됩니다. 가능한 경우 렌더링 컨텍스트는 하드웨어 GPU(그래픽 처리 장치)를 사용합니다. 그렇지 않은 경우 렌더링 컨텍스트는 소프트웨어를 사용합니다. 플랫폼에서 Context3D를 통한 렌더링이 지원되지 않는 경우 Stage 객체의 <code>stage3Ds</code> 속성은 빈 목록을 포함합니다.</p>
     
               <p>Context3D 렌더링 컨텍스트는 OpenGL ES 2와 매우 비슷한 프로그래밍 가능한 파이프라인이지만 다양한 하드웨어 및 GPU 인터페이스와 호환되도록 추상화되어 있습니다. 이 렌더링 파이프라인은 3D 그래픽용으로 설계되었지만 반드시 3차원으로 렌더링해야 하는 것은 아닙니다. 따라서 적절한 꼭지점 및 픽셀 조각 프로그램을 제공하면 2D 렌더러를 만들 수 있습니다. 3D와 2D 두 경우 유일하게 지원되는 기하 요소는 삼각형입니다.</p>
     
               <p>Stage3D 객체의 <code>requestContext3D()</code> 메서드를 호출하여 Context3D 클래스의 인스턴스를 가져옵니다. 스테이지 당 Context3D 객체 수는 제한되어 있습니다. <code>Stage.stage3Ds</code> 목록의 각 Stage3D마다 하나입니다. 컨텍스트를 만들면 Stage3D 객체가 <code>context3DCreate</code> 이벤트를 전달합니다. GPU를 사용하는 다른 응용 프로그램이 포커스를 얻을 때와 같이 필요에 따라 언제든지 렌더링 컨텍스트를 삭제하고 다시 만들 수 있습니다. 코드에서는 여러 <code>context3DCreate</code> 이벤트를 수신할 수 있다고 가정해야 합니다. 연관된 Stage3D 인스턴스의 <code>x</code> 및 <code>y</code> 속성을 사용하여 스테이지에 렌더링 영역을 배치합니다.</p>  
     
     
     
     
               <p>Context3D 객체를 가져온 후 장면을 렌더링하고 표시하려면 일반적으로 다음과 같은 단계를 따릅니다.</p>
               <ol>
                  <li>
                     <code>configureBackBuffer()</code>를 호출하여 기본 디스플레이 버퍼 특성을 구성합니다.</li>
                  <li>다음을 포함한 렌더링 리소스를 만들고 초기화합니다.
      <ul>
                        <li>장면의 도형을 정의하는 꼭지점 및 인덱스 버퍼</li>
                        <li>장면을 렌더링하는 꼭지점 및 픽셀 프로그램(셰이더)</li>
                        <li>텍스처</li>
                     </ul>
                  </li>
                  <li>프레임을 렌더링합니다.
      <ul>
                        <li>장면에 있는 객체 또는 객체 컬렉션의 렌더링 상태를 적절히 설정합니다.</li>
                        <li>
                           <code>drawTriangles()</code> 메서드를 호출하여 삼각형 세트를 렌더링합니다.</li>
                        <li>다음 객체 그룹의 렌더링 상태를 변경합니다.</li>
                        <li>
                           <code>drawTriangles()</code>를 호출하여 객체를 정의하는 삼각형을 그립니다.</li>
                        <li>장면이 완전히 렌더링될 때까지 반복합니다.</li>
                        <li>
                           <code>present()</code> 메서드를 호출하여 렌더링된 장면을 스테이지에 표시합니다.</li>
                     </ul>
                  </li>
               </ol>
     
               <p>렌더링에는 다음과 같은 제한 사항이 적용됩니다.</p>
               <p>리소스 제한:
      <table class="innertable" ><tr><th>리소스</th><th>허용 개수</th><th>총 메모리</th></tr><tr><td>
                                 <code>Vertex buffers</code>
                              </td><td>4096</td><td>256MB</td></tr><tr><td>
                                 <code>Index buffers</code>
                              </td><td>4096</td><td>128MB</td></tr><tr><td>
                                 <code>Programs</code>
                              </td><td>4096</td><td>16MB</td></tr><tr><td>
                                 <code>Textures</code>
                              </td><td>4096</td><td>128MB</td></tr><tr><td>
                                 <code>Cube textures</code>
                              </td><td>4096</td><td>256MB</td></tr></table>
               </p>
               <p>AGAL 제한: 프로그램당 opcode 200개입니다.</p>
     
               <p>그리기 호출 제한: <code>present()</code> 호출당 <code>drawTriangles()</code> 호출 32,768회입니다.</p>
               <p>텍스처에는 다음과 같은 제한 사항이 적용됩니다.</p>
               <p>AIR 32비트의 텍스처 제한:
      <table class="innertable" ><tr><th>Texture</th><th>최대 크기</th><th>총 GPU 메모리</th></tr><tr><td>
                                 <code>일반 텍스처(기준선 확장 이하)</code>
                              </td><td>2048 x 2048</td><td>512MB</td></tr><tr><td>
                                 <code>일반 텍스처(기준선 확장 이상)</code>
                              </td><td>4096x4096</td><td>512MB</td></tr><tr><td>
                                 <code>사각형 텍스처(기준선 확장 이하)</code>
                              </td><td>2048 x 2048</td><td>512MB</td></tr><tr><td>
                                 <code>사각형 텍스처(기준선 확장 이상)</code>
                              </td><td>4096x4096</td><td>512MB</td></tr><tr><td>
                                 <code>정육면체 텍스처</code>
                              </td><td>1024x1024</td><td>256MB</td></tr></table>
	              </p> 
	              <p>AIR 64비트의 텍스처 제한(데스크톱):
      <table class="innertable" ><tr><th>Texture</th><th>최대 크기</th><th>총 GPU 메모리</th></tr><tr><td>
                                 <code>일반 텍스처(기준선 확장 이하)</code>
                              </td><td>2048 x 2048</td><td>512MB</td></tr><tr><td>
                                 <code>일반 텍스처(표준으로 확장된 기준선)</code>
                              </td><td>4096x4096</td><td>512MB</td></tr><tr><td>
                                 <code>일반 텍스처(표준 확장 이상)</code>
                              </td><td>4096x4096</td><td>2048MB</td></tr><tr><td>
                                 <code>사각형 텍스처(기준선 확장 이하)</code>
                              </td><td>2048 x 2048</td><td>512MB</td></tr><tr><td>
                                 <code>사각형 텍스처(표준으로 확장된 기준선)</code>
                              </td><td>4096x4096</td><td>512MB</td></tr><tr><td>
                                 <code>사각형 텍스처(표준 확장 이상)</code>
                              </td><td>4096x4096</td><td>2048MB</td></tr><tr><td>
                                 <code>정육면체 텍스처</code>
                              </td><td>1024x1024</td><td>256MB</td></tr></table>
	              </p>
               <p>밉맵에 필요한 텍스처 메모리를 비롯하여 텍스처의 절대 제한은 512MB입니다. 하지만 정육면체 텍스처의 경우 메모리 제한은 256MB입니다.</p>
     
               <p>Context3D 생성자를 사용하여 Context3D 객체를 만들 수는 없습니다. 이 객체는 Stage3D 인스턴스의 속성으로 생성되고 제공됩니다. Context3D 클래스는 Flash Player와 AIR에서 실행될 때 데스크톱 플랫폼과 모바일 플랫폼에서 모두 사용할 수 있습니다.</p>
         
            <p></p><p><a href="Context3D.html#includeExamplesSummary">예제 보기</a></p><p><span class="classHeaderTableLabel">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a><br/><a href="Context3DClearMask.html" target="">Context3DClearMask</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DProgramType.html" target="">Context3DProgramType</a><br/><a href="Context3DRenderMode.html" target="">Context3DRenderMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="textures/CubeTexture.html" target="">flash.display3D.textures.CubeTexture</a><br/><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a><br/><a href="../geom/Matrix3D.html" target="">flash.geom.Matrix3D</a><br/><a href="Program3D.html" target="">Program3D</a><br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a><br/><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">공용 속성</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 상속되는 공용 속성 숨기기</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 상속되는 공용 속성 표시</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">속성</th><th>정의 주체</th></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferHeight" class="signatureLink">backBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[읽기 전용]  
        백 버퍼의 높이를 지정합니다. 이 값은 configureBackBuffer() 메서드 호출이 성공할 경우 변경될 수 있습니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferWidth" class="signatureLink">backBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[읽기 전용]  
        백 버퍼의 너비를 지정합니다. 이 값은 configureBackBuffer() 메서드 호출이 성공할 경우 변경될 수 있습니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 지정된 객체 인스턴스의 클래스 객체 또는 생성자 함수에 대한 참조입니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#driverInfo" class="signatureLink">driverInfo</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[읽기 전용]  
         이 렌더링 컨텍스트에서 사용되는 그래픽 라이브러리 드라이버의 유형입니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#enableErrorChecking" class="signatureLink">enableErrorChecking</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription"> 
         렌더러에서 발견한 오류를 응용 프로그램에 보고할지 여부를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferHeight" class="signatureLink">maxBackBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        백 버퍼의 최대 높이를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferWidth" class="signatureLink">maxBackBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        백 버퍼의 최대 너비를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::12##AIR::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#profile" class="signatureLink">profile</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[읽기 전용] 
		이 Context3D 객체에 사용되는 기능 지원 프로파일입니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#supportsVideoTexture" class="signatureLink">supportsVideoTexture</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[정적] [읽기 전용] 
          Context3D가 비디오 텍스처를 지원할 경우 명시됩니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::21##AIR::21##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#totalGPUMemory" class="signatureLink">totalGPUMemory</a> : <a href="../../Number.html">Number</a><div class="summaryTableDescription">[읽기 전용]  
         응용 프로그램의 Stage3D 데이터 구조에서 할당된 총 GPU 메모리를 반환합니다. GPU 리소스 객체가 만들어질 때마다, 활용된 메모리가 Context3D에 저장됩니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">공용 메서드 </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 상속되는 공용 메서드 숨기기</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 상속되는 공용 메서드 표시</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">메서드</th><th>정의 주체</th></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#addEventListener()" class="signatureLink">addEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false, priority:<a href="../../int.html">int</a> = 0, useWeakReference:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	리스너에서 이벤트 알림을 받을 수 있도록 EventDispatcher 객체에 이벤트 리스너 객체를 등록합니다.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#clear()" class="signatureLink">clear</a>(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         이 Context3D 객체에 연결된 색상, 심도 및 스텐실 버퍼를 지우고 지정된 값으로 채웁니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#configureBackBuffer()" class="signatureLink">configureBackBuffer</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         렌더링 버퍼의 뷰포트 크기 및 기타 특성을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createCubeTexture()" class="signatureLink">createCubeTexture</a>(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></div><div class="summaryTableDescription">
         CubeTexture 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createIndexBuffer()" class="signatureLink">createIndexBuffer</a>(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></div><div class="summaryTableDescription">
         IndexBuffer3D 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createProgram()" class="signatureLink">createProgram</a>():<a href="Program3D.html">Program3D</a></div><div class="summaryTableDescription">
         Program3D 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.8##AIR::3.8##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createRectangleTexture()" class="signatureLink">createRectangleTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></div><div class="summaryTableDescription">
         Rectangle Texture 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createTexture()" class="signatureLink">createTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></div><div class="summaryTableDescription">
         Texture 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVertexBuffer()" class="signatureLink">createVertexBuffer</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         VertexBuffer3D 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#createVertexBufferForInstances()" class="signatureLink">createVertexBufferForInstances</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         인스턴스 데이터에 대해 VertexBuffer3D 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVideoTexture()" class="signatureLink">createVideoTexture</a>():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></div><div class="summaryTableDescription">
         VideoTexture 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#dispatchEvent()" class="signatureLink">dispatchEvent</a>(event:<a href="../events/Event.html">Event</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	이벤트를 이벤트 흐름으로 전달합니다.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#dispose()" class="signatureLink">dispose</a>(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         이 Context3D에 연결된 모든 리소스와 내부 저장소를 해제합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawToBitmapData()" class="signatureLink">drawToBitmapData</a>(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         비트맵에 현재 렌더링 버퍼를 그립니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#drawTriangles()" class="signatureLink">drawTriangles</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         현재 버퍼 및 이 Context3D 객체의 상태를 사용하여 지정된 삼각형을 렌더링합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawTrianglesInstanced()" class="signatureLink">drawTrianglesInstanced</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         현재 버퍼 및 이 Context3D 객체의 상태를 사용하여 지정된 인스턴스화된 삼각형을 렌더링합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#hasEventListener()" class="signatureLink">hasEventListener</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	EventDispatcher 객체에 특정 유형의 이벤트에 대한 리스너가 등록되어 있는지 여부를 확인합니다.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 지정된 속성이 객체에 정의되어 있는지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Object 클래스의 인스턴스가 매개 변수로 지정된 객체의 프로토타입 체인에 있는지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#present()" class="signatureLink">present</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         백 렌더링 버퍼를 표시합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 지정된 속성이 존재하고 열거 가능한지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#removeEventListener()" class="signatureLink">removeEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	EventDispatcher 객체에서 리스너를 제거합니다.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setBlendFactors()" class="signatureLink">setBlendFactors</a>(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         기존 색상을 사용한 그리기 작업의 출력 색상을 블렌딩하는 데 사용하는 인수를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setColorMask()" class="signatureLink">setColorMask</a>(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         렌더링 버퍼에 색상을 기록할 때 사용하는 마스크를 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setCulling()" class="signatureLink">setCulling</a>(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         삼각형 컬링 모드를 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setDepthTest()" class="signatureLink">setDepthTest</a>(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         심도 테스트에 사용되는 비교 유형을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::16##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#setFillMode()" class="signatureLink">setFillMode</a>(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
		렌더링에 사용되는 채우기 모드를 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgram()" class="signatureLink">setProgram</a>(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         후속 렌더링에 사용할 꼭지점 및 조각 셰이더 프로그램을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.1##AIR::3.1##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromByteArray()" class="signatureLink">setProgramConstantsFromByteArray</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         ByteArray에 저장된 값을 사용하여 셰이더 프로그램에 사용할 상수를 설정합니다. </div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromMatrix()" class="signatureLink">setProgramConstantsFromMatrix</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         Matrix3D에 저장된 값을 사용하여 셰이더 프로그램에 사용할 상수를 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromVector()" class="signatureLink">setProgramConstantsFromVector</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         셰이더 프로그램에 대한 상수 입력을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     루프 작업에서 동적 속성을 사용할 수 있는지 여부를 설정합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToBackBuffer()" class="signatureLink">setRenderToBackBuffer</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         백 렌더링 버퍼를 렌더링 대상으로 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToTexture()" class="signatureLink">setRenderToTexture</a>(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         지정된 텍스처를 렌더링 대상으로 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.6##AIR::3.6##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setSamplerStateAt()" class="signatureLink">setSamplerStateAt</a>(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         텍스처 샘플러 상태를 수동으로 재정의합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setScissorRectangle()" class="signatureLink">setScissorRectangle</a>(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         드로잉 마스크의 한 유형인 자르기 사각형을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilActions()" class="signatureLink">setStencilActions</a>(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         스텐실 모드 및 작업을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilReferenceValue()" class="signatureLink">setStencilReferenceValue</a>(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
         스텐실 테스트에 사용되는 스텐실 비교 값을 설정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setTextureAt()" class="signatureLink">setTextureAt</a>(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         조각 프로그램의 텍스처 입력 레지스터에 사용할 텍스처를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setVertexBufferAt()" class="signatureLink">setVertexBufferAt</a>(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         단일 꼭지점 셰이더 프로그램 입력에 해당하는 꼭지점 데이터 구성 요소를 지정합니다.</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 로캘별 규칙에 따라 서식이 지정된 이 객체의 문자열 표현을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 지정된 객체의 문자열 표현을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 지정된 객체의 프리미티브 값을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#willTrigger()" class="signatureLink">willTrigger</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	이 EventDispatcher 객체 또는 조상 객체에 지정한 이벤트 유형에 대한 이벤트 리스너가 등록되어 있는지 여부를 확인합니다.</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="eventSummary" id="eventSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">이벤트</div><div class="showHideLinks"><a href="http://help.adobe.com/en_US/Flex/4.6/UsingSDK/WS2db454920e96a9e51e63e3d11c0bf69084-7ee9.html" target="_blank">이벤트에 대한 자세한 내용을 보려면 클릭하십시오.</a></div><div class="showHideLinks"><div id="hideInheritedEvent" class="hideInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(false,'Event');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 상속되는 이벤트 숨기기</a></div><div id="showInheritedEvent" class="showInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(true,'Event');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 상속되는 이벤트 표시</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable hideInheritedEvent" id="summaryTableEvent"><tr><th>&nbsp;</th><th colspan="2">이벤트</th><th> 요약 </th><th>정의 주체</th></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:activate" class="signatureLink">activate</a></div></td><td class="summaryTableDescription summaryTableCol">[브로드캐스트 이벤트] Flash Player 또는 AIR 응용 프로그램이 운영 체제 포커스를 얻어 활성화될 때 전달됩니다.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:deactivate" class="signatureLink">deactivate</a></div></td><td class="summaryTableDescription summaryTableCol">[브로드캐스트 이벤트] Flash Player 또는 AIR 응용 프로그램이 운영 체제 포커스를 잃고 비활성화될 때 전달됩니다.</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">속성 세부 정보</div><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferHeight" id="backBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferHeight</h3></td><td class="detailHeaderType">속성</td></tr></table><div class="detailBody"><code>backBufferHeight:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        백 버퍼의 높이를 지정합니다. 이 값은 <code>configureBackBuffer()</code> 메서드 호출이 성공할 경우 변경될 수 있습니다. 가장 최근에 <code>configureBackBuffer()</code> 메서드 호출이 성공했을 때 <code>wantsBestResolutionOnBrowserZoom</code>이 <code>true</code>로 설정된 경우 브라우저 확대/축소 인수 변경 시 높이가 수정될 수도 있습니다. 브라우저 확대/축소 변경 이벤트에 대한 이벤트 리스너를 등록하면 높이 변경을 감지할 수 있습니다.
        
        </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferHeight():<a href="../../int.html">int</a></code><br/><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferWidth" id="backBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferWidth</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>backBufferWidth:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        백 버퍼의 너비를 지정합니다. 이 값은 <code>configureBackBuffer()</code> 메서드 호출이 성공할 경우 변경될 수 있습니다. 가장 최근에 <code>configureBackBuffer()</code> 메서드 호출이 성공했을 때 <code>wantsBestResolutionOnBrowserZoom</code>이 <code>true</code>로 설정된 경우 브라우저 확대/축소 인수 변경 시 너비가 수정될 수도 있습니다. 브라우저 확대/축소 변경 이벤트에 대한 이벤트 리스너를 등록하면 너비 변경을 감지할 수 있습니다.
		
		</p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferWidth():<a href="../../int.html">int</a></code><br/><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="driverInfo" id="driverInfo"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>driverInfo</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>driverInfo:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         이 렌더링 컨텍스트에서 사용되는 그래픽 라이브러리 드라이버의 유형입니다. 렌더링 시 소프트웨어, DirectX 드라이버 또는 OpenGL 드라이버 중 어느 것을 사용하는지를 나타냅니다. 하드웨어 렌더링이 실패했는지도 나타냅니다. 하드웨어 렌더링이 실패하면 Flash Player에서 Stage3D에 대해 소프트웨어 렌더링을 사용하고 <code>driverInfo</code>에 다음 값 중 하나가 포함됩니다.
         <ul><li>"Software Hw_disabled=userDisabled" - Adobe Flash Player 설정 UI에서 [하드웨어 가속 사용] 체크 상자가 선택되지 않았습니다.</li><li>"Software Hw_disabled=oldDriver" - 하드웨어 그래픽 드라이버에 알려진 문제가 있습니다. 그래픽 드라이버를 업데이트하면 이 문제가 해결될 수도 있습니다.</li><li>"Software Hw_disabled=unavailable" - 하드웨어 그래픽 드라이버에 알려진 문제가 있거나 하드웨어 그래픽 초기화가 실패했습니다.</li><li>"Software Hw_disabled=explicit" - 내용이 requestContext3D를 통해 소프트웨어 렌더링을 명시적으로 요청했습니다.</li><li>"Software Hw_disabled=domainMemory" - 내용이 domainMemory를 사용하며, 이는 Stage3D 하드웨어 렌더링과 함께 사용되는 경우 라이센스가 필요합니다. 자세한 내용은 <a href="http://www.adobe.com/go/fpl" target="_new">adobe.com/go/fpl_kr</a>을 참조하십시오.</li></ul>
         
         </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get driverInfo():<a href="../../String.html">String</a></code><br/></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="enableErrorChecking" id="enableErrorChecking"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>enableErrorChecking</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>enableErrorChecking:<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         렌더러에서 발견한 오류를 응용 프로그램에 보고할지 여부를 지정합니다.
          
         <p><code>enableErrorChecking</code>이 <code>true</code>이면 <code>clear()</code> 및 <code>drawTriangles()</code> 메서드가 동기적이며 오류를 발생시킬 수 있습니다. <code>enableErrorChecking</code>이 기본값인 <code>false</code>이면 <code>clear()</code> 및 <code>drawTriangles()</code> 메서드가 비동기적이며 오류를 보고하지 않습니다. 오류 검사를 활성화하면 렌더링 성능이 저하됩니다. 디버깅 시에만 오류 검사를 활성화해야 합니다.</p>
         
         </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get enableErrorChecking():<a href="../../Boolean.html">Boolean</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set enableErrorChecking(value:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><br/><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferHeight" id="maxBackBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferHeight</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferHeight:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        백 버퍼의 최대 높이를 지정합니다. 이 초기 값은 플랫폼에 대한 시스템 제한 값입니다. 이 속성 값은 시스템 제한 값보다 작거나 동일하게 설정해야 합니다. 시스템 제한 값보다 크게 설정할 수 없습니다. 이 속성 값은 최소값 제한 값보다 크거나 동일하게 설정해야 합니다. 최소값 제한 값보다 작게 설정할 수 없습니다. 백 버퍼가 구성되지 않은 경우 최소값 제한 값은 상수, 32입니다. 백 버퍼 구성 후 마지막으로 <code>configureBackBuffer()</code> 메서드 호출을 성공했을 때 높이 매개 변수의 값이 최소값 제한 값이 됩니다.
        
        </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferHeight():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferHeight(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferWidth" id="maxBackBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferWidth</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferWidth:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        백 버퍼의 최대 너비를 지정합니다. 이 초기 값은 플랫폼에 대한 시스템 제한 값입니다. 이 속성 값은 시스템 제한 값보다 작거나 동일하게 설정해야 합니다. 시스템 제한 값보다 크게 설정할 수 없습니다. 이 속성 값은 최소값 제한 값보다 크거나 동일하게 설정해야 합니다. 최소값 제한 값보다 작게 설정할 수 없습니다. 백 버퍼가 구성되지 않은 경우 최소값 제한 값은 상수, 32입니다. 백 버퍼 구성 후 마지막으로 <code>configureBackBuffer()</code> 메서드 호출을 성공했을 때 너비 매개 변수의 값이 최소값 제한 값이 됩니다.
		
        </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferWidth():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferWidth(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::12##AIR::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="profile" id="profile"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>profile</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>profile:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 12, AIR 4</td></tr></table><p></p><p></p><p>
		이 Context3D 객체에 사용되는 기능 지원 프로파일입니다.
		</p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get profile():<a href="../../String.html">String</a></code><br/><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DProfile.html" target="">Context3DProfile</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="propertyDetail" id="propertyDetail"></a><a name="supportsVideoTexture" id="supportsVideoTexture"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>supportsVideoTexture</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>supportsVideoTexture:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
          Context3D가 비디오 텍스처를 지원할 경우 명시됩니다.
         
          </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public static function get supportsVideoTexture():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::21##AIR::21##"><a name="propertyDetail" id="propertyDetail"></a><a name="totalGPUMemory" id="totalGPUMemory"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>totalGPUMemory</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>totalGPUMemory:<a href="../../Number.html">Number</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 21, AIR 21</td></tr></table><p></p><p></p><p> 
         <p>응용 프로그램의 Stage3D 데이터 구조에서 할당된 총 GPU 메모리를 반환합니다.</p>
		 <p>GPU 리소스 객체가 만들어질 때마다, 활용된 메모리가 Context3D에 저장됩니다. 이 메모리에는 인덱스 버퍼, 꼭지점 버퍼, 텍스처(비디오 텍스처 제외) 및 이 Context3D를 통해 만들어진 프로그램이 포함됩니다.</p>
		 <p>API <code>totalGPUMemory</code>는 위 리소스에서 사용하는 총 메모리를 사용자에게 반환합니다. 반환되는 기본값은 0입니다. 반환되는 총 GPU 메모리는 바이트 단위입니다. 정보는 모바일의 직접 모드와 데스크톱의 직접 및 GPU 모드에서만 제공됩니다. 데스크톱에서 <code>&lt;renderMode&gt;gpu&lt;/renderMode&gt;</code>를 사용하면 <code>&lt;renderMode&gt;direct&lt;/renderMode&gt;</code>로 폴백됩니다. </p>
		 
         이 API는 SWF 버전이 32 이상인 경우 사용할 수 있습니다.
         
         
         </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get totalGPUMemory():<a href="../../Number.html">Number</a></code><br/></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">메서드 세부 정보</div><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="clear()" id="clear()"></a><a name="clear(Number,Number,Number,Number,Number,uint,uint)" id="clear(Number,Number,Number,Number,Number,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clear</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td></tr></table><div class="detailBody"><code> public function clear(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         이 Context3D 객체에 연결된 색상, 심도 및 스텐실 버퍼를 지우고 지정된 값으로 채웁니다.
         
         <p><code>mask</code> 매개 변수를 설정하여 지울 버퍼를 지정합니다. Context3DClearMask 클래스에 정의된 상수를 사용하여 <code>mask</code> 매개 변수를 설정합니다. bitwise OR 연산자("|")를 사용하여 mask에 여러 버퍼를 추가하거나 <code>Context3DClearMask.ALL</code>을 사용합니다. 백 버퍼로 렌더링할 경우에는 <code>clear()</code>를 호출하기 전에 <code>configureBackBuffer()</code> 메서드를 호출해야 합니다.</p>
         
         <p><b>참고:</b> 허용 범위에서 벗어나는 매개 변수 값을 지정하면 숫자 매개 변수 값이 0에서 1 사이의 범위로 잘리며 오류는 발생하지 않습니다. 마찬가지로 <code>stencil</code>은 0xff보다 큰 경우 0xff로 설정됩니다. </p> 
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 색상 버퍼를 지우는 데 사용할 색상의 빨강 요소이며 범위는 0에서 1 사이입니다.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 색상 버퍼를 지우는 데 사용할 색상의 녹색 요소이며 범위는 0에서 1 사이입니다.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 색상 버퍼를 지우는 데 사용할 색상의 파랑 요소이며 범위는 0에서 1 사이입니다.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; 색상 버퍼를 지우는 데 사용할 색상의 알파 요소이며 범위는 0에서 1 사이입니다. 알파 구성 요소는 블렌딩에 사용되지 않습니다. 버퍼 알파에 직접 기록됩니다.        
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">depth</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; 심도 버퍼를 지우는 데 사용할 값이며 범위는 0에서 1 사이입니다.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stencil</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 스텐실 버퍼를 지우는 데 사용할 8비트 값이며 범위는 0x00에서 0xff 사이입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xffffffff</code>)<code></code> &mdash; 지울 버퍼를 지정합니다.
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DClearMask.html" target="">Context3DClearMask</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="configureBackBuffer()" id="configureBackBuffer()"></a><a name="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)" id="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>configureBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function configureBackBuffer(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         렌더링 버퍼의 뷰포트 크기 및 기타 특성을 설정합니다.
         
         <p>렌더링에는 이중 버퍼가 사용됩니다. <code>present()</code> 메서드를 호출하면 백 버퍼와 표시되는 전면 버퍼가 교체됩니다. 버퍼의 최소 크기는 32x32 픽셀입니다. 백 버퍼의 최대 크기는 장치 기능에 따라 제한되며, <code>maxBackBufferWidth</code> 및 <code>maxBackBufferHeight</code> 속성을 통해 사용자가 설정할 수도 있습니다. 버퍼 구성은 속도가 느린 작업입니다. 일반적인 렌더링 작업 중에는 버퍼 크기 또는 특성을 변경하지 마십시오.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 버퍼의 폭입니다(픽셀 단위).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 버퍼의 높이입니다(픽셀 단위).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> &mdash; 요청된 앤티앨리어싱 품질을 지정하는 정수 값입니다. 이 값은 앤티앨리어싱에 사용되는 부분 샘플 수와 관련됩니다. 부분 샘플을 많이 사용할수록 많은 계산을 수행해야 하지만, 상대적인 성능 영향은 특정 렌더링 하드웨어에 따라 다릅니다. 앤티앨리어싱의 유형과 앤티앨리어싱이 수행되는지 여부는 장치 및 렌더링 모드에 따라 다릅니다. 소프트웨어 렌더링 컨텍스트에서는 앤티앨리어싱이 전혀 지원되지 않습니다.
         
         <table class="+ topic/table adobe-d/adobetable " ><tr><td>0</td><td>앤티앨리어싱 없음</td></tr><tr><td>2</td><td>최소 앤티앨리어싱</td></tr><tr><td>4</td><td>고품질 앤티앨리어싱</td></tr><tr><td>16</td><td>최고 품질 앤티앨리어싱</td></tr></table>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; <code>false</code>는 심도 또는 스텐실 버퍼가 생성되지 않는다는 것을 나타내고 <code>true</code>는 심도 및 스텐실 버퍼가 생성된다는 것을 나타냅니다. SWF 버전 15 이상으로 컴파일된 AIR 3.2 이상 응용 프로그램의 경우 응용 프로그램 설명자 파일의 <code>renderMode</code> 요소가 <code>direct</code>이면 응용 프로그램 설명자 파일의 <code>depthAndStencil</code> 요소 값도 이 인수와 동일해야 합니다. 기본적으로 <code>depthAndStencil</code> 요소의 값은 <code>false</code>입니다.
		 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolution</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code>이면 장치가 HiDPI 화면을 지원하는 경우 폭 및 높이 매개 변수로 나타낸 것보다 큰 백 버퍼의 할당을 시도하게 됩니다. 이렇게 되면 픽셀이 추가되고 셰이더 작업 결과가 바뀔 수 있기 때문에 기본값에 의해 해제되는 것입니다. 기본 백 버퍼가 확장된 정도를 확인하려면 Stage.contentsScaleFactor를 사용합니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolutionOnBrowserZoom</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code>: 백 버퍼의 크기가 브라우저 확대/축소 인수의 증가와 비례하여 증가합니다. 이 값은 여러 브라우저 확대/축소와 일관되게 설정되어야 합니다. 이 매개 변수의 기본값은 <code>false</code>입니다. 백 버퍼 크기 증가를 제한하려면 <code>maxBackBufferWidth</code> 및 <code>maxBackBufferHeight</code> 속성을 설정하십시오. 백 버퍼의 현재 크기를 결정하려면 <code>backBufferWidth</code> 및 <code>backBufferHeight</code>를 사용하십시오.
		 
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 입력 크기: width 또는 height 매개 변수가 최소 백 버퍼 허용 크기보다 작거나, 허용되는 최대 백 버퍼 크기보다
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3709: 응용 프로그램 설명자의 <code>depthAndStencil</code> 플래그는 Context3D 객체의 <code>configureBackBuffer()</code>로 전달되는 <code>enableDepthAndStencil</code> 부울과 일치해야 합니다.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createCubeTexture()" id="createCubeTexture()"></a><a name="createCubeTexture(int,String,Boolean,int)" id="createCubeTexture(int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createCubeTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createCubeTexture(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         CubeTexture 객체를 만듭니다.
         
         <p>CubeTexture 객체를 사용하여 정육면체 텍스처 비트맵을 렌더링 컨텍스트에 업로드하고 렌더링 도중 정육면체 텍스처를 참조합니다. 정육면체 텍스처는 정육면체 토폴로지로 정렬된 동일한 크기의 사각형 텍스처 6개로 구성되고 환경 맵을 설명하는 데 유용합니다.</p>
           
         <p>CubeTexture 생성자를 사용하여 CubeTexture 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. CubeTexture 객체를 만든 후에는 CubeTexture <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> 또는 <code>uploadCompressedTextureFromByteArray()</code> 메서드를 사용하여 텍스처 비트맵 데이터를 업로드합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">size</span>:<a href="../../int.html">int</a></code> &mdash; 텍스처 가장자리 길이입니다(텍셀 단위).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 열거 목록의 텍셀 형식입니다.
         <p> 텍스처 압축을 사용하면 GPU에서 직접 압축된 형식으로 텍스처 이미지를 저장할 수 있으므로 GPU 메모리와 메모리 대역폭이 절약됩니다. 일반적으로 압축된 텍스처는 오프라인으로 압축되고 Texture.uploadCompressedTextureFromByteArray 메서드를 사용하여 압축된 형태로 GPU에 업로드됩니다. 데스크톱 플랫폼의 Flash Player 11.4 및 AIR 3.4에서는 런타임 텍스처 압축에 대한 지원이 추가되었으며, 이는 벡터 아트에서 동적 텍스처를 렌더링하는 경우 등 일부 상황에서 유용할 수 있습니다. 이 기능은 현재 모바일 플랫폼에서는 사용할 수 없으며, 대신에 ArgumentError(텍스처 형식 불일치)가 발생합니다. 런타임 텍스처 압축을 사용하려면 다음 단계를 수행하십시오. 1. Context3D.createCubeTexture() 메서드를 호출하고, 형식 매개 변수로 flash.display3D.Context3DTextureFormat.COMPRESSED 또는 flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA를 전달하여 텍스처 객체를 만듭니다. 2. createCubeTexture()가 반환하는 flash.display3D.textures.Texture 인스턴스를 사용하여 flash.display3D.textures.CubeTexture.uploadFromBitmapData() 또는 flash.display3D.textures.CubeTexture.uploadFromByteArray()를 호출함으로써 한 번에 텍스처를 업로드하고 압축합니다.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 텍스처가 렌더링 대상으로 사용될 가능성이 있는 경우 <code>true</code>로 설정합니다.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 이미지가 렌더링되기 전에 로드해야 하는 밉 맵 레벨입니다. 텍스처 스트리밍을 사용하면 우선 최소 밉 레벨을 로드 및 표시한 후, 텍스처가 로드되는 동안 점진적으로 더 높은 품질의 이미지를 표시할 수 있습니다. 최종 사용자는 높은 품질의 이미지가 로드되는 동안 응용 프로그램에서 낮은 품질의 이미지를 볼 수 있습니다.
         <p>기본적으로 streamingLevels는 0이며, 이는 이미지가 렌더링되기 전에 MIP 맵의 최고 품질 이미지를 로드해야 함을 의미합니다. 이 매개 변수는 Flash Player 11.3 및 AIR 3.3에서 추가되었습니다. 기본값을 사용하면 이전 버전의 Flash Player 및 AIR의 비헤이비어가 유지됩니다. 
         </p>
         <p>텍스처 스트리밍을 활성화하려면 <code>streamingLevels</code>를 1과 밉 맵에 있는 이미지 수 사이의 값으로 설정합니다. 예를 들어 주 이미지(64x64 픽셀)를 최고 품질로 포함하는 밉 맵이 있다고 가정할 경우 이 밉 맵의 저품질 이미지는 전체 7개 이미지 또는 7개 레벨에 대해 32x32, 16x16, 8x8, 4x4, 2x2 및 1x1 픽셀입니다. 레벨 0은 최고 품질 이미지입니다. 이 속성의 최대값은 log2(min(width,height))입니다. 따라서 주 이미지가 64x64 픽셀인 경우 <code>streamingLevels</code>의 최대값은 7입니다. 8x8 픽셀 이미지가 로드된 후에 해당 이미지를 렌더링하려면 이 속성을 3으로 설정합니다.</p>
         
         <p><b>참고: </b>이 속성을 0보다 큰 값으로 설정하면 메모리 사용과 성능에 영향을 줄 수 있습니다. </p>
         
         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: Texture 객체가 너무 많이 만들어졌거나 텍스처에 할당된 메모리의 양을 초과한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 깊이 텍스처가 구현되지 않음: 깊이 텍스처를 만들려고 한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처 크기가 0임: <code>size</code> 매개 변수가 0보다 크지 않은 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처가 2의 거듭제곱이 아님: <code>size</code> 매개 변수가 2의 거듭제곱이 아닌 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처가 너무 큼: <code>size</code> 매개 변수가 1024보다 큰 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 CubeTexture 객체를 만들 수 없는 경우입니다(원인 정보가 제공되지 않음).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 잘못된 스트리밍 레벨: <code>streamingLevels</code>가 log2(크기)보다 크거나 같은 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createIndexBuffer()" id="createIndexBuffer()"></a><a name="createIndexBuffer(int,String)" id="createIndexBuffer(int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createIndexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createIndexBuffer(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         IndexBuffer3D 객체를 만듭니다.
         
         <p>IndexBuffer3D 객체를 사용하여 삼각형 인덱스 집합을 렌더링 컨텍스트에 업로드하고 렌더링을 위해 해당 인덱스 집합을 참조합니다. 인덱스 버퍼의 각 인덱스는 꼭지점 버퍼에서 해당 꼭지점을 참조합니다. 삼각형은 각각 세 개의 인덱스 집합으로 식별됩니다. IndexBuffer3D 객체를 <code>drawTriangles()</code> 메서드에 전달하여 인덱스 버퍼에 정의된 하나 이상의 삼각형을 렌더링합니다.</p>
         
         <p>IndexBuffer3D 클래스 생성자를 사용하여 IndexBuffer3D 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. IndexBuffer3D 객체를 만든 후에는 IndexBuffer3D <code>uploadFromVector()</code> 또는 <code>uploadFromByteArray()</code> 메서드를 사용하여 인덱스를 업로드합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numIndices</span>:<a href="../../int.html">int</a></code> &mdash; 버퍼에 저장할 꼭지점 수입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 예상 버퍼 사용량입니다. <code>Context3DBufferUsage</code>에 정의된 상수 중 하나를 사용합니다. 올바로 설정하면 하드웨어 드라이버가 최적화 작업을 제대로 수행할 수 있습니다. 이 매개 변수는 Flash 12 및 AIR 4 이후부터만 사용할 수 있습니다.
 
         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="IndexBuffer3D.html">IndexBuffer3D</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: 인덱스 버퍼가 너무 많이 만들어졌거나 인덱스 버퍼에 할당된 메모리의 양을 초과한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 버퍼가 너무 큼: <code>numIndices</code>가 0xf0000보다 크거나 같은 경우입니다. 
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createProgram()" id="createProgram()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createProgram():<a href="Program3D.html">Program3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Program3D 객체를 만듭니다.
         
         <p>Program3D 객체를 사용하여 셰이더 프로그램을 렌더링 컨텍스트에 업로드하고 업로드한 프로그램을 렌더링 도중 참조합니다. Program3D 객체는 두 개의 프로그램인 꼭지점 프로그램과 조각 프로그램(픽셀 프로그램이라고도 함)을 저장합니다. 프로그램은 이진 셰이더 어셈블리 언어로 기록됩니다. </p>
         
         <p>Program3D 생성자를 사용하여 Program3D 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. Program3D 객체를 만든 후에는 Program3D <code>upload()</code> 메서드를 사용하여 프로그램을 업로드합니다.</p>
         
         </p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Program3D.html">Program3D</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 프로그램 수가 4096을 초과하거나 총 메모리 크기가 16MB를 초과합니다(<code>dispose</code>를 사용하여 Program3D 리소스 해제).
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Program3D.html" target="">Program3D</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 이 예제에서는 렌더링 컨텍스트에 대해 한 쌍의 꼭지점 및 픽셀 프로그램을 만들고, 업로드하고, 활성화하는 방법을 보여 줍니다. <code>renderContext</code> 객체는 Context3D 클래스의 인스턴스입니다. 예제의 프로그램은 AGAL(Adobe Graphics Assembly Language)로 작성되었습니다. 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.8##AIR::3.8##"><a name="createRectangleTexture()" id="createRectangleTexture()"></a><a name="createRectangleTexture(int,int,String,Boolean)" id="createRectangleTexture(int,int,String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createRectangleTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createRectangleTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.8, AIR 3.8</td></tr></table><p></p><p></p><p>
         Rectangle Texture 객체를 만듭니다.
         
         <p>RectangleTexture 객체를 사용하여 텍스처 비트맵을 렌더링 컨텍스트에 업로드하고 렌더링 도중 텍스처를 참조합니다.</p>
         
         <p>RectangleTexture 생성자를 사용하여 RectangleTexture 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. RectangleTexture 객체를 만든 후에는 Texture <code>uploadFromBitmapData()</code> 또는 <code>uploadFromByteArray()</code> 메서드를 사용하여 텍스처 비트맵을 업로드합니다.</p>
         
         <p>32비트 정수 텍스처는 Flash <code>BitmapData</code> 형식과 일치하도록 압축된 BGRA 형식으로 저장됩니다. 부동 소수점 텍스처는 기본 RGBA 형식을 사용합니다. </p>
         
         <p> 사각형 텍스처는 폭과 높이가 2의 거듭제곱일 필요가 없다는 점에서 일반 2D 텍스처와 다릅니다. 또한 밉 맵을 포함하지 않습니다. 이러한 텍스처는 텍스처 케이스에 렌더링하는 경우에 매우 유용합니다. 사각형 텍스처를 밉 맵 필터링 또는 반복 래핑을 사용하는 견본과 함께 사용되면 drawTriangles 호출이 실패합니다. 또한 사각형 텍스처는 스트리밍을 허용하지 않습니다. 사각형 텍스처가 지원하는 텍스처 형식은 BGRA, BGR_PACKED, BGRA_PACKED뿐입니다. 압축된 텍스처 형식은 사각형 텍스처에서 지원되지 않습니다.
         </p>
                 
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 텍스처 폭입니다(텍셀 단위).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 텍스처 높이입니다(텍셀 단위).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 열거 목록의 텍셀 형식입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 텍스처가 렌더링 대상으로 사용될 가능성이 있는 경우 <code>true</code>로 설정합니다.                 
                                   
         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: Texture 객체가 너무 많이 만들어졌거나 텍스처에 할당된 메모리의 양을 초과한 경우입니다.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처 크기가 0임: <code>width</code> 또는 <code>height</code> 매개 변수가 0보다 작거나 0인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처가 너무 큼: <code>width</code> 또는 <code>height</code> 매개 변수가 2048보다 큰 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 Texture 객체를 만들 수 없는 경우입니다(원인 정보가 제공되지 않음).  
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 기준선 프로파일 이상 필요: 사각형 텍스처가 기준선 제한 프로파일로 만들어진 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createTexture()" id="createTexture()"></a><a name="createTexture(int,int,String,Boolean,int)" id="createTexture(int,int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         Texture 객체를 만듭니다.
         
         <p>Texture 객체를 사용하여 텍스처 비트맵을 렌더링 컨텍스트에 업로드하고 렌더링 도중 텍스처를 참조합니다.</p>
         
         <p>Texture 생성자를 사용하여 Texture 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. Texture 객체를 만든 후에는 Texture <code>uploadFromBitmapData()</code>, <code>uploadFromByteArray()</code> 또는 <code>uploadCompressedTextureFromByteArray()</code> 메서드를 사용하여 텍스처 비트맵을 업로드합니다.</p>
         
         <p>32비트 정수 텍스처는 Flash <code>BitmapData</code> 형식과 일치하도록 압축된 BGRA 형식으로 저장됩니다. 부동 소수점 텍스처는 기본 RGBA 형식을 사용합니다. </p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 텍스처 폭입니다(텍셀 단위).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 텍스처 높이입니다(텍셀 단위).
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 열거 목록의 텍셀 형식입니다.
         <p> 텍스처 압축을 사용하면 GPU에서 직접 압축된 형식으로 텍스처 이미지를 저장할 수 있으므로 GPU 메모리와 메모리 대역폭이 절약됩니다. 일반적으로 압축된 텍스처는 오프라인으로 압축되고 Texture.uploadCompressedTextureFromByteArray 메서드를 사용하여 압축된 형태로 GPU에 업로드됩니다. 데스크톱 플랫폼의 Flash Player 11.4 및 AIR 3.4에서는 런타임 텍스처 압축에 대한 지원이 추가되었으며, 이는 벡터 아트에서 동적 텍스처를 렌더링하는 경우 등 일부 상황에서 유용할 수 있습니다. 이 기능은 현재 모바일 플랫폼에서는 사용할 수 없으며, 대신에 ArgumentError(텍스처 형식 불일치)가 발생합니다. 런타임 텍스처 압축을 사용하려면 다음 단계를 수행하십시오. 1. Context3D.createTexture() 메서드를 호출하고, 형식 매개 변수로 flash.display3D.Context3DTextureFormat.COMPRESSED 또는 flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA를 전달하여 텍스처 객체를 만듭니다. 2. createTexture()가 반환하는 flash.display3D.textures.Texture 인스턴스를 사용하여 flash.display3D.textures.Texture.uploadFromBitmapData() 또는 flash.display3D.textures.Texture.uploadFromByteArray()를 호출함으로써 한 번에 텍스처를 업로드하고 압축합니다.
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 텍스처가 렌더링 대상으로 사용될 가능성이 있는 경우 <code>true</code>로 설정합니다.         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 이미지가 렌더링되기 전에 로드해야 하는 밉 맵 레벨입니다. 텍스처 스트리밍을 사용하면 우선 최소 밉 레벨을 로드 및 표시한 후, 텍스처가 로드되는 동안 점진적으로 더 높은 품질의 이미지를 표시할 수 있습니다. 최종 사용자는 높은 품질의 이미지가 로드되는 동안 응용 프로그램에서 낮은 품질의 이미지를 볼 수 있습니다.
         <p>기본적으로 streamingLevels는 0이며, 이는 이미지가 렌더링되기 전에 MIP 맵의 최고 품질 이미지를 로드해야 함을 의미합니다. 이 매개 변수는 Flash Player 11.3 및 AIR 3.3에서 추가되었습니다. 기본값을 사용하면 이전 버전의 Flash Player 및 AIR의 비헤이비어가 유지됩니다. 
         </p>
         <p>텍스처 스트리밍을 활성화하려면 <code>streamingLevels</code>를 1과 밉 맵에 있는 이미지 수 사이의 값으로 설정합니다. 예를 들어 주 이미지(64x64 픽셀)를 최고 품질로 포함하는 밉 맵이 있다고 가정할 경우 이 밉 맵의 저품질 이미지는 전체 7개 이미지 또는 7개 레벨에 대해 32x32, 16x16, 8x8, 4x4, 2x2 및 1x1 픽셀입니다. 레벨 0은 최고 품질 이미지입니다. 이 속성의 최대값은 log2(min(width,height))입니다. 따라서 주 이미지가 64x64 픽셀인 경우 <code>streamingLevels</code>의 최대값은 7입니다. 8x8 픽셀 이미지가 로드된 후에 해당 이미지를 렌더링하려면 이 속성을 3으로 설정합니다.</p>
         
         <p><b>참고: </b>이 속성을 0보다 큰 값으로 설정하면 메모리 사용과 성능에 영향을 줄 수 있습니다. </p>
         
         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/Texture.html">flash.display3D.textures:Texture</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: Texture 객체가 너무 많이 만들어졌거나 텍스처에 할당된 메모리의 양을 초과한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 깊이 텍스처가 구현되지 않음: 깊이 텍스처를 만들려고 한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처 크기가 0임: <code>width</code> 또는 <code>height</code> 매개 변수가 0보다 작거나 0인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처가 2의 거듭제곱이 아님: <code>width</code> 및 <code>height</code> 매개 변수가 모두 2의 거듭제곱이 아닌 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처가 너무 큼: 기준선 및 기준선 제한 프로파일에 대해 <code>width</code> 또는 <code>height</code> 매개 변수가 2048보다 크거나, 프로파일 기준선 확장 이상에 대해 <code>width</code> 또는 <code>height</code> 매개 변수가 4096보다 큰 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 Texture 객체를 만들 수 없는 경우입니다(원인 정보가 제공되지 않음).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 잘못된 스트리밍 레벨: <code>streamingLevels</code>가 log2(min(width,height))보다 크거나 같은 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createVertexBuffer()" id="createVertexBuffer()"></a><a name="createVertexBuffer(int,int,String)" id="createVertexBuffer(int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVertexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBuffer(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         VertexBuffer3D 객체를 만듭니다.
         
         <p>VertexBuffer3D 객체를 사용하여 꼭지점 데이터 집합을 렌더링 컨텍스트에 업로드합니다. 꼭지점 버퍼는 장면의 도형에서 각 포인트를 렌더링하는 데 필요한 데이터를 포함합니다. 일반적으로 각 꼭지점과 연결된 데이터 특성에는 위치, 색상 및 텍스처 좌표가 포함되며 이러한 특성은 꼭지점 셰이더 프로그램에 대한 입력으로 사용됩니다. <code>setVertexBufferAt()</code> 메서드를 사용하여 꼭지점 프로그램의 입력 중 하나에 해당하는 데이터 값을 식별합니다. 각 꼭지점에 대해 최대 64개의 32비트 값을 지정할 수 있습니다.</p>
         
         <p>VertexBuffer3D 생성자를 사용하여 VertexBuffer3D 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. VertexBuffer3D 객체를 만든 후에는 VertexBuffer3D <code>uploadFromVector()</code> 또는 <code>uploadFromByteArray()</code> 메서드를 사용하여 꼭지점 데이터를 업로드합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; 버퍼에 저장할 꼭지점 수입니다. 단일 버퍼에 있는 최대 꼭지점 수는 65535입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; 각 꼭지점과 연결된 32비트(4바이트) 데이터 값의 수입니다. 꼭지점당 최대 32비트 데이터 요소 수는 64(또는 256바이트)입니다. 참고로, 꼭지점 셰이더 프로그램은 어느 시점에서든 8개의 특성 레지스터에만 액세스할 수 있습니다. <code>SetVertextBufferAt()</code>을 사용하여 꼭지점 버퍼 내에서 특성을 선택합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 예상 버퍼 사용량입니다. <code>Context3DBufferUsage</code>에 정의된 상수 중 하나를 사용합니다. 올바로 설정하면 하드웨어 드라이버가 최적화 작업을 제대로 수행할 수 있습니다. 이 매개 변수는 Flash 12 및 AIR 4 이후부터만 사용할 수 있습니다.

         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: 꼭지점 버퍼 객체가 너무 많이 만들어졌거나 꼭지점 버퍼에 할당된 메모리의 양을 초과한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 버퍼가 너무 큼: <code>numVertices</code>가 0x10000보다 크거나 <code>data32PerVertex</code>가 64보다 큰 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 버퍼에 0인 크기가 있음: <code>numVertices</code>가 0이거나 <code>data32PerVertex</code>가 0인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 VertexBuffer3D 객체를 만들 수 없는 경우입니다(추가적인 원인 정보가 제공되지 않음). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 꼭지점 데이터 버퍼를 만들고 로드하는 방법을 보여 줍니다. 예제의 버퍼에는 각 꼭지점에 대한 두 가지 유형의 데이터인 위치(x, y, z 좌표로 표시)와 색상(rgb 구성 요소로 표시)이 포함되어 있습니다. 꼭지점 버퍼가 만들어진 후 예제에서는 <code>setVertexBufferAt()</code> 메서드를 호출하여 처음 세 개의 데이터 포인트가 세 개의 부동 소수점 값(va0)으로 꼭지점 프로그램에 전달되고 그 다음 세 개의 데이터 포인트가 va1로 전달되도록 지정합니다. 꼭지점 프로그램에는 이와 같이 정의된 입력을 8개까지 지정할 수 있으며, 이러한 입력을 꼭지점 특성 레지스터라고도 합니다.
<div class="listing"><pre>
const dataPerVertex:int = 6;
var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
    [
      // x, y, z    r, g, b format
         0, 0, 0,   1, 1, 1,
        -1, 1, 0,   0, 0,.5,
         1, 1, 0,   0, 0, 1,
         1,-1, 0,  .5, 0, 0,
        -1,-1, 0,   1, 0, 0
    ]
);
var vertexes:VertexBuffer3D = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
//Identify vertex data inputs for vertex program
renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va0 as the position data
renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va1 as the color data
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="createVertexBufferForInstances()" id="createVertexBufferForInstances()"></a><a name="createVertexBufferForInstances(int,int,int,String)" id="createVertexBufferForInstances(int,int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;createVertexBufferForInstances</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBufferForInstances(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         인스턴스 데이터에 대해 VertexBuffer3D 객체를 만듭니다.
         
         <p>VertexBuffer3D 객체를 사용하여 인스턴스 데이터 집합을 렌더링 컨텍스트에 업로드합니다. 꼭지점 버퍼에는 장면 도형에서 각 인스턴스를 렌더링하는 데 필요한 데이터가 포함됩니다. 인스턴스 데이터가 포함된 꼭지점 버퍼는 인스턴스의 모든 꼭지점에 공통되는 특성을 제공하며, 꼭지점 셰이더 프로그램에 대한 입력으로 사용됩니다. <code>setVertexBufferAt()</code> 메서드를 사용하여 꼭지점 프로그램의 입력 중 하나에 해당하는 데이터 값을 식별합니다. 꼭지점 버퍼의 각 요소에 대해 최대 64개의 32비트 값을 지정할 수 있습니다.</p>
         
         <p>VertexBuffer3D 생성자를 사용하여 VertexBuffer3D 객체를 만들 수는 없으며 대신 이 메서드를 사용합니다. VertexBuffer3D 객체를 만든 후에는 VertexBuffer3D <code>uploadFromVector()</code> 또는 <code>uploadFromByteArray()</code> 메서드를 사용하여 꼭지점 데이터를 업로드합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; 버퍼에 저장할 요소의 수입니다. 단일 버퍼의 최대 요소 수는 65535입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; 각 요소와 연결된 32비트(4바이트) 데이터 값의 수입니다. 꼭지점당 최대 32비트 데이터 요소 수는 64(또는 256바이트)입니다. 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">instancesPerElement</span>:<a href="../../int.html">int</a></code> &mdash; 꼭지점 버퍼의 요소 하나를 사용할 인스턴스의 수입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 예상 버퍼 사용량입니다. <code>Context3DBufferUsage</code>에 정의된 상수 중 하나를 사용합니다. 올바로 설정하면 하드웨어 드라이버가 최적화 작업을 제대로 수행할 수 있습니다. 이 매개 변수는 Flash 12 및 AIR 4 이후부터만 사용할 수 있습니다.
         
         </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: 꼭지점 버퍼 객체가 너무 많이 만들어졌거나 꼭지점 버퍼에 할당된 메모리의 양을 초과한 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 버퍼가 너무 큼: <code>numVertices</code>가 0x10000보다 크거나 <code>data32PerVertex</code>가 64보다 큰 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 버퍼에 0인 크기가 있음: <code>numVertices</code>가 0이거나 <code>data32PerVertex</code>가 0인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 VertexBuffer3D 객체를 만들 수 없는 경우입니다(추가적인 원인 정보가 제공되지 않음). 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 표준 확장 프로파일 이상 필요: 요청된 프로파일이 표준 확장 프로파일 미만일 때 이 메서드가 호출되는 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 요소당 인스턴스 수: instancesPerElement가 0보다 크지 않은 경우입니다.
         
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="createVideoTexture()" id="createVideoTexture()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVideoTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVideoTexture():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
         VideoTexture 객체를 만듭니다.
         
         <p>VideoTexture 객체를 사용하여 NetStream 객체 또는 Camera 객체에서 텍스처로 비디오 프레임을 가져온 후 이 비디오 프레임을 렌더링 컨텍스트로 업로드합니다.</p>
         
         <p>VideoTexture 생성자를 사용하여 VideoTexture 객체를 만들 수 없습니다. 대신 이 메서드를 사용하십시오. VideoTexture 객체를 생성하고 NetStream 객체 또는 Camera 객체를 연결한 후 VideoTexture <code>attachNetStream()</code> 또는 <code>attachCamera()</code> 메서드를 사용하여 비디오 프레임을 가져옵니다.</p>
         
         <p>시스템이 이 기능을 지원하지 않을 경우 이 메서드는 null을 반환합니다. </p>
         
         <p> VideoTexture에는 밉맵이 포함되지 않습니다. 사각형 텍스처를 밉 맵 필터링 또는 반복 래핑을 사용하는 견본과 함께 사용하면 drawTriangles 호출이 실패합니다. VideoTexture는 셰이더에 의해 BGRA 텍스처로 다뤄질 수 있습니다. <b>소프트웨어 렌더링 모드에서 Context3D가 요청된 경우 VideoTexture 객체를 인스턴스화하려고 시도하면 실패하게 됩니다.</b> 
         </p>
         
         <p> Context3D 인스턴스당 최대 4개의 VideoTexture 객체를 사용할 수 있습니다. 모바일에서 지원되는 VideoTexture 객체의 실제 수는 플랫폼의 제한으로 인해 4개 미만일 수도 있습니다. </p>
                                   
         </p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code></td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 리소스 제한 초과: Texture 객체가 너무 많이 만들어졌거나 텍스처에 할당된 메모리의 양을 초과한 경우입니다.         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처 만들기 실패: 렌더링 컨텍스트에서 Texture 객체를 만들 수 없는 경우입니다(원인 정보가 제공되지 않음).  
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="dispose()" id="dispose()"></a><a name="dispose(Boolean)" id="dispose(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         이 Context3D에 연결된 모든 리소스와 내부 저장소를 해제합니다.
          
         <p>각 항목에서 개별적으로 <code>dispose()</code>를 호출하는 경우와 같이 이 Context3D를 통해 만들어진 모든 인덱스 버퍼, 꼭지점 버퍼, 텍스처 및 프로그램은 삭제됩니다. 또한 Context3D 자체가 삭제되어 모든 임시 버퍼 및 백 버퍼가 지워집니다. dispose()를 호출한 후 configureBackBuffer(), clear(), drawTriangles(), createCubeTexture(), createTexture(), createProgram(), createIndexBuffer(), createVertexBuffer() 또는 drawToBitmapData()를 호출하면 런타임에 예외가 발생합니다.</p>                   
         
         <p><b>경고</b>: 연결된 Stage3D 객체에 Events.CONTEXT3D_CREATE에 대한 이벤트 리스너가 설정된 상태에서 Context3D에 대해 dispose()를 호출하면 dispose() 호출이 장치 손실을 시뮬레이션합니다. 이렇게 하면 Stage3D에 새 Context3D가 만들어지고 Events.CONTEXT3D_CREATE 이벤트가 다시 발생합니다. 이를 원치 않으면 dispose()를 호출하기 전에 Stage3D 객체에서 이벤트 리스너를 제거하거나 recreate 매개 변수를 false로 설정합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">recreate</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code></td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso">Stage3D<br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a></div></div></span><span id="pageFilter" runtime="AIR::3##"><a name="drawToBitmapData()" id="drawToBitmapData()"></a><a name="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)" id="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawToBitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawToBitmapData(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 3</td></tr></table><p></p><p></p><p>
         비트맵에 현재 렌더링 버퍼를 그립니다.
         
         <p>백 렌더링 버퍼의 현재 내용이 BitmapData 객체에 복사됩니다. 이 작업은 최대 1초가 걸리는 매우 느린 작업이므로 사용에 주의합니다. 이 함수는 스테이지에 표시되는 전면 렌더링 버퍼가 아니라 그려지는 버퍼를 복사합니다. 스테이지에 표시되는 렌더링된 이미지를 캡처하려면 <code>present()</code>를 호출하기 직전에 <code>drawToBitmapData()</code>를 호출합니다.</p>
         
		 
         <p>AIR 25부터는 API <code>drawToBitmapData()</code>에 두 개의 매개 변수가 새로 도입되었습니다. 따라서 이제 이 API에서는 세 개의 매개 변수를 사용합니다. 첫 번째는 기존 매개 변수인 <code>destination:BitmapData</code>입니다. 두 번째 매개 변수는 stage3D의 대상 사각형인 <code>srcRect:Rectangle</code>입니다. 세 번째 매개 변수는 대상 비트맵의 좌표에 해당하는 <code>destPoint:Point</code>입니다. 매개 변수 srcRect 및 destPoint는 선택 사항이며 각각 (0,0,bitmapWidth,bitmapHeight) 및 (0,0)으로 기본값이 지정됩니다.</p>
         
         <p>이미지는 그려질 때 비트맵에 맞게 크기가 조절되지 않습니다. 대신에 내용이 대상 비트맵의 크기로 클리핑됩니다.</p>
         
         <p>Flash BitmapData 객체는 알파 구성 요소가 이미 곱해진 색상을 저장합니다. 예를 들어 픽셀의 "순수" rgb 구성 요소가 (0x0A, 0x12, 0xBB)이고 알파 구성 요소가 0x7F(.5)인 경우 해당 픽셀은 rgba 값 (0x05, 0x09, 0x5D, 0x7F)와 함께 BitmapData 객체에 저장됩니다. 버퍼에 렌더링되는 색상에 알파를 곱하도록 블렌드 인수를 설정하거나 조각 셰이더에서 해당 작업을 수행할 수 있습니다. 렌더링 컨텍스트는 색상이 미리 곱한 형식으로 저장되었는지 검증하지 않습니다. </p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">destination</span>:<a href="../display/BitmapData.html">BitmapData</a></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">srcRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code></td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3802: 매개 변수 <code>destPoint:Point</code> 또는 <code>srcRect:Rectangle</code> 중 하나가 bitmap/stage3D 좌표 경계를 벗어나거나, 숫자가 아닌(NaN) 값이 입력으로 전달되는 경우입니다.
		 
         </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 일반 렌더링 버퍼 및 BitmapData 객체에 대해 두 개의 삼각형을 렌더링합니다. BitmapData 객체는 일반 표시 목록에 추가된 Bitmap 객체를 사용하여 표시됩니다. 비트맵 렌더링에는 드롭 그림자 필터가 적용됩니다. 
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.filters.DropShadowFilter;
    
    public class Context3D_drawToBitmapData extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var bitmap:Bitmap;
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawToBitmapData()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 0;
            stage3D.y = 0;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            var renderedBitmapData:BitmapData = new BitmapData( viewWidth, viewHeight, true );
            renderContext.drawToBitmapData( renderedBitmapData );
            
            renderContext.present();
            
            //Add to stage
            bitmap = new Bitmap( renderedBitmapData );
            this.addChild( bitmap );
            bitmap.x = 55;
            bitmap.y = 25;
            bitmap.filters = [new DropShadowFilter( 8, 235, .4 )];
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="drawTriangles()" id="drawTriangles()"></a><a name="drawTriangles(flash.display3D.IndexBuffer3D,int,int)" id="drawTriangles(flash.display3D.IndexBuffer3D,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawTriangles</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTriangles(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         현재 버퍼 및 이 Context3D 객체의 상태를 사용하여 지정된 삼각형을 렌더링합니다.
         
         <p>각 삼각형의 꼭지점은 꼭지점 셰이더 프로그램에 의해 처리되고 삼각형 표면은 픽셀 셰이더 프로그램에 의해 처리됩니다. 각 픽셀에 대해 픽셀 프로그램의 출력 색상이 렌더링 대상에 그려집니다. 스텐실 작업, 심도 테스트, 소스 및 대상 알파, 현재 블렌드 모드가 여기에 영향을 줍니다. 렌더링 대상은 기본 렌더링 버퍼 또는 텍스트처일 수 있습니다.</p>
         
         <p><code>setCulling()</code> 메서드로 컬링을 활성화하면 픽셀 프로그램이 실행되기 전에 삼각형이 장면에서 삭제될 수 있습니다. 스텐실 및 심도 테스트를 활성화하면 픽셀 프로그램의 출력 픽셀이 렌더링 대상을 업데이트하지 않고 삭제될 수 있습니다. 또한 픽셀 프로그램은 픽셀의 색상이 출력되지 않도록 결정할 수 있습니다.</p>
         
         <p>렌더링된 삼각형은 <code>present()</code> 메서드를 호출할 때까지 뷰포트에 표시되지 않습니다. 각각의 <code>present()</code>를 호출한 후에는 첫 번째 <code>drawTriangles()</code>를 호출하기 전에 <code>clear()</code> 메서드를 호출해야 하며 그렇지 않으면 렌더링이 실패합니다.</p>

         <p><code>enableErrorChecking</code>이 <code>false</code>이면 이 함수가 결과를 기다리지 않고 즉시 반환되며, 이 COntext3D 인스턴스가 삭제되었거나 그리기 호출이 너무 많은 경우에만 예외가 발생합니다. 렌더링 컨텍스트 상태가 유효하지 않은 경우 렌더링이 실패하며 오류는 발생하지 않습니다. <code>enableErrorChecking</code> 속성이 <code>true</code>이면 삼각형이 그려진 후 이 함수가 반환되며 드로잉 오류 또는 잘못된 컨텍스트 상태에 대해 예외가 발생합니다.</p> 
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; 렌더링할 꼭지점을 참조하는 꼭지점 인덱스 집합입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 렌더링하도록 선택된 첫 번째 꼭지점 인덱스의 인덱스입니다. 기본값은 0입니다.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 렌더링할 삼각형 수입니다. 각 삼각형에는 세 개의 인덱스가 사용됩니다. 인덱스 버퍼에서 모든 삼각형을 그리려면 -1을 전달합니다. 기본값은 -1입니다.  
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; <code>present()</code> 호출 간에 이 메서드를 너무 많이 호출한 경우입니다. 최대 호출 횟수는 32,768입니다. 
         
         <p>다음 오류는 <code>enableErrorChecking</code> 속성이 <code>true</code>인 경우에만 발생합니다.</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 그리기 전에 지워야 함: 마지막 <code>present()</code> 호출 이후 버퍼가 지워지지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 유효한 Program3D 객체가 설정되지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 유효한 인덱스 버퍼가 설정되지 않음: IndexBuffer3D 객체가 설정되지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 매개 변수에 대한 상태 검사에 실패함: 그릴 삼각형 수나 <code>firstIndex</code>가 허용되는 값을 초과한 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 버퍼에 있는 인덱스가 충분하지 않음: 버퍼에 있는 인덱스가 충분하지 않아서 그릴 삼각형 수를 정의할 수 없는 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 바인딩하는 텍스처가 렌더링에도 바인딩된 되어 있음: 렌더링 대상이 텍스처이고 해당 텍스처가 현재 조각 프로그램의 텍스처 입력에 할당된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 잘못된 텍스처를 바인딩함: 잘못된 텍스처가 현재 조각 프로그램의 입력으로 지정된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플러 형식이 텍스처 형식과 일치하지 않음: 현재 조각 프로그램에 대한 입력으로 할당된 텍스처의 형식이 샘플러 레지스터에 지정된 형식과 다른 경우입니다. 예를 들어 2D 텍스처가 정육면체 텍스처 샘플러에 할당된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 정의되지 않은 텍스처를 바인딩함: 현재 조각 프로그램이 <code>setTextureAt()</code>을 사용하여 설정되지 않은 텍스처 레지스터에 액세스합니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처가 같으면 샘플러 매개 변수도 같아야 함: 텍스처가 둘 이상의 샘플러 레지스터에 사용될 경우 모든 샘플러의 설정이 동일해야 합니다. 예를 들어 한 샘플러는 clamp로 설정하고 다른 샘플러는 wrap으로 설정할 수 없습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처가 바인딩되었지만 사용되지 않음: 텍스처가 셰이더 입력으로 설정되었지만 사용되지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 사용되지 않음: 꼭지점 버퍼가 꼭지점 특성 입력에 할당되었지만 꼭지점 프로그램이 해당 레지스터를 참조하지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 유효하지 않음: 꼭지점 프로그램 입력에 할당된 VertexBuffer3D 객체가 유효한 객체가 아닙니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 스트림에 꼭지점이 충분하지 않음: 지정된 삼각형을 그리기 위한 데이터를 제공하는 꼭지점 버퍼에 데이터가 충분하지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 스트림 꼭지점 오프셋이 경계를 벗어남: <code>setVertexBufferAt()</code> 호출에 지정된 오프셋이 음수이거나 버퍼의 끝을 지났습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 읽히지만 설정되지 않음: 현재 꼭지점 프로그램에 사용되는 꼭지점 특성이 <code>setVertexBufferAt()</code>를 사용하여 설정되지 않았습니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 클래스는 스테이지의 Stage3D 뷰포트에 대해 두 개의 삼각형을 그립니다. 두 삼각형은 원점(0,0,0)에 있는 꼭지점 하나를 공유합니다.
 
 <p>삼각형은 꼭지점 버퍼와 인덱스 버퍼를 사용하여 정의됩니다. 꼭지점 버퍼는 각 삼각형 꼭지점의 위치와 색상 정보를 포함합니다. 인덱스 버퍼는 꼭지점 버퍼에 대한 인덱스를 포함합니다. 세 개의 인덱스가 삼각형 하나를 정의합니다. 예를 들어 꼭지점 버퍼의 처음 세 점으로 구성된 삼각형은 인덱스 버퍼에서 0,1,2로 나열됩니다.</p>
 
 <p>이 간단한 예제에서는 3D 변형을 수행하지 않습니다. 정규 시야 영역 내의 객체(2x2x1 단위 볼륨)만 표시할 수 있으며 삼각형의 좌표는 이 영역 내에 있도록 정의됩니다. 그러나 일반적인 3D 장면을 렌더링할 때는 렌더링할 객체를 원근 또는 직각 투영을 사용하여 "월드" 좌표계에서 이 시야 영역에 투영합니다.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_drawTriangles extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawTriangles()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="drawTrianglesInstanced()" id="drawTrianglesInstanced()"></a><a name="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)" id="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawTrianglesInstanced</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTrianglesInstanced(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         현재 버퍼 및 이 Context3D 객체의 상태를 사용하여 지정된 인스턴스화된 삼각형을 렌더링합니다.
         
         <p>각 인스턴스의 각 삼각형에 대해 삼각형 꼭지점은 꼭지점 셰이더 프로그램에 의해 처리되고 삼각형 표면은 픽셀 셰이더 프로그램에 의해 처리됩니다. 각 픽셀에 대해 픽셀 프로그램의 출력 색상이 렌더링 대상에 그려집니다. 스텐실 작업, 심도 테스트, 소스 및 대상 알파, 현재 블렌드 모드가 여기에 영향을 줍니다. 렌더링 대상은 기본 렌더링 버퍼 또는 텍스트처일 수 있습니다.</p>
         
         <p><code>setCulling()</code> 메서드로 컬링을 활성화하면 픽셀 프로그램이 실행되기 전에 삼각형이 장면에서 삭제될 수 있습니다. 스텐실 및 심도 테스트를 활성화하면 픽셀 프로그램의 출력 픽셀이 렌더링 대상을 업데이트하지 않고 삭제될 수 있습니다. 또한 픽셀 프로그램은 픽셀의 색상이 출력되지 않도록 결정할 수 있습니다.</p>
         
         <p>렌더링된 인스턴스화된 삼각형은 <code>present()</code> 메서드를 호출할 때까지 뷰포트에 표시되지 않습니다. 각 <code>present()</code> 호출 후에는 첫 번째 <code>drawTrianglesInstanced()</code> 호출 전에 <code>clear()</code> 메서드를 호출해야 합니다. 그러지 않으면 렌더링이 실패합니다.</p>

         <p><code>enableErrorChecking</code>이 <code>false</code>이면 이 함수가 결과를 기다리지 않고 즉시 반환되며, 이 COntext3D 인스턴스가 삭제되었거나 그리기 호출이 너무 많은 경우에만 예외가 발생합니다. 렌더링 컨텍스트 상태가 유효하지 않은 경우 렌더링이 실패하며 오류는 발생하지 않습니다. <code>enableErrorChecking</code> 속성이 <code>true</code>이면 삼각형이 그려진 후 이 함수가 반환되며 드로잉 오류 또는 잘못된 컨텍스트 상태에 대해 예외가 발생합니다.</p>
		 
		 <p>인스턴스화된 버퍼가 <code>SetVertexAt()</code>으로 잘못 시퀀싱되는 경우 이 메서드에서 예외가 발생할 수 있습니다. 예를 들어 Direct 3D 9의 경우 인덱싱된 도형 데이터와 그릴 인스턴스의 수를 항상 <code>SetStreamSourceFreq()</code> API를 통해 스트림 0에 설정해야 합니다.</p>
		 
		 <p>따라서 <code>CreateVertexBufferForInstance()</code>를 사용하여 생성된 꼭지점 버퍼는 <code>SetVertexBufferAt()</code>을 통해 꼭지점 셰이더 프로그램의 입력으로 정렬되는 경우 최소 인덱스 수로 배치되어서는 안 됩니다. <code>CreateVertexBuffer()</code>를 사용하여 생성된 꼭지점 버퍼는 <code>CreateVertexBufferForInstance()</code>의 경우보다 작은 인덱스 수로 배치해야 합니다. 일반적으로 도형 데이터는 <code>SetVertexBufferAt()</code>을 통해 인스턴스별 데이터 앞에 배치해야 합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; 렌더링할 꼭지점을 참조하는 꼭지점 인덱스 집합입니다.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numInstances</span>:<a href="../../int.html">int</a></code> &mdash; 렌더링할 인스턴스의 수입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 렌더링하도록 선택된 첫 번째 꼭지점 인덱스의 인덱스입니다. 기본값은 0입니다.   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 렌더링할 삼각형 수입니다. 각 삼각형에는 세 개의 인덱스가 사용됩니다. 인덱스 버퍼에서 모든 삼각형을 그리려면 -1을 전달합니다. 기본값은 -1입니다.  
		 
		 </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; <code>present()</code> 호출 간에 이 메서드를 너무 많이 호출한 경우입니다. 최대 호출 횟수는 32,768입니다. 
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 표준 확장 프로파일 이상 필요: 요청된 프로파일이 표준 확장 프로파일 미만일 때 이 메서드가 호출되는 경우입니다.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 이 메서드가 음수 numInstances를 사용하여 호출되는 경우입니다.
         
         <p>다음 오류는 <code>enableErrorChecking</code> 속성이 <code>true</code>인 경우에만 발생합니다.</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 그리기 전에 지워야 함: 마지막 <code>present()</code> 호출 이후 버퍼가 지워지지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 유효한 Program3D 객체가 설정되지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 유효한 인덱스 버퍼가 설정되지 않음: IndexBuffer3D 객체가 설정되지 않은 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 매개 변수에 대한 상태 검사에 실패함: 그릴 삼각형 수나 <code>firstIndex</code>가 허용되는 값을 초과한 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 버퍼에 있는 인덱스가 충분하지 않음: 버퍼에 있는 인덱스가 충분하지 않아서 그릴 삼각형 수를 정의할 수 없는 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 바인딩하는 텍스처가 렌더링에도 바인딩된 되어 있음: 렌더링 대상이 텍스처이고 해당 텍스처가 현재 조각 프로그램의 텍스처 입력에 할당된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 잘못된 텍스처를 바인딩함: 잘못된 텍스처가 현재 조각 프로그램의 입력으로 지정된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플러 형식이 텍스처 형식과 일치하지 않음: 현재 조각 프로그램에 대한 입력으로 할당된 텍스처의 형식이 샘플러 레지스터에 지정된 형식과 다른 경우입니다. 예를 들어 2D 텍스처가 정육면체 텍스처 샘플러에 할당된 경우입니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플에서 정의되지 않은 텍스처를 바인딩함: 현재 조각 프로그램이 <code>setTextureAt()</code>을 사용하여 설정되지 않은 텍스처 레지스터에 액세스합니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처가 같으면 샘플러 매개 변수도 같아야 함: 텍스처가 둘 이상의 샘플러 레지스터에 사용될 경우 모든 샘플러의 설정이 동일해야 합니다. 예를 들어 한 샘플러는 clamp로 설정하고 다른 샘플러는 wrap으로 설정할 수 없습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 텍스처가 바인딩되었지만 사용되지 않음: 텍스처가 셰이더 입력으로 설정되었지만 사용되지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 사용되지 않음: 꼭지점 버퍼가 꼭지점 특성 입력에 할당되었지만 꼭지점 프로그램이 해당 레지스터를 참조하지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 유효하지 않음: 꼭지점 프로그램 입력에 할당된 VertexBuffer3D 객체가 유효한 객체가 아닙니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 스트림에 꼭지점이 충분하지 않음: 지정된 삼각형을 그리기 위한 데이터를 제공하는 꼭지점 버퍼에 데이터가 충분하지 않습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 스트림 꼭지점 오프셋이 경계를 벗어남: <code>setVertexBufferAt()</code> 호출에 지정된 오프셋이 음수이거나 버퍼의 끝을 지났습니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 스트림이 읽히지만 설정되지 않음: 현재 꼭지점 프로그램에 사용되는 꼭지점 특성이 <code>setVertexBufferAt()</code>를 사용하여 설정되지 않았습니다.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 꼭지점 버퍼 스트림에 인스턴스를 위한 충분한 요소가 포함되지 않음: 꼭지점 버퍼 스트림에 인스턴스의 수를 위한 충분한 요소가 포함되지 않는 경우입니다.
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 인스턴스에 대한 버퍼 꼭지점 스트림의 최소 인덱스 특성 레지스터가 잘못 설정됨: <code>CreateVertexBuffer()</code>를 사용하여 생성된 꼭지점 버퍼에 지정된 인덱스 수가 <code>CreateVertexBufferForInstance()</code>를 사용하여 생성된 꼭지점 버퍼의 인덱스 수보다 큰 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 클래스는 여러 그리기 호출 대신에 단일 그리기 호출을 사용하는 인스턴스화된 드로잉 기능을 사용해 삼각형 세 개를 그립니다.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstancedDrawing extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstancedDrawing()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //The vertex shader code runs for every vertex of each instance.
            //The vertex buffers uploaded for instance data (va1,va2) are used when the vertex shader for that particular instance is being executed.
            code += "add vt0, va0, va2\n";
            code += "mov op, vt0\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span><span id="pageFilter"><br/><div class="detailBody"> 다음 클래스는 여러 그리기 호출 대신에 단일 그리기 호출을 사용하는 인스턴스화된 드로잉 기능을 사용해 삼각형 세 개를 그립니다.
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstanceIdRegister extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstanceIdRegister()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            //Note : for instance id support , use the latest AgalMiniAssembler from github - https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/v3/AGALMiniAssembler.as
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //the vertex shader code will run for every vertex of every instance , 
            //the vertex buffers uploaded for instance data (va1,va2) will be used when vertex shader for that particular instance is being executed 
            //the vertex shader code below indexes the program constants matrix using iid.x. iid is a new register introduced in vertex shader for instanced drawing
            //it is a read only register , iid.x gives the current instance id whose shader is being executed
            code += "add vt0, va0, va2\n";
            code += "mul vt1, vt0, vc[iid.x]\n"
            code += "mov op, vt1\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code, 3);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code, 3);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            var instanceScalingData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 1.0, 1.0, 1.0,     // - 1st instance x,y,z,w
                1.4, 1.4, 1.4, 1.0,        // - 2nd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0,        // - 3rd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0
            ]);
            var m:Matrix3D = new Matrix3D();
            m.copyRawDataFrom(instanceScalingData);
            renderContext.setProgramConstantsFromMatrix("vertex",0,m,false);
            
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="present()" id="present()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>present</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function present():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         백 렌더링 버퍼를 표시합니다. 
         
         <p><code>present()</code> 메서드를 호출하면 마지막 <code>present()</code>를 호출한 이후의 모든 렌더링 작업 결과를 볼 수 있고 새 렌더링 주기가 시작됩니다. <code>present</code>를 호출한 후 다른 <code>drawTriangles()</code> 호출을 수행하기 전에 <code>clear()</code>를 호출해야 합니다. 그렇지 않으면 이 함수는 렌더링 버퍼를 노란색 및 녹색으로 번갈아가며 지우거나, <code>enableErrorChecking</code>이 <code>true</code>로 설정된 경우 예외가 발생합니다.</p>
         
         <p>또한 <code>present()</code>를 호출하면 <code>setRenderToBackBuffer()</code>를 호출하는 것과 같이 렌더링 대상이 재설정됩니다. </p>  
         
         </p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 그리기 전에 지워야 함: 이전의 <code>present()</code>를 호출한 이후에 <code>clear()</code>가 호출되지 않은 경우입니다. <code>present()</code> 두 개를 연속해서 호출할 수는 없으며 중간에 <code>clear()</code>를 호출해야 합니다.
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768: 백그라운드에서 실행되는 동안 <code>Stage3D</code> API는 사용할 수 없습니다.
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setBlendFactors()" id="setBlendFactors()"></a><a name="setBlendFactors(String,String)" id="setBlendFactors(String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setBlendFactors</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setBlendFactors(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         기존 색상을 사용한 그리기 작업의 출력 색상을 블렌딩하는 데 사용하는 인수를 지정합니다.
         
         <p>픽셀 셰이더 프로그램의 출력(소스) 색상은 다음 공식에 따라 해당 픽셀에서 기존(대상) 색상과 결합니다.</p> 
         <p><code>result color = (source color * sourceFactor) + (destination color * destinationFactor)</code></p>
         <p>대상 색상은 렌더링 버퍼에 있는 해당 픽셀의 현재 색상입니다. 그러므로 이는 가장 최근의 <code>clear()</code> 호출과 모든 중간 <code>drawTriangles()</code> 호출의 결과입니다. </p>
          
         <p>소스 색상과 대상 색상을 서로 더하기 전에 곱하는 데 사용할 인수를 설정하려면 <code>setBlendFactors()</code>를 사용합니다. 기본 블렌드 인수는 <code>sourceFactor = Context3DBlendFactor.ONE</code> 및 <code>destinationFactor = Context3DBlendFactor.ZERO</code>이며 결과적으로 소스 색상이 대상 색상을 덮어씁니다. 다시 말해 두 색상이 혼합되지 않습니다. 일반 알파 블렌딩에는 <code>sourceFactor = Context3DBlendFactor.SOURCE_ALPHA</code> 및 <code>destinationFactor = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA</code>를 사용합니다. 
         </p>
         
         <p>이 함수의 매개 변수를 설정하려면 Context3DBlendFactor 클래스에 정의된 상수를 사용합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceFactor</span>:<a href="../../String.html">String</a></code> &mdash; 소스 색상에 곱하는 인수입니다. 기본값은 <code>Context3DBlendFactor.ONE</code>입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destinationFactor</span>:<a href="../../String.html">String</a></code> &mdash; 대상 색상에 곱하는 인수입니다. 기본값은 <code>Context3DBlendFactor.ZERO</code>입니다.
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형: <code>sourceFactor</code> 또는 <code>destinationFactor</code>가 인식되는 값 중 하나가 아닌 경우입니다. 인식되는 값은 Context3DBlendFactor 클래스에 정의되어 있습니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 클래스는 다양한 블렌드 인수를 보여 줍니다. 예제에서는 렌더링 버퍼에 대해 색상이 지정된 서로 다른 네 개의 사각형을 그립니다. 이 사각형 집합은 블렌드 "대상"입니다. 다음으로, 소스 및 대상 블렌드 모드가 설정되고 블렌드 "소스"에 해당하는 좀 더 큰 사각형이 그려집니다. 키 "1" 및 "2"를 사용하여 소스 블렌드 모드를  돌아가면서 하나씩 표시합니다. 키 "3" 및 "4"를 사용하여 대상 블렌드 모드를 돌아가면서 하나씩 표시합니다.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.ui.Keyboard;
    
    public class Context3D_setBlendMode extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var sourceFactor:int = 6;
        private var destinationFactor:int = 4;
        private var blendFactors:Array = [Context3DBlendFactor.DESTINATION_ALPHA,
                                          Context3DBlendFactor.DESTINATION_COLOR,
                                          Context3DBlendFactor.ONE,
                                          Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR,
                                          Context3DBlendFactor.SOURCE_ALPHA,
                                          Context3DBlendFactor.SOURCE_COLOR,
                                          Context3DBlendFactor.ZERO];
            
        public function Context3D_setBlendMode()
        {
            this.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyHandler );
            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3,
                                                            6, 4, 5,
                                                            5, 7, 6,
                                                            10, 8, 9,
                                                            9, 11, 10,
                                                            12, 15, 14,
                                                            12, 13, 15,
                                                            16, 17, 19,
                                                            16, 19, 18
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 7;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format
                    -1, 1, 0,   1, 1, 1, .5,
                     0, 1, 0,   1, 1, 1, .5,
                    -1, 0, 0,   1, 1, 1, .5,
                     0, 0, 0,   1, 1, 1, .5,
                     
                     0, 1, 0,  .8,.8,.8, .6,
                     1, 1, 0,  .8,.8,.8, .6,
                     0, 0, 0,  .8,.8,.8, .6,
                     1, 0, 0,  .8,.8,.8, .6,
                     
                    -1, 0, 0,   1, 0, 0, .5,
                     0, 0, 0,   0, 1, 0, .5,
                    -1,-1, 0,   0, 0, 1, .5,
                     0,-1, 0,   1, 0, 1, .5,
                     
                     0, 0, 0,   0, 0, 0, .5,
                     1, 0, 0,   0, 0, 0, .5,
                     0,-1, 0,   0, 0, 0, .5,
                     1,-1, 0,   0, 0, 0, .5,
                     
                   -.8,.8, 0,  .6,.4,.2,.4,
                    .8,.8, 0,  .6,.4,.2,.4,
                  -.8,-.8, 0,  .6,.4,.2,.4,
                   .8,-.8, 0,  .6,.4,.2,.4
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_4 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear( 1, 1, 1, 1 );
            //Draw the back triangles
            renderContext.setBlendFactors( Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO ); //No blending
            renderContext.drawTriangles( indexList, 0, 8 );

            //Set blend
            renderContext.setBlendFactors( blendFactors[sourceFactor], blendFactors[destinationFactor] );
            
            //Draw the front triangles
            renderContext.drawTriangles( indexList, 24, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
        
        private function keyHandler( event:KeyboardEvent ):void
        {
            switch ( event.keyCode )
            {
                case Keyboard.NUMBER_1:
                    if( --sourceFactor &lt; 0 ) sourceFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_2:
                    if( ++sourceFactor &gt; blendFactors.length - 1) sourceFactor = 0;
                    break;
                case Keyboard.NUMBER_3:
                    if( --destinationFactor &lt; 0 ) destinationFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_4:
                    if( ++destinationFactor &gt; blendFactors.length - 1) destinationFactor = 0;
                    break;
            }
            trace( "Source blend factor: " + blendFactors[sourceFactor] + ", destination blend factor: " + blendFactors[destinationFactor] );
            render();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setColorMask()" id="setColorMask()"></a><a name="setColorMask(Boolean,Boolean,Boolean,Boolean)" id="setColorMask(Boolean,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setColorMask</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setColorMask(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         렌더링 버퍼에 색상을 기록할 때 사용하는 마스크를 설정합니다.
         
         <p>해당하는 색상 마스크 매개 변수가 <code>true</code>인 색상 구성 요소만 색상이 렌더링 버퍼에 기록될 때 업데이트됩니다. 예를 들어 <code>setColorMask( true, false, false, false )</code>를 호출하면 색상 마스크를 다시 변경할 때까지 색상의 빨강 구성 요소만 버퍼에 기록됩니다. 색상 마스크는 <code>clear()</code> 메서드의 비헤이비어에 영향을 미치지 않습니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 빨강 채널에 대한 변경을 차단하려면 <code>false</code>를 설정합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 녹색 채널에 대한 변경을 차단하려면 <code>false</code>를 설정합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 파랑 채널에 대한 변경을 차단하려면 <code>false</code>를 설정합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 알파 채널에 대한 변경을 차단하려면 <code>false</code>를 설정합니다.
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 색상 마스크를 설정하는 효과를 보여 줍니다. 이 예제에서는 색상이 동일한 두 개의 삼각형을 그립니다. 위쪽 삼각형은 마스크가 설정되기 전에 그려지므로 흰색으로 렌더링됩니다. 아래쪽 삼각형은 빨간색 채널을 제외한 모든 채널이 마스크 처리된 후에 그려집니다. 빨간색 채널만 업데이트할 수 있으므로 흰색 삼각형은 빨간색으로 렌더링됩니다.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_setColorMask extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_setColorMask()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   1, 1, 1,
                     1, 1, 0,   1, 1, 1,
                     1,-1, 0,   1, 1, 1,
                    -1,-1, 0,   1, 1, 1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            renderContext.clear( .3,.3,.3,1 );
            renderContext.drawTriangles( indexList, 0, 1 ); //Top triangle draws all colors, so is white
            renderContext.setColorMask( true, false, false, false ); //Mask all but red channel            
            renderContext.drawTriangles( indexList, 3, 1 ); //Bottom triangle only updates red
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setCulling()" id="setCulling()"></a><a name="setCulling(String)" id="setCulling(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setCulling</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setCulling(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         삼각형 컬링 모드를 설정합니다.
         
         <p>뷰 평면 기준 방향에 기초하여 렌더링 파이프라인의 초기에 삼각형이 장면에서 제외될 수 있습니다. 올바르게 컬링하도록 모델 외부에서 볼 때처럼 꼭지점 순서를 일관되게(시계 방향 또는 시계 반대 방향) 지정합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFaceToCull</span>:<a href="../../String.html">String</a></code> &mdash; 컬링 모드입니다. Context3DTriangleFace 클래스에 정의된 상수 중 하나를 사용합니다.
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형 오류: <code>triangleFaceToCull</code>이 Context3DTriangleFace 클래스에 정의된 값 중 하나가 아닌 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setDepthTest()" id="setDepthTest()"></a><a name="setDepthTest(Boolean,String)" id="setDepthTest(Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setDepthTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setDepthTest(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         심도 테스트에 사용되는 비교 유형을 설정합니다.
         
         <p>픽셀 셰이더 프로그램의 소스 픽셀 출력 심도가 심도 버퍼에 있는 현재 값과 비교됩니다. 비교가 <code>false</code>로 평가되면 소스 픽셀은 삭제되고, <code>true</code>이면 렌더링 파이프라인의 다음 단계인 스텐실 테스트에서 소스 픽셀이 처리됩니다. 또한 <code>depthMask</code> 매개 변수가 <code>true</code>로 설정되어 있는 한 심도 버퍼는 소스 픽셀의 심도로 업데이트됩니다.</p>
         
         <p>소스 및 대상 픽셀의 심도 값을 비교하는 데 사용되는 테스트를 설정합니다. 비교가 true인 경우 소스 픽셀은 대상 픽셀과 합성됩니다. 비교 연산자는 소스 및 대상 픽셀 값 사이의 중위 연산자로 해당 순서대로 적용됩니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">depthMask</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; true인 경우 소스 픽셀에서 대상 심도 값이 업데이트됩니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">passCompareMode</span>:<a href="../../String.html">String</a></code> &mdash; 심도 비교 테스트 작업입니다. Context3DCompareMode 값 중 하나입니다.
         
         </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a></div></div></span><span id="pageFilter" runtime="AIR::16##"><a name="setFillMode()" id="setFillMode()"></a><a name="setFillMode(String)" id="setFillMode(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="AIR 런타임에서만 사용 가능">&nbsp;&nbsp;&nbsp;</span>&nbsp;setFillMode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setFillMode(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>AIR 16</td></tr></table><p></p><p></p><p> 
		렌더링에 사용되는 채우기 모드를 설정합니다. 인터페이스는 AIR 데스크톱에서만 사용할 수 있습니다.
		
		</p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">fillMode</span>:<a href="../../String.html">String</a></code> &mdash; 값이 WIREFRAME인 경우 객체가 선 메시로 표시됩니다. 값이 SOLID인 경우 객체가 솔리드 음영 다각형으로 표시됩니다.
		
		</td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DFillMode.html" target="">Context3DFillMode</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgram()" id="setProgram()"></a><a name="setProgram(flash.display3D.Program3D)" id="setProgram(flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgram(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         후속 렌더링에 사용할 꼭지점 및 조각 셰이더 프로그램을 설정합니다.
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">program</span>:<a href="Program3D.html">Program3D</a></code> &mdash; 사용할 꼭지점 및 조각 프로그램을 나타내는 Program3D 객체입니다. 
         
         </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 이 예제에서는 렌더링 컨텍스트에 대해 한 쌍의 꼭지점 및 픽셀 프로그램을 만들고, 업로드하고, 활성화하는 방법을 보여 줍니다. <code>renderContext</code> 객체는 Context3D 클래스의 인스턴스입니다. 예제의 프로그램은 AGAL(Adobe Graphics Assembly Language)로 작성되었습니다. 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.1##AIR::3.1##"><a name="setProgramConstantsFromByteArray()" id="setProgramConstantsFromByteArray()"></a><a name="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)" id="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromByteArray(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.1, AIR 3.1</td></tr></table><p></p><p></p><p>
         <code>ByteArray</code>에 저장된 값을 사용하여 셰이더 프로그램에 사용할 상수를 설정합니다. 
         
         <p>꼭지점 또는 조각 프로그램에서 액세스할 수 있는 상수를 설정합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; Context3DProgramType 중 하나입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 설정할 첫 번째 셰이더 프로그램 상수의 인덱스입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> &mdash; 설정할 레지스터 수입니다. 모든 레지스터는 네 개의 float 값으로 읽힙니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 소스 ByteArray 객체
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArrayOffset</span>:<a href="../../uint.html">uint</a></code> &mdash; 읽기를 위한 ByteArray에 대한 오프셋
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; <code>data</code>가 null인 경우 kNullPointerError입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 최대 셰이더 상수 수를 초과하여 설정하려고 한 경우 kConstantRegisterOutOfBounds입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; <code>byteArrayOffset</code>이 <code>data</code>의 길이보다 크거나 같거나, <code>data</code> - <code>byteArrayOffset</code>의 요소 수가 <code>numRegisters</code>*16보다 작은 경우 kBadInputSize입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromMatrix()" id="setProgramConstantsFromMatrix()"></a><a name="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)" id="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromMatrix</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromMatrix(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         <code>Matrix3D</code>에 저장된 값을 사용하여 셰이더 프로그램에 사용할 상수를 설정합니다. 
         
         <p>이 함수를 사용하여 행렬을 셰이더 프로그램에 전달합니다. 이 함수는 꼭지점 또는 조각 프로그램에 사용되는 네 개의 상수 레지스터를 설정합니다. 행렬은 레지스터에 행별로 할당됩니다. 첫 번째 상수 레지스터에는 행렬의 맨 위 행이 할당됩니다. 꼭지점 프로그램에 128개의 레지스터를 설정하고 조각 프로그램에 28개의 레지스터를 설정할 수 있습니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; 셰이더 프로그램의 유형인 <code>Context3DProgramType.VERTEX</code> 또는 <code>Context3DProgramType.FRAGMENT</code>입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 설정할 첫 번째 상수 레지스터의 인덱스입니다. Matrix3D에 16개의 값이 있으므로 네 개의 레지스터가 설정됩니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix3D.html">Matrix3D</a></code> &mdash; 상수 값을 포함하는 행렬입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transposedMatrix</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code>인 경우 행렬 항목은 전치된 순서로 레지스터에 복사됩니다. 기본값은 <code>false</code>입니다.
            
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Null 포인터 오류: <code>matrix</code>가 null인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 상수 레지스터가 경계를 벗어남: 최대 개수의 셰이더 상수 레지스터를 초과하여 설정하려는 경우입니다.
         
         </td></tr></table><p id="learnMore"><span class="label">추가 정보</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_kr</a></div><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromVector()" id="setProgramConstantsFromVector()"></a><a name="setProgramConstantsFromVector(String,int,Vector$Number,int)" id="setProgramConstantsFromVector(String,int,Vector$Number,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromVector(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         셰이더 프로그램에 대한 상수 입력을 설정합니다.
         
         <p>꼭지점 또는 조각 셰이더 프로그램에서 액세스할 상수 배열을 설정합니다. Program3D에서 설정된 상수는 셰이더 프로그램 내에서 상수 레지스터로 액세스합니다. 각 상수 레지스터는 4개의 부동 소수점 값(x, y, z, w)으로 구성됩니다. 따라서 모든 레지스터는 데이터 벡터에 네 개의 항목이 필요합니다. 꼭지점 프로그램 및 프래그먼트 프로그램에 대해 설정할 수 있는 레지스터 수는 <code>Context3DProfile</code>에 따라 다릅니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; 셰이더 프로그램의 유형인 <code>Context3DProgramType.VERTEX</code> 또는 <code>Context3DProgramType.FRAGMENT</code>입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 설정할 첫 번째 상수 레지스터의 인덱스입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; 부동 소수점 상수 값입니다. <code>data</code>에는 최소한 네 개의 <code>numRegisters</code> 요소가 있어야 합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 설정할 상수 수입니다. 사용 가능한 모든 데이터를 사용하도록 충분한 레지스터를 설정하려면 기본값인 -1을 지정합니다.
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Null 포인터 오류: <code>data</code>가 <code>null</code>인 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 상수 레지스터가 경계를 벗어남: 최대 개수의 셰이더 상수 레지스터를 초과하여 설정하려는 경우입니다.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 잘못된 입력 크기: <code>data</code>의 요소 수가 <code>numRegisters</code>*4보다 작은 경우입니다.
         
         </td></tr></table><p id="learnMore"><span class="label">추가 정보</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_kr</a></div><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToBackBuffer()" id="setRenderToBackBuffer()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToBackBuffer():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         백 렌더링 버퍼를 렌더링 대상으로 설정합니다. 이후에 <code>drawTriangles()</code> 및 <code>clear()</code> 메서드를 호출하면 백 버퍼가 업데이트됩니다. <code>setRenderToTexture()</code> 메서드를 사용한 후 이 메서드를 사용하여 일반 렌더링을 다시 시작합니다. 
         
         
         </p></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToTexture()" id="setRenderToTexture()"></a><a name="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)" id="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToTexture(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         지정된 텍스처를 렌더링 대상으로 설정합니다.  
         
         <p>이후에 <code>drawTriangles()</code> 및 <code>clear()</code> 메서드를 호출하면 백 버퍼 대신에 지정된 텍스처가 업데이트됩니다. 밉맵은 자동으로 만들어집니다. <code>setRenderToBackBuffer()</code>를 사용하여 백 버퍼로의 일반 렌더링을 다시 시작합니다.</p>
         
         <p>그리기 전에 어떠한 지우기도 필요 없습니다. 지우기 작업이 없는 경우 내용 렌더링이 유지됩니다. 심도 버퍼 및 스텐실 버퍼 또한 지워지지 않게 됩니다. 하지만 처음에 그리는 경우 지우기가 적용됩니다. <code>present()</code>를 호출하면 대상이 백 버퍼로 재설정됩니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; 렌더링할 대상 텍스처입니다. 백 버퍼로 렌더링을 다시 시작하려면 <code>null</code>로 설정합니다(<code>setRenderToBackBuffer()</code> 및 <code>present</code>도 대상을 백 버퍼로 재설정함).       
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code>이면 심도 및 스텐실 테스트를 사용할 수 있습니다. <code>false</code>이면 후속 그리기 작업에서 모든 심도 및 스텐실 상태가 무시됩니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 앤티앨리어싱 품질입니다. 앤티앨리어싱을 비활성화하려면 0을 사용합니다. 값이 높을수록 앤티앨리어싱 품질이 향상되지만 더 많은 계산이 필요합니다. 값은 현재 모바일 플랫폼 및 소프트웨어 렌더링 컨텍스트에서 무시됩니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">surfaceSelector</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 업데이트할 텍스처의 요소를 지정합니다. 텍스트 객체에 하나의 표면이 있으므로 기본값인 0을 지정해야 합니다. CubeTexture 객체에는 6개의 표면이 있으므로 0부터 5까지의 정수를 지정할 수 있습니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorOutputIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 출력 색상 레지스터입니다. 제한된 모드 또는 기준선 모드의 경우 0이어야 합니다. 그렇지 않으면 출력 색상 레지스터를 지정합니다. 
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>surfaceSelector</code> 매개 변수가 일치하지 않는 경우입니다. 값은 2D 텍스처의 경우 0이고, 정육면체 맵의 경우 0에서 5 사이여야 합니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>texture</code>는 TextureBase 클래스(Texture 또는 CubeTexture 클래스)에서 파생되지 않습니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>colorOutputIndex</code>는 0부터 3까지의 정수여야 합니다.
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 이 호출에는 표준 프로파일 이상으로 만든 <code>Context3D</code>가 필요합니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#configureBackBuffer()" target="">configureBackBuffer()</a><br/><a href="textures/CubeTexture.html#uploadFromByteArray()" target="">flash.display3D.textures.CubeTexture.uploadFromByteArray()</a></div></div></span><span id="pageFilter" runtime="Flash::11.6##AIR::3.6##"><a name="setSamplerStateAt()" id="setSamplerStateAt()"></a><a name="setSamplerStateAt(int,String,String,String)" id="setSamplerStateAt(int,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setSamplerStateAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setSamplerStateAt(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.6, AIR 3.6</td></tr></table><p></p><p></p><p>
         텍스처 샘플러 상태를 수동으로 재정의합니다..
         
         <p>텍스처 샘플링 상태는 일반적으로 <code>setProgram</code>이 호출될 때 설정됩니다. 그러나 이 함수를 사용하여 텍스처 샘플러 상태를 재정의할 수 있습니다. 프로그램이 샘플러 상태를 변경하지 않도록 하려면 AGAL에서 <code>ignoresamnpler</code>비트를 설정하고 이 함수를 사용하십시오.          
         </p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; 사용할 샘플러 레지스터입니다. AGAL의 샘플러 레지스터에 매핑됩니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wrap</span>:<a href="../../String.html">String</a></code> &mdash; 래핑 모드입니다. <code>Context3DWrapMode</code>에서 정의됩니다. 기본값은 repeat입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../../String.html">String</a></code> &mdash; 텍스처 필터링 모드입니다. <code>Context3DTextureFilter</code>에서 정의됩니다. 기본값은 nearest입니다. 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mipfilter</span>:<a href="../../String.html">String</a></code> &mdash; 밉 맵 필터입니다. <code>Context3DMipFilter</code>에서 정의됩니다. 기본값은 none입니다.          
                  
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 샘플러가 범위를 벗어남
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 래핑, 필터, 밉필터의 잘못된 열거형 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 객체 삭제됨: <code>dispose()</code>를 호출했거나 기본 렌더링 하드웨어가 손실되어 이 Context3D 객체가 삭제된 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DWrapMode.html" target="">Context3DWrapMode</a><br/><a href="Context3DTextureFilter.html" target="">Context3DTextureFilter</a><br/><a href="Context3DMipFilter.html" target="">Context3DMipFilter</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setScissorRectangle()" id="setScissorRectangle()"></a><a name="setScissorRectangle(flash.geom.Rectangle)" id="setScissorRectangle(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setScissorRectangle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setScissorRectangle(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         드로잉 마스크의 한 유형인 자르기 사각형을 설정합니다. 렌더러는 자르기 사각형 안의 영역에만 그립니다. 자르기는 지우기 작업에 영향을 주지 않습니다. 
         
         <p>자르기를 해제하려면 <code>null</code>을 전달합니다.</p>     
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rectangle</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 안에 그릴 사각형입니다. 사각형 위치와 크기를 픽셀 단위로 지정합니다. 좌표계 원점은 뷰포트의 왼쪽 위 모서리이고 양수 값이 증가할수록 오른쪽 아래로 내려갑니다(일반 Flash 표시 좌표계와 동일). 
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 클래스는 스테이지의 640x480 픽셀 뷰포트에 두 개의 삼각형을 그립니다. 두 삼각형은 원점(0,0,0)에 있는 꼭지점 하나를 공유합니다.
 
 <p>삼각형은 꼭지점 버퍼와 인덱스 버퍼를 사용하여 정의됩니다. 꼭지점 버퍼는 각 삼각형 꼭지점의 위치와 색상 정보를 포함합니다. 인덱스 버퍼는 꼭지점 버퍼에 대한 인덱스를 포함합니다. 세 개의 인덱스가 삼각형 하나를 정의합니다. 예를 들어 꼭지점 버퍼의 처음 세 점으로 구성된 삼각형은 인덱스 버퍼에서 0,1,2로 나열됩니다.</p>
 
 <p>이 간단한 예제에서는 3D 변형을 수행하지 않습니다. 정규화된 시야 영역(원점을 중심으로 하는 2x2x2 정육면체) 내의 객체만 표시됩니다. 그러나 일반적인 3D 장면을 렌더링할 때는 렌더링할 객체를 원근 또는 직각 투영을 사용하여 이 시야 영역에 투영합니다.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_ScissorRectangle extends Sprite
    {
        public const viewWidth:Number = 640;
        public const viewHeight:Number = 480;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var scissorOn:Boolean = false;
        private var toggler:Timer = new Timer( 750 );
        
        public function Context3D_ScissorRectangle()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
            
            //Set up timer to turn scissoring on and off
            toggler.addEventListener( TimerEvent.TIMER, toggleScissor );
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
            toggler.start();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear();

            //Sciss a region excluding the outer 100 pixels of the viewport
            var scissor:Rectangle = new Rectangle( 100, 100, viewWidth - 200, viewHeight - 200 );
            if( scissorOn )    renderContext.setScissorRectangle( scissor ); //on
            else renderContext.setScissorRectangle( null ); //off

            //Draw the triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function toggleScissor( event:Event ):void
        {
            scissorOn = !scissorOn;
            render();
        }
        
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilActions()" id="setStencilActions()"></a><a name="setStencilActions(String,String,String,String,String)" id="setStencilActions(String,String,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilActions</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilActions(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         스텐실 모드 및 작업을 설정합니다.
         
         <p>8비트 스텐실 참조 값은 각 그리기 호출과 연결할 수 있습니다. 렌더링 도중 이전에 프레임 버퍼에 저장된 값과 비교하여 참조 값을 테스트할 수 있습니다. 테스트의 결과로 그리기 액션을 제어하고 저장된 스텐실 값의 업데이트 여부 또는 방법을 제어할 수 있습니다. 또한 심도 테스트는 스텐실 테스트가 수행되는지 여부를 제어합니다. 실패한 심도 테스트를 사용하여 스텐실 버퍼에 수행할 액션을 제어할 수도 있습니다.</p>
         
         <p>픽셀 처리 파이프라인에서 심도 테스트가 먼저 수행됩니다. 심도 테스트에 실패할 경우 스텐실 버퍼 업데이트 액션이 수행될 수 있지만 스텐실 버퍼 값의 평가를 더 이상 수행할 수 없습니다. 심도 테스트에 성공할 경우 스텐실 테스트가 수행됩니다. 스텐실 테스트의 결과에 따라 대체 액션이 수행될 수 있습니다.  </p>
         
         <p>스텐실 참조 값은 <code>setStencilReferenceValue()</code>를 사용하여 설정합니다. </p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFace</span>:<a href="../../String.html">String</a></code> (default = "<code>frontAndBack</code>")<code></code> &mdash; 스텐실 작업을 구성하도록 허용되는 삼각형의 방향입니다. Context3DTriangleFace 중 하나입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compareMode</span>:<a href="../../String.html">String</a></code> (default = "<code>always</code>")<code></code> &mdash; 현재 스텐실 참조 값과 대상 픽셀 스텐실 값을 비교하는 데 사용되는 테스트 연산자입니다. 비교가 true인 경우 대상 픽셀 색상 및 심도 업데이트가 수행됩니다. 스텐실 액션은 다음 액션 매개 변수에서 요청 시 수행됩니다. 비교 연산자는 현재 및 대상 참조 값 사이의 중위 연산자로 해당 순서대로 적용됩니다(의사 코드: <code>if stencilReference OPERATOR stencilBuffer then pass</code>). Context3DCompareMode 클래스에 정의된 상수 중 하나를 사용합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnBothPass</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 심도 및 스텐실 비교에 모두 성공할 경우 수행할 액션입니다. Context3DStencilAction 클래스에 정의된 상수 중 하나를 사용합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 심도 비교에 실패할 경우 수행할 액션입니다. Context3DStencilAction 클래스에 정의된 상수 중 하나를 사용합니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthPassStencilFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 심도 비교에 성공하고 스텐실 비교에 실패할 경우 수행할 액션입니다. Context3DStencilAction 클래스에 정의된 상수 중 하나를 사용합니다.
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형 오류: <code>triangleFace</code>가 Context3DTriangleFace 클래스에 정의된 값 중 하나가 아닌 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형 오류: <code>compareMode</code>가 Context3DCompareMode 클래스에 정의된 값 중 하나가 아닌 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형 오류: <code>actionOnBothPass</code>, <code>actionOnDepthFail</code> 또는 <code>actionOnDepthPassStencilFail</code>이 Context3DStencilAction 클래스에 정의된 값 중 하나가 아닌 경우입니다.
         
         </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3D.html#setStencilReferenceValue()" target="">setStencilReferenceValue()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 클래스에서는 스텐실을 그리고 이를 후속 그리기 작업에서 마스크로 사용하는 방법을 보여 줍니다. 이 예제에서는 다음 단계를 수행합니다.
 <ul><li>스텐실 버퍼를 0으로 지웁니다.</li><li>스텐실 테스트에 통과하면 스텐실 액션을 increment로 설정합니다.</li><li>스텐실 참조 값을 0으로 설정합니다.</li><li>삼각형 마스크를 그립니다. 스텐실 버퍼가 0으로 지워졌고 참조 값이 0이므로 삼각형이 그려질 때마다 스텐실 테스트에 통과합니다. 따라서 스텐실 버퍼는 삼각형 마스크가 그려지는 경우 1로 증가합니다.</li><li>후속 그리기 작업으로 인해 스텐실 버퍼가 변경되지 않도록 스텐실 액션을 keep으로 변경합니다.</li><li>전체 화면 사각형(여러 색상 지정)을 그립니다. 스텐실 참조 값이 여전히 0이므로 마스크 처리된 영역에서는 스텐실 테스트가 실패합니다. 따라서 사각형이 마스크 처리된 영역을 제외한 모든 영역에 그려집니다.</li><li>스텐실 참조 값을 1으로 변경합니다.</li><li>다른 전체 화면 사각형(빨간색)을 그립니다. 이제 1로 증가한 마스크 처리된 영역을 제외한 모든 영역에서 스텐실 테스트가 실패합니다. 따라서 사각형은 마스크 처리된 영역에만 그려집니다.</li></ul>
 <p>예제 위에 마우스를 갖다 대면 주요 단계를 순서대로 확인할 수 있습니다.</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DCompareMode;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DStencilAction;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_Stencil extends Sprite
    {
        public const viewWidth:Number = 350;
        public const viewHeight:Number = 240;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
                
        public function Context3D_Stencil()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
        
            non3DSetup();
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, true );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3, 2, 
                                                            0, 1, 3,
                                                            4, 7, 6,
                                                            4, 5, 7,
                                                            8, 9, 10
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  //x, y, z  r,g,b format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1,

                   -1, 1, 0,  .5,0,0,
                    1, 1, 0,  .5,0,0,
                   -1,-1, 0,  .5,0,0,
                    1,-1, 0,  .5,0,0,
                    
                    0, .7,.1, 0,0,0,
                  -.7,-.7,.1, 0,0,0,
                   .7,-.7,.1, 0,0,0
                ]);
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            render();
        }
        private function render():void
        {
            //Clear, setting stencil to 0
            renderContext.clear( .3, .3, .3, 1, 1, 0 );
            
            //Draw stencil, incrementing the stencil buffer value
            renderContext.setStencilReferenceValue( 0 );
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.INCREMENT_SATURATE );            
            if( state &gt; 0 ) renderContext.drawTriangles( indexList, 12, 1 );

            //Change stencil action when stencil passes so stencil buffer is not changed
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.KEEP );
            
            //Draw quad -- doesn't draw where stencil has already drawn
            if( state &gt; 1 ) renderContext.drawTriangles( indexList, 0, 2 );
            
            //Change the reference to 1 so this quad only draws into stenciled area
            renderContext.setStencilReferenceValue( 1 );
            if( state &gt; 2 ) renderContext.drawTriangles( indexList, 6, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        //The rest of the code is for the example UI and timer 
        private function doState( event:TimerEvent ):void
        {
            switch (state)
            {
                case 0:
                    description.text = "Draw triangle with stencil action == increment";
                    state = 1;
                    break;
                case 1:
                    description.text = "Draw the first plane where stencil == 0";
                    state = 2;
                    break;
                case 2:
                    description.text = "Draw second plane where stencil == 1";
                    state = 3;
                    break;
                case 3:
                    description.text = "Clear, setting stencil to 0";
                    state = 0;
                    break;

                default:
                    description.text = "";
                    state = 0;        
            }
            render();
        }

        private var state:int = 3;
        private var stateTimer:Timer = new Timer( 1250 );
        private var description:TextField = new TextField();
        
        private function non3DSetup():void
        {
            //Setup timer to animate the stages of drawing the scene
            stateTimer.addEventListener( TimerEvent.TIMER, doState );
            this.stage.addEventListener( MouseEvent.MOUSE_OVER, function(event:Event):void{stateTimer.start()} );
            this.stage.addEventListener( MouseEvent.MOUSE_OUT, function(event:Event):void{stateTimer.stop()} );
            
            description.height = 30;
            description.width = viewWidth;
            this.addChild( description );
            description.y = viewHeight + 15;
            description.defaultTextFormat = new TextFormat( null, 18, 0xffffff );
            description.text = "Mouse over to view.";
            
            //Allows mouse-over events
            var coverSprite:Sprite = new Sprite();
            coverSprite.graphics.beginFill( 0, .01 )
            coverSprite.graphics.lineTo( stage.stageWidth, 0 );
            coverSprite.graphics.lineTo( stage.stageWidth, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, 0 );
            this.addChild( coverSprite );            
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilReferenceValue()" id="setStencilReferenceValue()"></a><a name="setStencilReferenceValue(uint,uint,uint)" id="setStencilReferenceValue(uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilReferenceValue</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilReferenceValue(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         스텐실 테스트에 사용되는 스텐실 비교 값을 설정합니다. 
         
         <p>참조 값의 하위 8비트만 사용됩니다. 스텐실 버퍼 값도 역시 8비트 길이입니다. 비트 필드로 스텐실 버퍼를 사용하려면 <code>readMask</code> 및 <code>writeMask</code>를 사용합니다.</p>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">referenceValue</span>:<a href="../../uint.html">uint</a></code> &mdash; 참조 값 비교 테스트에 사용되는 8비트 참조 값입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">readMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 비교 이전에 현재 스텐실 버퍼 값과 참조 값 모두에 적용할 8비트 마스크입니다.  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">writeMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 스텐실 버퍼를 업데이트하기 전에 참조 값에 적용할 8비트 마스크입니다.
         
         </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3D.html#setStencilActions()" target="">setStencilActions()</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setTextureAt()" id="setTextureAt()"></a><a name="setTextureAt(int,flash.display3D.textures.TextureBase)" id="setTextureAt(int,flash.display3D.textures.TextureBase)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setTextureAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setTextureAt(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         조각 프로그램의 텍스처 입력 레지스터에 사용할 텍스처를 지정합니다.
         
         <p>조각 프로그램은 최대 8개의 텍스처 객체에서 정보를 읽을 수 있습니다. 이 함수를 사용하여 조각 프로그램에 사용되는 샘플러 레지스터 중 하나에 Texture 또는 CubeTexture 객체를 할당합니다. </p>
         
         <p><b>참고:</b> <code>setProgram</code>을 사용하여 활성 조각 프로그램을 더 적은 텍스처를 사용하는 셰이더로 변경할 경우 사용되지 않는 레지스터를 <code>null</code>로 설정합니다.</p>
         <div class="listing"><pre>
         setTextureAt( 7, null );
         </pre></div>
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; 0부터 7까지의 값인 샘플러 레지스터 인덱스입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; 사용 가능하게 만들 텍스처 객체입니다(Texture 또는 CubeTexture 인스턴스).
         
         </td></tr></table></p><p id="learnMore"><span class="label">추가 정보</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_kr</a></div><p><span class="label">관련 API 요소</span></p><div class="seeAlso">Texture<br/>CubeTexture</div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setVertexBufferAt()" id="setVertexBufferAt()"></a><a name="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)" id="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVertexBufferAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVertexBufferAt(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         단일 꼭지점 셰이더 프로그램 입력에 해당하는 꼭지점 데이터 구성 요소를 지정합니다.
         
         <p><code>setVertexBufferAt</code> 메서드를 사용하여 VertexBuffer3D 버퍼의 각 꼭지점에 정의된 데이터의 구성 요소와 해당 구성 요소가 속해 있는 꼭지점 프로그램에 대한 입력을 식별합니다. 꼭지점 프로그램의 개발자는 꼭지점당 필요한 데이터 양을 결정합니다. 해당 데이터는 하나 이상의 <code>VertexBuffer3D</code> 스트림에서 꼭지점 셰이더 프로그램의 특성 레지스터에 매핑됩니다.</p>
         
         <p>꼭지점 셰이더가 사용하는 가장 작은 데이터 단위는 32비트 데이터입니다. 꼭지점 스트림에 대한 오프셋은 32비트의 배수로 지정됩니다.</p>
         
         예를 들어 프로그래머가 다음 데이터를 사용하여 각 꼭지점을 정의한다고 가정할 수 있습니다.
<pre>
position:  x    float32
           y    float32
           z    float32
color:     r    unsigned byte
           g    unsigned byte
           b    unsigned byte
           a    unsigned byte
</pre>            
         꼭지점이 <code>buffer</code>라는 VertexBuffer3D 객체에 정의되었다는 가정하에 다음 코드를 사용하여 꼭지점 셰이더에 할당할 수 있습니다.
<pre>
setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
</pre>
         
         
         </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">index</span>:<a href="../../int.html">int</a></code> &mdash; 꼭지점 셰이더에 있는 특성 레지스터의 인덱스입니다(0-7).
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">buffer</span>:<a href="VertexBuffer3D.html">VertexBuffer3D</a></code> &mdash; 꼭지점 셰이더에 제공할 소스 꼭지점 데이터를 포함하는 버퍼입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferOffset</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 이 특성의 읽기를 시작할 단일 꼭지점의 데이터 시작 부분에서의 오프셋입니다. 위 예제에서 위치 데이터는 첫 번째 특성이므로 오프셋이 0이고 색상 특성 뒤에 세 개의 32비트 위치 값이 오므로 색상의 오프셋은 3입니다. 이 오프셋은 32비트 단위로 지정됩니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> (default = "<code>float4</code>")<code></code> &mdash; 이 특성의 데이터 유형을 지정하는 Context3DVertexBufferFormat 클래스 값입니다.  
         
         </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 잘못된 열거형: 형식이 Context3DVertexBufferFormat 클래스에 정의된 값 중 하나가 아닌 경우입니다.
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 특성 레지스터가 경계를 벗어남: <code>index</code> 매개 변수가 0-7 범위를 벗어난 경우입니다. 최대 8개의 꼭지점 특성 레지스터가 셰이더에 사용될 수 있습니다.
         
         </td></tr></table><p id="learnMore"><span class="label">추가 정보</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_kr</a></div><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">예제<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span></div><span id="pageFilter"><div class="exampleHeader">Context3DExample.as</div><br/><div class="detailBody"> 다음 클래스는 원근 투영을 사용하여 회전하는 정육면체를 그립니다.
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    import com.adobe.utils.PerspectiveMatrix3D;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.geom.Vector3D;
    
    public class Context3DExample extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        public const zNear:Number = 1;
        public const zFar:Number = 500;
        
        public const fov:Number = 45;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private var projection:PerspectiveMatrix3D = new PerspectiveMatrix3D();
        private var model:Matrix3D = new Matrix3D();
        private var view:Matrix3D = new Matrix3D();
        private var finalTransform:Matrix3D = new Matrix3D();
        
        //For rotating the cube
        private const pivot:Vector3D = new Vector3D();
        
        private const VERTEX_SHADER:String =
            "m44 op, va0, vc0    \n" +    // 4x4 matrix transform 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3DExample()
        {
            this.stage.scaleMode = StageScaleMode.NO_SCALE;
            this.stage.align = StageAlign.TOP_LEFT;
            this.stage.nativeWindow.activate(); //AIR only
                         
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextCreationError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
                renderContext = Stage3D( event.target ).context3D;
                trace( "3D driver: " + renderContext.driverInfo );
                setupScene();
        }
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //Create vertex index list for the triangles forming a cube
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 
                2,1,0, //front face
                3,2,0,
                4,7,5, //bottom face
                7,6,5,
                8,11,9, //back face
                9,11,10,
                12,15,13, //top face
                13,15,14,
                16,19,17, //left face
                17,19,18,
                20,23,21, //right face
                21,23,22
            ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes - cube faces do not share vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                    // x,y,z r,g,b format
                    0,0,0, 1,0,0, //front face
                    0,1,0, 1,0,0,
                    1,1,0, 1,0,0,
                    1,0,0, 1,0,0,
                    
                    0,0,0, 0,1,0, //bottom face
                    1,0,0, 0,1,0,
                    1,0,1, 0,1,0,
                    0,0,1, 0,1,0,
                    
                    0,0,1, 1,0,0, //back face
                    1,0,1, 1,0,0,
                    1,1,1, 1,0,0,
                    0,1,1, 1,0,0,
                    
                    0,1,1, 0,1,0, //top face
                    1,1,1, 0,1,0,
                    1,1,0, 0,1,0,
                    0,1,0, 0,1,0,
                    
                    0,1,1, 0,0,1, //left face
                    0,1,0, 0,0,1,
                    0,0,0, 0,0,1,
                    0,0,1, 0,0,1,
                    
                    1,1,0, 0,0,1, //right face
                    1,1,1, 0,0,1,
                    1,0,1, 0,0,1,
                    1,0,0, 0,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Set up 3D transforms
            projection.perspectiveFieldOfViewRH( fov, viewWidth/viewHeight, zNear, zFar );            
            view.appendTranslation( 0, 0, -2 );    //Move view back
            model.appendTranslation( -.5, -.5, -.5 ); //center cube on origin
            this.stage.addEventListener( Event.ENTER_FRAME, render );
        }
        
        private function render( event:Event ):void
        {
            //Rotate model on each frame
            model.appendRotation( .5, Vector3D.Z_AXIS, pivot );
            model.appendRotation( .5, Vector3D.Y_AXIS, pivot );
            model.appendRotation( .5, Vector3D.X_AXIS, pivot );
            
            //Combine transforms
            finalTransform.identity();
            finalTransform.append( model );
            finalTransform.append( view );
            finalTransform.append( projection );
            
            //Pass the final transform to the vertex shader as program constant, vc0
            renderContext.setProgramConstantsFromMatrix( Context3DProgramType.VERTEX, 0, finalTransform, true );
            
            //Clear is required before drawTriangles on each frame
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 12 triangles that make up the cube
            renderContext.drawTriangles( indexList, 0, 12 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextCreationError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
    }
}
</pre></div></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,true,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:17 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ko_KR/legalnotices/index.html">법적 고지 사항</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">온라인 개인 정보 보호 정책</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">영어로 표시되는 이유</span>
				</div>
				<div class="white_content_body">
					<b>ActionScript 3.0 참조 설명서의 내용이 영어로 나타납니다.</b><br><br>
					ActionScript 3.0 참조 설명서 중 일부는 전체 언어로 번역되지 않았습니다. 언어 요소가 번역되지 않은 경우 영어로 나타납니다. 예를 들어 ga.controls.HelpBox 클래스는 어떤 언어로도 번역되지 않았습니다. 그러므로 한국어 버전의 참조 설명서에서 ga.controls.HelpBox 클래스는 영어로 나타납니다.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:17 PM Z  -->
