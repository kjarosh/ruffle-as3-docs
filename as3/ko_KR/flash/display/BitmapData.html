<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="Adobe&reg; Flash&reg; Platform용 ActionScript&reg; 3.0 참조 설명서"><meta name="lang" content="ko-kr"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Adobe ActionScript&reg; 3 (AS3  ) API 참조 설명서</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "런타임";
			var productsLabel = "제품";
			var noneLabel = "없음";
			var qsearchBoxLabel = "빠른 검색";
			var qsearchText = "찾을 수 없는 용어";
			var ajaxErrorMsg="페이지 불러오기 오류";
			var ajaxErrorTryMsg="다시 시도";
			var ajaxLoadingMsg="불러오는 중";
			var cancelMsg = "취소";
			var classesText = "클래스";
			var strJiveReply = "이 질문은 다음 문서에 대응하여 제출되었습니다. "
			var showFilters = "필터 표시";
			var hideFilters = "필터 숨기기";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform용 ActionScript<sup>&reg;</sup> 3.0 참조 설명서<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> 홈 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">패키지 및 클래스 목록 표시</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">패키지 및 클래스 목록 숨기기</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> 패키지 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> 클래스 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> 새로운 내용 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> 색인 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> 부록 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">영어로 표시되는 이유</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/ko_KR/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>필터:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">서버에서 데이터를 검색하는 중...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> 속성 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 속성 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 생성자 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> 메서드 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> 전역 상수 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> 이벤트 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> 스타일 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> 스킨 파트 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> 스킨 상태 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> 효과 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> 상수 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> 전역 함수 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">함수</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> 인터페이스 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> 클래스 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> 예제 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								클래스
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">패키지</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">클래스</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">상속</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">구현</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 BitmapData 클래스를 사용하면 <span>Bitmap 객체</span>의 데이터(픽셀)를 처리할 수 있습니다. BitmapData 클래스의 메서드를 사용하여 임의의 크기로 투명 또는 불투명 비트맵 이미지를 만들고 런타임 시 다양한 방식으로 이를 조작할 수 있습니다. <span>BitmapData에서는 <code>flash.display.Loader</code> 클래스를 통해 로드한 비트맵 이미지에도 액세스할 수 있습니다.</span> 
 
               <p>이 클래스를 사용하면 비트맵 렌더링 작업을 Flash Player의 내부 표시 업데이트 루틴과 분리할 수 있습니다. BitmapData 객체를 직접 조작함으로써 매 프레임마다 벡터 데이터에서 내용을 반복해서 그려야 하는 수고 없이도 복잡한 이미지를 만들 수 있습니다.</p>
 
               <p>BitmapData 클래스의 메서드는 비트맵 이외의 표시 객체에서 필터를 통해 얻을 수 없는 효과를 지원합니다.</p>
 
               <p>BitmapData 객체에는 일련의 픽셀 데이터가 포함되어 있습니다. 이 데이터는 완전 불투명 비트맵을 나타낼 수도 있고 알파 채널 데이터가 포함된 투명 비트맵을 나타낼 수도 있습니다. 둘 중 어느 유형이든 BitmapData 객체는 32비트 정수의 버퍼로 저장됩니다. 각각의 32비트 정수는 비트맵에 포함된 단일 픽셀의 속성을 결정합니다.</p>
 
               <p>각각의 32비트 정수는 해당 픽셀의 ARGB(알파 투명도, 빨강, 녹색, 파랑) 값을 기술하는 8비트의 채널 값(0 ~ 255) 네 개가 합쳐진 것입니다. ARGB 값에서 최상위 바이트는 알파 채널 값을 나타내며 빨강, 녹색 및 파랑이 이어집니다.</p>
 
               <p>네 가지 채널(알파, 빨강, 녹색 및 파랑)은 <code>BitmapData.copyChannel()</code> 메서드 또는 <code>DisplacementMapFilter.componentX</code> 및 <code>DisplacementMapFilter.componentY</code> 속성과 함께 사용할 경우 숫자로 표시되며, 이 숫자는 BitmapDataChannel 클래스에서 다음 상수로 표시됩니다.</p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>BitmapData 객체의 <code>bitmapData</code> 속성을 사용하여 BitmapData 객체를 Bitmap 객체에 연결할 수 있습니다.</p>
 
               <p>
                  <code>Graphics.beginBitmapFill()</code> 메서드를 사용하여 BitmapData 객체를 통해 Graphics 객체를 채울 수 있습니다.</p>
 
               <p>AIR 런타임에서 각 DockIcon, Icon, InteractiveIcon 및 SystemTrayIcon 클래스에는 아이콘의 비트맵 이미지를 정의하는 BitmapData 객체의 배열인 <code>bitmaps</code> 속성이 들어 있습니다.</p>
 
               <p>AIR 1.5 및 Flash Player 10에서는 BitmapData 객체의 최대 크기가 8,191픽셀(폭 또는 높이)이며 총 픽셀 수는 16,777,215픽셀을 초과할 수 없습니다. 따라서 BitmapData 객체의 폭이 8,191픽셀이면 높이가 2,048픽셀 이하여야 합니다. Flash Player 9 이전 버전 및 AIR 1.1 이전 버전에서는 이 제한이 높이 2,880픽셀 및 폭 2,880픽셀입니다.</p>
 
               <p>AIR 3 및 Flash player 11부터는 BitmapData 객체의 크기 제한이 없어졌습니다. 이제 비트맵의 최대 크기는 운영 체제에 따라 결정됩니다.</p>
 
               <p>BitmapData 객체가 유효하지 않거나(예: <code>height == 0</code> 및 <code>width == 0</code>인 경우) dispose()를 통해 해제된 경우, BitmapData 객체의 메서드나 속성을 호출하면 ArgumentError 오류가 발생합니다. </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">예제 보기</a></p><p><span class="classHeaderTableLabel">관련 API 요소</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">공용 속성</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 상속되는 공용 속성 숨기기</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 상속되는 공용 속성 표시</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">속성</th><th>정의 주체</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 지정된 객체 인스턴스의 클래스 객체 또는 생성자 함수에 대한 참조입니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[읽기 전용] 
     비트맵 이미지의 높이(픽셀 단위)입니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[읽기 전용] 
     비트맵 이미지의 크기와 위치를 정의하는 사각형입니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[읽기 전용] 
     비트맵 이미지에서 픽셀별 투명도를 지원하는지 여부를 정의합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[읽기 전용] 
     비트맵 이미지의 폭(픽셀 단위)입니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">공용 메서드 </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 상속되는 공용 메서드 숨기기</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 상속되는 공용 메서드 표시</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">메서드</th><th>정의 주체</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     지정된 폭과 높이로 BitmapData 객체를 만듭니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     소스 이미지와 filter 객체를 사용하여 필터링된 이미지를 생성합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     원본 인스턴스를 내포된 비트맵까지 똑같이 복제한 새 BitmapData 객체를 반환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     ColorTransform 객체를 사용하여 비트맵 이미지의 지정된 영역에서 색상 값을 조정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     두 BitmapData 객체를 비교합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     현재 BitmapData 객체나 다른 BitmapData 객체의 채널에서 현재 BitmapData 객체의 채널로 데이터를 이전합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     연장 효과나 회전 효과 또는 색상 효과 없이 이미지에서 픽셀을 조작할 수 있는 빠른 경로를 제공합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     픽셀 데이터의 사각형 영역에서 바이트 배열을 채웁니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     BitmapData 객체를 저장하는 데 사용된 메모리를 비웁니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Flash 런타임 벡터 렌더러를 사용하여 비트맵 이미지에 source 표시 객체를 그립니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Flash 런타임 벡터 렌더러를 사용하여 비트맵 이미지에 source 표시 객체를 그립니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     선택한 압축 알고리즘을 사용하여 이 BitmapData 객체를 압축하고 새 ByteArray 객체를 반환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     사각형의 픽셀 영역을 지정된 ARGB 색상으로 채웁니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     (x, y) 좌표에서 시작하는 이미지에서 색상 채우기 작업을 수행하여 특정 색상으로 채웁니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     지정된 BitmapData 객체와 소스 사각형 및 필터 객체를 기준으로 applyFilter() 메서드 호출이 적용될 대상 사각형을 결정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     사각형 영역이 비트맵 이미지 내에서 지정된 색상의 모든 픽셀을 포함할지(findColor 매개 변수가 true로 설정된 경우) 또는 지정된 색상을 제외한 모든 픽셀을 포함할지(findColor 매개 변수가 false로 설정된 경우)를 결정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     특정 지점(x, y)에서 BitmapData 객체의 RGB 픽셀 값을 나타내는 정수를 반환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     알파 채널 데이터와 RGB 데이터를 포함하는 ARGB 색상 값을 반환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     픽셀 데이터의 사각형 영역에서 바이트 배열을 생성합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     픽셀 데이터의 사각형 영역에서 벡터 배열을 생성합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 지정된 속성이 객체에 정의되어 있는지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     BitmapData 객체의 256 값 이진 숫자 막대 그래프를 계산합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     하나의 비트맵 이미지와 특정한 점, 사각형 또는 다른 비트맵 이미지 간의 픽셀 수준 히트 감지를 수행합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Object 클래스의 인스턴스가 매개 변수로 지정된 객체의 프로토타입 체인에 있는지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     이 BitmapData 객체를 변경할 때 BitmapData 객체를 참조하는 어떤 객체(예: Bitmap 객체)도 업데이트되지 않도록 이미지를 잠급니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     소스 이미지에서 대상 이미지로 채널별 블렌드를 수행합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     임의의 노이즈를 나타내는 픽셀로 이미지를 채웁니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     각 채널에 하나씩 최대 네 개까지의 색상 팔레트 데이터 배열이 있는 이미지에서 색상 채널 값을 다시 매핑합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Perlin 노이즈 이미지를 생성합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     소스 이미지에서 대상 이미지로, 혹은 같은 이미지를 사용하여 픽셀 디졸브(dissolve)를 수행합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 지정된 속성이 존재하고 열거 가능한지 여부를 나타냅니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     특정 (x, y) 픽셀 양만큼 이미지를 스크롤합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     BitmapData 객체의 단일 픽셀을 설정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     BitmapData 객체의 단일 픽셀에 대한 색상 및 알파 투명도 값을 설정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     바이트 배열을 픽셀 데이터의 사각형 영역으로 변환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     루프 작업에서 동적 속성을 사용할 수 있는지 여부를 설정합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     벡터를 픽셀 데이터의 사각형 영역으로 변환합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     이미지의 픽셀 값을 지정된 임계값 기준으로 테스트하고 그 테스트를 통과한 픽셀을 새 색상 값으로 설정합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 로캘별 규칙에 따라 서식이 지정된 이 객체의 문자열 표현을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 지정된 객체의 문자열 표현을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     이 BitmapData 객체를 변경할 때 BitmapData 객체를 참조하는 임의의 객체(예: Bitmap 객체)도 업데이트되도록 이미지 잠금을 해제합니다.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 지정된 객체의 프리미티브 값을 반환합니다.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">속성 세부 정보</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">속성</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     비트맵 이미지의 높이(픽셀 단위)입니다.
     
     </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     비트맵 이미지의 크기와 위치를 정의하는 사각형입니다. 사각형의 맨 위와 왼쪽은 0입니다. 사각형의 폭과 높이는 BitmapData 객체의 폭과 높이와 같고 단위는 픽셀입니다.
     
     </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     비트맵 이미지에서 픽셀별 투명도를 지원하는지 여부를 정의합니다. 생성자의 <code>transparent</code> 매개 변수에 <code>true</code>를 전달하여 BitmapData 객체를 생성하는 경우에만 이 값을 설정할 수 있습니다. BitmapData 객체를 만든 후 <code>transparent</code> 속성 값이 <code>true</code>인지 확인하여 객체가 픽셀별 투명도를 지원하는지 여부를 확인할 수 있습니다.
     
     
     </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">속성</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[읽기 전용] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     비트맵 이미지의 폭(픽셀 단위)입니다.
     
     </p><br/><br/><span class="label"> 구현 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">생성자 세부 정보</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">생성자</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     지정된 폭과 높이로 BitmapData 객체를 만듭니다. <code>fillColor</code> 매개 변수에 값을 지정하면 비트맵의 모든 픽셀이 해당 색상으로 설정됩니다.
     
     <p><code>transparent</code> 매개 변수 값으로 <code>false</code>를 전달하지 않는 한, 기본적으로 비트맵은 투명하게 만들어집니다. 불투명 비트맵을 만든 후에는 이를 투명 비트맵으로 변경할 수 없습니다. 불투명 비트맵의 모든 픽셀에서는 24비트 색상 채널 정보만 사용합니다. 비트맵을 투명으로 정의한 경우에는 각 픽셀에서 알파 투명도 채널을 포함하여 32비트 색상 채널 정보를 사용합니다.</p>
     
     <p>AIR 1.5 및 Flash Player 10에서는 BitmapData 객체의 최대 크기가 8,191픽셀(폭 또는 높이)이며 총 픽셀 수는 16,777,215픽셀을 초과할 수 없습니다. 따라서 BitmapData 객체의 폭이 8,191픽셀이면 높이가 2,048픽셀 이하여야 합니다. Flash Player 9 이전 버전 및 AIR 1.1 이전 버전에서는 이 제한이 높이 2,880픽셀 및 폭 2,880픽셀입니다. 폭이나 높이를 2,880보다 큰 값으로 지정하는 경우 새 인스턴스는 생성되지 않습니다.</p>
     
     </p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 비트맵 이미지의 폭(픽셀 단위)입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 비트맵 이미지의 높이(픽셀 단위)입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; 비트맵 이미지의 픽셀별 투명도 지원 여부를 지정합니다. 기본값은 <code>true</code>(투명)입니다. 완전히 투명한 비트맵을 만들려면 <code>transparent</code> 매개 변수 값을 <code>true</code>로 설정하고 <code>fillColor</code> 매개 변수 값을 0x00000000(또는 0)으로 설정합니다. <code>transparent</code> 속성을 <code>false</code>로 설정하면 렌더링 성능이 약간 향상될 수 있습니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 비트맵 이미지 영역을 채울 때 사용하는 32비트 ARGB 색상 값입니다. 기본값은 0xFFFFFFFF(흰색)입니다.
     
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 폭 및/또는 높이가 최대 크기를 초과하는 경우입니다.
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">메서드 세부 정보</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     소스 이미지와 filter 객체를 사용하여 필터링된 이미지를 생성합니다.
     
     <p>이 메서드는 내장 필터 객체의 비헤이비어를 통해 입력 소스 사각형의 영향을 받는 대상 사각형을 결정합니다.</p>
     
     <p>필터링을 거친 후 생성되는 이미지가 원래의 이미지보다 더 클 수도 있습니다. 예를 들어 BlurFilter 클래스를 사용하여 (50,50,100,100)의 소스 사각형 및 (10,10)의 대상 지점을 흐리게 처리하면, 대상 이미지에서 변경된 영역은 흐리게 처리하기 효과 때문에 (10,10,60,60)보다 커집니다. 이 같은 변화는 <code>applyFilter()</code> 호출 과정에서 내부적으로 발생합니다.</p>
     
     <p><code>sourceBitmapData</code> 매개 변수의 <code>sourceRect</code> 매개 변수가 200 x 200 이미지에서 (50,50,100,100)의 경우처럼 내부 영역인 경우, 필터는 <code>sourceRect</code> 매개 변수 외부에서 소스 픽셀을 사용하여 대상 사각형을 생성합니다.</p>
     
     <p>BitmapData 객체와 <code>sourceBitmapData</code> 매개 변수로 지정된 객체가 동일한 객체인 경우, 응용 프로그램에서는 객체의 임시 복사본을 사용하여 필터를 수행합니다. 최상의 성능을 위해 이러한 상황은 피해야 합니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 현재의 BitmapData 인스턴스를 가리킬 수도 있고 혹은 다른 BitmapData 객체가 될 수도 있습니다.

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 소스 사각형의 왼쪽 위 모서리에 해당하는 대상 이미지(현재 BitmapData 인스턴스) 내부의 점입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; 필터링 작업을 수행하는 데 사용할 filter 객체입니다. 다음과 같이 각각의 필터 유형별로 요구 사항이 다릅니다.
     
     <ul><li><b>BlurFilter</b> - 이 필터는 소스 및 대상 이미지로 불투명하거나 투명한 이미지를 사용할 수 있습니다. 두 이미지의 형식이 서로 일치하지 않는 경우, 필터링 과정에서 만들어진 소스 이미지의 복사본은 대상 이미지의 형식과 일치합니다.</li><li><b>BevelFilter, DropShadowFilter, GlowFilter</b> - 이 필터의 대상 이미지는 투명 이미지여야 합니다. DropShadowFilter 또는 GlowFilter를 호출하면 드롭 그림자나 광선에 대한 알파 채널 데이터가 포함된 이미지가 생성됩니다. 대상 이미지 위에 드롭 그림자가 생성되는 것은 아닙니다. 불투명 대상 이미지에서 이 필터 중 하나를 사용하면 예외가 발생합니다.</li><li><b>ConvolutionFilter</b> - 이 필터는 투명한 이미지나 불투명한 이미지 모두 소스 및 대상 이미지로 사용할 수 있습니다.</li><li><b>ColorMatrixFilter</b> - 이 필터는 투명한 이미지나 불투명한 이미지 모두 소스 및 대상 이미지로 사용할 수 있습니다.</li><li><b>DisplacementMapFilter</b> - 이 필터는 소스 및 대상 이미지로 불투명하거나 투명한 이미지를 사용할 수 있지만, 두 이미지의 형식이 동일해야 합니다.</li></ul>
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect, destPoint 또는 filter가 null입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; BitmapData 객체의 투명도가 필터 작업과 호환되지 않습니다.
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 인스턴스에 흐림 필터를 적용하는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     원본 인스턴스를 내포된 비트맵까지 똑같이 복제한 새 BitmapData 객체를 반환합니다.
     
     </p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; 원본과 동일한 새 BitmapData 객체입니다.
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 인스턴스를 복제하는 방법을 보여 주며, 복제된 인스턴스를 수정하더라도 원본은 수정되지 않은 채로 남아 있음을 알 수 있습니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     <code>ColorTransform</code> 객체를 사용하여 비트맵 이미지에서 지정된 영역의 색상 값을 조절합니다. 비트맵 이미지의 경계선과 사각형이 일치하는 경우 이 메서드는 이미지 전체의 색상 값을 변환합니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; ColorTransform 객체가 적용될 이미지 영역을 정의하는 Rectangle 객체입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; 적용할 색상 변환 값을 설명하는 ColorTransform 객체입니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 또는 colorTransform이 null입니다.
      
      </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 객체의 왼쪽 절반 사각형에 색상 변형을 적용하는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     두 BitmapData 객체를 비교합니다. 두 BitmapData 객체의 크기(폭 및 높이)가 같은 경우 메서드는 새 BitmapData 객체를 반환하는데, 이 객체의 각 픽셀은 두 소스 객체의 픽셀 "차이"가 됩니다.
     
     <ul><li>두 픽셀이 동일하면 픽셀 차이는 0x00000000입니다. </li><li>두 픽셀이 서로 다른 RGB 값을 가지면(알파 값 무시) 픽셀 차이는 0xRRGGBB이고 여기서 RR/GG/BB는 빨강, 녹색 및 파랑 채널 각각의 차이 값입니다(소스 객체의 픽셀 값에서 <code>otherBitmapData</code> 객체의 픽셀 값을 뺀 값). 이 경우에는 알파 채널 차이가 무시됩니다. </li><li>알파 채널 값이 서로 다른 경우 픽셀 값은 0x<i>ZZ</i>FFFFFF이고 여기서 <i>ZZ</i>는 알파 값의 차이입니다(소스 객체의 알파 값에서 <code>otherBitmapData</code> 객체의 알파 값을 뺀 값).</li></ul>
     
     <p>예를 들어 다음 두 BitmapData 객체를 생각해 볼 수 있습니다.</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>참고:</b> 두 BitmapData 객체를 채우는 데 사용된 색상은 RGB 값이 약간 다릅니다(0xFF0000과 0xFFAA00). <code>compare()</code> 메서드의 결과는 각 픽셀이 두 비트맵의 RGB 값 차이를 나타내는 새 BitmapData 객체입니다.</p>
     
     <p>다음 두 BitmapData 객체를 생각해 볼 수 있습니다. 여기서 RGB 색상은 동일하지만 알파 값이 다릅니다.</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p><code>compare()</code> 메서드의 결과는 각 픽셀이 두 비트맵의 알파 값 차이를 나타내는 새 BitmapData 객체입니다.</p>
     
     <p>BitmapData 객체가 동일하면(폭, 높이 및 픽셀 값이 같은 경우) 메서드는 숫자 0을 반환합니다.</p>
     
     <p>BitmapData 객체의 폭이 동일하지 않으면 숫자 -3이 반환되고,  </p>
     
     <p>BitmapData 객체의 높이는 동일하지 않지만 폭이 같으면 메서드는 숫자 -4를 반환합니다.</p>
     
     <p>다음 예제에서는 폭이 다른(50과 60) 두 Bitmap 객체를 비교합니다.</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 소스 BitmapData 객체와 비교할 BitmapData 객체입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; 두 BitmapData 객체의 크기(폭 및 높이)가 같은 경우 메서드는 두 객체 간의 차이를 나타내는 새 BitmapData 객체를 반환합니다(주요 설명 부분 참조). BitmapData 객체가 동일한 경우 숫자 0이 반환됩니다. BitmapData 객체의 폭이 동일하지 않으면 숫자 -3이 반환되고, BitmapData 객체의 높이가 동일하지 않으면 -4가 반환됩니다. 
     
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; otherBitmapData가 null입니다.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 크기가 같은 두 BitmapData 객체를 비교한 결과로 생성되는 BitmapData 객체의 픽셀 값을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     현재 BitmapData 객체나 다른 BitmapData 객체의 채널에서 현재 BitmapData 객체의 채널로 데이터를 이전합니다. 대상 BitmapData 객체의 다른 채널에 있는 모든 데이터는 그대로 보존됩니다.
     
     <p>소스 채널 값과 대상 채널 값은 다음 값 가운데 하나가 됩니다. </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 다른 BitmapData 객체가 될 수도 있고 현재 BitmapData 객체를 참조할 수도 있습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 소스 Rectangle 객체입니다. 비트맵 내의 더 작은 영역에서 채널 데이터만 복사하려면 BitmapData 객체의 전체 크기보다 더 작은 소스 사각형을 지정합니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 새 채널 데이터가 위치할 사각형 영역의 왼쪽 위 모서리를 나타내는 대상 Point 객체입니다. 한 영역에서 대상 이미지 내의 다른 영역으로 채널 데이터를 복사하려면 (0,0) 이외의 점을 지정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; 소스 채널입니다. BitmapDataChannel 클래스의 값(<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>)을 사용합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; 대상 채널입니다. BitmapDataChannel 클래스의 값(<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>)을 사용합니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect 또는 destPoint가 null입니다.
      
      </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 20 x 20픽셀 영역에서 BitmapData 객체의 빨강 채널을 같은 객체의 파랑 채널로 복사하는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     연장 효과나 회전 효과 또는 색상 효과 없이 이미지에서 픽셀을 조작할 수 있는 빠른 경로를 제공합니다. 이 메서드는 소스 이미지의 사각형 영역을 대상 BitmapData 객체의 대상 지점에서 같은 크기의 사각형 영역에 복사합니다.
     
     <p><code>alphaBitmap</code> 및 <code>alphaPoint</code> 매개 변수를 포함시키면 복사본 이미지를 소스 이미지의 알파 소스로 사용할 수 있습니다. 소스 이미지가 알파 데이터를 가지고 있는 경우 두 가지 알파 데이터 모두 소스 이미지에서 대상 이미지로 픽셀을 합성하는 데 사용됩니다. <code>alphaPoint</code> 매개 변수는 알파 이미지에서 소스 사각형의 왼쪽 위 모서리에 해당하는 점입니다. 소스 이미지와 알파 이미지의 교점 밖에 있는 픽셀은 대상 이미지로 복사되지 않습니다.</p>
     
     <p><code>mergeAlpha</code> 속성은 투명 이미지를 다른 투명 이미지 위에 복사할 때 알파 채널을 사용할 것인지 여부를 제어합니다. 알파 채널 데이터와 함께 픽셀을 복사하려면 <code>mergeAlpha</code> 속성을 <code>true</code>로 설정합니다. 기본적으로 <code>mergeAlpha</code> 속성은 <code>false</code>입니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 픽셀을 복사해 올 입력 비트맵 이미지입니다. 소스 이미지는 현재의 BitmapData 인스턴스를 참조할 수도 있고 다른 BitmapData 인스턴스가 될 수도 있습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 새 픽셀이 위치할 사각형 영역의 왼쪽 위 모서리를 표시하는 대상 지점입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; 복사본 알파 BitmapData 객체 소스입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; 알파 BitmapData 객체 소스의 점으로서, <code>sourceRect</code> 매개 변수의 왼쪽 위 모서리에 해당됩니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 알파 채널을 사용하려면 값을 <code>true</code>로 설정합니다. 알파 채널을 사용하지 않고 픽셀을 복사하려면 값을 <code>false</code>로 설정합니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect 및 destPoint가 null입니다.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 한 BitmapData 객체의 20 x 20픽셀 영역에서 다른 BitmapData 객체로 픽셀을 복사하는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     픽셀 데이터의 사각형 영역에서 바이트 배열을 채웁니다. 이 메서드는 ByteArray의 <code>position</code> 색인부터 픽셀별로 부호 없는 정수(곱하지 않은 32비트 픽셀 값)를 바이트 배열에 씁니다. 필요한 경우 모든 바이트 배열의 크기가 픽셀 데이터를 유지하는 데 필요한 바이트 수까지 증가합니다.
           
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 현재 BitmapData 객체의 사각형 영역입니다
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 대상 ByteArray 객체입니다.
     
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; <code>rect</code> 인수가 <code>null</code>이거나 <code>data</code> 인수가 <code>null</code>인 경우입니다.
     
	 </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     BitmapData 객체를 저장하는 데 사용된 메모리를 비웁니다. 
     
     <p><code>dispose()</code> 메서드가 호출되면 해당 이미지의 폭과 높이가 0으로 설정됩니다. 이후로 이 BitmapData 인스턴스의 메서드나 속성에 대한 호출은 모두 실패하며 예외가 발생됩니다. </p>
     <p><code>BitmapData.dispose()</code>는 실제 비트맵 데이터가 차지한 메모리를 즉시 해제합니다(하나의 비트맵은 최대 64MB의 메모리를 사용할 수 있음). <code>BitmapData.dispose()</code>를 사용한 후에는 BitmapData 객체를 더 이상 사용할 수 없으므로 BitmapData 객체에 대한 함수를 호출하면 Flash 런타임에서 예외가 발생합니다. 그러나 <code>BitmapData.dispose()</code>는 BitmapData 객체(약 128바이트)를 대상으로 가비지 수집을 수행하지 않습니다. 따라서 실제 BitmapData 객체가 차지한 메모리는 BitmapData 객체가 가비지 수집기에 의해 수집될 때 해제됩니다.</p>
     
     </p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>dispose()</code> 메서드를 호출한 뒤 BitmapData 객체의 메서드를 호출한 결과를 보여 줍니다(예외 발생).
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Flash 런타임 벡터 렌더러를 사용하여 비트맵 이미지에 <code>source</code> 표시 객체를 그립니다. <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> 및 대상 <code>clipRect</code> 매개 변수를 지정하면 렌더링 수행 방식을 제어할 수 있습니다. 또한, 비트맵의 크기를 조절할 때 매끄럽게 할 것인지 여부를 선택적으로 지정할 수 있습니다(소스 객체가 BitmapData 객체인 경우에만 적용됨).
     
     <p><b>참고: </b><code>drawWithQuality()</code> 메서드는 <code>draw()</code> 메서드와 똑같이 작동합니다. 하지만 벡터 렌더링의 품질을 결정하기 위해 <code>Stage.quality</code> 속성을 사용하는 대신, <code>drawWithQuality()</code> 메서드에 대해 <code>quality</code> 매개 변수를 지정합니다.</p>
      
     <p>이 메서드는 제작 도구 인터페이스에서 객체용 표준 벡터 렌더러를 통해 객체가 그려지는 방식과 직접 연관되어 있습니다.</p>
     
     <p>이 메서드를 호출했을 때 소스 표시 객체는 적용된 변환을 전혀 사용하지 않습니다. 행렬 변환이나 색상 변환, 블렌드 모드 없이, 마치 라이브러리나 파일 내에 존재하는 것처럼 취급됩니다. 자체 변환 속성을 사용하여 동영상 클립과 같은 표시 객체를 그리기 위해 BitmapData 객체를 사용하는 Bitmap 객체의 <code>transform</code> 속성에 해당 <code>transform</code> 속성 객체를 복사할 수 있습니다.</p>
     
     <p>이 메서드는 <span>Flash Player 9.0.115.0 이상 및 </span>Adobe AIR의 RTMP에서 지원됩니다. 서버측 스크립트에서 Flash Media Server의 스트림에 대한 액세스를 제어할 수 있습니다. 자세한 내용은 <a href="http://www.adobe.com/go/learn_flash_ss_as_kr" target="external"> <i>Adobe Flash Media Server용 서버 측 ActionScript 언어 참조</i></a>에서 <code>Client.audioSampleAccess</code> 및 <code>Client.videoSampleAccess</code> 속성을 참조하십시오.</p>
     
     <p>source 객체 및 해당하는 모든 자식 객체(Sprite 또는 MovieClip 객체의 경우)가 호출자와 동일한 도메인에서 시작되지 않거나 <code>Security.allowDomain()</code> 메서드를 호출하여 호출자에 액세스할 수 있는 내용에 있지 않은 경우 <code>draw()</code>에 대한 호출은 SecurityError를 발생시킵니다. 이 제한은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.</p>
     
     <p>로드된 비트맵 이미지를 <code>source</code>로 사용할 때에도 제한 사항이 적용됩니다. <code>draw()</code> 메서드에 대한 호출은 로드된 이미지를 호출자와 동일한 도메인에서 가져오는 경우 성공합니다. 또한 이미지의 서버에 있는 크로스 도메인 정책 파일이 <code>draw()</code> 메서드를 호출하는 SWF 내용의 도메인에 권한을 부여할 수 있습니다. 이 경우 LoaderContext 객체의 <code>checkPolicyFile</code> 속성을 설정하고 이미지를 로드하는 데 사용되는 Loader 객체의 <code>load()</code> 메서드를 호출할 때 LoaderContext 객체를 <code>context</code> 매개 변수로 사용해야 합니다. 이러한 제한 사항은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.</p>
     
     <p>Windows에서 <code>draw()</code> 메서드는 <span>Adobe AIR의 HTMLLoader 객체</span>에 있는 HTML 페이지에 포함된 SWF 내용을 캡처할 수 없습니다.</p>
     
     <p><code>draw()</code> 메서드는 <span>Adobe AIR</span>의 PDF 내용을 캡처할 수 없습니다. 또한 이 메서드는 <span>Adobe AIR</span>의 <code>wmode</code> 특성이 <code>"window"</code>로 설정되어 있는 HTML에 포함된 SWF 내용을 캡처할 수 없습니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; BitmapData 객체에 그릴 표시 객체 또는 BitmapData 객체입니다 DisplayObject 및 BitmapData 클래스는 IBitmapDrawable 인터페이스를 구현합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; 비트맵 좌표의 크기 조절, 회전 또는 평행 이동에 사용되는 Matrix 객체입니다. 이미지에 행렬 변환을 적용하지 않으려면 이 매개 변수를 기본 <code>new Matrix()</code> 생성자를 통해 만든 단위 행렬로 설정하거나 <code>null</code> 값으로 설정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; 비트맵의 색상 값 조정에 사용하는 ColorTransform 객체입니다. 제공된 객체가 없으면 비트맵 이미지의 색상이 변환되지 않습니다. 이 매개 변수를 전달하고 이미지는 변환하지 않으려면, 이 매개 변수를 기본 <code>new ColorTransform()</code> 생성자를 통해 만든 ColorTransform 객체로 설정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; flash.display.BlendMode 클래스에서 얻은 문자열 값으로, 결과 비트맵에 적용될 블렌드 모드를 지정합니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 소스 객체에서 그릴 영역을 정의하는 Rectangle 객체입니다. 이 값을 제공하지 않으면 어떤 클리핑도 발생하지 않으며 소스 객체 전체가 그려집니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>matrix</code> 매개 변수의 크기 또는 회전으로 인해 BitmapData 객체의 크기를 조절하거나 회전할 때 매끄럽게 다듬을 것인지 여부를 결정하는 부울 값입니다. <code>smoothing</code> 매개 변수는 <code>source</code> 매개 변수가 BitmapData 객체인 경우에만 적용됩니다. <code>smoothing</code>을 <code>false</code>로 설정하면 회전하거나 크기를 조절한 BitmapData 이미지가 들쭉날쭉한 픽셀로 표시됩니다. 예를 들어 다음 두 이미지가 <code>source</code> 매개 변수에 대해 동일한 BitmapData 객체를 사용하지만, <code>smoothing</code> 매개 변수가 <code>true</code>(왼쪽) 및 <code>false</code>(오른쪽)로 설정됩니다.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="두 개의 이미지, 즉 매끄러움이 설정된 왼쪽 이미지 하나와 매끄러움이 설정되지 않은 오른쪽 이미지 하나입니다."></img></p>
     
     <p>비트맵을 그릴 때 <code>smoothing</code>을 <code>true</code>로 설정하면 <code>smoothing</code>을 <code>false</code>로 설정할 때보다 오래 걸립니다.</p>
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>source</code> 매개 변수가 BitmapData 또는 DisplayObject 객체가 아닙니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; <code>source</code> 객체 및 해당하는 모든 자식 객체(Sprite 또는 MovieClip 객체의 경우)가 호출자와 동일한 도메인에 있지 않거나 호출자가 <code>Security.allowDomain()</code> 메서드를 호출하여 액세스할 수 있는 내용에 있지 않습니다. 이 제한은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 소스가 null이거나 유효한 IBitmapDrawable 객체가 아닙니다.
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 객체에 TextField 객체를 그리는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Flash 런타임 벡터 렌더러를 사용하여 비트맵 이미지에 <code>source</code> 표시 객체를 그립니다. <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> 및 대상 <code>clipRect</code> 매개 변수를 지정하면 렌더링 수행 방식을 제어할 수 있습니다. 또한, 비트맵의 크기를 조절할 때 매끄럽게 할 것인지 여부를 선택적으로 지정할 수 있습니다(소스 객체가 BitmapData 객체인 경우에만 적용됨).
     
     <p><b>참고: </b><code>drawWithQuality()</code> 메서드는 <code>draw()</code> 메서드와 똑같이 작동합니다. 하지만 벡터 렌더링의 품질을 결정하기 위해 <code>Stage.quality</code> 속성을 사용하는 대신, <code>drawWithQuality()</code> 메서드에 대해 <code>quality</code> 매개 변수를 지정합니다.</p>
      
     <p>이 메서드는 제작 도구 인터페이스에서 객체용 표준 벡터 렌더러를 통해 객체가 그려지는 방식과 직접 연관되어 있습니다.</p>
     
     <p>이 메서드를 호출했을 때 소스 표시 객체는 적용된 변환을 전혀 사용하지 않습니다. 행렬 변환이나 색상 변환, 블렌드 모드 없이, 마치 라이브러리나 파일 내에 존재하는 것처럼 취급됩니다. 자체 변환 속성을 사용하여 동영상 클립과 같은 표시 객체를 그리기 위해 BitmapData 객체를 사용하는 Bitmap 객체의 <code>transform</code> 속성에 해당 <code>transform</code> 속성 객체를 복사할 수 있습니다.</p>
     
     <p>이 메서드는 <span>Flash Player 9.0.115.0 이상 및 </span>Adobe AIR의 RTMP에서 지원됩니다. 서버측 스크립트에서 Flash Media Server의 스트림에 대한 액세스를 제어할 수 있습니다. 자세한 내용은 <code>Client.audioSampleAccess</code> 및 <code>Client.videoSampleAccess</code> 속성(<a href="http://www.adobe.com/go/documentation_kr" target="external"><i>Adobe Flash Media Server용 서버측 ActionScript 언어 참조 설명서</i></a>)을 참조하십시오.</p>
     
     <p>source 객체 및 해당하는 모든 자식 객체(Sprite 또는 MovieClip 객체의 경우)가 호출자와 동일한 도메인에 속해 있거나, <code>Security.allowDomain()</code> 메서드를 호출하여 호출자에 액세스할 수 있는 내용에 있지 않은 경우 <code>drawWithQuality()</code>를 호출하면 SecurityError 예외가 발생합니다. 이 제한은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.</p>
     
     <p>로드된 비트맵 이미지를 <code>source</code>로 사용할 때에도 제한 사항이 적용됩니다. 로드된 이미지가 호출자와 동일한 도메인에 속해 있으면 <code>drawWithQuality()</code> 메서드를 호출할 수 있습니다. 또한 이미지의 서버에 있는 크로스 도메인 정책 파일은 <code>drawWithQuality()</code> 메서드를 호출하는 SWF 내용의 도메인에 대한 권한을 부여할 수 있습니다. 이 경우 LoaderContext 객체의 <code>checkPolicyFile</code> 속성을 설정하고 이미지를 로드하는 데 사용되는 Loader 객체의 <code>load()</code> 메서드를 호출할 때 LoaderContext 객체를 <code>context</code> 매개 변수로 사용해야 합니다. 이러한 제한 사항은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.</p>
     
     <p>Windows에서 <code>drawWithQuality()</code> 메서드는 <span>Adobe AIR의 HTMLLoader 객체</span>에 있는 HTML 페이지에 포함된 SWF 내용을 캡처할 수 없습니다.</p>
     
     <p><code>drawWithQuality()</code> 메서드는 <span>Adobe AIR</span>의 PDF 내용을 캡처할 수 없습니다. 또한 이 메서드는 <span>Adobe AIR</span>의 <code>wmode</code> 특성이 <code>"window"</code>로 설정되어 있는 HTML에 포함된 SWF 내용을 캡처할 수 없습니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; BitmapData 객체에 그릴 표시 객체 또는 BitmapData 객체입니다 DisplayObject 및 BitmapData 클래스는 IBitmapDrawable 인터페이스를 구현합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; 비트맵 좌표의 크기 조절, 회전 또는 평행 이동에 사용되는 Matrix 객체입니다. 이미지에 행렬 변환을 적용하지 않으려면 이 매개 변수를 기본 <code>new Matrix()</code> 생성자를 통해 만든 단위 행렬로 설정하거나 <code>null</code> 값으로 설정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; 비트맵의 색상 값 조정에 사용하는 ColorTransform 객체입니다. 제공된 객체가 없으면 비트맵 이미지의 색상이 변환되지 않습니다. 이 매개 변수를 전달하고 이미지는 변환하지 않으려면, 이 매개 변수를 기본 <code>new ColorTransform()</code> 생성자를 통해 만든 ColorTransform 객체로 설정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; flash.display.BlendMode 클래스에서 얻은 문자열 값으로, 결과 비트맵에 적용될 블렌드 모드를 지정합니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 소스 객체에서 그릴 영역을 정의하는 Rectangle 객체입니다. 이 값을 제공하지 않으면 어떤 클리핑도 발생하지 않으며 소스 객체 전체가 그려집니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>matrix</code> 매개 변수의 크기 또는 회전으로 인해 BitmapData 객체의 크기를 조절하거나 회전할 때 매끄럽게 다듬을 것인지 여부를 결정하는 부울 값입니다. <code>smoothing</code> 매개 변수는 <code>source</code> 매개 변수가 BitmapData 객체인 경우에만 적용됩니다. <code>smoothing</code>을 <code>false</code>로 설정하면 회전하거나 크기를 조절한 BitmapData 이미지가 들쭉날쭉한 픽셀로 표시됩니다. 예를 들어 다음 두 이미지가 <code>source</code> 매개 변수에 대해 동일한 BitmapData 객체를 사용하지만, <code>smoothing</code> 매개 변수가 <code>true</code>(왼쪽) 및 <code>false</code>(오른쪽)로 설정됩니다.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="두 개의 이미지, 즉 매끄러움이 설정된 왼쪽 이미지 하나와 매끄러움이 설정되지 않은 오른쪽 이미지 하나입니다."></img></p>
     
     <p>비트맵을 그릴 때 <code>smoothing</code>을 <code>true</code>로 설정하면 <code>smoothing</code>을 <code>false</code>로 설정할 때보다 오래 걸립니다.</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; StageQuality 값 중 하나입니다. 벡터 그래픽을 그릴 때 사용할 앤티앨리어싱 품질을 선택합니다. 
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>source</code> 매개 변수가 BitmapData 또는 DisplayObject 객체가 아닙니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; <code>source</code> 객체 및 해당하는 모든 자식 객체(Sprite 또는 MovieClip 객체의 경우)가 호출자와 동일한 도메인에 있지 않거나 호출자가 <code>Security.allowDomain()</code> 메서드를 호출하여 액세스할 수 있는 내용에 있지 않습니다. 이 제한은 응용 프로그램 보안 샌드박스의 AIR 내용에 적용되지 않습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 소스가 null이거나 유효한 IBitmapDrawable 객체가 아닙니다.
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 객체에 TextField 객체를 그리는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     선택한 압축 알고리즘을 사용하여 이 BitmapData 객체를 압축하고 새 ByteArray 객체를 반환합니다. 지정된 ByteArray에 결과 데이터를 쓸 수도 있습니다. <code>compressor</code> 인수는 인코딩 알고리즘을 지정하며, PNGEncoderOptions, JPEGEncoderOptions 또는 JPEGXREncoderOptions일 수 있습니다.
     
     <p>다음 예제에서는 JPEGEncoderOptions를 사용하여 BitmapData 객체를 압축합니다.</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 압축할 BitmapData 객체의 영역입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; 사용할 압축기 유형입니다. 사용할 수 있는 값은 다음과 같습니다. <code>flash.display.PNGEncoderOptions</code>, <code>flash.display.JPEGEncoderOptions</code> 및 <code>flash.display.JPEGXREncoderOptions</code>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; 인코딩된 이미지를 유지할 출력 ByteArray입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 인코딩된 이미지를 포함하는 ByteArray입니다. 
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     사각형의 픽셀 영역을 지정된 ARGB 색상으로 채웁니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 채울 사각형 영역입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 영역을 채울 ARGB 색상 값입니다. ARGB 색상은 0xFF336699 등과 같이 16진수 형식으로 지정되는 경우가 많습니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect가 null입니다.
      
      </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 객체의 사각형 영역을 파랑으로 채우는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     (<i>x</i>, <i>y</i>) 좌표에서 시작하는 이미지에 색상 채우기 작업을 수행하여 특정 색상으로 채웁니다. <code>floodFill()</code> 메서드는 다양한 페인팅 프로그램에서 제공하는 페인트 통 도구와 유사합니다. 색상은 알파 정보와 색상 정보가 포함된 ARGB 색상입니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 이미지의 <i>x</i> 좌표입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 이미지의 <i>y</i> 좌표입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 채우기에 사용할 ARGB 색상입니다.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 BitmapData 객체의 영역, 즉 점 <code>(10, 10)</code>에 의해 정의된 픽셀을 둘러싸며 모든 색상이 해당 점의 색상과 일치하는 영역을 빨강으로 채우는 방법을 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     지정된 BitmapData 객체와 소스 사각형 및 필터 객체를 기준으로 <code>applyFilter()</code> 메서드 호출이 적용될 대상 사각형을 결정합니다.
     
     <p>예를 들어 흐리게 처리하기 필터가 적용되는 영역의 크기는 원본 이미지의 크기보다 더 큽니다. 기본 BlurFilter 인스턴스(<code>blurX = blurY = 4</code>)를 통해 필터링되는 100 x 200픽셀 이미지는 <code>(-2,-2,104,204)</code>의 대상 사각형을 생성합니다. <code>generateFilterRect()</code> 메서드를 사용하면 이처럼 대상 사각형의 크기를 미리 확인할 수 있으므로 필터 작업 전에 대상 이미지의 크기를 적절히 조절할 수 있습니다.</p>
     
     <p>일부 필터는 소스 이미지의 크기를 기준으로 대상 사각형을 자릅니다. 예를 들어 내부 <code>DropShadow</code>를 사용하는 경우에는 소스 이미지보다 더 큰 이미지가 생성되지 않습니다. 이 API에서는 소스 <code>rect</code> 매개 변수가 아니라 BitmapData 객체를 소스 경계로 사용합니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; 대상 사각형을 계산하는 데 사용할 필터 객체입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 이미지, <code>sourceRect</code> 매개 변수 및 필터를 사용하여 계산된 대상 사각형입니다.
     
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceRect 또는 필터가 null입니다.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>generateFilterRect()</code> 메서드를 사용하여 흐림 필터 결과가 차지할 사각형 영역을 결정하는 방법을 보여 줍니다. <code>generateFilterRect()</code> 메서드의 결과는 <code>trace()</code> 함수에 의해 출력됩니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> <code>generateFilterRect()</code> 메서드는 필터를 적용하지 않습니다. 필터를 적용하려면 <code>applyFilter()</code> 메서드를 호출합니다. 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     비트맵 이미지 내에서 지정된 색상의 픽셀 전체를 완전히 감싸는 사각형 영역(<code>findColor</code> 매개 변수가 <code>true</code>로 설정된 경우) 또는 지정된 색상을 포함하지 않는 픽셀 전체를 완전히 감싸는 사각형 영역(<code>findColor</code> 매개 변수가 <code>false</code>로 설정된 경우)을 결정합니다. 
     
     <p>예를 들어 소스 이미지에서 0이 아닌 알파 채널을 포함하는 사각형 이미지를 확인하려는 경우, <code>{mask: 0xFF000000, color: 0x00000000}</code>을 매개 변수로 전달합니다. <code>findColor</code> 매개 변수가 <code>true</code>로 설정된 경우 <code>(value & mask) == color</code>인 픽셀의 경계를 전체 이미지에서 검색합니다. 여기서 <code>value</code>는 픽셀의 색상 값입니다. <code>findColor</code> 매개 변수가 <code>false</code>로 설정된 경우 <code>(value & mask) != color</code>인 픽셀의 경계를 전체 이미지에서 검색합니다(여기서 <code>value</code>는 픽셀의 색상 값). 이미지 주위의 여백 공간을 확인하려면 <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code>를 전달하여 흰색이 아닌 픽셀의 경계를 찾습니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; 고려할 ARGB 색상 비트 수를 지정하는 16진수 값입니다. 색상 값은 <code>&</code>(bitwise AND) 연산자를 사용하여 이 16진수 값과 결합됩니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 일치시키거나(<code>findColor</code>가 <code>true</code>로 설정된 경우) 일치시키지 <i>않을</i>(<code>findColor</code>가 <code>false</code>로 설정된 경우) ARGB 색상을 지정하는 16진수 값입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; 값이 <code>true</code>로 설정된 경우 이미지에서 색상 값의 경계를 반환합니다. <code>false</code>로 설정된 경우에는 이미지에서 이 색상이 존재하지 않는 영역의 경계를 반환합니다. 
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 지정된 색상으로 구성된 이미지 영역입니다. 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 픽셀의 위 절반이 빨간색인 BitmapData 객체를 만듭니다. 그런 다음 <code>getColorBoundsRect()</code> 메서드를 호출하여 픽셀이 빨간색(0xFF0000)인 사각형을 확인하고, 동일한 메서드를 호출하여 픽셀이 빨간색이 아닌(<code>findColor</code> 매개 변수를 <code>false</code>로 설정) 사각형을 확인합니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     특정 지점(<i>x</i>, <i>y</i>)에서 BitmapData 객체의 RGB 픽셀 값을 나타내는 정수를 반환합니다. <code>getPixel()</code> 메서드는 곱하지 않은 픽셀 값을 반환합니다. 알파 정보는 반환되지 않습니다.
     
     <p>BitmapData 객체에 포함된 모든 픽셀은 미리 곱해진 색상 값으로 저장됩니다. 미리 곱해진 이미지 픽셀은 알파 데이터가 이미 곱해진 RGB(빨강, 녹색, 파랑) 색상 채널 값을 갖습니다. 예를 들어 알파 값이 0인 경우 RGB 채널 값도 곱해지지 않은 값에 상관없이 0이 됩니다. 이와 같은 데이터 손실로 인해 작업을 수행할 때 몇 가지 문제가 발생할 수 있습니다. 모든 BitmapData 메서드는 곱하지 않은 값을 사용하고 반환합니다. 내부 픽셀 표현은 미리 곱한 값을 곱하지 않은 값으로 변환한 이후에 값으로 반환됩니다. 픽셀 값은 설정 작업에서 원시 이미지 픽셀을 설정하기 전에 미리 곱해집니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 픽셀의 <i>x</i> 위치입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 픽셀의 <i>y</i> 위치입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; RGB 픽셀 값을 나타내는 숫자입니다. (<i>x</i>, <i>y</i>) 좌표가 이미지의 경계를 벗어난 경우 0이 반환됩니다. 
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 빨강으로 채워진 BitmapData 객체를 만든 다음 <code>getPixel()</code> 메서드를 사용하여 왼쪽 위 픽셀의 색상 값을 결정합니다.
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     알파 채널 데이터와 RGB 데이터를 포함하는 ARGB 색상 값을 반환합니다. 이 메서드는 알파 채널 데이터 없이 RGB 색상을 반환하는 <code>getPixel()</code> 메서드와 유사합니다.
     
     <p>BitmapData 객체에 포함된 모든 픽셀은 미리 곱해진 색상 값으로 저장됩니다. 미리 곱해진 이미지 픽셀은 알파 데이터가 이미 곱해진 RGB(빨강, 녹색, 파랑) 색상 채널 값을 갖습니다. 예를 들어 알파 값이 0인 경우 RGB 채널 값도 곱해지지 않은 값에 상관없이 0이 됩니다. 이와 같은 데이터 손실로 인해 작업을 수행할 때 몇 가지 문제가 발생할 수 있습니다. 모든 BitmapData 메서드는 곱하지 않은 값을 사용하고 반환합니다. 내부 픽셀 표현은 미리 곱한 값을 곱하지 않은 값으로 변환한 이후에 값으로 반환됩니다. 픽셀 값은 설정 작업에서 원시 이미지 픽셀을 설정하기 전에 미리 곱해집니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 픽셀의 <i>x</i> 위치입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 픽셀의 <i>y</i> 위치입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; ARGB 픽셀 값을 나타내는 숫자입니다. (<i>x</i>, <i>y</i>) 좌표가 이미지 경계를 벗어난 경우 0이 반환됩니다.
     
     </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 색상으로 채워진 BitmapData 객체를 만든 다음 <code>getPixel32()</code> 메서드를 사용하여 왼쪽 위 픽셀의 색상 값을 결정하고 각 색상 구성 요소(알파, 빨강, 녹색 및 파랑)의 16진수 값을 결정합니다.
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     픽셀 데이터의 사각형 영역에서 바이트 배열을 생성합니다. 픽셀별로 부호 없는 정수(곱하지 않은 32비트 픽셀 값)를 바이트 배열에 씁니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 현재 BitmapData 객체의 사각형 영역입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 해당 Rectangle의 픽셀을 나타내는 ByteArray입니다.
     
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect가 null입니다.
      
      </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 임의 노이즈 픽셀로 채워진 BitmapData 객체를 만든 다음 <code>getPixels()</code> 메서드를 사용하여 ByteArray 객체를 BitmapData 객체의 픽셀 값으로 채웁니다.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     픽셀 데이터의 사각형 영역에서 벡터 배열을 생성합니다. 지정된 사각형에 대한 부호 없는 정수(곱하지 않는 32비트 픽셀 값)의 Vector 객체를 반환합니다.
     
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 현재 BitmapData 객체의 사각형 영역입니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; 해당 Rectangle을 나타내는 Vector입니다.
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect가 null입니다.
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     BitmapData 객체의 256 값 이진 숫자 막대 그래프를 계산합니다. 이 메서드는 네 개의 Vector.&lt;Number> 인스턴스(Number 객체를 포함하는 네 개의 Vector 객체)를 포함하는 Vector 객체를 반환합니다. 네 개의 Vector 인스턴스는 순서대로 빨강, 녹색, 파랑 및 알파 구성 요소를 나타냅니다. 각 Vector 인스턴스에는 개별 구성 요소 값의 채우기 수를 나타내는 256개의 값(0에서 255까지)이 포함되어 있습니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 사용할 BitmapData 객체의 영역입니다.
      
      </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     하나의 비트맵 이미지와 특정한 점, 사각형 또는 다른 비트맵 이미지 간의 픽셀 수준 히트 감지를 수행합니다. 히트는 점이나 사각형이 불투명 픽셀 위에 겹치거나 두 불투명 픽셀이 서로 겹치는 것으로 정의됩니다. 히트 테스트를 수행할 때 어느 한 객체의 확장이나 회전 또는 기타 변환은 고려하지 않습니다. 
     
     <p>불투명 이미지의 경우 이 메서드에서는 완전 불투명 사각형으로 간주됩니다. 투명도를 고려하는 픽셀 수준의 히트 테스트를 수행하려면 두 개의 이미지 모두 투명 이미지라야 합니다. 두 개의 투명 이미지를 테스트할 때 알파 임계값 매개 변수는 0에서 255 사이 범위에서 어떤 알파 채널 값이 불투명으로 간주되는지 제어합니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  임의의 좌표 영역에서 BitmapData 이미지의 왼쪽 위 모서리 위치입니다. 동일한 좌표 공간이 <code>secondBitmapPoint</code> 매개 변수를 정의하는 데 사용됩니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; 이 히트 테스트에서 불투명으로 간주되는 최소 알파 채널 값입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Rectangle, Point, Bitmap 또는 BitmapData 객체입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; 두 번째 BitmapData 객체에서 픽셀 위치를 정의하는 점입니다. <code>secondObject</code> 값이 BitmapData 객체일 때만 이 매개 변수를 사용합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; 두 번째 BitmapData 객체에서 불투명으로 간주되는 최소 알파 채널 값입니다. <code>secondObject</code> 값이 BitmapData 객체이고 두 BitmapData 객체가 모두 투명 객체일 때만 이 매개 변수를 사용합니다.
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; 히트가 발생하면 값이 <code>true</code>이고, 그렇지 않으면 <code>false</code>입니다.
        
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>secondObject</code> 매개 변수가 Point, Rectangle, Bitmap 또는 BitmapData 객체가 아닙니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; firstPoint가 null입니다.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 사각형 영역(20, 20, 40, 40)에서만 불투명한 BitmapData 객체를 만들고, Point 객체를 <code>secondObject</code>로 삼아 <code>hitTest()</code> 메서드를 호출합니다. 첫 번째 호출에서 Point 객체는 BitmapData 객체의 왼쪽 위 모서리(투명)를 정의하고, 두 번째 호출에서 Point 객체는 BitmapData 객체의 가운데(불투명)를 정의합니다.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     이 BitmapData 객체를 변경할 때 BitmapData 객체를 참조하는 어떤 객체(예: Bitmap 객체)도 업데이트되지 않도록 이미지를 잠급니다. 성능을 높이려면 <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 여러 차례 호출하기 전후에 이 메서드를 <code>unlock()</code> 메서드와 함께 사용합니다.
     
     </p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 Bitmap 객체 <code>picture</code>의 <code>bitmapData</code> 속성을 기반으로 BitmapData 객체를 만듭니다. 그리고 나서 <code>lock()</code> 메서드를 호출한 다음 BitmapData 객체를 수정하는 복잡한 사용자 정의 함수인 <code>complexTransformation()</code>을 호출합니다. <code>picture</code> 객체 및 <code>complexTransformation()</code> 함수는 이 예제에서 정의하지 않습니다. <code>complexTransformation()</code> 함수가 <code>picture</code> 객체의 <code>bitmapData</code> 속성을 업데이트하더라도 코드가 <code>bitmapData</code> 객체에서 <code>unlock()</code> 메서드를 호출하기 전까지는 변경 사항이 반영되지 않습니다.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     소스 이미지에서 대상 이미지로 채널별 블렌드를 수행합니다. 각 채널과 픽셀에 대해 소스 및 대상 픽셀의 채널 값에 따라 새 값이 계산됩니다. 예를 들어 빨강 채널에서 다음과 같은 새 값이 계산됩니다. 여기서 <code>redSrc</code>는 소스 이미지의 픽셀에 대한 빨강 채널 값이고 <code>redDest</code>는 대상 이미지의 해당 픽셀에 대한 빨강 채널 값입니다. 
     <p>
     <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p><code>redMultiplier</code>, <code>greenMultiplier</code>, <code>blueMultiplier</code> 및 <code>alphaMultiplier</code> 값은 각 색상 채널에 사용된 승수입니다. <code>0</code> ~ <code>0x100</code>(256) 범위의 16진수 값을 사용하며 여기서 <code>0</code>은 대상의 전체 값이 결과에서 사용됨을 지정하고, <code>0x100</code>은 소스의 전체 값이 사용됨을 지정하며, 사이의 숫자는 블렌드가 사용됨을 지정합니다(예: 50%의 경우 <code>0x80</code>).</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 다른 BitmapData 객체가 될 수도 있고 현재 BitmapData 객체를 참조할 수도 있습니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 소스 사각형의 왼쪽 위 모서리에 해당하는 대상 이미지(현재 BitmapData 인스턴스) 내부의 점입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 빨강 채널 값을 곱하는 16진수 단위 값입니다. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 녹색 채널 값을 곱하는 16진수 단위 값입니다. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 파랑 채널 값을 곱하는 16진수 단위 값입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; 알파 투명도 값을 곱하는 16진수 단위 값입니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect 또는 destPoint가 null입니다.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 두 개의 BitmapData 객체를 만듭니다. 두 객체 모두 크기가 100 x 80픽셀입니다. 첫 번째 객체는 녹색으로, 두 번째 객체는 빨간색으로 채워집니다. 이 코드는 <code>merge()</code> 메서드를 호출하여 지정된 사각형 영역에 한해 두 번째 BitmapData 픽셀을 첫 번째 BitmapData 객체에 병합합니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     임의의 노이즈를 나타내는 픽셀로 이미지를 채웁니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; 사용할 난수 초기값입니다. 다른 매개 변수가 모두 동일할 경우 난수 초기값을 변경하면 다양한 의사 난수 결과를 얻을 수 있습니다. 노이즈 함수는 진정한 의미의 난수 생성 함수가 아니라 매핑 함수이기 때문에 같은 난수 초기값을 입력하면 매번 같은 결과가 나옵니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 각 채널에 대해 생성할 최저 값입니다(0 ~ 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 각 채널에 대해 생성할 최고 값입니다(0 ~ 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; 네 가지 색상 채널 값(<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> 및 <code>BitmapDataChannel.ALPHA</code>)을 임의로 결합한 숫자입니다. logical OR 연산자(<code>|</code>)를 사용하여 채널 값을 결합할 수 있습니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 부울 값. 값이 <code>true</code>인 경우 모든 색상 채널 값을 동일하게 설정하여 회색 음영 이미지를 만듭니다. 이 매개 변수를 <code>true</code>로 설정해도 알파 채널 선택에는 영향을 미치지 않습니다. 
     
     </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 두 개의 BitmapData 객체를 만들고 양쪽 모두에서 <code>noise()</code> 메서드를 호출합니다. 그러나 첫 번째 객체의 <code>noise()</code> 메서드를 호출할 때는 <code>grayscale</code> 매개 변수를 <code>false</code>로 설정하고 두 번째 객체의 <code>noise()</code> 메서드를 호출할 때는 이 매개 변수를 <code>true</code>로 설정합니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     각 채널에 하나씩 최대 네 개까지의 색상 팔레트 데이터 배열이 있는 이미지에서 색상 채널 값을 다시 매핑합니다. 
     
     <p>Flash 런타임에서는 다음 단계를 사용하여 결과 이미지를 생성합니다.</p>
     
     <ol><li>빨강, 녹색, 파랑 및 알파 값을 계산한 후, 표준 32비트 정수 계산법을 사용하여 그 값들을 모두 더합니다. </li><li>각 픽셀의 빨강, 녹색, 파랑 및 알파 채널 값을 각각 0에서 255 사이의 값으로 추출합니다. 이러한 값을 사용하여 새 색상 값을 <code>redArray</code>, <code>greenArray</code>, <code>blueArray</code>, <code>alphaArray</code> 등의 적절한 배열로 조회합니다. 이와 같은 네 개의 배열에는 각각 256 값이 포함되어야 합니다. </li><li>네 개의 새 채널 값이 모두 검색되면 채널 값을 결합하여 픽셀에 적용할 하나의 표준 ARGB 값으로 만듭니다.</li></ol>
     
     <p>이 메서드에서는 채널 간 효과를 지원할 수 있습니다. 각각의 입력 배열은 32비트 값을 포함할 수 있고 값을 서로 더할 때 이동은 없습니다. 이 루틴은 채널별 고정은 지원하지 않습니다. </p>
     
     <p>채널에 대해 지정된 배열이 없으면 소스 이미지에서 대상 이미지로 색상 채널이 복사됩니다.</p>
     
     <p>이 메서드는 일반 팔레트 매핑(채널 하나를 택해 이를 false 색상 이미지로 변환하는 방법) 등과 같은 다양한 효과에 활용할 수 있습니다. 감마, 커브, 레벨, 양자화와 같은 다양한 고급 색상 조작 알고리즘에도 이 메서드를 사용할 수 있습니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 다른 BitmapData 객체일 수도 있고 현재 BitmapData 인스턴스를 참조할 수도 있습니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 소스 사각형의 왼쪽 위 모서리에 해당하는 대상 이미지(현재 BitmapData 객체) 내부의 점입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; <code>redArray</code>가 <code>null</code>이 아닌 경우 <code>red = redArray[source red value] else red = source rect value</code>입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; <code>greenArray</code>가 <code>null</code>이 아닌 경우 <code>green = greenArray[source green value] else green = source green value.</code>입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; <code>blueArray</code>가 <code>null</code>이 아닌 경우 <code>blue = blueArray[source blue value] else blue = source blue value</code>입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; <code>alphaArray</code>가 <code>null</code>이 아닌 경우 <code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>입니다.
     
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect 또는 destPoint가 null입니다.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 빨간색 사각형이 가운데에 있는 녹색 BitmapData 객체를 만든 다음 <code>paletteMap()</code> 메서드를 사용하여 BitmapData 객체 사각형의 아래쪽 절반을 빨간색에서 녹색으로 교체합니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Perlin 노이즈 이미지를 생성합니다.
     
     <p>Perlin 노이즈 생성 알고리즘은 옥타브라는 개별 임의의 노이즈 함수를 보다 자연스럽게 보이는 임의의 노이즈를 발생시키는 단일 함수에 삽입하고 결합합니다. 음악의 옥타브와 마찬가지로 각 옥타브 함수의 진동수는 선행 옥타브 함수의 두 배가 됩니다. Perlin 노이즈는 세부 정도가 서로 다른 다양한 노이즈 데이터 세트를 결합하기 때문에 "노이즈의 프랙탈 합"으로 설명되었습니다.</p>
     
     <p>Perlin 노이즈 함수는 나뭇결, 구름, 산맥 등과 같은 자연 현상이나 풍경을 시뮬레이션하는 데 사용할 수 있습니다. 대부분의 경우 Perlin 노이즈 함수의 결과는 직접 표시되지는 않지만 다른 이미지를 개선하고 의사 난수 변형을 제공하는 데 사용됩니다.</p>
     
     <p>단순한 디지털 노이즈 함수는 거칠고 대비가 심한 이미지를 생성합니다. 자연에서는 이와 같이 거친 대비를 좀처럼 찾아보기 어렵습니다. Perlin 노이즈 알고리즘은 서로 다른 세부 레벨에서 작동하는 여러 노이즈 함수를 혼합합니다. 이 알고리즘을 사용하면 인접한 픽셀 값 간의 차이가 작아집니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; <i>x</i> 방향에서 사용할 진동수입니다. 예를 들어 64 x 128 이미지에 맞는 크기의 노이즈를 생성하려면 <code>baseX</code> 값에 64를 전달해야 합니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; <i>y</i> 방향에서 사용할 진동수입니다. 예를 들어 64 x 128 이미지에 맞는 크기의 노이즈를 생성하려면 <code>baseY</code> 값에 128을 전달해야 합니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; 이 노이즈를 만들기 위해 결합할 옥타브, 즉 개별 노이즈 함수의 수입니다. 옥타브의 수가 많아질수록 보다 상세한 이미지가 만들어집니다. 또한 옥타브의 수가 많아질수록 처리 시간도 더 많이 소요됩니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; 사용할 난수 초기값입니다. 다른 매개 변수가 모두 동일할 경우 난수 초기값을 변경하면 다양한 의사 난수 결과를 얻을 수 있습니다. Perlin 노이즈 함수는 진정한 의미의 난수 생성 함수가 아니라 매핑 함수이기 때문에 같은 난수 초기값을 입력하면 같은 결과가 생성됩니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 부울 값. 값이 <code>true</code>이면 이 메서드는 비트맵 채우기 작업 시 매끄러운 경사면 질감을 만들어내기 위해 이미지의 가장자리를 부드럽게 다듬고자 시도합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 부울 값. 값이 <code>true</code>이면 이 메서드는 프랙탈 노이즈를 생성하고, 그렇지 않으면 휘몰아치기를 생성합니다. 휘몰아치기가 포함된 이미지는 그래디언트에서 불연속 선이 드러나기 때문에 불꽃과 파도와 같은 날카로운 시각적 효과를 만드는 데 적합합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  네 가지 색상 채널 값(<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code> 및 <code>BitmapDataChannel.ALPHA</code>)을 임의로 결합한 숫자입니다. logical OR 연산자(<code>|</code>)를 사용하여 채널 값을 결합할 수 있습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 부울 값. 값이 <code>true</code>이면 빨강, 녹색 및 파랑 색상 채널을 모두 같은 값으로 설정하여 회색 음영 이미지를 생성합니다. 이 값을 <code>true</code>로 설정해도 알파 채널 값에는 영향을 미치지 않습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; 각 옥타브의 <i>x</i> 및 <i>y</i> 오프셋에 해당하는 점 배열입니다. 오프셋 값을 조작하면 perlinNoise 이미지 레이어를 부드럽게 스크롤할 수 있습니다. 오프셋 배열의 각 점은 특정 옥타브 노이즈 함수에 영향을 미칩니다.
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>perlinNoise()</code> 메서드를 호출하여 빨강 및 파랑 수채화 효과를 생성하는 200 x 200픽셀의 BitmapData 객체를 만듭니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     소스 이미지에서 대상 이미지로, 혹은 같은 이미지를 사용하여 픽셀 디졸브(dissolve)를 수행합니다. Flash 런타임에서는 <code>randomSeed</code> 값을 사용하여 임의의 픽셀 디졸브를 생성합니다. 픽셀 디졸브가 완료될 때까지 해제를 지속하기 위해서는 함수의 반환 값을 다음 호출에서 전달해야 합니다.
     
     <p>소스 이미지가 대상 이미지와 일치하지 않는 경우, 모든 속성을 그대로 사용하여 소스에서 대상으로 픽셀이 복사됩니다. 이 과정에서 빈 이미지에서 가득찬 이미지로 디졸브가 가능합니다.</p>
     
     <p>소스 이미지와 대상 이미지가 일치하는 경우에는 <code>color</code> 매개 변수 값으로 픽셀이 채워집니다. 이를 통해 가득찬 이미지를 디졸브해서 지울 수 있습니다. 이 경우 대상 <code>point</code> 매개 변수는 무시됩니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 다른 BitmapData 객체일 수도 있고 현재 BitmapData 인스턴스를 참조할 수도 있습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 소스 사각형의 왼쪽 위 모서리에 해당하는 대상 이미지(현재 BitmapData 인스턴스) 내부의 점입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 픽셀 디졸브를 시작하는 데 사용할 난수 초기값입니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 기본값은 소스 영역(폭 x 높이)의 1/30입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 소스 값이 대상 값과 동일한 픽셀을 채우는 데 사용할 ARGB 색상 값입니다. 
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; 후속 호출에 사용할 새 난수 초기값입니다.
     
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect 또는 destPoint가 null입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; numPixels 값이 음수입니다.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>pixelDissolve()</code> 메서드를 통해 픽셀의 색상이 모두 변경될 때까지 한 번에 40픽셀씩 디졸브하여 회색 BitmapData 객체를 빨강 객체로 변환합니다.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     이미지를 특정 픽셀 수(<i>x</i>, <i>y</i>)만큼 스크롤합니다. 스크롤 영역 밖의 가장자리 영역은 변하지 않습니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 가로 방향으로 스크롤할 크기입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 세로 방향으로 스크롤할 크기입니다.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 비트맵 데이터 객체를 오른쪽으로 40픽셀 스크롤한 결과를 보여 줍니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     BitmapData 객체의 단일 픽셀을 설정합니다. 이 작업이 이루어지는 동안 이미지 픽셀의 현재 알파 채널 값은 그대로 보존됩니다. RGB color 매개 변수 값은 곱해지지 않은 색상 값으로 취급됩니다.
     
     <p><b>참고:</b> <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 반복해서 사용할 때 성능을 향상시키려면 <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 호출하기 전에 <code>lock()</code> 메서드를 호출하고, 픽셀 변경을 모두 마치고 나면 <code>unlock()</code> 메서드를 호출합니다. 이 프로세스는 픽셀 변경을 모두 마치기 전까지 이 BitmapData 인스턴스를 참조하는 객체가 업데이트되지 않도록 합니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 값이 변경되는 픽셀의 <i>x</i> 위치입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 값이 변경되는 픽셀의 <i>y</i> 위치입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 픽셀의 최종 RGB 색상입니다. 
     
     </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>setPixel()</code> 메서드를 사용하여 BitmapData 객체에 빨간색 선을 그립니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     BitmapData 객체의 단일 픽셀에 대한 색상 및 알파 투명도 값을 설정합니다. 이 메서드는 <code>setPixel()</code> 메서드와 유사하지만, <code>setPixel32()</code> 메서드의 경우 알파 채널 정보가 포함된 ARGB 색상 값을 사용한다는 점이 다릅니다.
     
     <p>BitmapData 객체에 포함된 모든 픽셀은 미리 곱해진 색상 값으로 저장됩니다. 미리 곱해진 이미지 픽셀은 알파 데이터가 이미 곱해진 RGB(빨강, 녹색, 파랑) 색상 채널 값을 갖습니다. 예를 들어 알파 값이 0인 경우 RGB 채널 값도 곱해지지 않은 값에 상관없이 0이 됩니다. 이와 같은 데이터 손실로 인해 작업을 수행할 때 몇 가지 문제가 발생할 수 있습니다. 모든 BitmapData 메서드는 곱하지 않은 값을 사용하고 반환합니다. 내부 픽셀 표현은 미리 곱한 값을 곱하지 않은 값으로 변환한 이후에 값으로 반환됩니다. 픽셀 값은 설정 작업에서 원시 이미지 픽셀을 설정하기 전에 미리 곱해집니다.</p>
     
     <p><b>참고:</b> <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 반복해서 사용할 때 성능을 향상시키려면 <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 호출하기 전에 <code>lock()</code> 메서드를 호출하고, 픽셀 변경을 모두 마치고 나면 <code>unlock()</code> 메서드를 호출합니다. 이 프로세스는 픽셀 변경을 모두 마치기 전까지 이 BitmapData 인스턴스를 참조하는 객체가 업데이트되지 않도록 합니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; 값이 변경되는 픽셀의 <i>x</i> 위치입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; 값이 변경되는 픽셀의 <i>y</i> 위치입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; 픽셀의 최종 ARGB 색상입니다. 비트맵이 투명이 아니고 불투명인 경우 이 색상 값의 알파 투명도 부분은 무시됩니다.
     
     </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>setPixel32()</code> 메서드를 사용하여 BitmapData 객체에 투명한(alpha == 0x60) 빨간색 선을 그립니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     바이트 배열을 픽셀 데이터의 사각형 영역으로 변환합니다. 각 픽셀에 대해 <code>ByteArray.readUnsignedInt()</code> 메서드가 호출되며, 반환 값이 해당 픽셀에 쓰여집니다. 사각형 전체를 쓰기 전에 바이트 배열이 끝나면 함수가 반환됩니다. 바이트 배열의 데이터는 32비트 ARGB 픽셀 값이여야 합니다. 픽셀 읽기 전후에는 바이트 배열에서 어떤 검색도 수행되지 않습니다.  
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; BitmapData 객체의 사각형 영역을 지정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 사각형 영역에서 사용할 곱하지 않은 32비트 픽셀 값으로 구성된 ByteArray 객체입니다.
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; <code>inputByteArray</code> 객체에 <code>rect</code> 사각형 영역을 채울 데이터가 충분하지 않습니다. 메서드가 최대한 많은 픽셀을 채운 후 예외가 발생합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; rect 또는 inputByteArray가 null입니다.
      
      </td></tr></table><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>getPixels()</code> 및 <code>setPixels()</code> 메서드를 사용하여 한 BitmapData 객체에서 다른 객체로 픽셀을 복사합니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     벡터를 픽셀 데이터의 사각형 영역으로 변환합니다. 각 픽셀마다 Vector 요소가 읽히고 BitmapData 픽셀로 작성됩니다. Vector에 포함된 데이터는 32비트 ARGB 픽셀 값이어야 합니다. 
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; BitmapData 객체의 사각형 영역을 지정합니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; 사각형 영역에서 사용할 곱하지 않은 32비트 픽셀 값으로 구성된 Vector 객체입니다.  
     
     </td></tr></table></p><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 벡터 배열이 모든 픽셀 데이터를 읽을 만큼 크지 않습니다. 
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     이미지의 픽셀 값을 지정된 임계값 기준으로 테스트하고 그 테스트를 통과한 픽셀을 새 색상 값으로 설정합니다. <code>threshold()</code> 메서드를 사용하면 이미지에서 색상 범위를 분리 및 대체할 수 있고 이미지 픽셀에서 다른 논리 연산을 수행할 수 있습니다. 
     
     <p><code>threshold()</code> 메서드의 테스트 논리는 다음과 같습니다.</p> 
     
     <ol><li><code>((pixelValue & mask) operation (threshold & mask))</code>인 경우 픽셀을 <code>color</code>로 설정합니다.</li><li>그렇지 않고 <code>copySource == true</code>인 경우 픽셀을 <code>sourceBitmap</code>의 해당 픽셀 값으로 설정합니다.</li></ol>
     
     <p><code>operation</code> 매개 변수는 임계값 테스트에 사용할 비교 연산자를 지정합니다. 예를 들어 "=="를 <code>operation</code> 매개 변수로 사용함으로써 이미지에서 특정 색상 값을 분리할 수 있습니다. 또는 <code>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</code>을 사용하여 소스 이미지 픽셀의 알파가 0x7F보다 작을 때 모든 대상 픽셀을 완전히 투명해지도록 설정할 수 있습니다. 이 기법을 사용하여 애니메이션 전환 효과 및 기타 효과를 생성할 수 있습니다.</p>
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; 사용할 입력 비트맵 이미지입니다. 소스 이미지는 현재의 BitmapData 인스턴스를 가리킬 수도 있고 혹은 다른 BitmapData 객체가 될 수도 있습니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 입력 이미지로 사용할 소스 이미지 영역을 정의하는 사각형입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; 소스 사각형의 왼쪽 위 모서리에 해당하는 대상 이미지(현재 BitmapData 인스턴스) 내부의 점입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; 다음 비교 연산자 중 하나로, 문자열로 전달됩니다. "&lt;", "&lt;=", ">", ">=", "==", "!="
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; 각 픽셀이 임계값을 충족하는지 아니면 초과하는지 확인하기 위해 각 픽셀을 테스트하는 값입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 임계값 테스트에 통과할 경우 픽셀에 설정할 색상 값입니다. 기본값은 0x00000000입니다.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 색상 구성 요소를 분리하는 데 사용할 마스크입니다. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 값이 <code>true</code>이면 임계값 테스트에 통과하지 못할 경우 소스 이미지의 픽셀 값이 대상으로 복사됩니다. 값이 <code>false</code>이면 임계값 테스트를 통과하지 못할 경우 소스 이미지가 복사되지 않습니다. 
     
     </td></tr></table></p><p></p><span class="label">반환값</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; 변경된 픽셀 수입니다.
     </td></tr></table><br/><span class="label">오류</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; sourceBitmapData, sourceRect destPoint 또는 연산이 null입니다.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 연산 문자열이 유효한 연산이 아닙니다. 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 <code>perlinNoise()</code> 메서드를 사용하여 한 BitmapData 객체에 파란색과 빨간색 패턴을 추가합니다. 그런 다음 <code>threshold()</code> 메서드를 사용하여 이 픽셀을 첫 번째 BitmapData 객체에서 두 번째 객체로 복사하며, 빨간색 값이 0x80(50%)보다 큰 픽셀은 투명 빨간색(0x20FF0000)으로 설정된 픽셀로 대체됩니다.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">메서드</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>언어 버전:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>런타임 버전:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     이 BitmapData 객체를 변경할 때 BitmapData 객체를 참조하는 임의의 객체(예: Bitmap 객체)도 업데이트되도록 이미지 잠금을 해제합니다. 성능을 높이려면 <code>setPixel()</code> 또는 <code>setPixel32()</code> 메서드를 여러 차례 호출하기 전후에 이 메서드를 <code>lock()</code> 메서드와 함께 사용합니다.
     
     </p><p><span class="label"> 매개 변수 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; 변경된 BitmapData 객체 영역입니다. 이 매개 변수의 값을 지정하지 않을 경우 BitmapData 객체의 전체 영역이 변경된 것으로 간주됩니다. 이 매개 변수에는 Flash Player 버전 9.0.115.0 이상이 필요합니다.
     
     </td></tr></table></p><p><span class="label">관련 API 요소</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> 예제 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span>)
            </span><br/><br/><div class="detailBody"> 다음 예제에서는 Bitmap 객체 <code>picture</code>의 <code>bitmapData</code> 속성을 기반으로 BitmapData 객체를 만듭니다. 그리고 나서 <code>lock()</code> 메서드를 호출한 다음 BitmapData 객체를 수정하는 복잡한 사용자 정의 함수인 <code>complexTransformation()</code>을 호출합니다. <code>picture</code> 객체 및 <code>complexTransformation()</code> 함수는 이 예제에서 정의하지 않습니다. <code>complexTransformation()</code> 함수가 <code>picture</code> 객체의 <code>bitmapData</code> 속성을 업데이트하더라도 코드가 <code>bitmapData</code> 객체에서 <code>unlock()</code> 메서드를 호출하기 전까지는 변경 사항이 반영되지 않습니다.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">예제<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_kr"> 예제 사용 방법 </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> 다음 예제에서는 BitmapDataExample 클래스를 사용하여 Image.gif 이미지를 DisplayObject의 기본 위치(0, 0)에 로드합니다. 그런 다음 Image.gif의 복사본이 원본 오른쪽에 배치되는데, 이 복사본에서 <code>threshold()</code> 메서드를 사용한 텍스트를 통과하는 픽셀에는 새 색상이 적용됩니다. 이 작업은 다음 단계를 사용하여 수행됩니다.
 <ol><li>이미지 파일의 이름과 위치를 나타내는 <code>url</code> 속성이 만들어집니다.</li><li>클래스 생성자가 Loader 객체를 만들고 이 객체는 <code>completeHandler()</code> 메서드에서 이미지 조작을 완료했을 때 전달되는 이벤트 리스너를 인스턴스화합니다.</li><li><code>request</code> URLRequest 객체가 표시 객체를 사용하여 이미지를 메모리에 로드하는 <code>loader.load()</code>에 전달됩니다.</li><li>이제 이미지가 표시 목록에 놓이고 화면의 <i>x = 0, y = 0</i> 좌표에 표시됩니다.</li><li><code>completeHandler()</code> 메서드는 다음 작업을 수행합니다. 
     <ul><li>두 번째 Loader를 Bitmap 객체와 함께 만들며, 이 Bitmap 객체는 Loader 객체와 함께 초기화됩니다.</li><li>두 번째 Bitmap 객체인 <code>duplicate</code>를 만든 뒤 <code>duplicateImage()</code> 메서드를 호출하여 원본 이미지의 복제본을 만듭니다. </li><li>BitmapData 객체를 만듭니다. 이 객체는 <code>duplicate</code> 객체의 BitmapData 객체에 할당됩니다.</li><li>원본 이미지와 동일한 좌표, 폭, 높이로 초기화된 새 Rectangle 객체를 만듭니다.</li><li>기본값이 <i>x = 0, y = 0</i>인 새 Point 객체를 만듭니다.</li><li>다음과 같은 변수를 만듭니다.
         <ul><li><code>operation</code> - 임계값이 원래 값보다 크거나 같은 경우 새 색상을 적용합니다.</li><li><code>threshold</code> - 각 픽셀의 비교 대상 값(이 예제에서는 알파가 0xCC인 밝은 회색)입니다. </li><li><code>color</code> - 임계값 테스트를 통과한 픽셀이 설정되는 색상으로, 이 경우에는 단색 노랑입니다.</li><li><code>mask</code> - 정반대 색상(투명 파랑)입니다.</li><li><code>copySource</code> - <code>false</code>로 설정되어 임계값이 통과하지 못할 경우 픽셀 값이 복사되지 않음을 나타냅니다. 하지만 이미지는 복제되어 있고 임계값 테스트를 통과한 픽셀만 변경되기 때문에 이 값은 아무 의미가 없습니다.</li></ul></li><li>앞서 나온 변수를 사용하여 <code>threshold()</code> 메서드를 호출합니다. 최종 임계값 수식은 <code>if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00</code>입니다. </li></ul></li></ol>
 <p> <b>참고:</b>
 <ul><li>[로컬 재생 보안]을 [로컬 파일만 액세스]로 설정하여 SWF 파일을 컴파일해야 합니다.
 </li><li>이 예제에서는 SWF 파일과 같은 디렉토리에 Image.gif 파일이 있어야 합니다.
 </li><li>폭이 최대 80픽셀 정도인 이미지를 사용하는 것이 좋습니다. </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:17 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/ko_KR/legalnotices/index.html">법적 고지 사항</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">온라인 개인 정보 보호 정책</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">영어로 표시되는 이유</span>
				</div>
				<div class="white_content_body">
					<b>ActionScript 3.0 참조 설명서의 내용이 영어로 나타납니다.</b><br><br>
					ActionScript 3.0 참조 설명서 중 일부는 전체 언어로 번역되지 않았습니다. 언어 요소가 번역되지 않은 경우 영어로 나타납니다. 예를 들어 ga.controls.HelpBox 클래스는 어떤 언어로도 번역되지 않았습니다. 그러므로 한국어 버전의 참조 설명서에서 ga.controls.HelpBox 클래스는 영어로 나타납니다.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:17 PM Z  -->
