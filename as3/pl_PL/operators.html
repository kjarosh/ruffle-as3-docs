<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 &mdash; dokumentacja dla platformy Adobe&reg; Flash&reg;  "><meta name="lang" content="pl-pl"><link rel="stylesheet" href="style.css" type="text/css" media="screen"><link rel="stylesheet" href="print.css" type="text/css" media="print"><link rel="stylesheet" href="override.css" type="text/css"><link rel="stylesheet" href="asfilter.css" type="text/css"><link rel="stylesheet" href="ion.css" type="text/css"><title>Operatory - Adobe ActionScript&reg; 3 (AS3) &mdash; dokumentacja interfejsu API</title>
		<link rel="stylesheet" href="filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="filter_new.css" type="text/css">
			
		<script src="jquery.js" type="text/javascript"></script>
		<script src="s_chl_code.js" type="text/javascript"></script>
		<script src="jquery.zclip.js" type="text/javascript"></script>
		<script src="jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="cookies.js" type="text/javascript"></script>
		<script src="asdoc.js" type="text/javascript"></script>
		<script src="iscroll.js" type="text/javascript"></script>
		<script src="AC_OETags.js" type="text/javascript"></script>
		<script src="omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Środowiska wykonawcze";
			var productsLabel = "Produkty";
			var noneLabel = "Brak";
			var qsearchBoxLabel = "Wyszukiwanie";
			var qsearchText = "Nie znaleziono terminu.";
			var ajaxErrorMsg="Błąd wczytywania strony";
			var ajaxErrorTryMsg="Ponów próbę";
			var ajaxLoadingMsg="Wczytywanie nadal w toku";
			var cancelMsg = "Anuluj";
			var classesText = "Klasy";
			var strJiveReply = "To pytanie zamieszczono w odpowiedzi na następujący artykuł: "
			var showFilters = "Pokaż filtry";
			var hideFilters = "Ukryj filtry";
			
		
			var baseRef = "./";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 &mdash; dokumentacja dla platformy Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="index.html"> Strona główna </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="operators.html#top" style="display:">Pokaż listę pakietów i klas</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="operators.html#top" style="display:none">Ukryj listę pakietów i klas</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="package-summary.html"> Pakiety </a>&nbsp;|&nbsp;
												<a target="_self" href="class-summary.html"> Klasy </a>&nbsp;|&nbsp;
												<a target="_self" href="whatsnew.html"> Nowości </a>&nbsp;|&nbsp;
												<a target="_self" href="all-index-Symbols.html"> Indeks </a>&nbsp;|&nbsp;
												<a target="_self" href="appendixes.html"> Dodatki </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Dlaczego język angielski?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/pl_PL/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('./')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('./')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="help.js"></script>
						<script language="javascript" type="text/javascript" src="asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filtry:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="operators.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">&nbsp;</a><br>
								<h1 id="classProductName">Operatory&nbsp;</h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="operators.html#propertySummary" style="display:none"> Właściwości </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="operators.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Właściwości </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="operators.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="operators.html#methodSummary" style="display:none"> Metody </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="operators.html#constantSummary" style="display:none"> Stałe globalne </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="operators.html#eventSummary" style="display:none"> Zdarzenia </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="operators.html#styleSummary" style="display:none"> Style </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="operators.html#SkinPartSummary" style="display:none"> Części karnacji </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="operators.html#SkinStateSummary" style="display:none"> Stany karnacji </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="operators.html#effectSummary" style="display:none"> Efekty </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="operators.html#constantSummary" style="display:none"> Stałe </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="operators.html#methodSummary" style="display:none"> Funkcje globalne </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="operators.html#methodSummary" style="display:none">Funkcje</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="operators.html#interfaceSummary" style="display:none"> Interfejsy </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="operators.html#classSummary" style="display:none"> Klasy </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="operators.html#includeExamplesSummary" style="display:none"> Przykłady </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="operators.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klasy
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><p>Operatory symboliczne są to znaki określające sposób łączenia, porównywania lub modyfikowania wartości wyrażeń.</p><br><a name="operatorSummary"></a><table cellspacing="0" cellpadding="3" class="summaryTable"><tr><th>&nbsp;</th><th colspan="3">arytmetyczne</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#addition">addition</a></td><td class="summaryTableLastCol"><shortdesc>Dodaje wyrażenia liczbowe.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">--</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#decrement">decrement</a></td><td class="summaryTableLastCol"><shortdesc>Odejmuje 1 od operandu.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">/</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#division">division</a></td><td class="summaryTableLastCol"><shortdesc>Dzieli wartość <code>expression1</code> przez wartość <code>expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">++</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#increment">increment</a></td><td class="summaryTableLastCol"><shortdesc>Dodaje 1 do wartości wyrażenia.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">%</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#modulo">modulo</a></td><td class="summaryTableLastCol"><shortdesc>Oblicza resztę z dzielenia wartości wyrażenia <code>expression1</code> przez wartość wyrażenia <code>expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">*</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#multiplication">multiplication</a></td><td class="summaryTableLastCol"><shortdesc>Mnoży dwa wyrażenia liczbowe.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">-</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#subtraction">subtraction</a></td><td class="summaryTableLastCol"><shortdesc>Służy do zmiany znaku lub odejmowania.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">ciągi</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#concatenation">concatenation</a></td><td class="summaryTableLastCol"><shortdesc>Przeprowadza konkatenację (połączenie) ciągów.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#concatenation_assignment">concatenation assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 + expression2</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">"</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#string_delimiter">string delimiter</a></td><td class="summaryTableLastCol"><shortdesc>Operator ten, użyty przed znakami i po znakach, oznacza, że znaki należy traktować dosłownie i że stanowią one ciąg, a nie zmienną, wartość liczbową czy inny element języka ActionScript.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3"> Komentarz </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">/*..*/</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#block_comment_delimiter">block comment delimiter</a></td><td class="summaryTableLastCol"><shortdesc>Stanowi ogranicznik jednego lub wielu wierszy komentarza w skrypcie.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">inne</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">[]</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#array_access">array access</a></td><td class="summaryTableLastCol"><shortdesc>Inicjuje nową tablicę lub tablicę wielowymiarową określonymi elementami (<code>a0</code> itd.) oraz umożliwia dostęp do elementów w tablicy.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#as">as</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy wyrażenie określone przez pierwszy operand jest elementem typu danych określonego przez drugi operand.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">?:</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#conditional">conditional</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia <code>expression1</code> i jeśli wyrażenie <code>expression1</code> jest równe <code>true</code>, wynikiem jest wartość <code>expression2</code>; w przeciwnym razie wynikiem jest wartość <code>expression3</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#delete">delete</a></td><td class="summaryTableLastCol"><shortdesc>Niszczy właściwość obiektu określoną przez operand <code>reference</code>; wynikiem jest wartość <code>true</code>, jeśli właściwość nie istnieje po ukończeniu operacji, albo wartość <code>false</code> w przeciwnym wypadku.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">.</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#dot">dot</a></td><td class="summaryTableLastCol"><shortdesc>Umożliwia dostęp do zmiennych i metod, pobieranie i ustawianie właściwości obiektów, a także stanowi ogranicznik importowanych pakietów i klas.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#in">in</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy właściwość należy do określonego obiektu.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#instanceof">instanceof</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy łańcuch prototypów wyrażenia zawiera obiekt prototypowy dla funkcji <code>function</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#is">is</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy obiekt jest kompatybilny z określonym typem danych, klasą lub interfejsem.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">::</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#name_qualifier">name qualifier</a></td><td class="summaryTableLastCol"><shortdesc>Identyfikuje przestrzeń nazw właściwości, metody, właściwości XML lub atrybutu XML.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#new">new</a></td><td class="summaryTableLastCol"><shortdesc>Tworzy instancję klasy.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">{}</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#object_initializer">object initializer</a></td><td class="summaryTableLastCol"><shortdesc>Tworzy nowy obiekt i inicjuje go określonymi parami właściwości <code>name</code> i <code>value</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">()</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#parentheses">parentheses</a></td><td class="summaryTableLastCol"><shortdesc>Umożliwia grupowanie operacji na jednym lub wielu parametrach, sekwencyjne wyznaczanie wartości wyrażeń, a także wskazanie parametru lub parametrów przekazywanych do funkcji, której nazwa poprzedza nawias.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">/</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#RegExp_delimiter">RegExp delimiter</a></td><td class="summaryTableLastCol"><shortdesc>Operator ten, użyty przed znakami i po znakach, oznacza, że znaki należy traktować literalnie i że stanowią one wyrażenie regularne, a nie zmienną, ciąg znaków lub inny element języka ActionScript.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">:</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#type">type</a></td><td class="summaryTableLastCol"><shortdesc>Służy do przypisywania typu danych; ten operator określa typ zmiennej, typ wartości zwracanej przez funkcję lub typ parametru funkcji.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#typeof">typeof</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia <code>expression</code> i zwraca ciąg znaków opisujący typ danych tego wyrażenia.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#void">void</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia po czym odrzuca tę wartość i zwraca wartość <code>undefined</code>.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">komentarz</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">//</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#line_comment_delimiter">line comment delimiter</a></td><td class="summaryTableLastCol"><shortdesc>Oznacza początek komentarza w skrypcie.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3"> Logiczne </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&&</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#logical_AND">logical AND</a></td><td class="summaryTableLastCol"><shortdesc>Zwraca wartość <code>expression1</code>, jeśli jest równa <code>false</code> lub można ją przekonwertować na wartość <code>false</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&&=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#logical_AND_assignment">logical AND assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 && expression2</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">!</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#logical_NOT">logical NOT</a></td><td class="summaryTableLastCol"><shortdesc>Odwraca wartość typu Boolean zmiennej lub wyrażenia.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">||</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#logical_OR">logical OR</a></td><td class="summaryTableLastCol"><shortdesc>Zwraca wartość <code>expression1</code>, jeśli jest równa <code>true</code> lub można ją przekonwertować na wartość <code>true</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">||=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#logical_OR_assignment">logical OR assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 || expression2</code>.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">operatory bitowe</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_AND">bitwise AND</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i wykonuje logiczną operację AND na parach odpowiednich bitów tych parametrów całkowitoliczbowych.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol"><<</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_left_shift">bitwise left shift</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wyrażenie <code>expression1</code> i <code>shiftCount</code> na 32-bitowe liczby całkowite, a następnie przesuwa wszystkie bity wartości <code>expression1</code> w lewo o liczbę pozycji określoną przez liczbę całkowitą będącą wynikiem konwersji wartości <code>shiftCount</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">~</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_NOT">bitwise NOT</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wartość wyrażenia <code>expression</code> na 32-bitową liczbę całkowitą ze znakiem, a następnie wykonuje na niej operację bitowego dopełnienia do jedynek.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">|</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_OR">bitwise OR</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i umieszcza 1 na wszystkich pozycjach bitowych, na których odpowiednie bity wyrażenia <code>expression1</code>, wyrażenia <code>expression2</code> lub obu tych wyrażeń są równe 1.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">>></td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_right_shift">bitwise right shift</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wyrażenie <code>expression</code> i <code>shiftCount</code> na 32-bitowe liczby całkowite, a następnie przesuwa wszystkie bity wartości <code>expression</code> w prawo o liczbę pozycji określoną przez liczbę całkowitą będącą wynikiem konwersji wartości <code>shiftCount</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">>>></td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_unsigned_right_shift">bitwise unsigned right shift</a></td><td class="summaryTableLastCol"><shortdesc>Działa tak samo jak operator przesunięcia bitowego w prawo (<code>&gt;&gt;</code>) poza tym, że nie zachowuje znaku pierwotnego wyrażenia, ponieważ bity po lewej stronie są zawsze wypełniane zerami.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">^</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_XOR">bitwise XOR</a></td><td class="summaryTableLastCol"><shortdesc>Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i umieszcza 1 na wszystkich pozycjach bitowych, na których odpowiednie bity jednego z wyrażeń, <code>expression1</code> albo <code>expression2</code>, (ale nie obu) są równe 1.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3"> Inne </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">,</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#comma">comma</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia <code>expression1</code>, następnie <code>expression2</code> i tak dalej.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">porównywanie</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">==</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#equality">equality</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy dwa wyrażenia są równe.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">></td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#greater_than">greater than</a></td><td class="summaryTableLastCol"><shortdesc>Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest większa od wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">>=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#greater_than_or_equal_to">greater than or equal to</a></td><td class="summaryTableLastCol"><shortdesc>Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest większa lub równa wartości <code>expression2</code> (<code>true</code>), czy też wartość <code>expression1</code> jest mniejsza niż wartość <code>expression2</code> (<code>false</code>).</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">!=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#inequality">inequality</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza warunek przeciwny do równości (<code>==</code>).</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol"><</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#less_than">less than</a></td><td class="summaryTableLastCol"><shortdesc>Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest mniejsza od wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol"><=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#less_than_or_equal_to">less than or equal to</a></td><td class="summaryTableLastCol"><shortdesc>Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest mniejsza lub równa wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">===</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#strict_equality">strict equality</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza, czy dwa wyrażenia są równe, ale nie przeprowadza automatycznej konwersji danych.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">!==</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#strict_inequality">strict inequality</a></td><td class="summaryTableLastCol"><shortdesc>Sprawdza warunek przeciwny do ścisłej równości (<code>===</code>).</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">przypisanie</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#assignment">assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wartość wyrażenia <code>expression2</code> (operandu po prawej stronie) zmiennej, elementowi tablicy lub właściwości w wyrażeniu <code>expression1</code>.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3"> XML </th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">@</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#attribute_identifier">attribute identifier</a></td><td class="summaryTableLastCol"><shortdesc>Identyfikuje atrybuty obiektu XML lub XMLList.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">{ }</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#braces_(XML)">braces (XML)</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia używanego do inicjowania obiektu XML lub XMLList.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">[ ]</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#brackets_(XML)">brackets (XML)</a></td><td class="summaryTableLastCol"><shortdesc>Umożliwia dostęp do właściwości lub atrybutu obiektu XML lub XMLList.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#concatenation_(XMLList)">concatenation (XMLList)</a></td><td class="summaryTableLastCol"><shortdesc>Konkatenuje (łączy) wartości XML lub XMLList w obiekt klasy XMLList.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#concatenation_assignment_(XMLList)">concatenation assignment (XMLList)</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> (które jest obiektem XMLList) wartość <code>expression1 + expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&nbsp;</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#delete_(XML)">delete (XML)</a></td><td class="summaryTableLastCol"><shortdesc>Usuwa elementy lub atrybuty XML określone przez parametr <code>reference</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">..</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#descendant_accessor">descendant accessor</a></td><td class="summaryTableLastCol"><shortdesc>Powoduje przejście do elementów potomnych obiektu XML lub XMLList albo (w połączeniu z operatorem @) znajduje dopasowane atrybuty elementów potomnych.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">.</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#dot_(XML)">dot (XML)</a></td><td class="summaryTableLastCol"><shortdesc>Powoduje przejście do elementów potomnych obiektu XML lub XMLList albo (w połączeniu z operatorem @) zwraca atrybuty obiektu XML lub XMLList.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">( )</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#parentheses_(XML)">parentheses (XML)</a></td><td class="summaryTableLastCol"><shortdesc>Wyznacza wartość wyrażenia w ramach konstrukcji XML zgodnej z notacją E4X. </shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">< ></td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#XML_literal_tag_delimiter">XML literal tag delimiter</a></td><td class="summaryTableLastCol"><shortdesc>Definiuje znacznik XML w literale XML.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">złożone operatory arytmetyczne</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">+=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#addition_assignment">addition assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 + expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">/=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#division_assignment">division assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 / expression2</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">%=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#modulo_assignment">modulo assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 % expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">*=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#multiplication_assignment">multiplication assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 * expression2</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">-=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#subtraction_assignment">subtraction assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 - expression2</code>.</shortdesc></td></tr><tr><th>&nbsp;</th><th colspan="3">złożone operatory poziomu bitowego</th></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">&=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_AND_assignment">bitwise AND assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1</code> <code>& expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol"><<=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_left_shift_and_assignment">bitwise left shift and assignment</a></td><td class="summaryTableLastCol"><shortdesc>Wykonuje przesunięcie bitowe w lewo (<code>&lt;&lt;=</code>) i przypisuje wynik w wyrażeniu <code>expression1</code>. </shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">|=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_OR_assignment">bitwise OR assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 | expression2</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">>>=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_right_shift_and_assignment">bitwise right shift and assignment</a></td><td class="summaryTableLastCol"><shortdesc>Wykonuje operację bitowego przesunięcia w prawo i zapisuje wynik w wyrażeniu <code>expression</code>.</shortdesc></td></tr><tr class="row1"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">>>>=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_unsigned_right_shift_and_assignment">bitwise unsigned right shift and assignment</a></td><td class="summaryTableLastCol"><shortdesc>Wykonuje operację bitowego przesunięcia w prawo bez zachowania znaku i zapisuje wynik w wyrażeniu <code>expression</code>.</shortdesc></td></tr><tr class="row0"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableOperatorCol">^=</td><td class="summaryTableSignatureCol"><a class="signatureLink" href="operators.html#bitwise_XOR_assignment">bitwise XOR assignment</a></td><td class="summaryTableLastCol"><shortdesc>Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 ^ expression2</code>.</shortdesc></td></tr></table><div class="detailSectionHeader">Szczegół operatora</div><a name="addition"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+&nbsp;addition</td><td class="detailHeaderType"> Operator </td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 + expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Dodaje wyrażenia liczbowe. Jeśli oba wyrażenia są liczbami całkowitymi, suma jest liczbą całkowitą; jeśli co najmniej jedno wyrażenie jest liczbą zmiennopozycyjną, suma jest liczbą zmiennopozycyjną.
            <p>Jeśli jedno wyrażenie jest ciągiem znaków, wszystkie pozostałe wyrażenia są konwertowane na ciągi znaków i konkatenowane, a nie sumowane. W przeciwnym razie, jeśli wyrażenie nie jest liczbą, program Flash<sup>&#xAE;</sup> Player konwertuje je na liczbę.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Wartość, która ma zostać dodana.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Wartość, która ma być dodana.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Liczba całkowita lub zmiennoprzecinkowa.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Ta instrukcja dodaje liczby całkowite 2 i 3:
<div class="listing"><pre>
trace(2 + 3); // 5</pre></div> 
Ta instrukcja dodaje liczby zmiennopozycyjne 2,5 i 3,25:
<div class="listing"><pre>
trace(2.5 + 3.25); // 5.75</pre></div> 
Ten przykład demonstruje, że jeśli jedno wyrażenie jest ciągiem znaków, wszystkie pozostałe wyrażenia są konwertowane na ciągi znaków i konkatenowane:
<div class="listing"><pre>
trace("Number " + 8 + 0); // Number 80</pre></div>
Zmienne skojarzone z dynamicznymi i wejściowymi polami tekstowymi należą do typu danych String. W poniższym przykładzie zmienna <code>deposit</code> jest wejściowym polem tekstowym na stole montażowym. Gdy użytkownik wprowadzi wartość zmiennej deposit, skrypt próbuje dodać zmienną <code>deposit </code> do zmiennej <code>oldBalance</code>. Ponieważ jednak zmienna <code>deposit</code> jest typu String, skrypt konkatenuje (łączy w jeden ciąg znaków) wartości zmiennych zamiast je dodać. 
<div class="listing"><pre>var oldBalance:Number = 1345.23; 
var currentBalance = deposit_txt.text + oldBalance; 
trace(currentBalance); </pre></div>
Na przykład, jeśli użytkownik w polu tekstowym deposit wprowadzi liczbę 475, instrukcja <code>trace()</code> wyświetli w panelu Wyjście wartość 4751345,23. Aby poprawić ten błąd, należy zastosować funkcję <code>Number()</code> w celu przekonwertowania ciągu znaków na liczbę: 
<div class="listing"><pre>var oldBalance:Number = 1345.23; 
var currentBalance:Number = Number(deposit_txt.text) + oldBalance;
trace(currentBalance);
</pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#concatenation" target="">+ (konkatenacja)</a></div></div><a name="addition_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+=&nbsp;addition assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 += expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 + expression2</code>. Na przykład następujące dwie instrukcje odniosą ten sam skutek: <pre>x += y; 
x = x + y; </pre>Wszystkie reguły obowiązujące dla operatora dodawania (+) mają również zastosowanie do operatora przypisania po dodawaniu (<code>+=</code>).
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik dodawania.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora przypisania po dodawaniu (<code>+=</code>) na wartościach liczbowych: 
<div class="listing"><pre>var x:Number = 5; 
var y:Number = 10; 
x += y; 
trace(x); // 15 
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#addition" target="">+ (dodawanie),</a></div></div><a name="array_access"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">[]&nbsp;array access</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre><code>myArray = [a0, a1,...aN]</code>
<code>myArray[i] = value</code> 
<code>myObject[propertyName]</code></pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Inicjuje nową tablicę lub tablicę wielowymiarową określonymi elementami (<code>a0</code> itd.) oraz umożliwia dostęp do elementów w tablicy. Operator dostępu do tablicy umożliwia dynamiczne ustawianie i pobieranie nazw instancji, zmiennych i obiektów. Umożliwia także dostęp do właściwości obiektów. 
			<p>Zastosowanie 1: Tablica jest obiektem, którego właściwości nazywane są elementami; każdy z elementów jest identyfikowany przez liczbę nazywaną indeksem. Tworząc tablicę, jej elementy ujmuje się w nawiasy kwadratowe ([]), które są operatorem dostępu do tablicy. Jedna tablica może zawierać elementy różnych typów. Na przykład poniższa tablica o nazwie <code>employee</code> ma trzy elementy: pierwszy jest liczbą, a następne dwa są ciągami znaków (ujętymi w cudzysłów): </p> 
			<div class="listing"><pre>var employee:Array = [15, "Barbara", "Jay"]; </pre></div> 
			Dozwolone jest zagnieżdżanie nawiasów w celu zasymulowania tablic wielowymiarowych. Tablice można zagnieżdżać do maksymalnie 256 poziomów. Poniższy kod tworzy tablicę o nazwie <code>ticTacToe</code> zawierającą trzy elementy; każdy element także jest tablicą zawierającą trzy elementy: <div class="listing"><pre>var ticTacToe:Array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; 
			
/* Select Debug &gt; List Variables in test mode 
to see a list of the array elements.*/ </pre></div> 
Zastosowanie 2: Ujmując indeks elementu w nawiasy kwadratowe ([]), można uzyskać dostęp bezpośrednio do tego elementu; istnieje możliwość dodawania nowych elementów do tablicy, a także zmiany lub pobierania wartości istniejących elementów. Pierwszy element tablicy ma zawsze indeks 0, co zilustrowano w poniższym przykładzie: <div class="listing"><pre>var my_array:Array = new Array(); 
my_array[0] = 15; 
my_array[1] = "Hello"; 
my_array[2] = true; </pre></div> 
Można użyć nawiasów kwadratowych w celu dodania czwartego elementu, tak jak w następującym przykładzie: 
<div class="listing"><pre>my_array[3] = "George"; </pre></div> 
Nawiasy kwadratowe umożliwiają dostęp do elementów tablicy wielowymiarowej. Pierwsza para nawiasów wskazuje element zewnętrznej tablicy, a druga para wskazuje element w tablicy zagnieżdżonej. Następująca instrukcja <code>trace()</code> odczytuje trzeci element (indeks 2) drugiej tablicy (indeks 1).
<div class="listing"><pre>var ticTacToe:Array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]; 
trace(ticTacToe[1][2]); // 6 </pre></div> 
Zastosowanie 3: Operator dostępu do tablicy umożliwia dynamiczne ustawianie i odczytywanie wartości właściwości obiektów: 
<div class="listing"><pre>var obj:Object = new Object();
obj.prop1 = "foo";
trace(obj["prop" + 1]); // foo
obj.prop2 = "bar";
for (j in obj) {
	trace(obj[j]);
} 
/* Output of for loop: 
foo
bar */
</pre></div>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myArray</span>:<a href="Object.html">Object</a></code> &mdash; 
					Nazwa tablicy.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">a0, a1,...aN</span>:<a href="Object.html">Object</a></code> &mdash; 
					Elementy w tablicy; dowolna instancja typu natywnego lub obiektu, w tym tablice zagnieżdżone.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">i</span>:<a href="Number.html">Number</a></code> &mdash; 
					Indeks, będący liczbą całkowitą większą lub równą 0.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">myObject</span>:<a href="Object.html">Object</a></code> &mdash; 
					Nazwa obiektu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">propertyName</span>:<a href="String.html">String</a></code> &mdash; 
					Ciąg znaków określający nazwę właściwości obiektu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Object.html">Object</a></code> &mdash; 
				<p>Zastosowanie 1: Odwołanie do tablicy. </p> <p>Zastosowanie 2: Wartość z tablicy; instancja typu natywnego lub obiektu (w tym instancja klasy Array). </p> <p>Zastosowanie 3: Właściwość obiektu; instancja typu natywnego lub obiektu (w tym instancja klasy Array). </p>
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje dwa sposoby tworzenia nowego pustego obiektu Array; w pierwszym wierszu użyto nawiasów kwadratowych: 
<div class="listing"><pre>var my_array:Array = []; 
var my_array:Array = new Array(); </pre></div> 
<p>Poniższy kod tworzy tablicę o nazwie <code>employee_array</code> zawierającą trzy elementy i zmienia trzeci element tej tablicy.</p>
<div class="listing"><pre>var employee_array = ["Barbara", "George", "Mary"]; 
trace(employee_array); // Barbara,George,Mary 
employee_array[2] = "Sam"; 
trace(employee_array); // Barbara,George,Sam </pre></div> 
W poniższym przykładzie najpierw wyznaczana jest wartość wyrażenia w nawiasach kwadratowych, a następnie wynik używany jest jako nazwa zmiennej, która ma być odczytana z obiektu <code>obj</code>: 
<div class="listing"><pre>var obj:Object = new Object();
obj.prop1 = "foo";
obj.prop2 = "bar";

for (var i:int = 1;i &lt; 3;i++) {
	trace(obj["prop"+i]);
}
/* Output of for loop:
foo
bar */ 
</pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Array.html" target="">Klasa Array</a><br/><a href="Object.html" target="">Klasa Object</a></div></div><a name="as"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;as</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression as datatype</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy wyrażenie określone przez pierwszy operand jest elementem typu danych określonego przez drugi operand. Jeśli pierwszy operand należy do typu danych, wynikiem jest pierwszy operand. W przeciwnym wypadku wynikiem jest wartość <code>null</code>.

			<p>Wyrażenie użyte w charakterze drugiego operandu musi po wyznaczeniu jego wartości zwracać typ danych.</p>
</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość, której kompatybilność z określonym typem danych należy sprawdzić.				
				</td></tr><tr><td width="20px"></td><td><code><span class="label">datatype</span>:<a href="Class.html">Class</a></code> &mdash; 
					Typ danych używany do wyznaczenia wartości operandu <code>expression</code>. Nie jest dozwolone użycie typu specjalnego *, który oznacza wartość bez typu.				
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Object.html">Object</a></code> &mdash; 
				Wynikiem jest wyrażenie <code>expression</code>, jeśli <code>expression</code> należy do typu danych określonego przez operand <code>datatype</code>. W przeciwnym wypadku wynikiem jest wartość <code>null</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
				W poniższym przykładzie tworzona jest prosta tablica o nazwie <code>myArray</code> i operator <code>as</code> używany jest z różnymi typami danych.
<div class="listing"><pre>
public var myArray:Array = ["one", "two", "three"];
trace(myArray as Array);  // one,two,three
trace(myArray as Number); // null
trace(myArray as int);    // null
</pre></div>
				
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#instanceof" target="">instanceof</a><br/><a href="operators.html#is" target="">is</a></div></div><a name="assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">=&nbsp;assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 = expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wartość wyrażenia <code>expression2</code> (operandu po prawej stronie) zmiennej, elementowi tablicy lub właściwości w wyrażeniu <code>expression1</code>. Możliwe są przypisania przez wartość lub przez odwołanie. Przypisanie przez wartość polega na skopiowaniu faktycznej wartości wyrażenia <code>expression2</code> do obiektu <code>expression1</code>. Przypisanie przez wartość jest stosowane, gdy wyrażenie <code>expression2</code> jest wartością pierwotną, co oznacza, że jego typem danych jest Boolean, Number, int, uint lub String. Przypisanie przez odwołanie polega na zapisaniu odwołania do obiektu <code>expression2</code> w obiekcie <code>expression1</code>. Przypisanie przez odwołanie jest często stosowane razem z operatorem <code>new</code>. Operator <code>new</code> tworzy obiekt w pamięci, a odwołanie do odpowiedniego miejsca w pamięci jest przypisywane zmiennej.
			<p><b>Uwaga:</b> W języku ActionScript 3.0 wszystkie wartości (w tym wartości pierwotne) są obiektami i wszystkie przypisania są faktycznie realizowane przez odwołanie, jednak z obiektami pierwotnymi są skojarzone operatory specjalne, dzięki którym obiekty te mogą zachowywać się tak, jak gdyby były przypisane przez wartość.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Zmienna, element tablicy lub właściwość obiektu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Object.html">Object</a></code> &mdash; 
				Przypisana wartość, <code>expression2</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie zastosowano przypisanie przez wartość w celu przypisania zmiennej <code>z</code> wartości 5. 
<div class="listing"><pre>var z:Number = 5;</pre></div>
			W następującym przykładzie zastosowano przypisanie przez wartość w celu przypisania zmiennej <code>z</code> wartości "<code>hello</code>":
<div class="listing"><pre>var x:String;
x = "hello";</pre></div>
W poniższym przykładzie zastosowano przypisanie przez odwołanie w celu utworzenia zmiennej <code>moonsOfJupiter</code>, która zawiera odwołanie do nowo utworzonego obiektu Array. Następnie wykonywane jest przypisanie przez wartość w celu skopiowania wartości "Callisto" do pierwszego elementu tablicy, do którego odwołuje się zmienna <code>moonsOfJupiter</code>: 
<div class="listing"><pre>var moonsOfJupiter:Array = new Array();
moonsOfJupiter[0] = "Callisto";
</pre></div>
W poniższym przykładzie zastosowano przypisanie przez odwołanie w celu utworzenia nowego obiektu i przypisania zmiennej <code>mercury</code> odwołania do tego obiektu. Następnie wykonywane jest przypisanie przez wartość w celu przypisania wartości 3030 do właściwości <code>diameter</code> obiektu <code>mercury</code>:
<div class="listing"><pre>var mercury:Object = new Object();
mercury.diameter = 3030; // in miles
trace(mercury.diameter); // 3030</pre></div>
Poniższy przykład jest kontynuacją poprzedniego przykładu; tworzona jest w nim zmienna <code>merkur</code> (niemiecka wersja nazwy planety <i>Merkury</i>) i zmiennej tej przypisywana jest wartość <code>mercury</code>. W ten sposób powstają dwie zmienne, które odwołują się do tego samego obiektu w pamięci; oznacza to, że dostęp do właściwości obiektu można uzyskiwać za pomocą dowolnej z tych zmiennych. Następnie można przypisać właściwości <code>diameter</code> wartość wyrażoną w kilometrach, a nie w milach:
<div class="listing"><pre>var merkur:Object = mercury;
merkur.diameter = 4878;  // in kilometers
trace(mercury.diameter); // 4878</pre></div><p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a></div></div><a name="attribute_identifier"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">@&nbsp;attribute identifier</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> myXML.@attributeName </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Identyfikuje atrybuty obiektu XML lub XMLList. Na przykład, <code>myXML.&#064;id</code> identyfikuje atrybuty o nazwie <code>id</code> obiektu XML <code>myXML</code>. Można również użyć następującej składni w celu uzyskania dostępu do atrybutów: <code>myXML.attribute("id")</code>, <code>myXML["&#064;id"]</code> oraz <code>myXML.&#064;["id"]</code>. Zalecana składnia to <code>myXML.&#064;id</code>. Aby zwrócić obiekt XMLList z listą wszystkich nazw atrybutów, należy użyć zapisu <code>&#064;&#42;</code>. Aby zwrócić atrybut o nazwie dopasowanej do słowa zastrzeżonego języka ActionScript, należy użyć metody <code>attribute()</code> zamiast operatora <code>&#064;</code>.
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">attributeName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Nazwa atrybutu.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Pierwszy przykład ilustruje użycie operatora <code>&#064;</code> (znak „at”) do identyfikacji atrybutu elementu:
<div class="listing"><pre>var myXML:XML = 
	&lt;item id = "42"&gt;
		&lt;catalogName&gt;Presta tube&lt;/catalogName&gt;
		&lt;price&gt;3.99&lt;/price&gt;
	&lt;/item&gt;;

trace(myXML.&#064;id); // 42</pre></div>

Następny przykładowy kod zwraca nazwy wszystkich atrybutów:

<div class="listing"><pre>var xml:XML =&lt;example id='123' color='blue'/&gt;
 var xml2:XMLList = xml.&#064;&#42;;
 trace(xml2 is XMLList); // true
 trace(xml2.length());  // 2
 for (var i:int = 0; i &lt; xml2.length(); i++)
 { 
	trace(typeof(xml2[i]));    // xml
	trace(xml2[i].nodeKind()); // attribute
	trace(xml2[i].name());     // id and color
 } </pre></div>
 
W następnym przykładzie zwracany jest atrybut o nazwie dopasowanej do słowa zastrzeżonego języka ActionScript. Nie można użyć składni <code>xml.&#064;class</code> (ponieważ <code>class</code> jest słowem zastrzeżonym języka ActionScript) Należy natomiast użyć składni <code>xml.attribute("class")</code>:
 
<div class="listing"><pre>var xml:XML = &lt;example class='123'/&gt;
trace(xml.attribute("class"));</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a><br/><a href="XML.html#attribute()" target="">XML.attribute()</a><br/><a href="XML.html#attributes()" target="">XML.attributes()</a></div></div><a name="bitwise_AND"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&&nbsp;bitwise AND</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 & expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">
				Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i wykonuje logiczną operację AND na parach odpowiednich bitów tych parametrów całkowitoliczbowych. Liczby zmiennopozycyjne są konwertowane na liczby całkowite poprzez usunięcie cyfr po kropce dziesiętnej. Wynik jest nową 32-bitową liczbą całkowitą. 
				<p>Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
				<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie wykonywana jest bitowa operacja AND na liczbach 13 (dwójkowo 1101) i 11 (dwójkowo 1011); w jej toku porównywane są bitowe reprezentacje liczb. Wynikowa liczba całkowita składa się z szeregu bitów, z których każdy jest ustawiony na 1 tylko wtedy, gdy odpowiednie (znajdujące się na tej samej pozycji) bity obu operandów są ustawione na 1. 
<div class="listing"><pre>var insert:Number = 13; 
var update:Number = 11; 
trace(insert & update); // 9 (or 1001 binary) </pre></div> 
Wynikiem bitowej operacji AND na liczbach 13 (dwójkowo 1101) i 11 (dwójkowo 1011) jest liczba 9, ponieważ tylko pierwszy i ostatni bit jest ustawiony na 1 w obu operandach. 
<pre>
  1101
& 1011
  ----
  1001
</pre>
<p>Poniższe przykłady ilustrują konwersję wartości zwracanej: </p> 
<div class="listing"><pre>trace(0xFFFFFFFF); // 4294967295 
trace(0xFFFFFFFF & 0xFFFFFFFF); // -1 
trace(0xFFFFFFFF & -1); // -1 
trace(4294967295 & -1); // -1 
trace(4294967295 & 4294967295); // -1 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitowym XOR)</a></div></div><a name="bitwise_AND_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&=&nbsp;bitwise AND assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1</code> <code>& expression2</code>. Na przykład następujące dwa wyrażenia są równoważne: 
<pre>x &= y; 
x = x & y; </pre>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wartość wyrażenia <code>expression1 & expression2</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zmiennej <code>x</code> jest przypisywana wartość 9: 
<div class="listing"><pre>var x:Number = 15; 
var y:Number = 9; 
trace(x &= y); // 9 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (iloczyn bitowy)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitowym XOR)</a></div></div><a name="bitwise_left_shift"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><<&nbsp;bitwise left shift</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &lt;&lt; shiftCount</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konwertuje wyrażenie <code>expression1</code> i <code>shiftCount</code> na 32-bitowe liczby całkowite, a następnie przesuwa wszystkie bity wartości <code>expression1</code> w lewo o liczbę pozycji określoną przez liczbę całkowitą będącą wynikiem konwersji wartości <code>shiftCount</code>. Pozycje bitowe opróżnione w wyniku tej operacji są wypełniane zerami, a bity wysunięte w lewo są usuwane. Przesunięcie wartości w lewo o jedną pozycję jest równoważne pomnożeniu jej przez 2. 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			<p>Jeśli wynik jest ujemną liczbą całkowitą, próba przypisania go do zmiennej typu <code>uint</code> spowoduje błąd w czasie wykonywania. Mimo że w języku ActionScript nie ma operatora „przesunięcia bitowego w lewo bez uwzględnienia znaku”, można uzyskać podobny efekt i uniknąć błędu w czasie wykonywania, stosując zapis <code>uint(expression1 &lt;&lt; shiftCount)</code>:</p>
			<div class="listing"><pre>
var num1:uint = 0xFF;
var num2:uint = uint(num1 &lt;&lt; 24); // uint() prevents runtime error</pre></div>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wartość ma być przesunięta w lewo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">shiftCount</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie liczba całkowita 1 jest przesuwana o 10 bitów w lewo:
<div class="listing"><pre>x = 1 &lt;&lt; 10</pre></div> Wynikiem przesunięcia bitowego w lewo jest wartość 1024. Wynika to z faktu, że 1 dziesiętnie równa się 1 dwójkowo, a dwójkowo zapisana liczba 1 przesunięta w lewo o 10 pozycji to 10000000000 w zapisie dwójkowym, czyli 1024 w zapisie dziesiętnym:
<pre>
   00000000001 binary 
<<          10 decimal
--------------
   10000000000 binary equals 1024 decimal 
</pre>
<p>W następującym przykładzie liczba całkowita 7 jest przesuwana o 8 bitów w lewo:</p> 
<div class="listing"><pre>x = 7 &lt;&lt; 8</pre></div> Wynikiem przesunięcia bitowego w lewo jest wartość 1792. Wynika to z faktu, że 7 dziesiętnie równa się 111 dwójkowo, a dwójkowo zapisana liczba 111 przesunięta w lewo o 8 pozycji to 11100000000 w zapisie dwójkowym, czyli 1792 w zapisie dziesiętnym:
<pre>
   00000000111 binary 
<<           8 decimal
--------------
   11100000000 binary equals 1792 decimal 
</pre>
<p>Poniższa instrukcja <code>trace</code> wykazuje, że bity zostały przesunięte o trzy pozycje w lewo: </p>
<div class="listing"><pre>// 1 binary == 0001 
// 8 binary == 1000 
trace(1 &lt;&lt; 3); // 8 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_left_shift_and_assignment" target=""><<= (przypisanie i przesunięcie bitowe w lewo)</a><br/><a href="operators.html#bitwise_right_shift" target="">>> (przesunięcie bitowe w prawo)</a><br/><a href="operators.html#bitwise_right_shift_and_assignment" target="">>>= (przypisanie i przesunięcie bitowe w prawo)</a><br/><a href="operators.html#bitwise_unsigned_right_shift" target="">>>> (przesunięcie bitowe w prawo bez znaku)</a><br/><a href="operators.html#bitwise_unsigned_right_shift_and_assignment" target="">>>>= (przypisanie i przesunięcie bitowe w prawo bez znaku)</a></div></div><a name="bitwise_left_shift_and_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><<=&nbsp;bitwise left shift and assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &lt;&lt;= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wykonuje przesunięcie bitowe w lewo (<code>&lt;&lt;=</code>) i przypisuje wynik w wyrażeniu <code>expression1</code>. Następujące dwa wyrażenia są równoważne: <pre>A <<= B
A = (A << B)</pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wartość ma być przesunięta w lewo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie zastosowano operator przesunięcia bitowego w lewo i przypisania (<<=) w celu przesunięcia wszystkich bitów o jedną pozycję w lewo: 
<div class="listing"><pre>var x:Number = 4; 
// Shift all bits one slot to the left. 
x &lt;&lt;= 1; 
trace(x); // 8 
// 4 decimal = 0100 binary 
// 8 decimal = 1000 binary </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_left_shift" target=""><< (przesunięcie bitowe w lewo)</a><br/><a href="operators.html#bitwise_right_shift" target="">>> (przesunięcie bitowe w prawo)</a><br/><a href="operators.html#bitwise_right_shift_and_assignment" target="">>>= (przypisanie i przesunięcie bitowe w prawo)</a></div></div><a name="bitwise_NOT"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">~&nbsp;bitwise NOT</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>~wyrażenie</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konwertuje wartość wyrażenia <code>expression</code> na 32-bitową liczbę całkowitą ze znakiem, a następnie wykonuje na niej operację bitowego dopełnienia do jedynek. Oznacza to, że każdy bit o wartości 0 jest w wyniku ustawiany na 1, a każdy bit o wartości 1 jest w wyniku ustawiany na 0. Wynik jest 32-bitową liczbą całkowitą ze znakiem. Ten operator jest nazywany także operatorem dopełnienia bitowego lub dopełnienia do jedynek. <p>Na przykład wartość szesnastkowa 0x7777 w zapisie dwójkowym ma postać:</p>
			<pre>0111011101110111</pre> 
			<p>Wynik negacji bitowej tej wartości szesnastkowej, ~0x7777, w zapisie dwójkowym ma postać:</p>
			<pre>1000100010001000</pre> 
			<p>W zapisie szesnastkowym jest to liczba 0x8888. A zatem ~0x7777 równa się 0x8888.</p> 
			<p>Operatory bitowe są stosowane najczęściej na wartościach zawierających bity flag (tj. wartości logiczne, z których każda zajmuje 1 bit). </p> 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba przeznaczona do konwersji.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora bitowego NOT (<code>~</code> na bitach flag: 
<div class="listing"><pre>var ReadOnlyFlag:int = 0x0001; // defines bit 0 as the read-only flag 
var flags:int = 0; 
trace(flags); 
/* To set the read-only flag in the flags variable, 
   the following code uses the bitwise OR: 
*/
flags |= ReadOnlyFlag; 
trace(flags); 
/* To clear the read-only flag in the flags variable, 
   first construct a mask by using bitwise NOT on ReadOnlyFlag. 
   In the mask, every bit is a 1 except for the read-only flag. 
   Then, use bitwise AND with the mask to clear the read-only flag. 
   The following code constructs the mask and performs the bitwise AND: 
*/ 
flags &= ~ReadOnlyFlag; 
trace(flags); 
// 0 1 0 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (bitowe AND)</a><br/><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitowym XOR)</a></div></div><a name="bitwise_OR"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">|&nbsp;bitwise OR</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 | expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i umieszcza 1 na wszystkich pozycjach bitowych, na których odpowiednie bity wyrażenia <code>expression1</code>, wyrażenia <code>expression2</code> lub obu tych wyrażeń są równe 1. 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje bitową operację OR (<code>|</code>): <div class="listing"><pre>// 15 decimal = 1111 binary 
var a:Number = 15; 
// 9 decimal = 1001 binary 
var b:Number = 9; 
// 1111 | 1001 = 1111 
trace(a | b); // returns 15 decimal (1111 binary) </pre></div>  Nie należy mylić pojedynczego symbolu <code>|</code> (bitowa operacja OR) z podwójnym symbolem <code>||</code> (logiczna operacja OR).
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (bitowe AND)</a><br/><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitowym XOR)</a></div></div><a name="bitwise_OR_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">|=&nbsp;bitwise OR assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 |= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 | expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
<pre>x |= y; 
x = x | y; </pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba przeznaczona do konwersji.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba przeznaczona do konwersji.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie użyto operatora bitowego OR i przypisania (<code>|=</code>): <div class="listing"><pre>// 15 decimal = 1111 binary 
var a:Number = 15; 
// 9 decimal = 1001 binary 
var b:Number = 9; 
// 1111 |= 1001 = 1111 
trace(a |= b); // returns 15 decimal (1111 binary) </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (bitowe AND)</a><br/><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitowym XOR)</a></div></div><a name="bitwise_right_shift"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>>&nbsp;bitwise right shift</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression &gt;&gt; shiftCount</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konwertuje wyrażenie <code>expression</code> i <code>shiftCount</code> na 32-bitowe liczby całkowite, a następnie przesuwa wszystkie bity wartości <code>expression</code> w prawo o liczbę pozycji określoną przez liczbę całkowitą będącą wynikiem konwersji wartości <code>shiftCount</code>. Bity wysunięte z prawej strony są usuwane. Aby zachowany został znak pierwotnego wyrażenia, bity po lewej stronie są wypełniane zerami, jeśli najbardziej znaczący (skrajny lewy) bit wartości <code>expression</code> jest równy 0, lub wypełniane jedynkami, jeśli najbardziej znaczący bit jest równy 1. Przesunięcie wartości o jedną pozycję w prawo jest równoznaczne z podzieleniem jej przez 2 i odrzuceniem reszty. 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wartość ma być przesunięta w prawo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">shiftCount</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następujący kod konwertuje wartość 65535 na 32-bitową liczbę całkowitą i przesuwa ją o 8 bitów w prawo; wynikiem tej operacji jest wartość 255: 
<div class="listing"><pre>var a:Number = 65535 &gt;&gt; 8; 
trace(a); // 255</pre></div> 
Wynika to z faktu, że dziesiętna liczba 65535 równa się 00000000000000001111111111111111 w zapisie dwójkowym (szesnaście zer, a po nich szesnaście jedynek); przesunięcie w prawo o 8 bitów powoduje odrzucenie 8 najmniej znaczących (skrajnych prawych) bitów. Ponieważ 65535 jest wartością dodatnią, pozycje bitowe zwolnione w wyniku przesunięcia (8 skrajnych lewych pozycji) są wypełniane zerami. Wynikiem jest liczba dwójkowa 00000000000000000000000011111111 (dwadzieścia cztery zera i osiem jedynek), która odpowiada 32-bitowej liczbie całkowitej 255.
<pre>
    00000000000000001111111111111111 binary (65535 decimal)
>>                                 8 decimal
--------------------
    00000000000000000000000011111111 binary (255 decimal)
</pre>
Następujący kod konwertuje wartość -8 na 32-bitową liczbę całkowitą i przesuwa ją o 1 bit w prawo; wynikiem tej operacji jest wartość -4:
<div class="listing"><pre>var a:Number = -8 &gt;&gt; 1;
trace(a); // -4</pre></div> 
Wynika to z faktu, że dziesiętna liczba -8 równa się 11111111111111111111111111111000 w zapisie dwójkowym (dwadzieścia dziewięć jedynek, a po nich trzy zera); przesunięcie w prawo o jeden bit powoduje odrzucenie najmniej znaczącego (skrajnego prawego) bitu. Ponieważ -8 jest wartością ujemną, pozycja bitowa zwolniona w wyniku przesunięcia (1 skrajna lewa pozycja) jest wypełniona jedynką. Wynikiem jest liczba dwójkowa 11111111111111111111111111111100 (trzydzieści jedynek i dwa zera), która odpowiada 32-bitowej liczbie całkowitej -4.
<pre>
    11111111111111111111111111111000 binary (-8 decimal)
>>							    1 decimal
--------------------
    11111111111111111111111111111100 binary (-4 decimal)
</pre>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_right_shift_and_assignment" target="">>>= (przypisanie z przesunięciem bitowym w prawo)</a></div></div><a name="bitwise_right_shift_and_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>>=&nbsp;bitwise right shift and assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression &gt;&gt;= shiftCount</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wykonuje operację bitowego przesunięcia w prawo i zapisuje wynik w wyrażeniu <code>expression</code>. 
			<p> Następujące dwie instrukcje są równoważne: </p> 
			<pre>A >>= B; 
A = (A >> B);</pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wartość ma być przesunięta w prawo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">shiftCount</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym kodzie użyto operatora przesunięcia bitowego w prawo i przypisania (<code>&gt;&gt;=</code>): 
<div class="listing"><pre>function convertToBinary(numberToConvert:Number):String { 
	var result:String = ""; 
	for (var i = 0; i &lt; 32; i++) { 
		// Extract least significant bit using bitwise AND. 
		var lsb:Number = numberToConvert & 1; 
		// Add this bit to the result.
		result = (lsb ? "1" : "0")+result; 
		// Shift numberToConvert right by one bit, to see next bit. 
		numberToConvert &gt;&gt;= 1; 
	} 
	return result; 
} 
trace(convertToBinary(479)); 
// Returns the string 00000000000000000000000111011111. 
// This string is the binary representation of the decimal number 479.</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_right_shift" target="">>> (przesunięcie bitowe w prawo)</a></div></div><a name="bitwise_unsigned_right_shift"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>>>&nbsp;bitwise unsigned right shift</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression &gt;&gt;&gt; shiftCount</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Działa tak samo jak operator przesunięcia bitowego w prawo (<code>&gt;&gt;</code>) poza tym, że nie zachowuje znaku pierwotnego wyrażenia, ponieważ bity po lewej stronie są zawsze wypełniane zerami. 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba bez znaku, a więc jest liczbą całkowitą z zakresu od 0 do 4294967295. </p>
			<p><b>Uwaga: </b> W języku ActionScript nie ma komplementarnego operatora „przesunięcia bitowego w lewo bez uwzględnienia znaku”, można uzyskać podobny efekt, stosując zapis <code>uint(expression &lt;&lt; shiftCount)</code>.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie do przesunięcia przesunięta w prawo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">shiftCount</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="uint.html">uint</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następujący kod konwertuje wartość -1 na 32-bitową liczbę całkowitą i przesuwa ją o 1 bit w prawo: 
<div class="listing"><pre>var a:Number = -1 &gt;&gt;&gt; 1; 
trace(a); // 2147483647 </pre></div> 
Wynik bierze się stąd, że dziesiętna liczba -1 w to zapisie dwójkowym 11111111111111111111111111111111 (trzydzieści dwie jedynki), a przesunięcie jej w prawo (bez zachowania znaku) o 1 pozycję bitową powoduje usunięcie najmniej znaczącego (skrajnego prawego) bitu i wypełnienie najbardziej znaczącego (skrajnego lewego) bitu zerem. Wynikiem jest dwójkowa liczba 01111111111111111111111111111111, która reprezentuje 32-bitową liczbę całkowitą 2147483647. 
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_right_shift" target="">>> (przesunięcie bitowe w prawo)</a><br/><a href="operators.html#bitwise_right_shift_and_assignment" target="">>>= (przypisanie i przesunięcie bitowe w prawo)</a></div></div><a name="bitwise_unsigned_right_shift_and_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>>>=&nbsp;bitwise unsigned right shift and assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression &gt;&gt;&gt;= shiftCount</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wykonuje operację bitowego przesunięcia w prawo bez zachowania znaku i zapisuje wynik w wyrażeniu <code>expression</code>. Następujące dwie instrukcje są równoważne: 
			<pre>A >>>= B; 
A = (A >>> B); </pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wartość ma być przesunięta w prawo.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">shiftCount</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, które da się przekonwertować na liczbę całkowitą z przedziału od 0 do 31.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="uint.html">uint</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następujący kod konwertuje wartość -1 na 32-bitową liczbę całkowitą i przesuwa ją o 1 bit w prawo: 
<div class="listing"><pre>var a:Number = -1;
a &gt;&gt;&gt;= 1; 
trace(a); // 2147483647 </pre></div> 
Wynik bierze się stąd, że dziesiętna liczba -1 w to zapisie dwójkowym 11111111111111111111111111111111 (trzydzieści dwie jedynki), a przesunięcie jej w prawo (bez zachowania znaku) o 1 pozycję bitową powoduje usunięcie najmniej znaczącego (skrajnego prawego) bitu i wypełnienie najbardziej znaczącego (skrajnego lewego) bitu zerem. Wynikiem jest dwójkowa liczba 01111111111111111111111111111111, która reprezentuje 32-bitową liczbę całkowitą 2147483647. 
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_unsigned_right_shift" target="">>>> (przesunięcie bitowe w prawo bez znaku)</a><br/><a href="operators.html#bitwise_right_shift_and_assignment" target="">>>= (przypisanie z przesunięciem bitowym w prawo)</a></div></div><a name="bitwise_XOR"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">^&nbsp;bitwise XOR</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 ^ expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konwertuje wyrażenia <code>expression1</code> i <code>expression2</code> na 32-bitowe liczby całkowite bez znaku i umieszcza 1 na wszystkich pozycjach bitowych, na których odpowiednie bity jednego z wyrażeń, <code>expression1</code> albo <code>expression2</code>, (ale nie obu) są równe 1. 
			<p>Liczba zmiennopozycyjna jest konwertowana na całkowitą poprzez usunięcie cyfr po kropce dziesiętnej. Dodatnia liczba całkowita jest konwertowana na liczbę szesnastkową bez znaku o maksymalnej wartości 4294967295 lub 0xFFFFFFFF; w wartościach większych od maksymalnej cyfry najbardziej znaczące są usuwane podczas konwersji, tak aby wartości były zawsze 32-bitowe. Liczba ujemna jest konwertowana na liczbę szesnastkową bez znaku przy wykorzystaniu notacji dopełnienia do dwóch, z minimalną wartością -2147483648 lub 0x800000000; liczby mniejsze od minimalnej wartości są konwertowane do wartości z dopełnieniem do dwóch o większej precyzji, a następnie najbardziej znaczące cyfry są usuwane. </p> 
			<p>Wynik jest interpretowany jako 32-bitowa liczba z dopełnieniem do dwóch, a więc jest liczbą całkowitą z zakresu od -2147483648 do 2147483647. </p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie operator bitowy XOR jest stosowany na liczbach dziesiętnych 15 i 9 po czym wynik przypisywany jest zmiennej <code>a</code>: 
<div class="listing"><pre>// 15 decimal = 1111 binary 
// 9 decimal = 1001 binary 
var a:Number = 15 ^ 9; 
trace(a); 
// 1111 ^ 1001 = 0110 
// returns 6 decimal (0110 binary) </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (bitowe AND)</a><br/><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR_assignment" target="">^= (przypisanie z bitową operacją XOR)</a></div></div><a name="bitwise_XOR_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">^=&nbsp;bitwise XOR assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 ^= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 ^ expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
			<pre>x ^= y 
x = x ^ y </pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="int.html">int</a></code> &mdash; 
				Wynik operacji bitowej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje operację przypisania wyniku bitowej operacji XOR (^=): <div class="listing"><pre>// 15 decimal = 1111 binary 
var a:Number = 15; 
// 9 decimal = 1001 binary 
var b:Number = 9; 
trace(a ^= b); // returns 6 decimal (0110 binary) </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#bitwise_AND" target="">& (bitowe AND)</a><br/><a href="operators.html#bitwise_AND_assignment" target="">&= (przypisanie z bitowym AND)</a><br/><a href="operators.html#bitwise_NOT" target="">~ (bitowe NOT)</a><br/><a href="operators.html#bitwise_OR" target="">| (suma bitowa)</a><br/><a href="operators.html#bitwise_OR_assignment" target="">|= (przypisanie z bitowym OR)</a><br/><a href="operators.html#bitwise_XOR" target="">^ (bitowe XOR)</a></div></div><a name="block_comment_delimiter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">/*..*/&nbsp;block comment delimiter</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>/* comment */</pre> <pre>/* comment</pre> <pre>   comment */</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Stanowi ogranicznik jednego lub wielu wierszy komentarza w skrypcie. Znaki między ogranicznikiem otwierającym (<code>/*</code>) a ogranicznikiem zamykającym (<code>*/</code>) są interpretowane jako komentarz i ignorowane przez kompilator języka ActionScript. Tych ograniczników należy używać do oznaczania komentarzy zajmujących wiele kolejnych wierszy; do oznaczania komentarzy jednowierszowych należy używać ogranicznika <code>//</code>. 
			<p>Pominięcie ogranicznika zamykającego blok komentarza (<code>*/</code>) lub próba zagnieżdżenia komentarza spowoduje zgłoszenie błędu. Pierwszy ogranicznik zamykający (<code>*/</code>) po ograniczniku otwierającym (<code>/*</code>) kończy komentarz, niezależnie od liczby umieszczonych przed nim ograniczników otwierających.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">comment</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Dowolne znaki.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Na początku poniższego skryptu zastosowano ograniczniki bloku komentarza: 
<div class="listing"><pre>/* records the X and Y positions of 
the ball and bat movie clips */ 
var ballX:Number = ball_mc._x; 
var ballY:Number = ball_mc._y; 
var batX:Number = bat_mc._x; 
var batY:Number = bat_mc._y; </pre></div> Następująca próba zagnieżdżenia komentarzy spowoduje wyświetlenie komunikatu o błędzie: 
<div class="listing"><pre>/* This is an attempt to nest comments. 
/* But the first closing tag will be paired 
with the first opening tag */ 
and this text will not be interpreted as a comment */ </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#line_comment_delimiter" target="">// (ogranicznik komentarza jednowierszowego)</a></div></div><a name="braces_(XML)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">{ }&nbsp;braces (XML)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> myXML = <{tagName} {attributeName} = {attributeValue}>{content}</{tagName}></pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia używanego do inicjowania obiektu XML lub XMLList. Wartość inicjująca obiekt XML lub XMLList to wartość literalna przypisywana zmiennej typu XML lub XMLList. Wyrażenie ograniczone operatorami XML <code>{</code>and<code>}</code> może być użyte do inicjowania obiektu XML lub XMLList zamiast literalnych nazw lub wartości. W miejsce parametrów <code>tagName</code>, <code>attributeName</code>, <code>attributeValue</code> i <code>content</code> można używać wyrażeń.

			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">tagName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest nazwą znacznika XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">attributeName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest nazwą atrybutu XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">attributeValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest wartością atrybutu XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">content</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest zawartością znacznika XML.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatorów { i } do definiowania literału klasy XML:
<div class="listing"><pre>var tagname:String = "item"; 
var attributename:String = "id"; 
var attributevalue:String = "5"; 
var content:String = "Chicken"; 
var x:XML = &lt;{tagname} {attributename}={attributevalue}&gt;{content}&lt;/{tagname}&gt;; 
trace(x.toXMLString()); // &lt;item id="5"&gt;Chicken&lt;/item&gt;</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a></div></div><a name="brackets_(XML)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">[ ]&nbsp;brackets (XML)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> myXML[expression]</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Umożliwia dostęp do właściwości lub atrybutu obiektu XML lub XMLList. Operator nawiasów kwadratowych umożliwia uzyskanie dostępu do właściwości o nazwach, które są niedostępne za pośrednictwem operatora kropki (<code>.</code>).

			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest nazwą znacznika lub atrybutu XML.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatorów <code>[</code>and<code>]</code> do uzyskania dostępu do właściwości XML, która nie jest dostępna za pośrednictwem operatora kropki z uwagi na obecność łącznika w nazwie znacznika:
<div class="listing"><pre>
var myXML:XML = &lt;a&gt;&lt;foo-bar&gt;44&lt;/foo-bar&gt;&lt;/a&gt;;
trace(myXML["foo-bar"]);
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a></div></div><a name="comma"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">,&nbsp;comma</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>(expression1, expression2[, expressionN... ])</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia <code>expression1</code>, następnie <code>expression2</code> i tak dalej. Ten operator jest używany przede wszystkim w instrukcji pętli <code>for</code>, często razem z operatorem nawiasów <code>()</code>.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość ma zostać wyznaczona.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość ma zostać wyznaczona.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expressionN</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Dowolna liczba dodatkowych wyrażeń, których wartość ma być wyznaczona.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Object.html">Object</a></code> &mdash; 
				Wyznaczone wartości wyrażeń.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie operator przecinka (<code>,</code>) zastosowano w pętli <code>for</code>: 
<div class="listing"><pre>for (i = 0, j = 0; i &lt; 3 && j &lt; 3; i++, j+=2) { 
	trace("i = " + i + ", j = " + j); 
} 
// output: 
// i = 0, j = 0 
// i = 1, j = 2</pre></div> 
W poniższym przykładzie zastosowano operator przecinka bez operatora nawiasów, aby zademonstrować, że operator przecinka ma niższy priorytet niż operator przypisania (<code>=</code>): 
<div class="listing"><pre>var v:Number = 0; 
v = 4, 5, 6; 
trace(v); // 4 </pre></div> 
W poniższym przykładzie użyto operatora przecinka z nawiasami, aby zilustrować fakt, że operator ten zwraca wartość ostatniego wyrażenia: 
<div class="listing"><pre>var v:Number = 0; 
v = (4, 5, 6); 
trace(v); // 6 </pre></div> 
W poniższym przykładzie użyto operatora przecinka bez nawiasów, aby zilustrować fakt, że operator ten powoduje sekwencyjne wyznaczenie wartości wszystkich wyrażeń. Pierwsze wyrażenie, <code>v + 4</code>, jest przypisywane do zmiennej <code>v</code>, ponieważ operator przypisania (=) ma wyższy priorytet niż operator przecinka. Wyznaczana jest wartość drugiego wyrażenia, <code>z++</code>, i zmienna <code>z</code> jest inkrementowana o jeden. 
<div class="listing"><pre>var v:Number = 0; 
var z:Number = 0; 
v = v + 4 , z++, v + 6; 
trace(v); // 4 
trace(z); // 1 </pre></div> 
Poniższy przykład jest identyczny z poprzednim, z tym że dodano nawiasy, które zmieniają kolejność wykonywania operacji w taki sposób, że operator przecinka zyskuje wyższy priorytet niż przypisanie (<code>=</code>): 
<div class="listing"><pre>var v:Number = 0; 
var z:Number = 0; 
v = (v + 4, z++, v + 6); 
trace(v); // 6 
trace(z); // 1 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#parentheses" target="">() (nawiasy)</a></div></div><a name="concatenation"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+&nbsp;concatenation</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 + expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przeprowadza konkatenację (połączenie) ciągów. Jeśli jedno wyrażenie jest ciągiem znaków, wszystkie pozostałe wyrażenia są konwertowane na ciągi znaków i konkatenowane. 
			<p>Jeśli oba wyrażenia są liczbami, operator ten działa tak samo, jak operator dodawania.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="String.html">String</a></code> &mdash; 
					Ciąg, który ma zostać skonkatenowany.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="String.html">String</a></code> &mdash; 
					Ciąg, który ma zostać skonkatenowany.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="String.html">String</a></code> &mdash; 
				Wynikowy skonkatenowany ciąg.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje konkatenację dwóch ciągów. 
<div class="listing"><pre>
var lastName:String = "Cola"; 
var instrument:String = "Drums"; 
trace(lastName + " plays " + instrument); // Cola plays Drums </pre></div>
Ten przykład demonstruje, że jeśli jedno wyrażenie jest ciągiem, wszystkie pozostałe wyrażenia są konwertowane na ciągi i konkatenowane:
<div class="listing"><pre>
trace("Number " + 8 + 0); // Number 80</pre></div>
Poniższy przykład demonstruje, że sumy liczbowe po prawej stronie wyrażenia będącego ciągiem znaków nie są obliczane, ponieważ zostają przekonwertowane na ciągi znaków:
<div class="listing"><pre>var a:String = 3 + 10 + "asdf"; 
trace(a); // 13asdf 
var b:String = "asdf" + 3 + 10; 
trace(b); // asdf310 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#addition" target="">+ (dodawanie)</a></div></div><a name="concatenation_(XMLList)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+&nbsp;concatenation (XMLList)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>expression1 + expression2</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Konkatenuje (łączy) wartości XML lub XMLList w obiekt klasy XMLList. Wynikiem konkatenacji jest obiekt XMLList pod warunkiem, że oba operandy są wartościami klasy XML lub XMLList.
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość XML lub XMLList.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="XMLList.html">XMLList</a></code> &mdash; 
				Skonkatenowany obiekt XMLList.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora konkatenacji (<code>+</code>) do obiektu XMLList:
<div class="listing"><pre>var x1:XML = 
		&lt;employee id = "42"&gt;
			&lt;firstName&gt;Joe&lt;/firstName&gt;
			&lt;lastName&gt;Smith&lt;/lastName&gt;
		&lt;/employee&gt;;

var x2:XML = 
		&lt;employee id = "43"&gt;
			&lt;firstName&gt;Susan&lt;/firstName&gt;
			&lt;lastName&gt;Jones&lt;/lastName&gt;
		&lt;/employee&gt;;

var myXMLList:XMLList = x1 + x2;
	
trace(myXMLList.toXMLString()); 
</pre></div>
<p>Instrukcja <code>trace</code> wygeneruje następujące wyniki:</p>
<pre><code>&lt;employee id = "42"&gt;
	&lt;firstName&gt;Joe&lt;/firstName&gt;
	&lt;lastName&gt;Smith&lt;/lastName&gt;
&lt;/employee&gt;
&lt;employee id = "43"&gt;
	&lt;firstName&gt;Susan&lt;/firstName&gt;
	&lt;lastName&gt;Jones&lt;/lastName&gt;
&lt;/employee&gt;
	
</code></pre>
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XMLList.html" target="">Klasa XMLList</a><br/><a href="package.html#XMLList()" target="">Funkcja globalna XMLList</a></div></div><a name="concatenation_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+=&nbsp;concatenation assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 += expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 + expression2</code>. Na przykład następujące dwie instrukcje odniosą ten sam skutek: <pre>x += y; 
x = x + y;</pre>Wszystkie reguły obowiązujące dla operatora konkatenacji (<code>+</code>) obowiązują również dla operatora przypisania po konkatenacji (<code>+=</code>). Należy zwrócić uwagę, że przypisanie po konkatenacji do właściwości <code>text</code> obiektu <code>TextField</code> (tj. <code>someTextField.text += moreText</code>) działa znacznie wolniej niż funkcja <code>TextField.appendText()</code>, zwłaszcza gdy obiekt <code>TextField</code> zawiera tekst o znacznej objętości.
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="String.html">String</a></code> &mdash; 
					Ciąg.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="String.html">String</a></code> &mdash; 
					Ciąg.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik konkatenacji.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W tym przykładzie operator <code>+=</code> został zastosowany razem z wyrażeniem typu String:
<div class="listing"><pre>var x1:String = "My name is "; 
x1 += "Gilbert"; 
trace(x1); // My name is Gilbert </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#concatenation" target="">+ (konkatenacja)</a></div></div><a name="concatenation_assignment_(XMLList)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">+=&nbsp;concatenation assignment (XMLList)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>expression1 += expression2</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> (które jest obiektem XMLList) wartość <code>expression1 + expression2</code>. Na przykład następujące dwie instrukcje odniosą ten sam skutek: 
<pre>x += y; 
x = x + y; </pre>Wszystkie reguły obowiązujące dla operatora konkatenacji do obiektu XMLList (<code>+</code>) obowiązują również dla operatora przypisania po konkatenacji do obiektu XMLList (<code>+=</code>).
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="XMLList.html">XMLList</a></code> &mdash; 
					Obiekt XMLList, do którego jest dodawana nowa wartość.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość XML lub XMLList.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora konkatenacji i przypisania (<code>+=</code>) do obiektu XMLList:
<div class="listing"><pre>var x1:XML = &lt;location&gt;Athens&lt;/location&gt;;	
var x2:XML = &lt;location&gt;Paris&lt;/location&gt;;		
myXMLList = x1 + x2;

var x3:XML = &lt;location&gt;Springfield&lt;/location&gt;;
myXMLList += x3;
		    
trace(myXMLList.toXMLString());</pre></div>
<p>Instrukcja <code>trace</code> wygeneruje następujące wyniki:</p>
<pre><code>&lt;location&gt;Athens&lt;/location&gt;
	
&lt;location&gt;Paris&lt;/location&gt;	

&lt;location&gt;Springfield&lt;/location&gt;</code></pre>
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a><br/><a href="package.html#XML()" target="">Funkcja globalna XML()</a><br/><a href="package.html#XMLList()" target="">Funkcja globalna XMLList()</a></div></div><a name="conditional"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">?:&nbsp;conditional</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>expression1 ? expression2 : expression3</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia <code>expression1</code> i jeśli wyrażenie <code>expression1</code> jest równe <code>true</code>, wynikiem jest wartość <code>expression2</code>; w przeciwnym razie wynikiem jest wartość <code>expression3</code>.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 
					Wyrażenie, którego wyznaczona wartość należy do typu Boolean; zwykle wyrażenie porównania, takie jak <code>x &lt; 5</code>.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression3</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość wyrażenia <code>expression2</code> albo wyrażenia <code>expression3</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższa instrukcja przypisuje wartość zmiennej <code>x</code> do zmiennej <code>z</code>, ponieważ wynikiem pierwszego wyrażenia jest <code>true</code>: 
<div class="listing"><pre>var x:Number = 5; 
var y:Number = 10; 
var z = (x &lt; 6) ? x: y; 
trace(z); // returns 5</pre></div> Poniższy przykład ilustruje skróconą postać instrukcji warunkowej: 
<div class="listing"><pre>var timecode:String = (new Date().getHours() &lt; 11) ? "AM" : "PM"; 
trace(timecode); </pre></div> Tę samą instrukcję warunkową można także zapisać w dłuższej postaci, co ilustruje poniższy przykład: 
<div class="listing"><pre>if (new Date().getHours() &lt; 11) { 
	var timecode:String = "AM"; 
} else { 
	var timecode:String = "PM"; 
}
trace(timecode); </pre></div>
			<p></p></div><a name="decrement"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">--&nbsp;decrement</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>--expression</pre> <pre>expression--</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Odejmuje 1 od operandu. Operand może być zmienną, elementem tablicy lub właściwością obiektu. Operator w formie dekrementacji poprzedzającej (<code>--expression</code>) odejmuje 1 od wartości <code>expression</code> i zwraca wynik. Operator w formie dekrementacji następującej (<code>expression--</code>) odejmuje 1 od wartości <code>expression</code> i zwraca pierwotną wartość wyrażenia <code>expression</code> (tj. jego wartość przed odejmowaniem).</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub zmienna, której wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynikowa wartość po dekrementacji.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Operator dekrementacji w postaci poprzedzającej dekrementuje <code>x</code> do wartości 2 (<code>x</code> - <code>1 = 2</code>) i zwraca wynik jako <code>y</code>: 
<div class="listing"><pre>var x:Number = 3; 
var y:Number = --x; // y is equal to 2</pre></div> 
Operator dekrementacji w postaci następującej dekrementuje <code>x</code> do wartości 2 (<code>x</code> - <code>1 = 2</code>) i zwraca pierwotną wartość <code>x</code> jako wynik <code>y</code>: 
<div class="listing"><pre>var x:Number = 3; 
var y:Number = x--; // y is equal to 3</pre></div> 
Poniższy przykład zawieraj pętlę odliczającą od 10 do 1; w każdej iteracji pętli wartość zmiennej licznikowej <code>i</code> jest zmniejszana o 1:
<div class="listing"><pre>for (var i = 10; i &gt; 0; i--) { 
	trace(i); 
}</pre></div>
			<p></p></div><a name="delete"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;delete</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> delete reference</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Niszczy właściwość obiektu określoną przez operand <code>reference</code>; wynikiem jest wartość <code>true</code>, jeśli właściwość nie istnieje po ukończeniu operacji, albo wartość <code>false</code> w przeciwnym wypadku. Operator <code>delete</code> zwraca wartość <code>true</code>, jeśli zostanie wywołany na nieistniejącej właściwości lub właściwości dynamicznej niezdefiniowanej w klasie. 
			<p>Działanie operatora <code>delete</code> może zakończyć się niepowodzeniem i zwróceniem wartości <code>false</code>, jeśli parametr <code>reference</code> określa właściwość, której nie można usunąć. Nie można usuwać właściwości ustalonych ani zmiennych zadeklarowanych za pomocą instrukcji <code>var</code>. Właściwość ustalona jest to zmienna lub metoda zdefiniowana w definicji klasy.	</p>
			<p>Operatora <code>delete</code> nie można używać do niszczenia właściwości klas innych niż dynamiczne klasy dodane w czasie wykonywania. Za pomocą operatora <code>delete</code> nie można niszczyć właściwości klas zapieczętowanych. Zamiast tego należy przypisać właściwości wartość <code>null</code>.</p>
			<p><b>Uwaga:</b> Nie jest możliwe usunięcie obiektu, ale usuwając wszystkie odwołania do obiektu, można spowodować uwzględnienie go w procesie czyszczenia pamięci. Najczęściej spotykanym rodzajem odwołania do obiektu jest zmienna, która na niego wskazuje. Takie odwołanie można usunąć, przypisując zmiennej wartość <code>null</code>. Proces czyszczenia pamięci usuwa z pamięci wszelkie obiekty, do których nie ma odwołań.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">reference</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Nazwa właściwości, którą należy wyeliminować.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli usuwanie się powiodło, albo <code>false</code>, jeśli się nie powiodło.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie usuwana jest właściwość obiektu:
<div class="listing"><pre>// create the new object "account" 
var account:Object = new Object(); 
// assign property name to the account 
account.name = "Jon"; 
// delete the property 
delete account.name; 
trace(account.name); // undefined

// delete a nonexistent property
var fooDeleted:Boolean = delete account.foo;
trace(fooDeleted); // true
</pre></div> 
<p>Poniższy przykładowy kod usuwa element tablicy, ale wartość właściwości <code>length</code> nie ulega zmianie:</p> 
<div class="listing"><pre>
var my_array:Array = new Array(); 
my_array[0] = "abc"; // my_array.length == 1 
my_array[1] = "def"; // my_array.length == 2 
my_array[2] = "ghi"; // my_array.length == 3 
// my_array[2] is deleted, but Array.length is not changed 
delete my_array[2]; 
trace(my_array.length); // 3 
trace(my_array); // abc,def,</pre></div> 

<p>Poniższy przykład ilustruje, w jaki sposób wartość Boolean zwrócona przez operator <code>delete</code> może posłużyć jako warunek w dalszym wykonaniu kodu. Należy zwrócić uwagę, że jeśli element został już usunięty, wywołanie <code>delete</code> na tym elemencie ponownie zwróci wartość <code>false</code>.</p> <div class="listing"><pre>
var my_array:Array = [ "abc", "def", "ghi" ];
var deleteWasSuccessful:Boolean

deleteWasSuccessful = delete my_array[0];
if(deleteWasSuccessful) delete my_array[1];
deleteWasSuccessful = delete my_array[0];
if(deleteWasSuccessful) delete my_array[2];

trace(my_array) // outputs: undefined,undefined,ghi</pre></div>
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#var" target="">var</a></div></div><a name="delete_(XML)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;delete (XML)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> delete reference</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Usuwa elementy lub atrybuty XML określone przez parametr <code>reference</code>.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">reference</span>:<a href="XMLList.html">XMLList</a></code> &mdash; 
					Obiekt XMLList określający elementy lub atrybuty XML przeznaczone do usunięcia.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Zawsze zwraca wartość <code>true</code>. Wynikiem jest zawsze wartość <code>true</code>, ponieważ operand typu XMLList zawsze odwołuje się do poprawnego (lecz potencjalnie pustego) obiektu XMLList.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje usunięcie atrybutu, następnie pojedynczego elementu, a następnie wielu elementów:

<div class="listing"><pre> 
var x1:XML = &lt;x1&gt;
				&lt;a id = "52"&gt;AYY&lt;/a&gt;
				&lt;a&gt;AYY 2 &lt;/a&gt;
				&lt;b&gt;BEE&lt;/b&gt;
				&lt;c&gt;CEE&lt;/c&gt;
			&lt;/x1&gt;;

trace(x1.toXMLString());
trace("___________");

delete x1.a.@id;

trace(x1.toXMLString());
trace("___________");

delete x1.b;

trace(x1.toXMLString());
trace("___________");

delete x1.a;

trace(x1.toXMLString());</pre></div>

<p>Wynik będzie następujący:</p>

<pre><code>&lt;x1&gt;
  &lt;a id="52"&gt;AYY&lt;/a&gt;
  &lt;a&gt;AYY 2&lt;/a&gt;
  &lt;b&gt;BEE&lt;/b&gt;
  &lt;c&gt;CEE&lt;/c&gt;
&lt;/x1&gt;
___________
&lt;x1&gt;
  &lt;a&gt;AYY&lt;/a&gt;
  &lt;a&gt;AYY 2&lt;/a&gt;
  &lt;b&gt;BEE&lt;/b&gt;
  &lt;c&gt;CEE&lt;/c&gt;
&lt;/x1&gt;
___________
&lt;x1&gt;
  &lt;a&gt;AYY&lt;/a&gt;
  &lt;a&gt;AYY 2&lt;/a&gt;
  &lt;c&gt;CEE&lt;/c&gt;
&lt;/x1&gt;
___________
&lt;x1&gt;
  &lt;c&gt;CEE&lt;/c&gt;
&lt;/x1&gt;
</code></pre>
			
			<p></p>Poniższy przykład ilustruje sposób usunięcia całej zawartości elementu, łącznie z atrybutami i elementami potomnymi, bez usuwania samego elementu:

<div class="listing"><pre> 
var xml:XML = 
			&lt;order&gt;
				&lt;item id="121"&gt;hamburger&lt;/item&gt;
				&lt;item id="122"&gt;fries&lt;/item&gt;
				&lt;item id="123"&gt;chocolate shake&lt;/item&gt;
			&lt;/order&gt;;
delete xml.item[1].*;
delete xml.item[1].@*;
trace(xml);
</pre></div>
<p>Wynik działania tego kodu przykładowego jest następujący:</p>	
<pre><code>&lt;order&gt;
  &lt;tem id="121"&gt;hamburger&lt;/item&gt;
  &lt;item/&gt;
  &lt;item id="123"&gt;chocolate shake&lt;/item&gt;
&lt;/order&gt;</code></pre>
			
			<p></p></div><a name="descendant_accessor"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">..&nbsp;descendant accessor</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> myXML..childElement1..@attributeName </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Powoduje przejście do elementów potomnych obiektu XML lub XMLList albo (w połączeniu z operatorem @) znajduje dopasowane atrybuty elementów potomnych. Dopasowane elementy lub atrybuty nie muszą być bezpośrednimi potomkami obiektu XML lub XMLList; mogą znajdować się niżej w hierarchii (np. być potomkami drugiego rzędu, tj. „wnukami”). Wynikiem jest obiekt klasy XMLList, ponieważ możliwe jest dopasowanie więcej niż jednego elementu potomnego lub atrybutu. 
			
			<p>Kolejność węzłów w zwróconym obiekcie XMLList wynika z przejścia przez elementy począwszy od najgłębiej położonego. Przykład:</p>
			
<div class="listing"><pre>var myXML:XML = &lt;a&gt;
			&lt;b&gt;one
				&lt;c&gt; 
					&lt;b&gt;two&lt;/b&gt; 
				&lt;/c&gt; 
			&lt;/b&gt;
			&lt;b&gt;three&lt;/b&gt;
		&lt;/a&gt;;

trace(myXML..b[0].toXMLString());
trace("______________");
trace(myXML..b[1].toXMLString());
trace("______________");
trace(myXML..b[2].toXMLString());</pre></div>

<p>Uzyskane wyniki byłyby następujące:</p>

<pre><code>&lt;b&gt;
  one
  &lt;c&gt;
    &lt;b&gt;two&lt;/b&gt;
  &lt;/c&gt;
&lt;/b&gt;
______________
&lt;b&gt;two&lt;/b&gt;
______________
&lt;b&gt;three&lt;/b&gt;
</code></pre>

<p>Aby zwrócić wszystkie obiekty potomne o nazwach zgodnych z wyrazem zastrzeżonym w narzędziu ActionScript, należy użyć metody <code>XML.descendants()</code> zamiast operatora descendant (..), co ilustruje następujący przykład: </p>

<div class="listing"><pre>
var xml:XML = 
&lt;enrollees&gt;
	&lt;student id="239"&gt;
		&lt;class name="Algebra" /&gt;
 		&lt;class name="Spanish 2"/&gt;
	&lt;/student&gt;
	&lt;student id="206"&gt;
		&lt;class name="Trigonometry" /&gt;
 		&lt;class name="Spanish 2" /&gt;
	&lt;/student&gt;
 &lt;/enrollees&gt;;
 trace(xml.descendants("class")); 
 </pre></div>
			
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">childElement1_or_attributeName</span></code> &mdash; 
					Nazwa właściwości XML lub nazwa atrybutu.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora dostępu do elementów potomnych (..) w celu zwrócenia elementów potomnych obiektu XML oraz atrybutu elementu:
<div class="listing"><pre>var myXML:XML = 
	&lt;employees&gt;
		&lt;employee id = "42"&gt;
			&lt;firstName&gt;Billy&lt;/firstName&gt;
			&lt;lastName&gt;Einstein&lt;/lastName&gt;
		&lt;/employee&gt;
		&lt;employee id = "43"&gt;
			&lt;firstName&gt;Sally&lt;/firstName&gt;
			&lt;lastName&gt;Shostakovich&lt;/lastName&gt;
		&lt;/employee&gt;
	&lt;/employees&gt;
	
trace(myXML..firstName); 
	// &lt;firstName&gt;Billy&lt;/firstName&gt;
	// &lt;firstName&gt;Sally&lt;/firstName&gt;
				
trace(myXML..@id); //4243</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a><br/><a href="XML.html#descendants()" target="">XML.descendants()</a></div></div><a name="division"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">/&nbsp;division</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 / expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Dzieli wartość <code>expression1</code> przez wartość <code>expression2</code>. Wynikiem dzielenia jest liczba zmiennopozycyjna o podwójnej precyzji.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub zmienna, której wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Zmiennopozycyjny wynik operacji.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład demonstruje, że wyniki dzielenia przez 0 są różne w zależności od tego, czy dzielna jest dodatnia, ujemna, czy równa 0.
<div class="listing"><pre>trace(3/0);   // Infinity
trace(-3/0);  // -Infinity
trace(0/0);   // NaN</pre></div> 
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#modulo" target="">% (modulo)</a></div></div><a name="division_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">/=&nbsp;division assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 /= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 / expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
<pre>x /= y; 
x = x / y;</pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub zmienna, której wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub zmienna, której wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Liczba.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy kod ilustruje użycie operatora przypisania wyniku dzielenia (<code>/=</code>) ze zmiennymi i liczbami: 
<div class="listing"><pre>var a:Number = 10; 
var b:Number = 2; 
a /= b; trace(a); // 5 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#division" target="">/ (dzielenie)</a></div></div><a name="dot"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">.&nbsp;dot</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>object.property_or_method</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Umożliwia dostęp do zmiennych i metod oraz pobieranie i ustawianie właściwości obiektów, a także stanowi ogranicznik importowanych pakietów i klas.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; 
					Instancja klasy. Operand object może być instancją dowolnej klasy wbudowanej języka ActionScript lub klasy zdefiniowanej przez użytkownika. Ten operand znajduje się zawsze po lewej stronie operatora kropki (.).
				</td></tr><tr><td width="20px"></td><td><code><span class="label">property_or_method</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Nazwa właściwości lub metody skojarzonej z obiektem. Wszystkie poprawne metody i właściwości klas wbudowanych są wymienione w tabelach podsumowań metod i właściwości tych klas. Ten operand znajduje się zawsze po prawej stronie operatora kropki (.).
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Zmienna, metoda lub właściwość, której nazwa znajduje się po prawej stronie kropki.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie operatora kropki użyto jako ogranicznika przy importowaniu klasy Timer.
<div class="listing"><pre>import flash.utils.Timer;</pre></div> 
W poniższym przykładzie tworzony jest obiekt ogólny, a operator kropki został użyty do dodania nowej właściwości.
<div class="listing"><pre>var obj:Object = new Object();
obj.propertyA = "hello";
trace(obj.propertyA);  // hello</pre></div> 
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#dot_(XML)" target="">operator kropki (XML)</a></div></div><a name="dot_(XML)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">.&nbsp;dot (XML)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>myXML.childElement
myXML.@attributeName </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Powoduje przejście do elementów potomnych obiektu XML lub XMLList albo (w połączeniu z operatorem @) zwraca atrybuty obiektu XML lub XMLList. Zwrócony obiekt należy do klasy XMLList, ponieważ możliwe jest dopasowanie więcej niż jednego elementu potomnego lub atrybutu. 
			<p>Aby zwrócić elementy z nazwami dopasowanymi do słów zastrzeżonych języka ActionScript, należy użyć metody <code>XML.elements()</code> lub metody <code>XML.descendants()</code>, a nie operatora kropki (.), co ilustruje następujący przykład: </p>
			
<div class="listing"><pre>
var xml:XML = 
	&lt;student id="206"&gt;
		&lt;class name="Trigonometry" /&gt;
		&lt;class name="Spanish 2" /&gt;
	&lt;/student&gt;;
trace(xml.elements("class"));
trace(xml.descendants("class")); 
</pre></div>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">childElement</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Nazwa właściwości XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">attributeName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Nazwa atrybutu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="XMLList.html">XMLList</a></code> &mdash; 
				Określony obiekt XMLList.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatora kropki (.) do zwrócenia elementu potomnego obiektu XML oraz atrybutu elementu:
<div class="listing"><pre>var myXML:XML = 
	&lt;employee id = "42"&gt;
		&lt;firstName&gt;Billy&lt;/firstName&gt;
		&lt;lastName&gt;Einstein&lt;/lastName&gt;
	&lt;/employee&gt;;

trace(myXML.firstName); // Billy
trace(myXML.@id);       // 42
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a><br/><a href="XML.html#descendants()" target="">XML.descendants()</a><br/><a href="XML.html#elements()" target="">XML.elements()</a></div></div><a name="equality"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">==&nbsp;equality</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 == expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy dwa wyrażenia są równe. Wynikiem jest wartość <code>true</code>, jeśli wyrażenia są równe. 
			<p>Jeśli typy danych obu operandów są identyczne, definicja równości zależy od typu danych operandów:</p> 
			<ul> 
			  <li>Wartości typu int, uint i Boolean są uznawane za równe, jeśli mają te same wartości.</li> 
			  <li>Liczby o takich samych wartościach są uznawane za równe, chyba że obie mają wartość <code>NaN</code>.</li>
			  <li>Jeśli oba operandy mają wartość <code>null</code> lub <code>undefined</code>, są uznawane za równe.</li>
			  <li>Wyrażenia typu String są równe, jeśli mają tę samą liczbę znaków i znaki na odpowiednich pozycjach są identyczne.</li> 
			  <li>W przypadku obiektów XML:
			    <ul>
				<li>Jeśli jeden operand jest tekstem lub węzłem atrybutu, a drugi ma treść prostą, oba operandy są konwertowane na ciągi znaków za pomocą metody <code>toString()</code> i są uznawane za równe, jeśli wynikowe ciągi znaków są równe. </li>
				<li>W przeciwnym razie obiekty są uznawane za równe tylko wówczas, gdy oba obiekty mają takie same nazwy kwalifikowane, atrybuty i właściwości potomne.</li>
			    </ul>
			  </li>
			  <li>Obiekty XMLList są uznawane za równe, jeśli mają tę samą liczbę właściwości, a kolejność i wartości tych właściwości są takie same.</li>
			  <li>Wartości obiektów typu Namespace są uznawane za równe, jeśli właściwości <code>uri</code> obu obiektów są równe.</li>
			  <li>Wartości typu QName są uznawane za równe, jeśli odpowiednio właściwości <code>uri</code> oraz <code>localName</code> obu obiektów są równe.</li>
			  <li>Zmienne reprezentujące obiekty, tablice i funkcje są porównywane przez odwołanie. Dwie takie zmienne są równe, jeśli odwołują się do tego samego obiektu, tablicy lub funkcji. Dwie odrębne tablice nigdy nie są uznawane za równe, nawet jeśli mają tę samą liczbę elementów.</li> 
			</ul> 


			Jeśli typy danych operandów są różne, wynikiem jest zawsze wartość <code>false</code>, z wyjątkiem następujących sytuacji:
			  <ul>
				<li>Oba operandy mają wartość <code>undefined</code> lub <code>null</code>; wówczas wynikiem jest wartość <code>true</code>.</li>
				<li>W wyniku automatycznej konwersji typów danych wartości typu String, Boolean, int, uint i Number zostały przekonwertowane na typy kompatybilne i przekonwertowane wartości są równe; wówczas operandy są uznawane za równe.</li>
				<li>Jednym z operandów jest obiekt XML z treścią prostą (<code>hasSimpleContent() == true</code>), a po przekonwertowaniu obu operandów na ciągi znaków za pomocą metody <code>toString()</code> wynikowe ciągi znaków są równe.</li>
				<li>Jeden operand należy do typu XMLList i spełniony jest jeden z następujących warunków:
					<ul>
						<li>Właściwość <code>length</code> obiektu XMLList ma wartość 0, a drugi obiekt jest równy <code>undefined</code>.</li>
						<li>Właściwość <code>length</code> obiektu XMLList ma wartość 1 i ten jeden element obiektu XMLList jest równy drugiemu operandowi.</li>
					</ul>
				</li>
			  </ul>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg znaków, wartość typu Boolean, zmienna, obiekt, tablica lub wyrażenie.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg, wartość logiczna, zmienna, obiekt, tablica lub wyrażenie.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wyrażenia są równe, wartość <code>false</code> w przeciwnym wypadku.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie operator równości (<code>==</code>) zastosowano w instrukcji <code>if</code>:
<div class="listing"><pre>var a:String = "David"
var b:String = "David"; 
if (a == b) { 
	trace("David is David"); 
} </pre></div> 
Następujące przykłady ilustrują automatyczną konwersję typów przy porównywaniu według wartości. Wartości typu String są konwertowane na liczby: 
<div class="listing"><pre>var a:Number = 5; 
var b:String = "5"; 
trace(a == b); // true</pre></div>
Wartości typu Boolean są konwertowane na liczby w taki sposób, że wartość <code>true</code> jest zamieniana na 1, a wartość <code>false</code> na 0:
<div class="listing"><pre>var c:Number = 1; 
var d:Boolean = true; 
trace(c == d); // true
var e:Number = 0; 
var f:Boolean = false; 
trace(e == f); // true</pre></div>
Jednak ciągi znaków nie są konwertowane na wartości typu Boolean, a zatem następujący kod zwraca wartość <code>false</code>:
<div class="listing"><pre>var g:String = "true";
var h:Boolean = true;
trace(g == h); // false</pre></div>
Poniższe przykłady ilustrują porównanie według odwołań. W pierwszym przykładzie porównywane są dwie tablice o identycznych długościach i elementach. Operator porównania tych dwóch tablic zwraca wartość <code>false</code>. Mimo że tablice są z pozoru identyczne, w porównaniu przez odwołanie zmienne <code>firstArray</code> i <code>secondArray</code> muszą odwoływać się do tej samej tablicy. W drugim przykładzie tworzona jest zmienna <code>thirdArray</code>, która wskazuje na tę samą tablicę, co <code>firstArray</code>. Porównanie tych dwóch tablic za pomocą operatora równości zwraca wartość true, ponieważ odwołują się one do tej samej tablicy. 
<div class="listing"><pre>var firstArray:Array = new Array("one", "two", "three"); 
var secondArray:Array = new Array("one", "two", "three"); 
trace(firstArray == secondArray); // false 
/* Arrays are only considered equal 
if the variables refer to the same array. */
var thirdArray:Array = firstArray; 
trace(firstArray == thirdArray); // true </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_AND" target="">&& (bitowe AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="greater_than"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>&nbsp;greater than</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &gt; expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest większa od wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>. Jeśli wartość <code>expression1</code> jest mniejsza lub równa <code>expression2</code>, wynikiem jest wartość <code>false</code>. 
			<p>Jeśli oba operandy należą do typu String, są porównywane według kolejności alfabetycznej; wszystkie wielkie litery poprzedzają małe litery. W przeciwnym razie operandy są najpierw konwertowane na liczby, a potem porównywane.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg znaków, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wartość <code>expression1</code> jest większa od wartości <code>expression2</code>; w przeciwnym razie wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład demonstruje, że ciągi znaków są porównywane alfabetycznie, przy czym wielkie litery poprzedzają małe litery:
<div class="listing"><pre>
var a:String = "first";
var b:String = "First";
trace(a &gt; b); // true
</pre></div>
Poniższy przykład ilustruje sposób konwertowania wartości typu String i Boolean na liczby:
<div class="listing"><pre>
var c:Number = 5;
var d:String = "4";
trace(c &gt; d); // true

var e: Number = 2;
var f:Boolean = true;
trace(e &gt; f); // true</pre></div>


			
			<p></p></div><a name="greater_than_or_equal_to"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">>=&nbsp;greater than or equal to</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &gt;= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest większa lub równa wartości <code>expression2</code> (<code>true</code>), czy też wartość <code>expression1</code> jest mniejsza niż wartość <code>expression2</code> (<code>false</code>).</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg znaków, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wartość <code>expression1</code> jest większa lub równa wartości <code>expression2</code>; w przeciwnym razie wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie operator (>=) służy do określenia, czy bieżąca godzina jest większa lub równa 12: 
<div class="listing"><pre>if (new Date().getHours() &gt;= 12) { 
	trace("good afternoon"); 
} else { 
	trace("good morning"); 
}</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#greater_than" target="">> (większe niż)</a></div></div><a name="in"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;in</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 in expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy właściwość należy do określonego obiektu. Używając operatora <code>in</code>, należy podać nazwę właściwości jako pierwszy operand i obiekt jako drugi operand. Jeśli określony obiekt zawiera taką właściwość, wynikiem będzie wartość <code>true</code>; w przeciwnym razie wynikiem będzie wartość <code>false</code>.
			<p>Jeśli określony obiekt jest obiektem Array, operatora <code>in</code> można użyć do sprawdzenia, czy konkretny indeks jest poprawny. W wypadku podania liczby całkowitej jako pierwszego operandu wynikiem będzie wartość <code>true</code>, jeśli indeks mieści się w dozwolonym zakresie liczb albo wartość <code>false</code> w przeciwnym wypadku.</p>
			</p></p><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli operand <code>expression1</code> jest właściwością obiektu reprezentowanego przez operand <code>expression2</code>; w przeciwnym razie wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
				W poniższym przykładzie operatora <code>in</code> użyto w celu zademonstrowania, że <code>PI</code> jest właściwością obiektu Math, a <code>myProperty</code> nie jest właściwością tego obiektu.
<div class="listing"><pre>
trace("PI" in Math);         // true
trace("myProperty" in Math); // false
</pre></div>
<p>W poniższym przykładzie operator <code>in</code> zastosowano w celu zademonstrowania, że liczby 0, 1 i 2 są poprawnym indeksami tablicy <code>myArray</code>, ale liczba 3 nie jest poprawnym indeksem.</p>
<div class="listing"><pre>
public var myArray:Array = ["zero", "one", "two"];
trace(0 in myArray); // true
trace(1 in myArray); // true
trace(2 in myArray); // true
trace(3 in myArray); // false
</pre></div>
				
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#instanceof" target="">instanceof</a></div></div><a name="increment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">++&nbsp;increment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>++expression</pre> <pre> expression++</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Dodaje 1 do wartości wyrażenia. Wyrażenie może być zmienną, elementem tablicy lub właściwością obiektu. Operator inkrementacji w postaci poprzedzającej (<code>++expression</code>) dodaje 1 do wartości <code>expression</code> i zwraca wynik. Operator inkrementacji w postaci następującej (<code>expression++</code>) dodaje 1 do <code>expression</code> i zwraca pierwotną wartość <code>expression</code> (tj. wartość sprzed dodawania). 
			
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub zmienna, której wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik inkrementacji.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
W poniższym przykładzie użyto operatora inkrementacji poprzedzającej ++ wewnątrz pętli <code>while</code> w celu zademonstrowania, że wartość dodawana do tablicy jest wartością po inkrementacji: 
<div class="listing"><pre>
var preInc:Array = new Array(); 
var i:int = 0; 
while (i &lt; 10) { 
    preInc.push(++i); 
} 
trace(preInc); // 1,2,3,4,5,6,7,8,9,10 
</pre></div> 
W poniższym przykładzie użyto operatora inkrementacji następującej ++ wewnątrz pętli <code>while</code> w celu zademonstrowania, że wartość dodawana do tablicy jest wartością początkową: 
<div class="listing"><pre> 
var postInc:Array = new Array(); 
var i:int = 0; 
while (i &lt; 10) { 
   postInc.push(i++); 
} 
trace(postInc); // 0,1,2,3,4,5,6,7,8,9 
</pre></div> 
W poniższym przykładzie użyto operatora inkrementacji następującej ++ w celu pięciokrotnego wykonania <code>while</code>: 
<div class="listing"><pre>var i:int = 0; 
while (i++ &lt; 5) { 
	trace("this is execution " + i); 
} 
/* output: 
   this is execution 1 
   this is execution 2 
   this is execution 3 
   this is execution 4 
   this is execution 5 
*/</pre></div> 
			<p></p></div><a name="inequality"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">!=&nbsp;inequality</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 != expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza warunek przeciwny do równości (<code>==</code>). Jeśli wyrażenie <code>expression1</code> jest równe <code>expression2</code>, wynikiem będzie wartość <code>false</code>. Podobnie jak w przypadku operatora równości (<code>==</code>) definicja równości zależy od tego, jakie typy danych są porównywane. 
			<p>Jeśli typy danych obu operandów są identyczne, definicja równości zależy od typu danych operandów:</p> 
			<ul> 
			  <li>Wartości typu int, uint i Boolean są uznawane za równe, jeśli mają te same wartości.</li> 
			  <li>Liczby o takich samych wartościach są uznawane za równe, chyba że obie mają wartość <code>NaN</code>.</li>
			  <li>Jeśli oba operandy mają wartość <code>null</code> lub <code>undefined</code>, są uznawane za równe.</li>
			  <li>Wyrażenia typu String są równe, jeśli mają tę samą liczbę znaków i znaki na odpowiednich pozycjach są identyczne.</li> 
			  <li>W przypadku obiektów XML:
			    <ul>
				<li>Jeśli jeden operand jest tekstem lub węzłem atrybutu, a drugi ma treść prostą, oba operandy są konwertowane na ciągi znaków za pomocą metody <code>toString()</code> i są uznawane za równe, jeśli wynikowe ciągi znaków są równe. </li>
				<li>W przeciwnym razie obiekty są uznawane za równe tylko wówczas, gdy oba obiekty mają takie same nazwy kwalifikowane, atrybuty i właściwości potomne.</li>
			    </ul>
			  </li>
			  <li>Obiekty XMLList są uznawane za równe, jeśli mają tę samą liczbę właściwości, a kolejność i wartości tych właściwości są takie same.</li>
			  <li>Wartości obiektów typu Namespace są uznawane za równe, jeśli właściwości <code>uri</code> obu obiektów są równe.</li>
			  <li>Wartości typu QName są uznawane za równe, jeśli odpowiednio właściwości <code>uri</code> oraz <code>localName</code> obu obiektów są równe.</li>
			  <li>Zmienne reprezentujące obiekty, tablice i funkcje są porównywane przez odwołanie. Dwie takie zmienne są równe, jeśli odwołują się do tego samego obiektu, tablicy lub funkcji. Dwie odrębne tablice nigdy nie są uznawane za równe, nawet jeśli mają tę samą liczbę elementów.</li> 
			</ul> 


			Jeśli typy operandów są różne, operator nierówności (<code>!=</code>) zwraca wartość <code>true</code> zawsze, z wyjątkiem następujących sytuacji:
			  <ul>
				<li>Oba operandy mają wartość <code>undefined</code> lub <code>null</code>; wówczas wynikiem jest wartość <code>true</code>.</li>
				<li>W wyniku automatycznej konwersji typów danych wartości typu String, Boolean, int, uint i Number zostały przekonwertowane na typy kompatybilne i przekonwertowane wartości są równe; wówczas operandy są uznawane za równe.</li>
				<li>Jednym z operandów jest obiekt XML z treścią prostą (<code>hasSimpleContent() == true</code>), a po przekonwertowaniu obu operandów na ciągi znaków za pomocą metody <code>toString()</code> wynikowe ciągi znaków są równe.</li>
				<li>Jeden operand należy do typu XMLList i spełniony jest jeden z następujących warunków:
					<ul>
						<li>Właściwość <code>length</code> obiektu XMLList ma wartość 0, a drugi obiekt jest równy <code>undefined</code>.</li>
						<li>Właściwość <code>length</code> obiektu XMLList ma wartość 1 i ten jeden element obiektu XMLList jest równy drugiemu operandowi.</li>
					</ul>
				</li>
			  </ul>

			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg, wartość logiczna, zmienna, obiekt, tablica lub funkcja.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg znaków, wartość typu Boolean, zmienna, obiekt, tablica lub funkcja.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wyrażenia nie są równe, wartość <code>false</code> w przeciwnym wypadku.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje wynik działania operatora nierówności (<code>!=</code>): 
<div class="listing"><pre>trace(5 != 8); // true 
trace(5 != 5); // false </pre></div> 
Poniższy przykład ilustruje zastosowanie operatora nierówności (<code>!=</code>) w instrukcji <code>if</code>: 
<div class="listing"><pre>var a:String = "David";
var b:String = "Fool";
if (a != b) { 
	trace("David is not a fool"); 
}</pre></div> 
Poniższy przykład ilustruje porównanie przez odwołanie z zastosowaniem dwóch funkcji: 
<div class="listing"><pre>var a:Function = function() { trace("foo"); }; 
var b:Function = function() { trace("foo"); }; 
a(); // foo 
b(); // foo 
trace(a != b); // true 
a = b; 
a(); // foo 
b(); // foo 
trace(a != b); // false</pre></div> 
Poniższy przykład ilustruje porównanie przez odwołanie z zastosowaniem dwóch tablic: 
<div class="listing"><pre>var a:Array = [ 1, 2, 3 ]; 
var b:Array = [ 1, 2, 3 ]; 
trace(a);      // 1,2,3 
trace(b);      // 1,2,3 
trace(a != b); // true 
a = b; 
trace(a);      // 1,2,3 
trace(b);      // 1,2,3 
trace(a != b); // false</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#logical_AND" target="">&& (bitowe AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="instanceof"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;instanceof</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression instanceof function</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy łańcuch prototypów wyrażenia zawiera obiekt prototypowy dla funkcji <code>function</code>. Operator <code>instanceof</code> jest obsługiwany ze względu na zgodność wstecz z wydaniem 3. specyfikacji języka ECMAScript i może być przydatny dla zaawansowanych programistów, którzy stosują dziedziczenie w oparciu o prototypy oraz funkcje-konstruktory, a nie w oparciu o klasy. 
			<p>Aby sprawdzić, czy obiekt należy do określonego typu danych, należy użyć operatora <code>is</code>.</p>
			<p>Operator <code>instanceof</code> używany w odniesieniu do klas działa podobnie, jak operator <code>is</code>, ponieważ łańcuch prototypów klasy zawiera wszystkie jej nadklasy. Jednak interfejsy nie są uwzględnione w łańcuchu prototypów, dlatego operator <code>instanceof</code> zawsze zwraca wartość <code>false</code>, gdy operandem jest interfejs, podczas gdy operator <code>is</code> zwraca wartość <code>true</code>, jeśli obiekt należy do klasy implementującej określony interfejs.</p>
			<p><b>Uwaga:</b> Operator <code>is</code> w języku ActionScript jest równoważny operatorowi <code>instanceof</code> w języku Java.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt zawierający łańcuch prototypów do sprawdzenia.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">function</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt będący funkcją (lub klasa).
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Zwraca wartość <code>true</code>, jeśli łańcuch prototypów wyrażenia <code>expression</code> zawiera obiekt prototypowy dla funkcji <code>function</code>, a w przeciwnym wypadku zwraca wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
				W poniższym przykładzie tworzona jest instancja klasy Sprite o nazwie <code>mySprite</code> i operator <code>instanceof</code> jest używany do sprawdzenia, czy łańcuch prototypów obiektu <code>mySprite</code> zawiera obiekty prototypowe klas Sprite i DisplayObject. Wynikiem jest wartość <code>true</code> zarówno w przypadku klasy Sprite, jak i klasy DisplayObject, ponieważ obiekty prototypowe klas Sprite i DisplayObject należą do łańcucha prototypów obiektu <code>mySprite</code>.
<div class="listing"><pre>
var mySprite:Sprite = new Sprite();
trace(mySprite instanceof Sprite);        // true
trace(mySprite instanceof DisplayObject); // true
</pre></div>
W poniższym przykładzie zastosowano interfejs IBitmapDrawable w celu zademonstrowania, że operator <code>instanceof</code> nie działa z interfejsami. Wynikiem działania operatora <code>is</code> jest wartość <code>true</code>, ponieważ klasa DisplayObject, będąca nadklasą klasy Sprite, implementuje interfejs IBitmapDrawable.
<div class="listing"><pre>
var mySprite:Sprite = new Sprite();
trace(mySprite instanceof IBitmapDrawable); // false
trace(mySprite is IBitmapDrawable);         // true
</pre></div>
				
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#is" target="">is</a><br/><a href="Object.html#prototype" target="">prototype</a></div></div><a name="is"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;is</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 is expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy obiekt jest kompatybilny z określonym typem danych, klasą lub interfejsem. Do porównywania typów należy używać operatora <code>is</code>, a nie operatora <code>instanceof</code>. Operatora <code>is</code> można także używać do sprawdzania, czy obiekt implementuje określony interfejs. 
			</p></p><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wyrażenie <code>expression1</code> jest kompatybilne z typem danych, klasą lub interfejsem określonym w wyrażeniu <code>expression2</code>, a wartość <code>false</code> w przeciwnym wypadku.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
				W poniższym przykładzie tworzona jest instancja klasy Sprite o nazwie <code>mySprite</code>, po czym operator <code>is</code> używany jest do sprawdzania, czy <code>mySprite</code> jest instancją klas Sprite i DisplayObject oraz czy implementuje interfejs IEventDispatcher.
<div class="listing"><pre>
import flash.display.*;
import flash.events.IEventDispatcher;

var mySprite:Sprite = new Sprite();
trace(mySprite is Sprite);           // true
trace(mySprite is DisplayObject);    // true
trace(mySprite is IEventDispatcher); // true
</pre></div>
				
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#as" target="">as</a><br/><a href="operators.html#instanceof" target="">instanceof</a></div></div><a name="less_than"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><&nbsp;less than</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &lt; expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest mniejsza od wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>. Jeśli wartość <code>expression1</code> jest większa lub równa <code>expression2</code>, wynikiem jest wartość <code>false</code>. 
			<p>Jeśli oba operandy należą do typu String, są porównywane według kolejności alfabetycznej; wszystkie wielkie litery poprzedzają małe litery. W przeciwnym razie operandy są najpierw konwertowane na liczby, a potem porównywane.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg znaków, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wartość <code>expression1</code> jest mniejsza od wartości <code>expression2</code>; w przeciwnym razie wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje wyniki <code>true</code> i <code>false</code> porównań liczb i ciągów: 
<div class="listing"><pre>trace(5 &lt; 10); // true 
trace(2 &lt; 2);            // false 
trace(10 &lt; 3);           // false 
trace("Allen" &lt; "Jack"); // true 
trace("Jack" &lt; "Allen"); // false 
trace("11" &lt; "3");       // true 
trace("11" &lt; 3);         // false (numeric comparison) 
trace("C" &lt; "abc");      // true 
trace("A" &lt; "a");        // true </pre></div>
			<p></p></div><a name="less_than_or_equal_to"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><=&nbsp;less than or equal to</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &lt;= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Porównuje dwa wyrażenia i określa, czy wartość wyrażenia <code>expression1</code> jest mniejsza lub równa wartości <code>expression2</code>; jeśli tak, wynikiem jest wartość <code>true</code>. Jeśli wartość wyrażenia <code>expression1</code> jest większa od wartości <code>expression2</code>, wynikiem jest wartość <code>false</code>. 
			<p>Jeśli oba operandy należą do typu String, są porównywane według kolejności alfabetycznej; wszystkie wielkie litery poprzedzają małe litery. W przeciwnym razie operandy są najpierw konwertowane na liczby, a potem porównywane.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg znaków, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Ciąg, liczba całkowita lub liczba zmiennopozycyjna.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wartość <code>true</code>, jeśli wartość <code>expression1</code> jest mniejsza lub równa wartości <code>expression2</code>; w przeciwnym razie wartość <code>false</code>.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje wyniki <code>true</code> i <code>false</code> porównań liczb i ciągów znaków: 
<div class="listing"><pre>trace(5 &lt;= 10); // true 
trace(2 &lt;= 2);            // true 
trace(10 &lt;= 3);           // false 
trace("Allen" &lt;= "Jack"); // true 
trace("Jack" &lt;= "Allen"); // false 
trace("11" &lt;= "3");       // true 
trace("11" &lt;= 3);         // false (numeric comparison) 
trace("C" &lt;= "abc");      // true 
trace("A" &lt;= "a");        // true </pre></div>
			<p></p></div><a name="line_comment_delimiter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">//&nbsp;line comment delimiter</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>// comment</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Oznacza początek komentarza w skrypcie. Znaki między ogranicznikiem komentarza (<code>//</code>) a znakiem końca wiersza są interpretowane jako komentarz i ignorowane. Tego ogranicznika należy używać do oznaczania komentarzy jednowierszowych; w celu oznaczenia komentarzy zajmujących wiele kolejnych wierszy należy używać ograniczników <code>/*</code> i <code>*/</code>. 

			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">comment</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Dowolne znaki.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Oto przykład komentarza jednowierszowego: 
<div class="listing"><pre>// Any text following a line comment delimiter is ignored during compilation</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#block_comment_delimiter" target="">/*..*/ (ogranicznik bloku komentarza)</a></div></div><a name="logical_AND"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&&&nbsp;logical AND</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 && expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Zwraca wartość <code>expression1</code>, jeśli jest równa <code>false</code> lub można ją przekonwertować na wartość <code>false</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>. Przykładami wartości, które można przekonwertować na <code>false</code>, są: 0, <code>NaN</code>, <code>null</code> oraz <code>undefined</code>. Jeśli wyrażenie <code>expression2</code> jest wywołaniem funkcji, to funkcja nie zostanie wywołana, jeśli wyznaczoną wartością <code>expression1</code> będzie <code>false</code>. 
			<p>Jeśli oba operandy należą do typu Boolean, wynik będzie równy <code>true</code> tylko wtedy, gdy oba operandy będą równe <code>true</code>, tak jak przedstawiono to w poniższej tabeli:</p> 
			<table class="innertable" width="250"><colspec colnum="1"></colspec><colspec colnum="2"></colspec><thead><tr><th><p>Wyrażenie </p></th><th><p>Wyznaczona wartość </p></th></tr></thead><tbody><tr><td><p><code>true && true</code> </p></td><td><p><code>true</code></p></td></tr><tr><td><p><code>true && false</code> </p></td><td><p><code>false</code></p></td></tr><tr><td><p><code>false && false</code> </p></td><td><p><code>false</code></p></td></tr><tr><td><p><code>false && true</code> </p></td><td><p><code>false</code></p></td></tr></tbody></table>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość lub wyrażenie dowolnego typu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość wyrażenia dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość typu Boolean, jeśli oba operandy należą do typu Boolean. W przeciwnym razie wynik jest wartością wyrażenia.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie użyto operatora logicznego AND (<code>&&</code>) w celu sprawdzenia, czy gracz wygrał grę. Wartości zmiennych <code>turns</code> i <code>score</code> są aktualizowane, gdy gracz zaczyna rundę gry lub zdobywa punkty w grze. Skrypt wyświetla komunikat „You Win the Game!”, gdy gracz osiągnie wynik równy co najmniej 75 w nie więcej niż trzech rundach.
<div class="listing"><pre>var turns:Number = 2; 
var score:Number = 77; 
if ((turns &lt;= 3) && (score &gt;= 75)) { 
	trace("You Win the Game!"); 
} else { 
	trace("Try Again!"); 
} </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#logical_OR_assignment" target="">||= (przypisanie logicznego OR)</a><br/><a href="operators.html#logical_AND_assignment" target="">&&= (przypisanie z iloczynem logicznym)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="logical_AND_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&&=&nbsp;logical AND assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 &&= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 && expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
<pre>x &&= y; 
x = x && y; </pre>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość typu Boolean, jeśli oba operandy należą do typu Boolean. W przeciwnym razie wynik jest wartością jednego z dwóch wyrażeń.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zmienna <code>myVar</code> zostaje zmieniona na znacznik XML, chyba że <code>myVar</code> ma wartość null. W następującym przykładzie wartość zmiennej <code>myVar</code> jest modyfikowana, pod warunkiem że wyznaczona wartość zmiennej nie jest równa <code>false</code>. Wykorzystano tutaj fakt, że operator logiczny AND (<code>&&</code>) zwraca wartość wyrażenia <code>expression1</code>, jeśli wyznaczona wartość <code>expression1</code> równa się <code>false</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>. Jeśli zmienna <code>myVar</code> zawiera już wartość, która po wyznaczeniu jest równa <code>true</code>, zmienna <code>myVar</code> zostanie zmodyfikowana na wzór znacznika XML. Jeśli jednak zmienna <code>myVar</code> zawiera wartość, która po wyznaczeniu jest równa <code>false</code>, np. wartość <code>null</code>, <code>""</code> (pusty ciąg znaków) i <code>undefined</code>, zmienna <code>myVar</code> pozostanie niezmieniona.
			<div class="listing"><pre>var myVar:String = 'tag';
			myVar &&= "&lt;" + myVar + "/&gt;";
			trace (myVar); // output: &lt;tag/&gt;</pre></div>
						Ten sam rezultat można osiągnąć za pomocą instrukcji <code>if</code>, co ilustruje następujący przykład:
			<div class="listing"><pre>var myVar:String = 'tag';
			if (myVar != '') {
			  myVar = "&lt;" + myVar + "/&gt;";
			}
			trace (myVar); // output: &lt;tag/&gt;</pre></div>
						Wersja, w której użyto instrukcji <code>if</code>, jest bardziej czytelna, natomiast zaletą zastosowania operatora przypisania logicznego AND (<code>&&=</code>) jest brak konieczności podawania konkretnej wartości domyślnej dla danego typu danych.
						
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_OR" target="">|| (logiczne OR)</a><br/><a href="operators.html#logical_OR_assignment" target="">||= (przypisanie logicznego OR)</a><br/><a href="operators.html#logical_AND" target="">&& (bitowe AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="logical_NOT"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">!&nbsp;logical NOT</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>!wyrażenie</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Odwraca wartość typu Boolean zmiennej lub wyrażenia. Jeśli <code>expression</code> jest zmienną o bezwzględnej lub przekonwertowanej wartości <code>true</code>, wartością <code>!expression</code> jest <code>false</code>. Jeśli wyznaczoną wartością wyrażenia <code>x && y</code> jest <code>false</code>, wyznaczoną wartością wyrażenia <code>!(x && y)</code> będzie <code>true</code>. 
			<p>  Następujące wyrażenia ilustrują efekt użycia operatora logicznego NEGACJI (!): </p> 
			<ul><li><code>!true</code> zwraca <code>false</code>.</li> 
				<li><code>!false</code> zwraca <code>true</code>.</li></ul></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Boolean.html">Boolean</a></code> &mdash; 
					Wyrażenie lub zmienna, którego/której wyznaczona wartość należy do typu Boolean.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wynik operacji logicznej należący do typu Boolean.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zmiennej <code>happy</code> jest przypisywana wartość <code>false</code>. Instrukcja <code>if</code> wyznacza wartość warunku <code>!happy</code>, i jeśli jest on spełniony (<code>true</code>), instrukcja <code>trace()</code> generuje ciąg znaków. 
<div class="listing"><pre>var happy:Boolean = false; 
if (!happy) { 
	trace("don't worry, be happy"); // don't worry, be happy 
} </pre></div> Instrukcja <code>trace</code> zostanie wykonana, ponieważ <code>!false</code> równa się <code>true</code>.
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_AND" target="">&& (iloczyn logiczny)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#logical_AND_assignment" target="">&&= (przypisanie logicznego AND)</a><br/><a href="operators.html#logical_OR_assignment" target="">||= (przypisanie z sumą logiczną)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="logical_OR"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">||&nbsp;logical OR</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 || expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Zwraca wartość <code>expression1</code>, jeśli jest równa <code>true</code> lub można ją przekonwertować na wartość <code>true</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>. Jeśli wyrażenie <code>expression2</code> jest wywołaniem funkcji, to funkcja nie zostanie wywołana, jeśli wyznaczoną wartością <code>expression1</code> będzie <code>true</code>. 
			<p>Jeśli oba operandy są typu Boolean, wynik jest równy <code>true</code>, gdy co najmniej jedno z wyrażeń jest równe <code>true</code>; wynik jest równy <code>false</code> tylko wówczas, gdy oba wyrażenia są równe <code>false</code>, tak jak przedstawiono to w poniższej tabeli:
			</p>
			<table class="innertable" width="250"><colspec colnum="1"></colspec><colspec colnum="2"></colspec><thead><tr><th><p>Wyrażenie </p></th><th><p>Wyznaczona wartość </p></th></tr></thead><tbody><tr><td><p><code>true || true</code> </p></td><td><p><code>true</code></p></td></tr><tr><td><p><code>true || false</code> </p></td><td><p><code>true</code></p></td></tr><tr><td><p><code>false || false</code> </p></td><td><p><code>false</code></p></td></tr><tr><td><p><code>false || true</code> </p></td><td><p><code>true</code></p></td></tr></tbody></table>

			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość typu Boolean, jeśli oba operandy należą do typu Boolean. W przeciwnym razie wynik jest wartością jednego z dwóch wyrażeń.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie operator logicznego OR (<code>||</code>) zastosowano w instrukcji <code>if</code>. Wartością drugiego wyrażenia jest <code>true,</code> dlatego ostateczny wynik jest równy <code>true</code>: 
<div class="listing"><pre>var a:Number = 10; 
var b:Number = 250; 
var start:Boolean = false; 
if ((a &gt; 25) || (b &gt; 200) || (start)) { 
    trace("the logical OR test passed"); // the logical OR test passed 
} </pre></div> 
Komunikat "the logical OR test passed" jest wyświetlany, ponieważ jeden z warunków w instrukcji <code>if</code> jest spełniony (<code>b &gt; 200</code>). 
<p>Poniższy przykład demonstruje, że użycie wywołania funkcji jako drugiego operandu może prowadzić do nieoczekiwanych wyników. Jeśli wyznaczoną wartością wyrażenia po lewej stronie operatora jest <code>true</code>, wynik ten jest zwracany od razu i nie jest wyznaczana wartość wyrażenia po prawej stronie (funkcja <code>fx2()</code> nie jest wywoływana). </p> 
<div class="listing"><pre>function fx1():Boolean { 
	trace("fx1 called"); 
	return true; 
} 
function fx2():Boolean { 
	trace("fx2 called"); 
	return true; 
} 
if (fx1() || fx2()) { 
	trace("IF statement entered");
}</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_AND" target="">&& (iloczyn logiczny)</a><br/><a href="operators.html#logical_AND_assignment" target="">&&= (przypisanie logicznego AND)</a><br/><a href="operators.html#logical_OR_assignment" target="">||= (przypisanie z sumą logiczną)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="logical_OR_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">||=&nbsp;logical OR assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 ||= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code>expression1 || expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
<pre>x ||= y; 
x = x || y; </pre>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wartość dowolnego typu.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość typu Boolean, jeśli oba operandy należą do typu Boolean. W przeciwnym razie wynik jest wartością jednego z dwóch wyrażeń.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zadeklarowanej uprzednio zmiennej o nazwie <code>myVar</code> przypisywana jest wartość domyślna. Wykorzystano tutaj fakt, że operator logiczny OR (<code>||</code>) zwraca wartość wyrażenia <code>expression1</code>, jeśli wyznaczona wartość <code>expression1</code> równa się <code>true</code>, a w przeciwnym razie zwraca wartość wyrażenia <code>expression2</code>. Jeśli zmienna <code>myVar</code> zawiera już wartość, która po wyznaczeniu jest równa <code>true</code>, zmienna <code>myVar</code> nie zostanie zmodyfikowana. Jeśli jednak zmienna <code>myVar</code> zawiera wartość, która po wyznaczeniu jest równa <code>false</code>, m. in. wartość <code>null</code>, <code>""</code> (pusty ciąg znaków) i <code>undefined</code>, zmiennej <code>myVar</code> zostanie przypisana wartość <code>"default"</code>.
<div class="listing"><pre>myVar ||= "default";</pre></div>
			
			
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_OR" target="">|| (logiczne OR)</a><br/><a href="operators.html#logical_AND" target="">&& (iloczyn logiczny)</a><br/><a href="operators.html#logical_AND_assignment" target="">&&= (przypisanie logicznego AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="modulo"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">%&nbsp;modulo</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 % expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Oblicza resztę z dzielenia wartości wyrażenia <code>expression1</code> przez wartość wyrażenia <code>expression2</code>. Jeśli którykolwiek z operandów nie jest liczbą, operator modulo (<code>%</code>) podejmuje próbę przekonwertowania go na liczbę. 
			<p>Znak wyniku operacji modulo jest taki sam, jak znak dzielnej (pierwszej liczby). Na przykład <code>-4 % 3</code> i <code>-4 % -3</code> dają w wyniku tę samą wartość <code>-1</code>.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą. Wyznaczona wartość ciągu znaków zawierającego tylko cyfry jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą. Wyznaczona wartość ciągu znaków zawierającego tylko cyfry jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik operacji arytmetycznej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W następującym przykładzie obliczeniowym użyto operatora modulo (<code>%</code>): 
<div class="listing"><pre>
trace(12 % 5);    // 2 
trace(4.3 % 2.1); // 0.0999999999999996 
trace(4 % 4);     // 0 </pre></div> Pierwsza instrukcja trace zwraca wartość 2, a nie 12/5 (2,4), ponieważ operator modulo (<code>%</code>) zwraca tylko resztę z dzielenia. Druga instrukcja trace zwraca wartość 0,0999999999999996, a nie oczekiwaną wartość 0,1, z uwagi na niedokładność obliczeń dwójkowych na liczbach zmiennopozycyjnych.
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#division" target="">/ (dzielenie)</a><br/><a href="Math.html#round()" target="">Math.round()</a></div></div><a name="modulo_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">%=&nbsp;modulo assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 %= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 % expression2</code>. Następujące dwie instrukcje są równoważne: 
			<pre>x %= y; 
x = x % y; </pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik operacji arytmetycznej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zmiennej <code>a</code> jest przypisywana wartość 4: 
<div class="listing"><pre>var a:Number = 14; 
var b:Number = 5; 
a %= b;
trace(a); // 4 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#modulo" target="">% (modulo)</a></div></div><a name="multiplication"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">*&nbsp;multiplication</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 * expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Mnoży dwa wyrażenia liczbowe. Jeśli oba wyrażenia są liczbami całkowitymi, iloczyn jest liczbą całkowitą. Jeśli przynajmniej jedno wyrażenie jest liczbą zmiennopozycyjną, iloczyn jest liczbą zmiennopozycyjną.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Liczba całkowita lub zmiennopozycyjna.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następująca instrukcja mnoży liczby całkowite 2 i 3, dając w wyniku liczbę całkowitą 6: 
<div class="listing"><pre>trace(2*3); // 6 </pre></div> 
Ta instrukcja mnoży liczby zmiennopozycyjne 2,0 i 3,1416, dając w wyniku liczbę zmiennopozycyjną 6,2832: 
<div class="listing"><pre>trace(2.0 * 3.1416); // 6.2832 </pre></div> <p></p></div><a name="multiplication_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">*=&nbsp;multiplication assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 *= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 * expression2</code>. Na przykład następujące dwa wyrażenia są równoważne: 
			<pre>x *= y 
x = x * y </pre></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wartość wyrażenia <code>expression1 * expression2</code>. Jeśli któregokolwiek z wyrażeń nie można przekonwertować na wartość liczbową, zwracana jest wartość <code>NaN</code> („nie jest liczbą”).
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zmiennej <code>a</code> jest przypisywana wartość 50: 
<div class="listing"><pre>var a:Number = 5; 
var b:Number = 10; 
trace(a *= b); // 50 </pre></div> 
W drugim i trzecim wierszu poniższego przykładu obliczane są wartości wyrażeń po prawej stronie znaku równości, a wyniki są przypisywane zmiennym <code>c</code> i <code>d</code>: 
<div class="listing"><pre>var i:Number = 5; 
var c:Number = 4 - 6; 
var d:Number = i + 2; 
trace(c *= d); // -14 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#multiplication" target="">* (mnożenie)</a></div></div><a name="name_qualifier"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">::&nbsp;name qualifier</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>namespace::property</pre> 
			<pre>namespace::method()</pre> 
			<pre>namespace::xmlObject.property</pre> 
			<pre>namespace::xmlObject.@attribute</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Identyfikuje przestrzeń nazw właściwości, metody, właściwości XML lub atrybutu XML.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">namespace</span>:<a href="Object.html">Object</a></code> &mdash; 
					Identyfikująca przestrzeń nazw.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">propertyName</span>:<a href="Object.html">Object</a></code> &mdash; 
					Właściwość, metoda, właściwość XML lub atrybut XML do identyfikacji
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie użyto operatora <code>::</code> do zidentyfikowania dwóch metod, które mają tę samą nazwę w dwóch różnych przestrzeniach nazw: 
<div class="listing"><pre>public class NamespaceExample extends Sprite {
	public namespace French;
	public namespace Hawaiian;
	public function NamespaceExample() {
		trace(Hawaiian::hello()); // aloha
		trace(French::hello()); // bonjour
	}
    Hawaiian function hello():String {
        return "aloha";
    }

    French function hello():String { 
        return "bonjour";
    }
}</pre></div> 

W poniższym przykładzie zastosowano operator <code>::</code> do wskazania właściwości XML w konkretnych przestrzeniach nazw: 
<div class="listing"><pre>var soap:Namespace = new Namespace("http://schemas.xmlsoap.org/wsdl/soap/");
var w:Namespace = new Namespace("http://weather.example.org/forecast");
var myXML:XML = 
	&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"&gt; 
	 &lt;soap:Body&gt;
	  &lt;w:forecast xmlns:w="http://weather.example.org/forecast"&gt;
	   &lt;w:city&gt;Quito&lt;/w:city&gt;
	   &lt;w:country&gt;Ecuador&lt;/w:country&gt;
	   &lt;date&gt;2006-01-14&lt;/date&gt;
	  &lt;/w:forecast&gt;
	  &lt;/soap:Body&gt;
	&lt;/soap:Envelope&gt;;
	
trace(myXML.soap::Body.w::forecast.w::city); // Quito</pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="Namespace.html" target="">Klasa przestrzeni nazw</a><br/><a href="XML.html" target="">Klasa XML</a></div></div><a name="new"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;new</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>new constructor(parameters)</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 5</td></tr></table><p></p><p><p otherprops="description">Tworzy instancję klasy. Operatora <code>new</code> można używać z klasami lub zmiennymi typu Class do tworzenia instancji klasy. Operator <code>new</code> jest zazwyczaj używany z obiektem klasy w celu utworzenia instancji klasy. Na przykład instrukcja <code>new Sprite()</code> tworzy instancję klasy Sprite.
			<p>Operator <code>new</code> może również posłużyć do skojarzenia klasy z zasobem osadzonym, czyli obiektem zewnętrznym, takim jak obraz, dźwięk lub czcionka, umieszczonym w pliku SWF w trakcie kompilacji. Taki zasób osadzony jest reprezentowany przez unikatową klasę zasobu osadzonego. Aby uzyskać dostęp do zasobu osadzonego, należy użyć operatora <code>new</code> w celu utworzenia skojarzonej z nim klasy. Następnie można wywoływać odpowiednie metody i właściwości klasy obiektu osadzonego, aby manipulować tym zasobem.</p>
			<p>Jeśli preferowane jest definiowanie klas z wykorzystaniem obiektów Function, a nie słowa kluczowego <code>class</code>, można używać operatora <code>new</code> do tworzenia obiektów w oparciu o funkcje-konstruktory. Nie należy mylić funkcji-konstruktorów z metodami-konstruktorami klas. Funkcja-konstruktor to obiekt Function zdefiniowany za pomocą słowa kluczowego <code>function</code>, który nie należy do definicji klasy. W przypadku zastosowania funkcji-konstruktorów do tworzenia obiektów, należy stosować dziedziczenie prototypów zamiast dziedziczenia klas.</p>
			
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">constructor</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Klasa, funkcja lub zmienna zawierająca wartość typu Class.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">parameters</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Jeden lub więcej parametrów oddzielonych przecinkami.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie tworzona jest klasa <code>Book</code> i za pomocą operatora <code>new</code> tworzone są obiekty <code>book1</code> i <code>book2</code>.
<div class="listing"><pre>
class Book {
  var bName:String;
  var bPrice:Number;
  
  public function Book(nameParam:String, priceParam:Number){
    bName = nameParam;
    bPrice = priceParam;
  }
}

var book1:Book = new Book("Confederacy of Dunces", 19.95);
var book2:Book = new Book("The Floating Opera", 10.95);
trace(book1); // [object Book]
</pre></div>
W poniższym przykładzie operator <code>new</code> jest używany do utworzenia instancji klasy Array z 18 elementami:
<div class="listing"><pre>
var golfCourse:Array = new Array(18);
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#array_access" target="">[] (array access)</a><br/><a href="statements.html#class" target="">instrukcja class</a><br/><a href="Object.html#constructor" target="">Object.constructor</a><br/><a href="Object.html#prototype" target="">Object.prototype</a><br/><a href="operators.html#object_initializer" target="">{} (operator inicjowania obiektu)</a></div></div><a name="object_initializer"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">{}&nbsp;object initializer</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>object = {name1 : value1, name2 : value2,... nameN : valueN}</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Tworzy nowy obiekt i inicjuje go określonymi parami właściwości <code>name</code> i <code>value</code>. Użycie tego operatora jest równoważne użyciu składni <code>new Object</code> i wypełnieniu par właściwości za pomocą operatora przypisania. Prototypem nowo utworzonego obiektu jest obiekt klasy Object o nazwie ogólnej. <p>Ten operator służy także do oznaczania ciągłych bloków kodu związanych z instrukcjami sterowania przepływem (<code>for</code>, <code>while</code>, <code>if</code>, <code>else</code>, <code>switch</code>) i funkcjami. </p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">object</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt, który ma zostać utworzony.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">name1,2,...N</span>:<a href="Object.html">Object</a></code> &mdash; 
					Nazwy właściwości.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">value1,2,...N</span>:<a href="Object.html">Object</a></code> &mdash; 
					Wartości poszczególnych właściwości <code>name</code>.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Object.html">Object</a></code> &mdash; 
				Obiekt klasy Object.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Pierwszy wiersz w poniższym kodzie tworzy pusty obiekt za pomocą operatora inicjowania obiektu ({}); drugi wiersz tworzy nowy obiekt przy użyciu funkcji-konstruktora: 
<div class="listing"><pre>var object:Object = {}; 
var object:Object = new Object(); </pre></div> 
W poniższym przykładzie tworzony jest obiekt <code>account</code>, a jego właściwości <code>name</code>, <code>address</code>, <code>city</code>, <code>state</code>, <code>zip</code> oraz <code>balance</code> są inicjowane podanymi wartościami: 
<div class="listing"><pre>var account:Object = {name:"Adobe Systems, Inc.", address:"601 Townsend Street", city:"San Francisco", state:"California", zip:"94103", balance:"1000"}; 
for (i in account) { 
	trace("account."+i+" = "+account[i]); 
} </pre></div> 
Poniższy przykład ilustruje zagnieżdżanie operatorów inicjujących obiekty: 
<div class="listing"><pre>var person:Object = {name:"Gina Vechio", children:["Ruby", "Chickie", "Puppa"]}; </pre></div> 
W poniższym kodzie ten sam rezultat, co w poprzednim przykładzie, uzyskiwany jest za pomocą funkcji-konstruktora: 
<div class="listing"><pre>var person:Object = new Object(); 
person.name = "Gina Vechio"; 
person.children = new Array(); 
person.children[0] = "Ruby"; 
person.children[1] = "Chickie"; 
person.children[2] = "Puppa"; </pre></div> 

			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#braces_(XML)" target="">nawiasy klamrowe (XML)</a><br/><a href="Object.html" target="">Klasa Object</a></div></div><a name="parentheses"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">()&nbsp;parentheses</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>(expression1[, expression2])</pre> <pre>(expression1, expression2)</pre> <pre>function(parameter1,..., parameterN) </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Umożliwia grupowanie operacji na parametrze lub parametrach, sekwencyjne wyznaczanie wartości wyrażeń, a także wskazanie parametru lub parametrów do przekazania do funkcji, której nazwa poprzedza nawias. <p>Zastosowanie 1: Steruje kolejnością wykonywania operatorów. Nawiasy wymuszają zmianę normalnej kolejności wykonywania i powodują, że wartości wyrażeń w nawiasach są wyznaczane jako pierwsze. W przypadku zagnieżdżenia nawiasów zawartość najgłębiej zagnieżdżonych nawiasów jest wyznaczana przed zawartością nawiasów zewnętrznych.</p> <p>Zastosowanie 2: Powodują wyznaczenie kolejno wartości wyrażeń rozdzielonych przecinkami i zwrócenie wyniku ostatniego wyrażenia. </p> 
			<p>Zastosowanie 3: Otaczają jeden lub wiele parametrów przekazywanych do funkcji, której nazwa występuje przed nawiasem otwierającym.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Wyrażenie, które może zawierać liczby, ciągi znaków, zmienne lub tekst.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Wyrażenie, które może zawierać liczby, ciągi, zmienne lub tekst.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">function</span>:<a href="Function.html">Function</a></code> &mdash; 
					Funkcja, która ma być wykonana na zawartości nawiasów.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">parameter1...parameterN</span>:<a href="Object.html">Object</a></code> &mdash; 
					Szereg parametrów, które należy wykonać przed przekazaniem wyników jako argumentów funkcji, której nazwa poprzedza nawias otwierający.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Zastosowanie 1: Poniższe instrukcje ilustrują użycie nawiasów do sterowania kolejnością wykonywania wyrażeń:
<div class="listing"><pre>
trace((2 + 3) * (4 + 5)); // 45 
trace(2 + (3 * (4 + 5))); // 29
trace(2 + (3 * 4) + 5);   // 19
trace(2 + (3 * 4) + 5);   // 19</pre></div> 
Zastosowanie 2: W poniższym przykładzie wyznaczana jest wartość funkcji <code>foo()</code>, następnie funkcji <code>bar()</code>, po czym zwracany jest wynik wyrażenia <code>a + b</code>: 
<div class="listing"><pre>var a:Number = 1; 
var b:Number = 2; 
function foo() { 
  a += b; 
} 
function bar() { 
  b *= 10; 
} 
trace((foo(), bar(), a + b)); // 23 </pre></div> 
Zastosowanie 3: W poniższym przykładzie przedstawiono zastosowanie nawiasów z funkcjami: 
<div class="listing"><pre>var today:Date = new Date(); 
trace(today.getFullYear()); // outputs current year 
function traceParameter(param):void { 
  trace(param); 
} 
traceParameter(2 * 2); // 4 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#parentheses_(XML)" target="">nawiasy (XML)</a><br/><a href="statements.html#with" target="">with</a></div></div><a name="parentheses_(XML)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">( )&nbsp;parentheses (XML)</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>myXML.(expression)</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia w ramach konstrukcji XML zgodnej z notacją ECMAScript for XML (E4X). Na przykład kod <code>myXML.(lastName == "Smith")</code> identyfikuje elementy XML o nazwie <code>lastName</code> i wartości <code>"Smith"</code>. Wynikiem jest obiekt klasy XMLList.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie definiujące dopasowane elementy.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="XMLList.html">XMLList</a></code> &mdash; 
				Obiekt XMLList określony za pomocą nawiasów.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie nawiasów do identyfikacji elementów i atrybutów:
<div class="listing"><pre>var myXML:XML = 
	&lt;employees&gt;
		&lt;employee id = "42"&gt;
			&lt;firstName&gt;Joe&lt;/firstName&gt;
			&lt;lastName&gt;Smith&lt;/lastName&gt;
		&lt;/employee&gt;
		&lt;employee id = "43"&gt;
			&lt;firstName&gt;Susan&lt;/firstName&gt;
			&lt;lastName&gt;Jones&lt;/lastName&gt;
		&lt;/employee&gt;
		&lt;employee id = "44"&gt;
			&lt;firstName&gt;Anne&lt;/firstName&gt;
			&lt;lastName&gt;Smith&lt;/lastName&gt;
		&lt;/employee&gt;
	&lt;/employees&gt;;
	
trace(myXML.employee.(lastName == "Smith").@id.toXMLString()); 
	// 42
	// 44
                
trace(myXML.employee.(Number(@id) &gt; 42).@id.toXMLString()); 
	// 43
	// 44
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a></div></div><a name="RegExp_delimiter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">/&nbsp;RegExp delimiter</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>/pattern/flags</pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Operator ten, użyty przed znakami i po znakach, oznacza, że znaki należy traktować literalnie i że stanowią one wyrażenie regularne, a nie zmienną, ciąg znaków lub inny element języka ActionScript. Należy jednak zwrócić uwagę, że dwa następujące po sobie ukośniki (<code>//</code>) oznaczają początek komentarza. </p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">pattern</span>:<a href="String.html">String</a></code> &mdash; 
					Sekwencja złożona z jednego lub wielu znaków, definiująca wzorzec wyrażenia regularnego.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">flags</span>:<a href="String.html">String</a></code> &mdash; 
					Sekwencja złożona z zera lub większej liczby znaków z następującego zbioru: <code>g</code> (flaga <code>global</code>), <code>i</code> (flaga <code>ignoreCase</code>), <code>s</code> (flaga <code>dotall</code>), <code>x</code> (flaga <code>extended</code> flag).
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie użyto znaków ukośnika (/) do przypisania wartości zmiennej typu RegExp (ustawiona jest flaga <code>i</code> powodująca ignorowanie wielkości liter podczas dopasowywania): 
<div class="listing"><pre>var myRegExp:RegExp = /foo-\d+/i; 
trace(myRegExp.exec("ABC Foo-32 def.")); // Foo-32 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="RegExp.html" target="">Klasa RegExp</a></div></div><a name="strict_equality"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">===&nbsp;strict equality</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 === expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza, czy dwa wyrażenia są równe, ale nie przeprowadza automatycznej konwersji danych. Wynikiem jest wartość <code>true</code>, jeśli wyrażenia są równe co do wartości i typu danych.
			<p>Operator ścisłej równości (<code>===</code>) pod trzema względami działa tak samo, jak operator równości (<code>==</code>):</p> 
			<ul> 
			  <li>Liczby i wartości typu Boolean są porównywane na podstawie wartości i są uznawane za równe, jeśli ich wartości są takie same.</li> 
			  <li>Wyrażenia typu String są równe, jeśli mają tę samą liczbę znaków i znaki na odpowiednich pozycjach są identyczne.</li> 
			  <li>Zmienne reprezentujące obiekty, tablice i funkcje są porównywane przez odwołanie. Dwie takie zmienne są równe, jeśli odwołują się do tego samego obiektu, tablicy lub funkcji. Dwie odrębne tablice nigdy nie są uznawane za równe, nawet jeśli mają tę samą liczbę elementów.</li> 
			</ul>
			Operator ścisłej równości (<code>===</code>) różni się od operatora równości (<code>==</code>) tylko pod dwoma względami:
			<ul>
			  <li>Operator ścisłej równości przeprowadza automatyczną konwersję danych tylko dla typów liczbowych (Number, int oraz uint), natomiast operator równości przeprowadza konwersję typów na wszystkich pierwotnych typach danych.</li>
			  <li>Wynikiem porównania wartości <code>null</code> i <code>undefined</code> za pomocą operatora ścisłej równości jest wartość <code>false</code>.</li>
			</ul>
			W dwóch sytuacjach związanych z użyciem wartości pierwotnych (na przykład <code>var x:Number = 1</code>) oraz obiektów pierwotnych (na przykład <code>var x:Number = new Number(1)</code>) operator równości zachowuje się w języku ActionScript 3.0 inaczej niż w języku ActionScript 2.0. Wynika to z faktu, że w języku ActionScript 3.0 zniknęło rozróżnienie między wartościami pierwotnymi a obiektami będącymi kontenerami dla wartości pierwotnych. 
			<p>Po pierwsze, porównania między wartościami pierwotnymi i obiektami pierwotnymi zawierającymi tę samą wartość zwracają wartość <code>true</code> w języku ActionScript 3.0, natomiast we wcześniejszych wersjach zwracają wartość <code>false</code>. We wcześniejszych wersjach typem danych wartości pierwotnej jest Boolean, Number albo String, natomiast typem danych obiektu pierwotnego jest zawsze typ Object, a nie Boolean, Number lub String. Praktyczne znaczenie tej różnicy ilustruje poniższy przykład. We wcześniejszych wersjach języka ActionScript zwraca on wartość <code>false</code>, ponieważ typy danych operandów są różne, ale w języku ActionScript 3.0 zwraca wynik <code>true</code>, ponieważ wartości pierwotne mają przypisany typ Boolean, Number, int, uint lub String niezależnie od tego, czy są zawarte w obiekcie, czy nie.</p>
			<div class="listing"><pre>
var num1:Number = 1;
var num2:Number = new Number(1);
trace(num1 === num2); // true in ActionScript 3.0, false in ActionScript 2.0
			</pre></div>
			Po drugie, porównania między dwoma obiektami pierwotnymi zawierającymi tę samą wartość zwracają wartość <code>true</code> w języku ActionScript 3.0, natomiast we wcześniejszych wersjach zwracają wartość <code>false</code>.
			<div class="listing"><pre>
var num1:Number = new Number(1);
var num2:Number = new Number(1);
trace(num1 == num2);  // true in ActionScript 3.0, false in ActionScript 2.0
trace(num1 === num2); // true in ActionScript 3.0, false in ActionScript 2.0</pre></div>
			Wynika to z faktu, że we wcześniejszych wersjach języka ActionScript obie zmienne należały do typu danych Object, a więc były porównywane według odwołań i wynikiem porównań zwykłych i ścisłych była wartość <code>false</code>. Natomiast w języku ActionScript 3.0 obie zmienne należą do typu danych Number, są więc porównywane według wartości, a wynikiem porównań zwykłych i ścisłych jest wartość <code>true</code>.
</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg, wartość logiczna, zmienna, obiekt, tablica lub funkcja.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg znaków, wartość typu Boolean, zmienna, obiekt, tablica lub funkcja.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wynik porównania należący do typu Boolean.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Następujący przykład demonstruje, że równość ścisła (<code>===</code>) jest tożsama z równością (<code>==</code>), gdy równe są i wartości, i typy danych:
<div class="listing"><pre>
var string1:String = "5"; 
var string2:String = "5"; 
trace(string1 == string2);  // true 
trace(string1 === string2); // true
</pre></div>
Poniższy przykład demonstruje, że operator ścisłej równości nie konwertuje typu danych String na typ Number, ale operator równości (<code>==</code>) dokonuje takiej konwersji:
<div class="listing"><pre>// The equality (==) operator converts 5 to "5", but the strict equality operator does not
var string1:String = "5"; 
var num:Number = 5; 
trace(string1 == num);  // true 
trace(string1 === num); // false 
</pre></div>
Poniższy przykład demonstruje, że operator ścisłej równości nie konwertuje wartości typu Boolean na liczby, ale operator równości dokonuje takiej konwersji:
<div class="listing"><pre>
var num:Number = 1;
var bool:Boolean = true;
trace(num == bool);  // true 
trace(num === bool); // false</pre></div>
Poniższy przykład demonstruje, że operator ścisłej równości nie konwertuje typów danych int i uint:
<div class="listing"><pre>
var num1:Number = 1;
var num2:int = 1;
var num3:uint = 1;
trace(num1 === num2); // true
trace(num1 === num3); // true</pre></div>
Poniższy przykład demonstruje, że operator ścisłej równości traktuje wartości <code>null</code> i <code>undefined</code> jako nierówne, ale operator równości uznaje je za równe:
<div class="listing"><pre>
trace(null == undefined);  // true 
trace(null === undefined); // false 
</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_AND" target="">&& (bitowe AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#strict_inequality" target="">!== (ścisła nierówność)</a></div></div><a name="strict_inequality"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">!==&nbsp;strict inequality</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 !== expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Sprawdza warunek przeciwny do ścisłej równości (<code>===</code>). Operator ścisłej nierówności działa tak samo, jak operator nierówności, z tym że konwertowane są wyłącznie typy danych int oraz unit. 
			<p>Jeśli wyrażenie <code>expression1</code> jest równe <code>expression2</code>, a ich typy danych są równe, wynikiem będzie wartość <code>false</code>.</p>
			<p>Operator ścisłej nierówności (<code>!==</code>) pod trzema względami działa tak samo, jak operator nierówności (<code>!=</code>):</p> 
			<ul> 
			  <li>Liczby i wartości typu Boolean są porównywane na podstawie wartości i są uznawane za równe, jeśli ich wartości są takie same.</li> 
			  <li>Wyrażenia typu String są równe, jeśli mają tę samą liczbę znaków i znaki na odpowiednich pozycjach są identyczne.</li> 
			  <li>Zmienne reprezentujące obiekty, tablice i funkcje są porównywane przez odwołanie. Dwie takie zmienne są równe, jeśli odwołują się do tego samego obiektu, tablicy lub funkcji. Dwie odrębne tablice nigdy nie są uznawane za równe, nawet jeśli mają tę samą liczbę elementów.</li> 
			</ul>
			Operator ścisłej nierówności różni się od operatora nierówności (<code>!=</code>) tylko pod dwoma względami:
			<ul>
			  <li>Operator ścisłej nierówności (<code>!==</code>) przeprowadza automatyczną konwersję danych tylko dla typów liczbowych Number, int oraz uint, natomiast operator nierówności (<code>!=</code>) przeprowadza konwersję typów na wszystkich pierwotnych typach danych.</li>
			  <li>Wynikiem porównania wartości <code>null</code> i <code>undefined</code> za pomocą operatora ścisłej nierówności (<code>!==</code>) jest wartość <code>true</code>.</li>
			</ul>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg, wartość logiczna, zmienna, obiekt, tablica lub funkcja.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Object.html">Object</a></code> &mdash; 
					Liczba, ciąg znaków, wartość typu Boolean, zmienna, obiekt, tablica lub funkcja.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Boolean.html">Boolean</a></code> &mdash; 
				Wynik porównania należący do typu Boolean.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Komentarze w poniższym kodzie zawierają wartości zwracane przez operator równości (<code>==</code>), ścisłej równości (<code>===</code>) oraz ścisłej nierówności (<code>!==</code>): 
<div class="listing"><pre>var s1:String = "5"; 
var s2:String = "5"; 
var s3:String = "Hello"; 
var n:Number = 5; 
var b:Boolean = true; 
trace(s1 == s2);  // true 
trace(s1 == s3);  // false 
trace(s1 == n);   // true 
trace(s1 == b);   // false 
trace(s1 === s2); // true 
trace(s1 === s3); // false 
trace(s1 === n);  // false 
trace(s1 === b);  // false 
trace(s1 !== s2); // false 
trace(s1 !== s3); // true 
trace(s1 !== n);  // true 
trace(s1 !== b);  // true </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#equality" target="">== (równość)</a><br/><a href="operators.html#inequality" target="">!= (nierówność)</a><br/><a href="operators.html#logical_AND" target="">&& (bitowe AND)</a><br/><a href="operators.html#logical_NOT" target="">! (logiczne NOT)</a><br/><a href="operators.html#logical_OR" target="">|| (suma logiczna)</a><br/><a href="operators.html#strict_equality" target="">=== (ścisła równość)</a></div></div><a name="string_delimiter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">"&nbsp;string delimiter</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> "text" </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Operator ten, użyty przed znakami i po znakach, oznacza, że znaki należy traktować literalnie i że stanowią one ciąg, a nie zmienną, wartość liczbową lub inny element języka ActionScript.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">text</span>:<a href="String.html">String</a></code> &mdash; 
					Sekwencja złożona z zera lub większej liczby znaków.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie znaki cudzysłowu (") zastosowano w celu wskazania, że wartość zmiennej <code>yourGuess</code> jest literalnie traktowanym ciągiem znaków <code>"Prince Edward Island"</code>, a nie nazwą zmiennej. 
<div class="listing"><pre>var yourGuess:String = "Prince Edward Island"; 
submit_btn.onRelease = function() { trace(yourGuess); }; 
// Prince Edward Island</pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="String.html" target="">Klasa String</a><br/><a href="package.html#String()" target="">Funkcja String()</a></div></div><a name="subtraction"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">-&nbsp;subtraction</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre><code>-expression</code></pre> <pre> <code>expression1 - expression2</code></pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Służy do zmiany znaku lub odejmowania. <p> Zastosowanie 1: Gdy operator ten jest używany do zmiany znaku, odwraca znak wyrażenia liczbowego. </p><p> Zastosowanie 2: Gdy operator jest używany do odejmowania, wykonuje operację arytmetycznego odejmowania na dwóch wyrażeniach liczbowych, tj. odejmuje <code>expression 2</code> od <code>expression1</code>. Gdy oba wyrażenia są liczbami całkowitymi, różnica jest liczbą całkowitą. Gdy przynajmniej jedno wyrażenie jest liczbą zmiennopozycyjną, różnica jest liczbą zmiennopozycyjną.</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Liczba całkowita lub zmiennopozycyjna.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Zastosowanie 1: Następująca instrukcja odwraca znak wyrażenia 2 + 3: 
<div class="listing"><pre>trace(-(2 + 3)); // -5 </pre></div> 
Zastosowanie 2: Następująca instrukcja odejmuje liczbę całkowitą 2 od liczby całkowitej 5: 
<div class="listing"><pre>trace(5 - 2); // 3 </pre></div> Wynik, 3, jest liczbą całkowitą.
<p>Następująca instrukcja odejmuje liczbę zmiennopozycyjną 1,5 od liczby zmiennopozycyjnej 3,25:</p>
<div class="listing"><pre>trace(3.25 - 1.5); // 1.75 </pre></div> 
Wynik, 1,75, jest liczbą zmiennopozycyjną.<p></p></div><a name="subtraction_assignment"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">-=&nbsp;subtraction assignment</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>expression1 -= expression2</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Przypisuje wyrażeniu <code>expression1</code> wartość <code> expression1 - expression2</code>. Na przykład następujące dwie instrukcje są równoważne: 
			<pre>x -= y ;
x = x - y;</pre> 
			<p>Wyrażenia typu String muszą być przekonwertowane na liczby; w przeciwnym razie wynikiem będzie wartość <code>NaN</code> („nie jest liczbą”).</p></p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression1</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">expression2</span>:<a href="Number.html">Number</a></code> &mdash; 
					Liczba lub wyrażenie, którego wyznaczona wartość jest liczbą.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Number.html">Number</a></code> &mdash; 
				Wynik operacji arytmetycznej.
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>W poniższym przykładzie zastosowano operator przypisania po odejmowaniu (<code>-=</code>) w celu odjęcia liczby 10 od liczby 5 i przypisania wyniku zmiennej <code>x</code>: 
<div class="listing"><pre>var x:Number = 5; 
var y:Number = 10; 
x -= y; 
trace(x); // -5 </pre></div> Następujący przykład ilustruje konwersję ciągów znaków na liczby: 
<div class="listing"><pre>var x:String = "5"; 
var y:String = "10"; 
x -= y; 
trace(x); // -5 </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#subtraction" target="">- (odejmowanie)</a></div></div><a name="type"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">:&nbsp;type</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre>[modifiers] var variableName:type</pre> <pre>function functionName():type { ... }</pre> <pre>function functionName(parameter1:type, ..., parameterN:type) [:type]{ ... } </pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Służy do przypisywania typu danych; ten operator określa typ zmiennej, typ wartości zwracanej przez funkcję lub typ parametru funkcji. Gdy jest używany w deklaracji zmiennej lub przypisaniu, operator ten określa typ zmiennej; gdy jest używany w deklaracji lub definicji zmiennej, operator ten określa typ wartości zwracanej przez funkcję; gdy jest używany z parametrem funkcji w definicji funkcji, operator ten określa typ zmiennej oczekiwany dla tego parametru. 
			<p>Typ jest sprawdzany zawsze w czasie wykonywania. Jednak gdy kompilator działa w trybie ścisłym, wszystkie typy są również sprawdzane w czasie kompilacji, a w razie niezgodności generowane są błędy. Niezgodności mogą wystąpić w operacjach przypisania, wywołaniach funkcji i rozstrzyganiu odwołań do elementów klas za pomocą operatora kropki (<code>.</code>).</p> 
			<p>Do typów, których można używać, należą wszystkie natywne typy obiektów, klasy oraz interfejsy zdefiniowane przez użytkownika oraz typ <code>void</code>. Rozpoznawane typy natywne to Boolean, Number, int, uint oraz String. Jako typy natywne obsługiwane są również wszystkie klasy wbudowane.</p>
			<p>Jeśli typ nie zostanie przypisany, zmienne, wartości zwracane przez funkcję lub parametry funkcji uznawane są za pozbawione typu, co oznacza że ich wartości mogą należeć do dowolnych typów. Aby jednoznacznie wyrazić zamiar użycia wartości bez typu, można jako adnotacji typu użyć znaku gwiazdki (&#42;). Znak gwiazdki użyty w charakterze opisu typu jest równoważny pozostawieniu zmiennej, wartości zwracanej przez funkcję lub parametru funkcji bez określonego typu.</p>
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">variableName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Identyfikator zmiennej.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">type</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Natywny typ danych, nazwa klasy zdefiniowanej przez użytkownika lub nazwa interfejsu.			
				</td></tr><tr><td width="20px"></td><td><code><span class="label">functionName</span>:<a href="Function.html">Function</a></code> &mdash; 
					Identyfikator funkcji.			
				</td></tr><tr><td width="20px"></td><td><code><span class="label">parameter</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Identyfikator parametru funkcji.			
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Zastosowanie 1: W poniższym przykładzie deklarowana jest zmienna publiczna o nazwie <code>userName</code> typu String; zmiennej tej jest przypisywany pusty ciąg znaków: 
<div class="listing"><pre>var userName:String = ""; </pre></div> 
Zastosowanie 2: Poniższy przykład ilustruje sposób określania typu wartości zwracanej przez funkcję poprzez zdefiniowanie funkcji o nazwie <code>randomInt()</code>, która zwraca wartość typu int: 
<div class="listing"><pre>function randomInt(integer:int):int { 
	return Math.round(Math.random()*integer); 
} 
trace(randomInt(8)); </pre></div> 
Zastosowanie 3: W poniższym przykładzie definiowana jest funkcja o nazwie <code>squareRoot()</code> z parametrem o nazwie <code>val</code> należącym do typu Number; funkcja ta zwraca pierwiastek kwadratowy parametru <code>val</code>, również typu Number: 
<div class="listing"><pre>function squareRoot(val:Number):Number { 
	return Math.sqrt(val); 
} 
trace(squareRoot(121)); </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="statements.html#function" target="">instrukcja function</a><br/><a href="statements.html#var" target="">instrukcja var</a></div></div><a name="typeof"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;typeof</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>typeof expression</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia <code>expression</code> i zwraca ciąg znaków opisujący typ danych tego wyrażenia. Wynikiem może być jedna z sześciu wartości typu String: <code>boolean</code>, <code>function</code>, <code>number</code>, <code>object</code>, <code>string</code> albo <code>xml</code>. Zastosowanie tego obiektu do instancji klasy zdefiniowanej przez użytkownika da w wyniku ciąg znaków <code>object</code>. Operator <code>typeof</code> został uwzględniony w celu zachowania zgodności wstecz. Do sprawdzania kompatybilności typów należy używać operatora <code>is</code>.
			</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Object.html">Object</a></code> &mdash; 
					Obiekt do sprawdzenia.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="String.html">String</a></code> &mdash; 
				Ciąg znaków opisujący typ wyrażenia <code>expression</code>. W poniższej tabeli przedstawiono wyniki działania operatora <code>typeof</code> na wyrażeniach poszczególnych typów.
<p></p>
<table class="innertable" width="250"><colspec colnum="1"></colspec><colspec colnum="2"></colspec><thead><tr><th><p>Typ wyrażenia</p></th><th><p>Wynik</p></th></tr></thead><tbody><tr><td><p>
      Array
    </p></td><td><p>
      <code>obiekt</code>
    </p></td></tr><tr><td><p>
      Boolean
    </p></td><td><p>
      <code>boolean</code>
    </p></td></tr><tr><td><p>
      Funkcja
    </p></td><td><p>
      <code>funkcja</code>
    </p></td></tr><tr><td><p>
      int
    </p></td><td><p>
      <code>liczba</code>
    </p></td></tr><tr><td><p>
      Number
    </p></td><td><p>
      <code>liczba</code>
    </p></td></tr><tr><td><p>
      Object
    </p></td><td><p>
      <code>object</code>
    </p></td></tr><tr><td><p>
      String
    </p></td><td><p>
      <code>string</code>
    </p></td></tr><tr><td><p>
      uint
    </p></td><td><p>
      <code>number</code>
    </p></td></tr><tr><td><p>
      XML
    </p></td><td><p>
      <code>xml</code>
    </p></td></tr><tr><td><p>
      XMLList
    </p></td><td><p>
      <code>xml</code>
    </p></td></tr><tr><td><p>
      &#42;
    </p></td><td><p>
      <code>undefined</code>
    </p></td></tr></tbody></table>
			</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>
				Poniższy przykład ilustruje wynik zastosowania operatora <code>typeof</code> do różnych obiektów i wartości.
<div class="listing"><pre>
trace(typeof Array); // object
trace(typeof Date);  // object
trace(typeof 3);     // number
</pre></div>
Poniższy przykład demonstruje, że w języku ActionScript 3.0 typ danych obiektu pierwotnego jest taki sam, niezależnie od tego, czy obiektowi przypisano wartość literalną, czy też użyto do jego utworzenia operatora <code>new</code>. Zachowanie to jest inne niż obowiązujące w poprzednich wersjach języka ActionScript, w których operator <code>typeof</code> zwróciłby wartość <code>object</code> dla zmiennej <code>b</code>:
<div class="listing"><pre>
var a:String = "sample";
var b:String = new String("sample");
trace(typeof a); // string
trace(typeof b); // string 
</pre></div>
				
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="operators.html#as" target="">as</a><br/><a href="operators.html#instanceof" target="">instanceof</a><br/><a href="operators.html#is" target="">is</a></div></div><a name="void"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">&nbsp;void</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><code>void expression</code></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Wyznacza wartość wyrażenia po czym odrzuca tę wartość i zwraca wartość <code>undefined</code>. Operator <code>void</code> jest często używany w porównaniach razem z operatorem <code>==</code> do sprawdzania, czy wartości są niezdefiniowane.</p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">expression</span>:<a href="Object.html">Object</a></code> &mdash; 
					Wyrażenie, którego wartość ma być wyznaczona.
				</td></tr></table><p></p><span class="label">Wynik</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
				Wartość <code>undefined</code>.
			</td></tr></table></div><a name="XML_literal_tag_delimiter"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName">< >&nbsp;XML literal tag delimiter</td><td class="detailHeaderType"> Operator </td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><span class="label">Zastosowanie</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><p outputclass="usage"><pre> myXML= <{tagName} {attributeName} = {attributeValue}>{content}</{tagName}></pre></p></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9</td></tr></table><p></p><p><p otherprops="description">Definiuje znacznik XML w literale XML. Do zdefiniowania znacznika zamykającego należy użyć ukośnika /. </p></p><p></p><span class="label">Operandy</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">myXML</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Obiekt XML lub XMLList.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">tagName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest nazwą znacznika XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">attributeName</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest nazwą atrybutu XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">attributeValue</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest wartością atrybutu XML.
				</td></tr><tr><td width="20px"></td><td><code><span class="label">content</span>:<a xmlns:xd="http://www.pnp-software.com/XSLTdoc" href="specialTypes.html#*">*</a></code> &mdash; 
					Wyrażenie, którego wartość jest zawartością znacznika XML.
				</td></tr></table><br/><span class="label">Przykład</span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Poniższy przykład ilustruje użycie operatorów <<code>&lt;</code> i <code>&gt;</code> do definiowania literału XML:
<div class="listing"><pre>var x:XML = &lt;item id= "324"&gt;cola&lt;/item&gt;; </pre></div>
			<p></p><p><span class="label"> Powiązane elementy interfejsu API </span></p><div class="seeAlso"><a href="XML.html" target="">Klasa XML</a><br/><a href="XMLList.html" target="">Klasa XMLList</a></div></div><p></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:23 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/pl_PL/legalnotices/index.html">Informacje prawne</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Zasady prywatności online</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Dlaczego język angielski?</span>
				</div>
				<div class="white_content_body">
					<b>Treść dokumentacji języka ActionScript 3.0 wyświetlana w języku angielskim</b><br><br>
					Niektóre części dokumentacji języka ActionScript 3.0 nie są przetłumaczone na poszczególne języki. Gdy element nie jest przetłumaczony na dany język, jest wyświetlany tekst angielski. Na przykład opis klasy ga.controls.HelpBox nie jest przetłumaczony na żaden dodatkowy język. Z tego powodu polska wersja dokumentacji zawiera opis klasy ga.controls.HelpBox w języku angielskim.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:23 PM Z  -->
