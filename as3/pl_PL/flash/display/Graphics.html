<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 &mdash; dokumentacja dla platformy Adobe&reg; Flash&reg;  "><meta name="lang" content="pl-pl"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="lite"><meta name="runtimever" content="lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="lite"><meta name="productver" content="lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="Graphics,flash.display.Graphics,beginBitmapFill,beginFill,beginGradientFill,beginShaderFill,clear,copyFrom,cubicCurveTo,curveTo,drawCircle,drawEllipse,drawGraphicsData,drawPath,drawRect,drawRoundRect,drawTriangles,endFill,lineBitmapStyle,lineGradientStyle,lineShaderStyle,lineStyle,lineTo,moveTo,readGraphicsData"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>Graphics - Adobe ActionScript&reg; 3 (AS3 ) &mdash; dokumentacja interfejsu API</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Środowiska wykonawcze";
			var productsLabel = "Produkty";
			var noneLabel = "Brak";
			var qsearchBoxLabel = "Wyszukiwanie";
			var qsearchText = "Nie znaleziono terminu.";
			var ajaxErrorMsg="Błąd wczytywania strony";
			var ajaxErrorTryMsg="Ponów próbę";
			var ajaxLoadingMsg="Wczytywanie nadal w toku";
			var cancelMsg = "Anuluj";
			var classesText = "Klasy";
			var strJiveReply = "To pytanie zamieszczono w odpowiedzi na następujący artykuł: "
			var showFilters = "Pokaż filtry";
			var hideFilters = "Ukryj filtry";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 &mdash; dokumentacja dla platformy Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Strona główna </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="Graphics.html#top" style="display:">Pokaż listę pakietów i klas</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="Graphics.html#top" style="display:none">Ukryj listę pakietów i klas</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Pakiety </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Klasy </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Nowości </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Indeks </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Dodatki </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Dlaczego język angielski?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/pl_PL/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filtry:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="Graphics.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">Graphics&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="Graphics.html#propertySummary" style="display:none"> Właściwości </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="Graphics.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Właściwości </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="Graphics.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="Graphics.html#methodSummary" style="display:none"> Metody </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="Graphics.html#constantSummary" style="display:none"> Stałe globalne </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="Graphics.html#eventSummary" style="display:none"> Zdarzenia </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="Graphics.html#styleSummary" style="display:none"> Style </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="Graphics.html#SkinPartSummary" style="display:none"> Części karnacji </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="Graphics.html#SkinStateSummary" style="display:none"> Stany karnacji </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="Graphics.html#effectSummary" style="display:none"> Efekty </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="Graphics.html#constantSummary" style="display:none"> Stałe </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="Graphics.html#methodSummary" style="display:none"> Funkcje globalne </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="Graphics.html#methodSummary" style="display:none">Funkcje</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="Graphics.html#interfaceSummary" style="display:none"> Interfejsy </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="Graphics.html#classSummary" style="display:none"> Klasy </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="Graphics.html#includeExamplesSummary" style="display:none"> Przykłady </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="Graphics.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klasy
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Pakiet</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">Klasa</td><td class="classSignature">public final   class  Graphics</td></tr><tr><td class="classHeaderTableLabel">Dziedziczenie</td><td class="inheritanceList">Graphics  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 Klasa Graphics zawiera zbiór metod używanych do tworzenia kształtów wektorowych. Obiekty wyświetlane, które obsługują rysowanie zawierają obiekty Sprite i Shape. Każda z tych klas zawiera właściwość <code>graphics</code>, która jest obiektem Graphics. Poniżej zostały wymienione funkcje pomocnicze, zapewnione w celu ułatwienia obsługi: <code>drawRect()</code>, <code>drawRoundRect()</code>, <code>drawCircle()</code> oraz <code>drawEllipse()</code>.
 
 <p>Nie jest możliwe utworzenie obiektu Graphics bezpośrednio z kodu ActionScript. W przypadku wywołania metody <code>new Graphics()</code> zostanie zgłoszony wyjątek.</p>
 
               <p>Klasa Graphics jest końcowa; nie mogą być tworzone z niej podklasy.</p>
 
 
            <p></p><p><a href="Graphics.html#includeExamplesSummary">Wyświetl przykłady</a></p><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Właściwości publiczne</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="Graphics.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ukryj dziedziczone właściwości publiczne</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="Graphics.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Pokaż dziedziczone właściwości publiczne</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable hideInheritedProperty" id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Właściwość</th><th>Zdefiniowane przez</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Odwołanie do obiektu klasy lub funkcji konstruktora, dotyczące danej instancji obiektu.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Metody publiczne </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="Graphics.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ukryj dziedziczone metody publiczne</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="Graphics.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Pokaż dziedziczone metody publiczne</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Metoda</th><th>Zdefiniowane przez</th></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#beginBitmapFill()" class="signatureLink">beginBitmapFill</a>(bitmap:<a href="BitmapData.html">BitmapData</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, repeat:<a href="../../Boolean.html">Boolean</a> = true, smooth:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Wypełnia obszar rysunkowy obrazem bitmapowym.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#beginFill()" class="signatureLink">beginFill</a>(color:<a href="../../uint.html">uint</a>, alpha:<a href="../../Number.html">Number</a> = 1.0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
 	 Określa proste wypełnienie jednokolorowe, które będzie używane w kolejnych wywołaniach innych metod klasy Graphics, takich jak lineTo() lub drawCircle().</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#beginGradientFill()" class="signatureLink">beginGradientFill</a>(type:<a href="../../String.html">String</a>, colors:<a href="../../Array.html">Array</a>, alphas:<a href="../../Array.html">Array</a>, ratios:<a href="../../Array.html">Array</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, spreadMethod:<a href="../../String.html">String</a> = "pad", interpolationMethod:<a href="../../String.html">String</a> = "rgb", focalPointRatio:<a href="../../Number.html">Number</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Określa wypełnienie gradientowe, które będzie stosowane przy kolejnych wywołaniach metod z klasy Graphics (np. lineTo() i drawCircle()) dla obiektu.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#beginShaderFill()" class="signatureLink">beginShaderFill</a>(shader:<a href="Shader.html">Shader</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
 	 Określa wypełnienie cieniowane, które będzie stosowane przy kolejnych wywołaniach metod klasy Graphics (np. lineTo() i drawCircle()) dla obiektu.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#clear()" class="signatureLink">clear</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Kasuje grafikę przypisaną do tego obiektu Graphics, resetuje wypełnienia i style linii.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#copyFrom()" class="signatureLink">copyFrom</a>(sourceGraphics:<a href="Graphics.html">Graphics</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Kopiuje wszystkie polecenia rysunku ze źródłowego obiektu Graphics do wywołującego obiektu Graphics.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#cubicCurveTo()" class="signatureLink">cubicCurveTo</a>(controlX1:<a href="../../Number.html">Number</a>, controlY1:<a href="../../Number.html">Number</a>, controlX2:<a href="../../Number.html">Number</a>, controlY2:<a href="../../Number.html">Number</a>, anchorX:<a href="../../Number.html">Number</a>, anchorY:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Rysuje sześcienną krzywą Beziera z bieżącego położenia rysowania do określonego punktu kotwiczenia.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#curveTo()" class="signatureLink">curveTo</a>(controlX:<a href="../../Number.html">Number</a>, controlY:<a href="../../Number.html">Number</a>, anchorX:<a href="../../Number.html">Number</a>, anchorY:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje kwadratową krzywą Beziera przy użyciu bieżącego stylu linii z bieżącego położenia rysowania do punktu (anchorX, anchorY) zgodnie z punktem kontrolnym (controlX, controlY).</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawCircle()" class="signatureLink">drawCircle</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, radius:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje okrąg.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawEllipse()" class="signatureLink">drawEllipse</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje elipsę.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawGraphicsData()" class="signatureLink">drawGraphicsData</a>(graphicsData:<a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Wysyła serię instancji IGraphicsData dla rysunku.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawPath()" class="signatureLink">drawPath</a>(commands:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt;, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, winding:<a href="../../String.html">String</a> = "evenOdd"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Wysyła serię poleceń dla rysunku.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawRect()" class="signatureLink">drawRect</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje prostokąt.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawRoundRect()" class="signatureLink">drawRoundRect</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>, ellipseWidth:<a href="../../Number.html">Number</a>, ellipseHeight:<a href="../../Number.html">Number</a> = NaN):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje zaokrąglony prostokąt.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#drawTriangles()" class="signatureLink">drawTriangles</a>(vertices:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, indices:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt; = null, uvtData:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt; = null, culling:<a href="../../String.html">String</a> = "none"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Renderuje zbiór trójkątów, zwykle w celu odkształcenia bitmap i nadania im wyglądu trójwymiarowego.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#endFill()" class="signatureLink">endFill</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Stosuje wypełnienie linii oraz krzywych, które zostały dodane od momentu ostatniego wywołania metod beginFill(), beginGradientFill() lub beginBitmapFill().</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy dla obiektu zdefiniowano określoną właściwość.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy instancja klasy Object należy do łańcucha prototypów obiektu określonego jako parametr.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#lineBitmapStyle()" class="signatureLink">lineBitmapStyle</a>(bitmap:<a href="BitmapData.html">BitmapData</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, repeat:<a href="../../Boolean.html">Boolean</a> = true, smooth:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Określa bitmapę, jaka będzie używana dla obrysu podczas rysowania linii.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#lineGradientStyle()" class="signatureLink">lineGradientStyle</a>(type:<a href="../../String.html">String</a>, colors:<a href="../../Array.html">Array</a>, alphas:<a href="../../Array.html">Array</a>, ratios:<a href="../../Array.html">Array</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, spreadMethod:<a href="../../String.html">String</a> = "pad", interpolationMethod:<a href="../../String.html">String</a> = "rgb", focalPointRatio:<a href="../../Number.html">Number</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Określa gradient, jaki będzie używany dla obrysu podczas rysowania linii.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::10##AIR::1.5##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#lineShaderStyle()" class="signatureLink">lineShaderStyle</a>(shader:<a href="Shader.html">Shader</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Określa moduł cieniujący, jaki będzie używany dla obrysu podczas rysowania linii.</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#lineStyle()" class="signatureLink">lineStyle</a>(thickness:<a href="../../Number.html">Number</a> = NaN, color:<a href="../../uint.html">uint</a> = 0, alpha:<a href="../../Number.html">Number</a> = 1.0, pixelHinting:<a href="../../Boolean.html">Boolean</a> = false, scaleMode:<a href="../../String.html">String</a> = "normal", caps:<a href="../../String.html">String</a> = null, joints:<a href="../../String.html">String</a> = null, miterLimit:<a href="../../Number.html">Number</a> = 3):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Określa styl linii jaki będzie używany dla kolejnych wywołań metod Graphics, takich jak lineTo() lub drawCircle().</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#lineTo()" class="signatureLink">lineTo</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	 Rysuje linię przy wykorzystaniu obecnego stylu linii z obecnej pozycji rysowania do (x,y); wówczas obecna pozycja rysowania jest ustawiana na (x,y).</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#moveTo()" class="signatureLink">moveTo</a>(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Zmienia położenie kursora rysowania na (x, y).</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy określona właściwość istnieje i jest przeliczalna.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11.6##AIR::3.6##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Graphics.html#readGraphicsData()" class="signatureLink">readGraphicsData</a>(recurse:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;</div><div class="summaryTableDescription">
	 Pobiera zawartość grafiki wektorowej obiektu Sprite lub Shape (opcjonalnie jego elementów potomnych).</div></td><td class="summaryTableOwnerCol">Graphics</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ustawia dostępność właściwości dynamicznej używanej w pętlach.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Zwraca ciąg reprezentujący obiekt &mdash; sformatowany zgodnie z konwencjami właściwymi dla ustawień regionalnych.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Zwraca ciąg reprezentujący określony obiekt.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Zwraca pierwotną wartość dla określonego obiektu.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Szczegół metody</div><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="beginBitmapFill()" id="beginBitmapFill()"></a><a name="beginBitmapFill(flash.display.BitmapData,flash.geom.Matrix,Boolean,Boolean)" id="beginBitmapFill(flash.display.BitmapData,flash.geom.Matrix,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>beginBitmapFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td></tr></table><div class="detailBody"><code> public function beginBitmapFill(bitmap:<a href="BitmapData.html">BitmapData</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, repeat:<a href="../../Boolean.html">Boolean</a> = true, smooth:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Wypełnia obszar rysunkowy obrazem bitmapowym. Bitmapa może być powtarzana lub w postaci mozaiki w celu wypełnienia obszaru. Wypełnienie będzie obowiązywało do czasu wywołania metody <code>beginFill()</code>, <code>beginBitmapFill()</code>, <code>beginGradientFill()</code> lub <code>beginShaderFill()</code>. Wywołanie metody <code>clear()</code> powoduje wyczyszczenie zawartości wypełnienia.
	 
	 <p>Aplikacja renderuje wypełnienie w momencie narysowania trzech lub więcej punktów lub gdy wywołana zostanie metoda <code>endFill()</code>. </p>
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">bitmap</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Przezroczysty lub nieprzezroczysty obraz bitmapowy, zawierający bity, które będą wyświetlane.
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt matrycy (klasy flash.geom.Matrix), który może zostać wykorzystany do definiowana przekształceń bitmapy. Na przykład: możliwe jest wykorzystanie poniższej macierzy do obracania bitmapy o 45 stopni (pi/4 radiany):
	 
	 <div class="listing"><pre>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </pre></div>
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">repeat</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Jeżeli wartość <code>true</code>, wówczas obraz bitmapowy jest powtarzany we wzorze mozaikowym. Jeżeli wartość <code>false</code>, wówczas obraz bitmapowy nie jest powtarzany, zaś krawędzie bitmapy są wykorzystywane w dowolnym obszarze wypełniania, który rozciąga się poza bitmapę. 
	 
	 <p>Przykładowo biorąc pod uwagę poniższą bitmapę (wzór szachownicy wielkości 20 x 20 pikseli):</p>
	 
     <p><img src="../../images/movieClip_beginBitmapFill_repeat_1.jpg" alt="szachownica wielkości 20 na 20 pikseli"></img></p>
	 
	 <p>W przypadku ustawienia właściwości <code>repeat</code> na wartość <code>true</code> (tak jak w poniższym przykładzie), wypełnienie bitmapy powtarza bitmapę:</p>
	 
     <p><img src="../../images/movieClip_beginBitmapFill_repeat_2.jpg" alt="szachownica wielkości 60 na 60 pikseli"></img></p>
	 
	 <p>W przypadku ustawienia dla właściwości <code>repeat</code> wartości <code>false</code> wypełnienie bitmapy wykorzystuje piksele krawędziowe w obszarze wypełniania, który znajduje się poza bitmapą:</p>
	 
     <p><img src="../../images/movieClip_beginBitmapFill_repeat_3.jpg" alt="obraz wielkości 60 na 60 pikseli bez powtarzania"></img></p>
	 
   	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smooth</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Jeżeli wartość <code>false</code>, wówczas powiększone obrazy bitmapowe są renderowane za pomocą algorytmu sąsiadowania i występuje efekt pikselizacji. Jeżeli wartość <code>true</code>, wówczas powiększone obrazy bitmapowe są renderowane za pomocą algorytmu dwuliniowego. Renderowanie przy użyciu algorytmu najbliższego sąsiada (NNA, ang. nearest neighbor algorithm) jest szybsze.
	 
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#endFill()" target="">endFill()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje zastosowanie obrazu (<code>image1.jpg</code>), który jest obracany i powtarzany, w celu wypełnienia prostokąta.
 
 <ol><li>Plik obrazu (<code>image1.jpg</code>) jest ładowany przy pomocy obiektów <code>Loader</code> i <code>URLRequest</code>. W tym przypadku plik znajduje się w tym samym katalogu co plik SWF. Konieczne jest aby plik SWF został skompilowany przy pomocy zabezpieczenia odtwarzania lokalnego, ustawionego na dostęp tylko do plików lokalnych.</li><li>Przy ładowaniu obrazu (zdarzenie <code>Event</code> jest zakończone) wywoływana jest metoda <code>drawImage()</code>. Metoda <code>ioErrorHandler()</code> zapisuje komentarz śledzenia, w przypadku niepoprawnego załadowania obrazu.</li><li>W metodzie <code>drawImage()</code> obiekt <code>BitmapData</code> jest instancjonowany, zaś jego szerokość i wysokość są ustawiane zgodnie z obrazem (<code>image1.jpg</code>). Wówczas obraz źródłowy jest wrysowywany w obiekt BitmapData. Następnie w obiekcie Sprite <code>mySprite</code> rysowany jest prostokąt wypełniany przy wykorzystaniu obiektu BitmapData. Korzystając z obiektu <code>Matrix</code>, metoda <code>beginBitmapFill()</code> obraca obraz o 45 stopni, a następnie rozpoczyna wypełnianie prostokąta obrazem. </li></ol>
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.net.URLRequest;
    import flash.events.Event;
    import flash.events.IOErrorEvent;
    import flash.geom.Matrix;

    public class Graphics_beginBitmapFillExample extends Sprite {
 
        private var url:String = "image1.jpg";
        private var loader:Loader = new Loader();

        public function Graphics_beginBitmapFillExample() {

            var request:URLRequest = new URLRequest(url);
            
            loader.load(request);
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, drawImage);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
        }

        private function drawImage(event:Event):void {

            var mySprite:Sprite = new Sprite();
            var myBitmap:BitmapData = new BitmapData(loader.width, loader.height, false);
  
            myBitmap.draw(loader, new Matrix());
            
            var matrix:Matrix = new Matrix();
            matrix.rotate(Math.PI/4);
            
            mySprite.graphics.beginBitmapFill(myBitmap, matrix, true);
            mySprite.graphics.drawRect(100, 50, 200, 90);
            mySprite.graphics.endFill();
            
            addChild(mySprite);
        }
 
         private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }   
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="beginFill()" id="beginFill()"></a><a name="beginFill(uint,Number)" id="beginFill(uint,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>beginFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function beginFill(color:<a href="../../uint.html">uint</a>, alpha:<a href="../../Number.html">Number</a> = 1.0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
 	 Określa proste wypełnienie jednokolorowe, które będzie używane w kolejnych wywołaniach innych metod klasy Graphics, takich jak <code>lineTo()</code> lub <code>drawCircle()</code>. Wypełnienie będzie obowiązywało do czasu wywołania metody <code>beginFill()</code>, <code>beginBitmapFill()</code>, <code>beginGradientFill()</code> lub <code>beginShaderFill()</code>. Wywołanie metody <code>clear()</code> powoduje wyczyszczenie zawartości wypełnienia.
	 
	 <p>Aplikacja renderuje wypełnienie w momencie narysowania trzech lub więcej punktów lub gdy wywołana zostanie metoda <code>endFill()</code>.</p>
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Kolor wypełnienia (0xRRGGBB).
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; Wartość alpha wypełnienia (0,0 do 1,0). 
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#endFill()" target="">endFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a></div><br/><span class="label"> Przykład </span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Sposób zastosowania tej metody został przedstawiony na końcu tej lekcji w sekcji <a href="Graphics.html#includeExamplesSummary" >Przykład</a>. 
      
      </div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="beginGradientFill()" id="beginGradientFill()"></a><a name="beginGradientFill(String,Array,Array,Array,flash.geom.Matrix,String,String,Number)" id="beginGradientFill(String,Array,Array,Array,flash.geom.Matrix,String,String,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>beginGradientFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function beginGradientFill(type:<a href="../../String.html">String</a>, colors:<a href="../../Array.html">Array</a>, alphas:<a href="../../Array.html">Array</a>, ratios:<a href="../../Array.html">Array</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, spreadMethod:<a href="../../String.html">String</a> = "pad", interpolationMethod:<a href="../../String.html">String</a> = "rgb", focalPointRatio:<a href="../../Number.html">Number</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Określa wypełnienie gradientowe, które będzie stosowane przy kolejnych wywołaniach metod z klasy Graphics (np. <code>lineTo()</code> i <code>drawCircle()</code>) dla obiektu. Wypełnienie będzie obowiązywało do czasu wywołania metody <code>beginFill()</code>, <code>beginBitmapFill()</code>, <code>beginGradientFill()</code> lub <code>beginShaderFill()</code>. Wywołanie metody <code>clear()</code> powoduje wyczyszczenie zawartości wypełnienia.
	 
	 <p>Aplikacja renderuje wypełnienie w momencie narysowania trzech lub więcej punktów lub gdy wywołana zostanie metoda <code>endFill()</code>. </p>
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">type</span>:<a href="../../String.html">String</a></code> &mdash; Wartość z klasy GradientType, która określa który z typów gradientów należy zastosować: <code>GradientType.LINEAR</code> czy <code>GradientType.RADIAL</code>. 
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colors</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica wartości kolorów RGB w formacie szesnastkowym do wykorzystania w gradiencie, na przykład: czerwony to 0xFF0000, niebieski to 0x0000FF itd. Możliwe jest określenie maksymalnie 15 kolorów. Dla każdego koloru należy określić odpowiednią wartość w parametrach alpha i proporcji.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphas</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica wartości alpha dla odpowiednich kolorów w tablicy kolorów; wartości prawidłowe są w zakresie od 0 do 1. Jeżeli wartość wynosi mniej niż 0, wówczas wartość domyślna wynosi 0. Jeżeli wartość wynosi więcej niż 1, wówczas wartość domyślna wynosi 1.
     
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">ratios</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica proporcji dystrybucji kolorów; wartości prawidłowe są w zakresie od 0 do 255. Ta wartość definiuje procent szerokości, w której kolor jest próbkowany w 100%. Wartość 0 reprezentuje położenie po lewej stronie pola gradientu, zaś wartość 255 reprezentuje położenie po prawej stronie pola gradientu. 
	 
	 <p><b>Uwaga:</b> Ta wartość reprezentuje położenia w polu gradientu, a nie układu współrzędnych końcowego gradientu, który może być szerszy lub cieńszy od pola gradientu. Należy określić wartość dla każdej wartości parametru <code>colors</code>. </p>
	 
	 <p>Przykładowo dla gradientu liniowego, który zawiera dwa kolory (niebieski i zielony), poniższy przykład ilustruje umiejscowienie kolorów w formie gradientowej według wartości innych niż znajdujące się w tablicy <code>ratios</code>:</p>
	 
	 <table class="innertable" ><tr><th><code>ratios</code></th><th>Gradient</th></tr><tr><td><code>[0, 127]</code></td><td><img src="../../images/gradient-ratios-1.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 0 i 127"></img></td></tr><tr><td><code>[0, 255]</code></td><td><img src="../../images/gradient-ratios-2.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 0 i 255"></img></td></tr><tr><td><code>[127, 255]</code></td><td><img src="../../images/gradient-ratios-3.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 127 i 255"></img></td></tr></table>
	 
	 <p>Wartości w tablicy muszą zwiększać się w sekwencji; przykładowo: <code>[0, 63, 127, 190, 255]</code>. </p>
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Macierz przekształceń jest zdefiniowana przez klasę flash.geom.Matrix. Klasa flash.geom.Matrix zawiera metodę <code>createGradientBox()</code>, która pozwala na wygodne ustawienie matrycy do użycia z metodą <code>beginGradientFill()</code>.
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">spreadMethod</span>:<a href="../../String.html">String</a></code> (default = "<code>pad</code>")<code></code> &mdash; Wartość z klasy SpreadMethod określa którą z metod rysowania należy wykorzystać: <code>SpreadMethod.PAD</code>, <code>SpreadMethod.REFLECT</code> lub <code>SpreadMethod.REPEAT</code>. 
	 
	 <p>Przykładowo biorąc pod uwagę prosty gradient liniowy między dwoma barwami:</p>
	 
	 <div class="listing"><pre>
     import flash.geom.*
     import flash.display.*
     var fillType:String = GradientType.LINEAR;
     var colors:Array = [0xFF0000, 0x0000FF];
     var alphas:Array = [1, 1];
     var ratios:Array = [0x00, 0xFF];
     var matr:Matrix = new Matrix();
     matr.createGradientBox(20, 20, 0, 0, 0);
     var spreadMethod:String = SpreadMethod.PAD;
     this.graphics.beginGradientFill(fillType, colors, alphas, ratios, matr, spreadMethod);        
     this.graphics.drawRect(0,0,100,100);
     </pre></div>
	 
	 	<p>W tym przykładzie zastosowano metodę rysowania <code>SpreadMethod.PAD</code>, dzięki czemu wypełnienie gradientu wygląda następująco:</p>
	 
      <p><img src="../../images/beginGradientFill_spread_pad.jpg" alt="gradient liniowy z metodą SpreadMethod.PAD"></img></p>
 	 
	 	<p>W przypadku zastosowania metody rysowania <code>SpreadMethod.REFLECT</code> wypełnienie gradientu wygląda następująco:</p>
 	 
      <p><img src="../../images/beginGradientFill_spread_reflect.jpg" alt="gradient liniowy z metodą SpreadMethod.REFLECT"></img></p>
 	 
	 	<p>W przypadku zastosowania metody rysowania <code>SpreadMethod.REPEAT</code> wypełnienie gradientu wygląda następująco:</p>
 	 
      <p><img src="../../images/beginGradientFill_spread_repeat.jpg" alt="gradient liniowy z metodą SpreadMethod.REPEAT"></img></p>
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">interpolationMethod</span>:<a href="../../String.html">String</a></code> (default = "<code>rgb</code>")<code></code> &mdash; Wartość dla klasy InterpolationMethod, która określa wartość do użycia: <code>InterpolationMethod.LINEAR_RGB</code> lub <code>InterpolationMethod.RGB</code>
	 
	 <p>Przykładowo biorąc pod uwagę prosty gradient liniowy między dwoma barwami (przy parametrze <code>spreadMethod</code> ustawionym na wartość <code>SpreadMethod.REFLECT</code>). Różne metody interpolacji wpływają na wygląd w następujący sposób: </p>
	 
      <table class="+ topic/table adobe-d/adobetable " ><tr><td align="center">  <img src="../../images/beginGradientFill_interp_linearrgb.jpg" alt="gradient liniowy z metodą InterpolationMethod.LINEAR_RGB"></img>  </td><td align="center">  <img src="../../images/beginGradientFill_interp_rgb.jpg" alt="gradient liniowy z metodą InterpolationMethod.RGB"></img>  </td></tr><tr><td align="center"><code>InterpolationMethod.LINEAR_RGB</code></td><td align="center"><code>InterpolationMethod.RGB</code></td></tr></table>
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">focalPointRatio</span>:<a href="../../Number.html">Number</a></code> (default = <code>0</code>)<code></code> &mdash; Liczba kontrolująca położenie ogniskowej gradientu. 0 oznacza, że ogniskowa znajduje się po środku. 1 oznacza, że ogniskowa znajduje się na jednej z granic okręgu gradientu. -1 oznacza, że ogniskowa znajduje się na drugiej z granic okręgu gradientu. Wartość mniejsza niż -1 lub większa niż 1 jest zaokrąglana do -1 lub 1. Przykład poniżej przedstawia właściwość <code>focalPointRatio</code> ustawioną na wartość 0,75:
	 
     <p><img src="../../images/radial_sketch.jpg" alt="gradient radialny z właściwością focalPointRatio ustawioną na wartość 0,75"></img> </p>
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Jeżeli parametr <code>type</code> nie jest poprawny.
	 
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#endFill()" target="">endFill()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="../geom/Matrix.html#createGradientBox()" target="">flash.geom.Matrix.createGradientBox()</a><br/><a href="GradientType.html" target="">flash.display.GradientType</a><br/><a href="SpreadMethod.html" target="">flash.display.SpreadMethod</a></div></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="beginShaderFill()" id="beginShaderFill()"></a><a name="beginShaderFill(flash.display.Shader,flash.geom.Matrix)" id="beginShaderFill(flash.display.Shader,flash.geom.Matrix)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>beginShaderFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function beginShaderFill(shader:<a href="Shader.html">Shader</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
 	 Określa wypełnienie dla modułu cieniującego, które będzie stosowane przy kolejnych wywołaniach metod klasy Graphics (np. <code>lineTo()</code> i <code>drawCircle()</code>) dla obiektu. Wypełnienie będzie obowiązywało do czasu wywołania metody <code>beginFill()</code>, <code>beginBitmapFill()</code>, <code>beginGradientFill()</code> lub <code>beginShaderFill()</code>. Wywołanie metody <code>clear()</code> powoduje wyczyszczenie zawartości wypełnienia.
	 
	 <p>Aplikacja renderuje wypełnienie w momencie narysowania trzech lub więcej punktów lub gdy wywołana zostanie metoda <code>endFill()</code>.</p>
	 
	 <p>Wypełnianie przy użyciu modułów cieniujących nie jest obsługiwane w przypadku renderowania GPU </p>
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">shader</span>:<a href="Shader.html">Shader</a></code> &mdash; Moduł cieniujący, jaki ma zostać użyty dla wypełnienia. Ta instancja modułu cieniującego nie musi określać obrazu wejściowego. Jeśli jednak w module cieniującym określone są obrazy wejściowe, dane wejściowe należy wprowadzić ręcznie. Aby określić dane wejściowe, należy ustawić właściwość <code>input</code> odpowiedniej właściwości ShaderInput, która należy do właściwości <code>Shader.data</code>.
	 
	 <p>W przypadku przekazania instancji modułu cieniującego jako argumentu moduł cieniujący jest kopiowany wewnętrznie. Podczas operacji wypełniania używana jest kopia wewnętrzna, a nie odwołanie do oryginalnego modułu cieniującego. Wszelkie zmiany modułu cieniującego, takie jak zmiana wartości parametru, obiektu wejściowego lub kodu bajtowego, nie są stosowane do skopiowanego modułu cieniującego, który jest używany dla wypełnienia.</p>
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt macierzy (klasy flash.geom.Matrix), który może zostać wykorzystany do definiowana przekształceń modułu cieniującego. Na przykład: możliwe jest użycie poniższej macierzy do obracania modułu cieniującego o 45 stopni (pi/4 radiany):
	 
	 <div class="listing"><pre>
     matrix = new flash.geom.Matrix(); 
     matrix.rotate(Math.PI / 4);
     </pre></div>
	 
	 <p>Współrzędne odebrane w module cieniującym są określane na podstawie macierzy określonej dla parametru <code>matrix</code>. W przypadku domyślnej macierzy (<code>null</code>) współrzędne w module cieniującym są współrzędnymi lokalnych pikseli, które mogą być używane do próbkowania danych wejściowych.</p>
	 
	 </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Gdy typ wyjścia modułu cieniującego nie jest zgodny z tą operacją (moduł cieniujący musi określać wyjście <code>pixel3</code> lub <code>pixel4</code>).
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Gdy moduł cieniujący określa obraz wejściowy, które nie został udostępniony.
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; W przypadku filtrów ByteArray lub Vector.Instancja &lt;Number> jest używana jako obiekt wejściowy, a właściwości <code>width</code> i <code>height</code> nie zostały określone dla ShaderInput, lub określone wartości nie są zgodne z ilością danych w obiekcie wejściowym. Więcej informacji można znaleźć w opisie właściwości <code>ShaderInput.input</code>.
	 
	 </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#endFill()" target="">endFill()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a><br/><a href="ShaderInput.html" target="">flash.display.ShaderInput</a></div></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="clear()" id="clear()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clear</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clear():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Czyści grafikę przypisaną do tego obiektu Graphics, zeruje wypełnienia i style linii.
     
	 </p></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="copyFrom()" id="copyFrom()"></a><a name="copyFrom(flash.display.Graphics)" id="copyFrom(flash.display.Graphics)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyFrom</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyFrom(sourceGraphics:<a href="Graphics.html">Graphics</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Kopiuje wszystkie polecenia rysowania ze źródłowego obiektu Graphics do wywołującego obiektu Graphics.
	 
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceGraphics</span>:<a href="Graphics.html">Graphics</a></code> &mdash; Obiekt Graphics, z którego kopiowane będą polecenia rysunku.
	  
	  </td></tr></table></p></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="cubicCurveTo()" id="cubicCurveTo()"></a><a name="cubicCurveTo(Number,Number,Number,Number,Number,Number)" id="cubicCurveTo(Number,Number,Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>cubicCurveTo</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function cubicCurveTo(controlX1:<a href="../../Number.html">Number</a>, controlY1:<a href="../../Number.html">Number</a>, controlX2:<a href="../../Number.html">Number</a>, controlY2:<a href="../../Number.html">Number</a>, anchorX:<a href="../../Number.html">Number</a>, anchorY:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
     Rysuje sześcienną krzywą Beziera z bieżącego położenia rysowania do określonego punktu kotwiczenia. Sześcienne krzywe Beziera składają się z dwóch punktów kotwiczenia oraz dwóch punktów kontrolnych. Krzywa interpoluje oba punkty kotwiczenia i zmienia kształt w kierunku dwóch punktów kontrolnych. 
     
	 <p><img src="../../images/cubic_bezier.png" alt="Sześcienna krzywa Beziera"></img></p>
     
     <p>
     Cztery punkty używane do rysowania sześciennej krzywej Beziera przy użyciu metody <code>cubicCurveTo()</code>:
     <ul><li>Bieżące położenie rysowania stanowi pierwszy punkt kotwiczenia. </li><li>Parametry <code>anchorX</code> i <code>anchorY</code> określają drugi punkt kotwiczenia.</li><li>Parametry <code>controlX1</code> i <code>controlY1</code> określają pierwszy punkt kontrolny.</li><li>Parametry <code>controlX2</code> i <code>controlY2</code> określają drugi punkt kontrolny.</li></ul>
     </p>
     <p>
     W przypadku wywołania metody <code>cubicCurveTo()</code> przed wywołaniem metody <code>moveTo()</code> krzywa ma początek w punkcie (0, 0). 
     </p>
     <p>
     Jeśli metoda <code>cubicCurveTo()</code> zakończy się powodzeniem, środowisko wykonawcze Flash ustawi bieżące położenie rysowania w punkcie (<code>anchorX</code>, <code>anchorY</code>). Jeśli metoda <code>cubicCurveTo()</code> zakończy się niepowodzeniem, bieżące położenie rysowania pozostanie bez zmian.
     </p>
     <p>
     Jeśli w klipie filmowym istnieje zawartość utworzona przy użyciu narzędzi do rysowania aplikacji Flash, wówczas rezultaty wywołań metody <code>cubicCurveTo()</code> są rysowane pod tą zawartością. 
     </p>
	 
  	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">controlX1</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję poziomą pierwszego punktu kontrolnego względem punktu pasowania macierzystego obiektu ekranowego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">controlY1</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję pionową pierwszego punktu kontrolnego względem punktu pasowania macierzystego obiektu ekranowego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">controlX2</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję poziomą drugiego punktu kontrolnego względem punktu pasowania macierzystego obiektu ekranowego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">controlY2</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję pionową drugiego punktu kontrolnego względem punktu pasowania macierzystego obiektu ekranowego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">anchorX</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję poziomą punktu kotwiczenia względem punktu pasowania macierzystego obiektu ekranowego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">anchorY</span>:<a href="../../Number.html">Number</a></code> &mdash; Określa pozycję pionową punktu kotwiczenia względem punktu pasowania macierzystego obiektu ekranowego.  
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje rysowanie niebieskiego okrągłego obiektu o szerokości i wysokości 100 pikseli, w odległości 250 pikseli w prawo od początku układu współrzędnych (0,0) obiektu ekranowego Sprite.  
 <p>Kod rysuje cztery krzywe w celu otrzymania okręgu, a następnie wypełnia kształt kolorem niebieskim.</p>
   
 <p>Ze względu na naturę równania kwadratowego Beziera nie jest to okrąg doskonały. Najlepszym sposobem rysowania okręgu jest wykorzystanie metody <code>drawCircle()</code> klasy Graphics.</p>
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_cubicCurveToExample extends Sprite
    {
        public function Graphics_cubicCurveToExample():void
        {
            var rounderObject:Shape = new Shape();

            rounderObject.graphics.beginFill(0x0000FF);
            rounderObject.graphics.moveTo(250, 0);
            rounderObject.graphics.cubicCurveTo(275, 0, 300, 25, 300, 50);
            rounderObject.graphics.cubicCurveTo(300, 75, 275, 100, 250, 100);
            rounderObject.graphics.cubicCurveTo(225, 100, 200, 75, 200, 50);
            rounderObject.graphics.cubicCurveTo(200, 25, 225, 0, 250, 0);
            rounderObject.graphics.endFill();
            
            this.addChild(rounderObject);
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="curveTo()" id="curveTo()"></a><a name="curveTo(Number,Number,Number,Number)" id="curveTo(Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>curveTo</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function curveTo(controlX:<a href="../../Number.html">Number</a>, controlY:<a href="../../Number.html">Number</a>, anchorX:<a href="../../Number.html">Number</a>, anchorY:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje kwadratową krzywą Beziera przy użyciu bieżącego stylu linii z bieżącego położenia rysowania do punktu (anchorX, anchorY) zgodnie z punktem kontrolnym o współrzędnych (<code>controlX</code>, <code>controlY</code>). Obecna pozycja rysowania jest ustawiona na (<code>anchorX</code>, <code>anchorY</code>). W przypadku, gdy klip filmowy w którym przeprowadzane jest rysowanie posiada zawartość, która została utworzona przy pomocy narzędzi rysowania aplikacji Flash, wówczas wywołania metody <code>curveTo()</code> są rysowane pod zawartością. W sytuacji gdy zostanie wywołana metoda <code>curveTo()</code> przed wywołaniami metody <code>moveTo()</code>, wówczas domyślną pozycją obecnego rysowania jest (0,0). Jeżeli brak jest któregoś z parametrów ta metoda kończy się niepowodzeniem, zaś obecna pozycja rysowania nie jest zmieniana.
	 
	 <p>Narysowana krzywa jest kwadratową krzywą Beziera. Kwadratowe krzywe Beziera składają się z dwóch punktów kotwiczenia oraz jednego punktu kontrolnego. Krzywa interpoluje oba punkty kotwiczenia i krzywi się w kierunku punktu kontrolnego. </p>
	 
	 <p><img src="../../images/quad_bezier.png" alt="Kwadratowa krzywa Beziera"></img></p>
	 
  	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">controlX</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą punktu kontrolnego względem punktu rejestracji nadrzędnego obiektu wyświetlanego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">controlY</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową punktu kontrolnego względem punktu rejestracji nadrzędnego obiektu wyświetlanego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">anchorX</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą następnego punktu kotwiczenia względem punktu rejestracji nadrzędnego obiektu wyświetlanego.  
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">anchorY</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową następnego punktu kotwiczenia względem punktu rejestracji nadrzędnego obiektu wyświetlanego.  
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje rysowanie zielonego okrągłego obiektu o szerokości i wysokości 100 pikseli, w odległości 250 pikseli w prawo od punktu rejestracji (0,0) obiektu wyświetlanego Sprite.  
 <p>Należy narysować cztery krzywe w celu otrzymania okręgu, a następnie wypełnić kolorem zielonym.</p>
   
 <p>Należy zauważyć, iż ze względu na naturę równania kwadratowego Beziera, nie jest to okrąg doskonały. Najlepszym sposobem rysowania okręgu jest wykorzystanie metody <code>drawCircle()</code> klasy Graphics.</p>
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    
    public class Graphics_curveToExample1 extends Sprite
    {
        public function Graphics_curveToExample1():void
        {
            var roundObject:Shape = new Shape();

            roundObject.graphics.beginFill(0x00FF00);
            roundObject.graphics.moveTo(250, 0);
            roundObject.graphics.curveTo(300, 0, 300, 50);
            roundObject.graphics.curveTo(300, 100, 250, 100);
            roundObject.graphics.curveTo(200, 100, 200, 50);
            roundObject.graphics.curveTo(200, 0, 250, 0);
            roundObject.graphics.endFill();
            
            this.addChild(roundObject);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><br/><div class="detailBody"> Poniższy przykład ilustruje sposób rysowania nowego księżyca za pomocą metody <code>curveTo()</code>.
 
 <p>Rysowane są dwie krzywe linie grubości 1 pikseli, zaś przestrzeń pomiędzy jest wypełniana na biało. Metoda <code>moveTo()</code> jest stosowana w celu ustawiania obecnej pozycji rysowania na współrzędne (100, 100). Pierwsza krzywa przenosi pozycję rysowania na (100, 200) - punkt docelowy. Druga krzywa zwraca pozycję z powrotem do pozycji startowej (100, 100) - punktu docelowego. Poziome punkty kontrolne określają różne rozmiary krzywych.</p>
 
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_curveToExample2 extends Sprite
    {
        public function Graphics_curveToExample2() {
            var newMoon:Shape = new Shape();
            
            newMoon.graphics.lineStyle(1, 0);
            newMoon.graphics.beginFill(0xFFFFFF);
            newMoon.graphics.moveTo(100, 100); 
            newMoon.graphics.curveTo(30, 150, 100, 200);    
            newMoon.graphics.curveTo(50, 150, 100, 100);
            graphics.endFill();
            
            this.addChild(newMoon);
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="drawCircle()" id="drawCircle()"></a><a name="drawCircle(Number,Number,Number)" id="drawCircle(Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawCircle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawCircle(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, radius:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje okrąg. Należy ustawić styl linii, wypełnienie lub obie te właściwości przed wywołaniem metody <code>drawCircle()</code>, poprzez wywołanie metody <code>linestyle()</code>, <code>lineGradientStyle()</code>, <code>beginFill()</code>, <code>beginGradientFill()</code> lub <code>beginBitmapFill()</code>.
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Położenie <i>x</i> środka okręgu względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Położenie <i>y</i> środka okręgu względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">radius</span>:<a href="../../Number.html">Number</a></code> &mdash; Promień okręgu (w pikselach).
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#drawEllipse()" target="">drawEllipse()</a><br/><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a></div><br/><span class="label"> Przykład </span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Sposób zastosowania tej metody został przedstawiony na końcu tej lekcji w sekcji <a href="Graphics.html#includeExamplesSummary" >Przykład</a>. 
      
      </div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="drawEllipse()" id="drawEllipse()"></a><a name="drawEllipse(Number,Number,Number,Number)" id="drawEllipse(Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawEllipse</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawEllipse(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje elipsę. Należy ustawić styl linii, wypełnienie lub obie te właściwości przed wywołaniem metody <code>drawEllipse()</code>, poprzez wywołanie metody <code>linestyle()</code>, <code>lineGradientStyle()</code>, <code>beginFill()</code>, <code>beginGradientFill()</code> lub <code>beginBitmapFill()</code>.
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Położenie <i>x</i> lewego górnego punktu obwiedni elipsy względem punktu rejestracji macierzystego obiektu wyświetlania (w pikselach).
	
	</td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Położenie <i>y</i> lewego górnego punktu obwiedni elipsy względem punktu rejestracji macierzystego obiektu wyświetlania (w pikselach).
	
	</td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../Number.html">Number</a></code> &mdash; Szerokość elipsy (w pikselach).
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../Number.html">Number</a></code> &mdash; Wysokość elipsy (w pikselach).
	 
	 </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#drawCircle()" target="">drawCircle()</a><br/><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje wykorzystanie funkcji metody <code>drawEgg()</code> w celu narysowania trzech jaj różnego rozmiaru (trzy rozmiary elips), w zależności od parametru <code>eggSize</code>.  
 <ol><li>Konstruktor wywołuje funkcję metody <code>drawEgg()</code> oraz przekazuje parametry poziome i pionowe gdzie jajo powinno być narysowane, oraz typ jaja (<code>eggSize</code>) (Wysokość i szerokość jaj (elips) może być wykorzystana przy podjęciu decyzji gdzie należy je wyświetlić.)</li><li>Funkcja metody <code>drawEgg()</code> rysuje elipsy różnego rozmiaru oraz wypełnia je przy wykorzystaniu metody <code>beginFill()</code>. Dla tej funkcji nie opracowano mechanizmu obsługi błędów postępu.</li></ol>
 
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.Shape;

    public class Graphics_drawEllipseExample extends Sprite
    {
        public static const SMALL:uint = 0;
        public static const MEDIUM:uint = 1;
        public static const LARGE:uint = 2;

        public function Graphics_drawEllipseExample()
        {
            drawEgg(SMALL, 0, 100);
            drawEgg(MEDIUM, 100, 60);
            drawEgg(LARGE, 250, 35);    
        }

        public function drawEgg(eggSize:uint, x:Number, y:Number):void  {
            
            var myEgg:Shape = new Shape();
            
            myEgg.graphics.beginFill(0xFFFFFF);
            myEgg.graphics.lineStyle(1);

            switch(eggSize) {
                case SMALL:
                    myEgg.graphics.drawEllipse(x, y, 60, 70);
                    break;
                case MEDIUM:
                    myEgg.graphics.drawEllipse(x, y, 120, 150);    
                    break;
                case LARGE:
                    myEgg.graphics.drawEllipse(x, y, 150, 200);
                    break;
                default:
                    trace ("Wrong size! There is no egg.");
                break;            
            }
            
            myEgg.graphics.endFill();
    
            this.addChild(myEgg);
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="drawGraphicsData()" id="drawGraphicsData()"></a><a name="drawGraphicsData(Vector$flash.display.IGraphicsData)" id="drawGraphicsData(Vector$flash.display.IGraphicsData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawGraphicsData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawGraphicsData(graphicsData:<a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
	 Wysyła serię instancji IGraphicsData dla rysunku. Ta metoda akceptuje wektor zawierający obiekty, łącznie ze ścieżkami, wypełnieniami i obrysami, które implementują interfejs IGraphicsData. W celu renderowania pełnego kształtu wektor instancji IGraphicsData może odwoływać się do części kształtu lub złożonego, w pełni zdefiniowanego zestawu danych.
     
     
     <p>
     Ścieżki Graphics mogą zawierać inne ścieżki graficzne. Jeśli wektor <code>graphicsData</code> zawiera ścieżkę, podczas tej operacji będzie renderowana ścieżka i wszystkie jej ścieżki podrzędne.
     </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">graphicsData</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;</code> &mdash; Wektor zawierający obiekty graficzne, z których każdy musi implementować interfejs IGraphicsData.
     
	 </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="IGraphicsData.html" target="">Interfejs IGraphicsData</a><br/><a href="GraphicsBitmapFill.html" target="">Klasa GraphicsBitmapFill</a><br/><a href="GraphicsEndFill.html" target="">Klasa GraphicsEndFill</a><br/><a href="GraphicsGradientFill.html" target="">Klasa GraphicsGradientFill</a><br/><a href="GraphicsPath.html" target="">Klasa GraphicsPath</a><br/><a href="GraphicsShaderFill.html" target="">Klasa GraphicsShaderFill</a><br/><a href="GraphicsSolidFill.html" target="">Klasa GraphicsSolidFill</a><br/><a href="GraphicsStroke.html" target="">Klasa GraphicsStroke</a><br/><a href="GraphicsTrianglePath.html" target="">Klasa GraphicsTrianglePath</a><br/><a href="Graphics.html#readGraphicsData()" target="">Metoda readGraphicsData()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> W poniższym przykładzie tworzony jest obiekt GraphicsGradientFill w celu określenia właściwości wypełnienia kwadratu. Następnie tworzone są obiekty GraphicsStroke (w celu określenia grubości linii) oraz obiekt GraphicsSolidFill (w celu określenia koloru linii) służące do ustawienia właściwości obramowania kwadratu. W dalszej kolejności tworzony jest obiekt GraphicsPath zawierający wartości służące do narysowania kształtu. Wszystkie te obiekty są zapisywane w obiekcie IGraphicsData i przekazywane do polecenia <code>drawGraphicsData()</code> w celu renderowania kształtu.
<div class="listing"><pre>
package
{
    import flash.display.*;
    import flash.geom.*;

    public class DrawGraphicsDataExample extends Sprite
    {
        public function DrawGraphicsDataExample()
        {
            // establish the fill properties
            var myFill:GraphicsGradientFill = new GraphicsGradientFill();
            myFill.colors = [0xEEFFEE, 0x0000FF];
            myFill.matrix = new Matrix();
            myFill.matrix.createGradientBox(100, 100, 0);
            
            // establish the stroke properties
            var myStroke:GraphicsStroke = new GraphicsStroke(2);
            myStroke.fill = new GraphicsSolidFill(0x000000);
            
            // establish the path properties
            var pathCommands = new Vector.&lt;int&gt;(5, true);
            pathCommands[0] = GraphicsPathCommand.MOVE_TO;
            pathCommands[1] = GraphicsPathCommand.LINE_TO;
            pathCommands[2] = GraphicsPathCommand.LINE_TO;
            pathCommands[3] = GraphicsPathCommand.LINE_TO;
            pathCommands[4] = GraphicsPathCommand.LINE_TO;
            
            var pathCoordinates:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;(10, true);
            pathCoordinates.push(10,10, 10,100, 100,100, 100,10, 10,10);
            
            var myPath:GraphicsPath = new GraphicsPath(pathCommands, pathCoordinates);
            
            // populate the IGraphicsData Vector array
            var myDrawing:Vector.&lt;IGraphicsData&gt; = new Vector.&lt;IGraphicsData&gt;(3, true);
            myDrawing[0] = myFill;
            myDrawing[1] = myStroke;
            myDrawing[2] = myPath;
            
            // render the drawing
            graphics.drawGraphicsData(myDrawing);
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="drawPath()" id="drawPath()"></a><a name="drawPath(Vector$int,Vector$Number,String)" id="drawPath(Vector$int,Vector$Number,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawPath</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawPath(commands:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt;, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, winding:<a href="../../String.html">String</a> = "evenOdd"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
	 Wysyła serię poleceń dla rysunku. Metoda <code>drawPath()</code> przyjmuje w jednym wywołaniu obiekt Vector zawierający połączone polecenia rysowania <code>moveTo()</code>, <code>lineTo()</code> i <code>curveTo()</code>. Parametry metody <code>drawPath()</code> łączą polecenia rysowania z parami wartości x i y oraz kierunkiem rysowania. Polecenia rysowania są reprezentowane przez liczby całkowite &mdash; stałe zdefiniowane w klasie GraphicsPathCommand. Pary współrzędnych x- i y- są liczbami w tablicy, w której każda para definiuje miejsce w układzie współrzędnych. Kierunek rysowania jest wartością z klasy GraphicsPathWinding.
     
	 <p>Zwykle rysunki są renderowane szybciej w przypadku użycia metody <code>drawPath()</code> niż kolejnych wywołań metod <code>lineTo()</code> i <code>curveTo()</code>.</p>
     
	 <p>Metoda <code>drawPath()</code> korzysta z obliczeń zmiennoprzecinkowych, dzięki czemu rotacje i skalowanie kształtów jest bardziej dokładne i zapewnia lepsze wyniki. Jednak krzywe wprowadzone za pośrednictwem metody <code>drawPath()</code> mogą zawierać niewielkie błędy na poziomie wyrównania pikseli, gdy metoda będzie używana łącznie z metodami <code>lineTo()</code> oraz <code>curveTo()</code>.</p>
     
	 <p>Metoda <code>drawPath()</code> korzysta również z innych reguł wypełniania i rysowania linii. Reguły są następujące:</p>
     
	 <ul><li>Gdy do renderowania ścieżki stosowane jest wypełnienie:
	  <ul><li>Ścieżka podrzędna zawierająca mniej niż 3 punkty nie jest renderowana. (Należy jednak pamiętać o tym, że dojdzie do renderowania obrysu, co jest spójne z regułami dla obrysów, które zostały przedstawione poniżej).</li><li>Ścieżka podrzędna, która nie jest zamknięta (punkt końcowy nie jest równy punktowi początkowemu), jest zamknięta niejawnie.</li></ul>
     </li><li>Gdy do renderowania ścieżki stosowany jest obrys:
       <ul><li>Ścieżki podrzędne mogą być złożone z dowolnej liczby punktów.</li><li>Ścieżka podrzędna nigdy nie jest zamknięta niejawnie.</li></ul>
     </li></ul>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">commands</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt;</code> &mdash; Wektor zawierający liczby całkowite reprezentujące polecenia rysowania. Zestaw wartości dopuszczalnych jest określony w stałych klasy GraphicsPathCommand.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; Wektor wystąpień klasy Number, w którym każda para liczb jest traktowana jako para współrzędnych (para x, y). Pary wartości x- i y- nie są obiektami Point; wektor <code>data</code> stanowi serię liczb, w którym każde dwie liczby reprezentują miejsce w układzie współrzędnych. 
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">winding</span>:<a href="../../String.html">String</a></code> (default = "<code>evenOdd</code>")<code></code> &mdash; Określa regułę zawijania korzystającą z wartości zdefiniowanej w klasie GraphicsPathWinding.
     
	 </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="GraphicsPathCommand.html" target="">flash.display.GraphicsPathCommand</a><br/><a href="GraphicsPathWinding.html" target="">flash.display.GraphicsPathWinding</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład przedstawia wypełnianie dwóch obiektów Vector, a następnie przekazanie ich do metody <code>drawPath()</code> w celu renderowania niebieskiej gwiazdy. Pierwszy wektor &mdash; <code>star_commands</code> &mdash; zawiera serię stałych reprezentujących polecenia rysowania z klasy GraphicsPathCommand. Drugi obiekt Vector &mdash; <code>star_coord</code> &mdash; zawiera 5 zestawów par współrzędnych x i y. Metoda <code>drawPath()</code> uzgadnia polecenia z pozycjami w celu narysowania gwiazdy.
<div class="listing"><pre>
package
{
    import flash.display.*;
        
    public class DrawPathExample extends Sprite
    {
        public function DrawPathExample()
        {
            var star_commands:Vector.&lt;int&gt; = new Vector.&lt;int&gt;(5, true);
            
            star_commands[0] = GraphicsPathCommand.MOVE_TO;
            star_commands[1] = GraphicsPathCommand.LINE_TO;
            star_commands[2] = GraphicsPathCommand.LINE_TO;
            star_commands[3] = GraphicsPathCommand.LINE_TO;
            star_commands[4] = GraphicsPathCommand.LINE_TO;
            
            var star_coord:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;(10, true);
            star_coord[0] = 66; //x
            star_coord[1] = 10; //y 
            star_coord[2] = 23; 
            star_coord[3] = 127; 
            star_coord[4] = 122; 
            star_coord[5] = 50; 
            star_coord[6] = 10; 
            star_coord[7] = 49; 
            star_coord[8] = 109; 
            star_coord[9] = 127;
            
            graphics.beginFill(0x003366);
            graphics.drawPath(star_commands, star_coord);
        }
    }
}

</pre></div> <b>Uwaga:</b> Domyślnie metoda <code>drawPath()</code> korzysta z zawijania parzyste-nieparzyste. Dlatego środek gwiazdy nie jest wypełniony. Jeśli dla trzeciego parametru zostanie określony typ zawijania inny niż zero, środek gwiazdy zostanie wypełniony.
 <div class="listing"><pre>
 graphics.drawPath(star_commands, star_coord, GraphicsPathWinding.NON_ZERO);
 </pre></div>
 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="drawRect()" id="drawRect()"></a><a name="drawRect(Number,Number,Number,Number)" id="drawRect(Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawRect(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje prostokąt. Należy ustawić styl linii, wypełnienie lub obie te właściwości przed wywołaniem metody <code>drawRect()</code>, poprzez wywołanie metody <code>linestyle()</code>, <code>lineGradientStyle()</code>, <code>beginFill()</code>, <code>beginGradientFill()</code> lub <code>beginBitmapFill()</code>.
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą względem punktu rejestracji macierzystego obiektu wyświetlania (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../Number.html">Number</a></code> &mdash; Szerokość prostokąta (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../Number.html">Number</a></code> &mdash; Wysokość prostokąta (w pikselach).
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; W sytuacji gdy parametry <code>width</code> lub <code>height</code> nie są liczbą (<code>Number.NaN</code>).
	 
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="Graphics.html#drawRoundRect()" target="">drawRoundRect()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje możliwość rysowania kształtów w języku ActionScript 3.0. Przykład pochodzi z witryny <a href="http://actionscriptexamples.com/2008/12/07/drawing-shapes-using-the-drawing-api-in-actionscript-30-and-actionscript-20/" target="_mmexternal">ActionScriptExamples.com</a>. 
<div class="listing"><pre>
var movieClip:MovieClip = new MovieClip();
movieClip.graphics.beginFill(0xFF0000);
movieClip.graphics.drawRect(0, 0, 100, 80);
movieClip.graphics.endFill();
movieClip.x = 10;
movieClip.y = 10;
addChild(movieClip);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="drawRoundRect()" id="drawRoundRect()"></a><a name="drawRoundRect(Number,Number,Number,Number,Number,Number)" id="drawRoundRect(Number,Number,Number,Number,Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawRoundRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawRoundRect(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>, width:<a href="../../Number.html">Number</a>, height:<a href="../../Number.html">Number</a>, ellipseWidth:<a href="../../Number.html">Number</a>, ellipseHeight:<a href="../../Number.html">Number</a> = NaN):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje zaokrąglony prostokąt. Należy ustawić styl linii, wypełnienie lub obie te właściwości przed wywołaniem metody <code>drawRoundRect()</code>, poprzez wywołanie metody <code>linestyle()</code>, <code>lineGradientStyle()</code>, <code>beginFill()</code>, <code>beginGradientFill()</code> lub <code>beginBitmapFill()</code>.
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą względem punktu rejestracji macierzystego obiektu wyświetlania (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../Number.html">Number</a></code> &mdash; Szerokość zaokrąglonego prostokąta (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../Number.html">Number</a></code> &mdash; Wysokość zaokrąglonego prostokąta (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">ellipseWidth</span>:<a href="../../Number.html">Number</a></code> &mdash; Szerokość elipsy wykorzystywanej przy rysowaniu zaokrąglonych narożników (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">ellipseHeight</span>:<a href="../../Number.html">Number</a></code> (default = <code>NaN</code>)<code></code> &mdash; Wysokość elipsy wykorzystywanej przy rysowaniu zaokrąglonych narożników (w pikselach). Opcjonalnie; w sytuacji gdy nie określona została żadna wartość, wówczas wartość domyślna odpowiada wartości dostarczonej dla parametru <code>ellipseWidth</code>.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; W sytuacji gdy parametry <code>width</code>, <code>height</code>, <code>ellipseWidth</code> lub <code>ellipseHeight</code> nie są liczbą (<code>Number.NaN</code>).
	 
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="Graphics.html#drawRect()" target="">drawRect()</a></div><br/><span class="label"> Przykład </span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Sposób zastosowania tej metody został przedstawiony na końcu tej klasy w sekcji <a href="Graphics.html#includeExamplesSummary" >example</a>. 
      
      </div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="drawTriangles()" id="drawTriangles()"></a><a name="drawTriangles(Vector$Number,Vector$int,Vector$Number,String)" id="drawTriangles(Vector$Number,Vector$int,Vector$Number,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawTriangles</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTriangles(vertices:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, indices:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt; = null, uvtData:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt; = null, culling:<a href="../../String.html">String</a> = "none"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
	 Renderuje zbiór trójkątów, zwykle w celu odkształcenia bitmap i nadania im wyglądu trójwymiarowego. Metoda <code>drawTriangles()</code> odwzorowuje bieżące wypełnienie lub wypełnienie bitmapy na powierzchnie trójkątów, stosując zestaw współrzędnych (u,v). 
     <p>
     Można użyć dowolnego typu wypełnienia, ale jeśli wypełnienie ma macierz transformacji, jest ona ignorowana.
     </p>
     
     <p>
     Parametr <code>uvtData</code> poprawia odwzorowywanie tekstury, gdy używane jest wypełnienie bitmapy. 
     </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">vertices</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; Wektor wartości liczbowych, w którym każda para liczb jest traktowana jako para współrzędnych (para x, y). Parametr <code>vertices</code> jest wymagany.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">indices</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../int.html">int</a>&gt;</code> (default = <code>null</code>)<code></code> &mdash; Wektor liczb całkowitych lub indeksów, w którym każde trzy indeksy definiują trójkąt. Jeśli parametr <code>indexes</code> jest równy null, wówczas każde trzy wierzchołki (sześć par x,y w wektorze <code>vertices</code>) definiują trójkąt. W przeciwnym wypadku każdy indeks odwołuje się do wierzchołka, który jest parą liczb w wektorze <code>vertices</code>. Przykład: <code>indexes[1]</code> odwołuje się do (<code>vertices[2]</code>, <code>vertices[3]</code>). Parametr <code>indexes</code> jest opcjonalny, ale zwykle przyczynia się on do zmniejszenia ilości wprowadzanych danych oraz ilości obliczanych danych. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">uvtData</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> (default = <code>null</code>)<code></code> &mdash; Wektor znormalizowanych współrzędnych używanych do zastosowania odwzorowania tekstury. Każda współrzędna odnosi się do punktu na bitmapie używanego dla wypełnienia. Dla każdego wierzchołka musi istnieć jedna współrzędna UV lub jedna współrzędna UVT. W przypadku współrzędnych UV (0,0) jest lewym górnym narożnikiem bitmapy, a (1,1) jest prawym dolnym narożnikiem bitmapy. 
     <p>Jeśli długość tego wektora jest dwukrotnie większa od długości wektora <code>vertices</code>, wówczas współrzędne znormalizowane będą używane bez korygowania perspektywy. </p>
     <p>Jeśli długość tego wektora jest trzykrotnie większa niż długość wektora <code>vertices</code>, wówczas trzecia współrzędna jest interpretowana jako „t” &mdash; odległość od oka do tekstury w przestrzeni oka). Dzięki temu mechanizm renderowania może poprawnie stosować perspektywę podczas odwzorowywania tekstur w trzech wymiarach.</p>
     <p>Jeśli parametr <code>uvtData</code> ma wartość null, wówczas będą miały zastosowanie normalne reguły wypełniania (przy dowolnym typie wypełnienia).</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">culling</span>:<a href="../../String.html">String</a></code> (default = "<code>none</code>")<code></code> &mdash; Określa, czy renderowane są trójkąty, które są skierowane w określonym kierunku. Ten parametr zapobiega renderowaniu trójkątów, które nie mogą być widoczne w bieżącym widoku. Dla tego parametru można ustawić dowolną wartość zdefiniowaną przez klasę TriangleCulling.  
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="TriangleCulling.html" target="">flash.display.TriangleCulling</a><br/><a href="GraphicsTrianglePath.html" target="">flash.display.GraphicsTrianglePath</a></div></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="endFill()" id="endFill()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>endFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function endFill():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Stosuje wypełnienie linii oraz krzywych, które zostały dodane od momentu ostatniego wywołania metod <code>beginFill()</code><code>beginGradientFill()</code><code>beginBitmapFill()</code>. Aplikacja Flash stosuje wypełnienie, które zostało określone przy poprzednim wywołaniu metod <code>beginFill()</code>, <code>beginGradientFill()</code>, <code>beginBitmapFill()</code>. W sytuacji, gdy obecna pozycja rysowania nie jest równa poprzedniej pozycji określonej w metodzie <code>moveTo()</code> oraz zdefiniowane jest wypełnienie, wówczas ścieżka jest zamknięta linią a następnie wypełniana.
	 
	 </p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#beginFill()" target="">beginFill()</a><br/><a href="Graphics.html#beginBitmapFill()" target="">beginBitmapFill()</a><br/><a href="Graphics.html#beginGradientFill()" target="">beginGradientFill()</a></div></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="lineBitmapStyle()" id="lineBitmapStyle()"></a><a name="lineBitmapStyle(flash.display.BitmapData,flash.geom.Matrix,Boolean,Boolean)" id="lineBitmapStyle(flash.display.BitmapData,flash.geom.Matrix,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lineBitmapStyle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lineBitmapStyle(bitmap:<a href="BitmapData.html">BitmapData</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, repeat:<a href="../../Boolean.html">Boolean</a> = true, smooth:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
	 Określa bitmapę, jaka będzie używana dla obrysu podczas rysowania linii. 
     
     <p>Styl linii bitmapy będzie używany dla kolejnych wywołań metod Graphics, takich jak <code>lineTo()</code> lub <code>drawCircle()</code>. Styl linii będzie obowiązywał do czasu wywołania metod <code>lineStyle()</code> lub <code>lineGradientStyle()</code> albo ponownego wywołania metody <code>lineBitmapStyle()</code> z innymi parametrami. </p>
     
     <p>Metodę <code>lineBitmapStyle()</code> można wywołać w trakcie rysowania ścieżki w celu określenia innych stylów dla różnych segmentów linii w ścieżce. </p>
     
     <p>Aby aktywować obrys, należy wywołać metodę <code>lineStyle()</code> przed wywołaniem metody <code>lineBitmapStyle()</code> &mdash; w przeciwnym wypadku styl linii będzie następujący: <code>undefined</code>.</p>
     
     <p>Wywołania metody <code>clear()</code> powodują ponowne ustawienie stylu linii: <code>undefined</code>.
     </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">bitmap</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Bitmapa, jaka będzie używana dla obrysu linii.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Opcjonalna macierz transformacji zdefiniowana przez klasę flash.geom.Matrix. Macierz może być używana w celu skalowania lub innego manipulowania bitmapą przed zastosowaniem jej do stylu linii.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">repeat</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Określa, czy bitmapa będzie powtarzana we wzorze mozaikowym.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smooth</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Określa, czy do bitmapy będzie stosowane wygładzanie.
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a></div></div></span><span id="pageFilter" runtime="Flash::9##"><a name="lineGradientStyle()" id="lineGradientStyle()"></a><a name="lineGradientStyle(String,Array,Array,Array,flash.geom.Matrix,String,String,Number)" id="lineGradientStyle(String,Array,Array,Array,flash.geom.Matrix,String,String,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lineGradientStyle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lineGradientStyle(type:<a href="../../String.html">String</a>, colors:<a href="../../Array.html">Array</a>, alphas:<a href="../../Array.html">Array</a>, ratios:<a href="../../Array.html">Array</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, spreadMethod:<a href="../../String.html">String</a> = "pad", interpolationMethod:<a href="../../String.html">String</a> = "rgb", focalPointRatio:<a href="../../Number.html">Number</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9</td></tr></table><p></p><p></p><p>
	 Określa gradient, jaki będzie używany dla obrysu podczas rysowania linii.
     
     <p>Styl linii gradientowej będzie używany dla kolejnych wywołań metod Graphics, takich jak <code>lineTo()</code> lub <code>drawCircle()</code>. Linia będzie obowiązywała do czasu wywołania metod <code>lineStyle()</code> lub <code>lineBitmapStyle()</code>, albo ponownie metody <code>lineGradientStyle()</code> z innymi parametrami. </p>
     
     <p>Możliwe jest wywołanie metody <code>lineGradientStyle()</code> w trakcie rysowania ścieżki w celu określenia różnych stylów dla odrębnych segmentów linii w ścieżce. </p>
     
     <p>Aby aktywować obrys, należy wywołać metodę <code>lineStyle()</code> przed wywołaniem metody <code>lineGradientStyle()</code> &mdash; w przeciwnym wypadku styl linii będzie następujący: <code>undefined</code>.</p>
     
     <p>Wywołania metody <code>clear()</code> powodują ponowne ustawienie stylu linii: <code>undefined</code>.
     </p>
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">type</span>:<a href="../../String.html">String</a></code> &mdash; Wartość z klasy GradientType określająca, który z typów gradientu należy zastosować &mdash; GradientType.LINEAR czy też GradientType.RADIAL.
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colors</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica wartości kolorów RGB w formacie szesnastkowym do wykorzystania w gradiencie (na przykład czerwony to 0xFF0000, niebieski to 0x0000FF itd.).
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphas</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica wartości alpha dla odpowiednich kolorów w tablicy kolorów; wartości prawidłowe są w zakresie od 0 do 1. Jeżeli wartość wynosi mniej niż 0, wówczas wartość domyślna wynosi 0. Jeżeli wartość wynosi więcej niż 1, wówczas wartość domyślna wynosi 1.
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">ratios</span>:<a href="../../Array.html">Array</a></code> &mdash; Tablica proporcji dystrybucji kolorów; wartości prawidłowe są w zakresie od 0 do 255. Ta wartość definiuje procent szerokości, w której kolor jest próbkowany w 100%. Wartość 0 reprezentuje położenie po lewej stronie pola gradientu, zaś wartość 255 reprezentuje położenie po prawej stronie pola gradientu. Ta wartość reprezentuje położenia w polu gradientu, a nie współrzędne w układzie współrzędnych końcowego gradientu, który może być szerszy lub cieńszy od pola gradientu. Należy określić wartość dla każdej wartości parametru <code>colors</code>. 
	 
	 <p>Przykładowo dla gradientu liniowego, który zawiera dwa kolory (niebieski i zielony), poniższa figura ilustruje umiejscowienie kolorów w formie gradientowej według wartości innych niż znajdujące się w tablicy <code>ratios</code>:</p>
	 
	 <table class="innertable" ><tr><th><code>ratios</code></th><th>Gradient</th></tr><tr><td><code>[0, 127]</code></td><td><img src="../../images/gradient-ratios-1.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 0 i 127"></img></td></tr><tr><td><code>[0, 255]</code></td><td><img src="../../images/gradient-ratios-2.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 0 i 255"></img></td></tr><tr><td><code>[127, 255]</code></td><td><img src="../../images/gradient-ratios-3.jpg" alt="gradient liniowy niebieskiego do zielonego w proporcjach 127 i 255"></img></td></tr></table>
	 
	 <p>Wartości w tablicy muszą zwiększać się w sekwencji; przykładowo: <code>[0, 63, 127, 190, 255]</code>. </p>
   	 
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Matryca transformacyjna jest zdefiniowana przez klasę flash.geom.Matrix. Klasa flash.geom.Matrix zawiera metodę <code>createGradientBox()</code>, która pozwala na wygodne ustawienie matrycy do użycia z metodą <code>lineGradientStyle()</code>.
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">spreadMethod</span>:<a href="../../String.html">String</a></code> (default = "<code>pad</code>")<code></code> &mdash; Wartość z klasy SpreadMethod, określająca którą z metod należy zastosować: 
	 
	 <p>
      <table class="+ topic/table adobe-d/adobetable " ><tr><td align="center"><img src="../../images/beginGradientFill_spread_pad.jpg" alt="gradient liniowy z metodą SpreadMethod.PAD"></img></td><td align="center"><img src="../../images/beginGradientFill_spread_reflect.jpg" alt="gradient liniowy z metodą SpreadMethod.REFLECT"></img></td><td align="center"><img src="../../images/beginGradientFill_spread_repeat.jpg" alt="gradient liniowy z metodą SpreadMethod.REPEAT"></img></td></tr><tr><td align="center"><code>SpreadMethod.PAD</code></td><td align="center"><code>SpreadMethod.REFLECT</code></td><td align="center"><code>SpreadMethod.REPEAT</code></td></tr></table>
	 </p>
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">interpolationMethod</span>:<a href="../../String.html">String</a></code> (default = "<code>rgb</code>")<code></code> &mdash; Wartość z klasy InterpolationMethod, określająca którą z wartości należy zastosować. Przykładowo biorąc pod uwagę prosty gradient liniowy między dwoma barwami (przy parametrze <code>spreadMethod</code> ustawionym na wartość <code>SpreadMethod.REFLECT</code>). Różne metody interpolacji wpływają na wygląd w następujący sposób:
	 
	 <p>
      <table class="+ topic/table adobe-d/adobetable " ><tr><td align="center"><img src="../../images/beginGradientFill_interp_linearrgb.jpg" alt="gradient liniowy z metodą InterpolationMethod.LINEAR_RGB"></img></td><td align="center"><img src="../../images/beginGradientFill_interp_rgb.jpg" alt="gradient liniowy z metodą InterpolationMethod.RGB"></img></td></tr><tr><td align="center"><code>InterpolationMethod.LINEAR_RGB</code></td><td align="center"><code>InterpolationMethod.RGB</code></td></tr></table>
	 </p>
	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">focalPointRatio</span>:<a href="../../Number.html">Number</a></code> (default = <code>0</code>)<code></code> &mdash; Liczba kontrolująca położenie ogniskowej gradientu. Wartość równa 0 oznacza, że ogniskowa znajduje się po środku. Wartość równa 1 oznacza, że ogniskowa znajduje się na jednej z granic okręgu gradientu. Wartość równa -1 oznacza, że ogniskowa znajduje się na drugiej z granic okręgu gradientu. Wartości mniejsze niż -1 lub większe niż 1 są zaokrąglane do -1 lub 1. Poniższy obraz przedstawia gradient z właściwością <code>focalPointRatio</code> o wartości -0,75:
   	 
     <p><img src="../../images/radial_sketch.jpg" alt="gradient radialny z właściwością focalPointRatio ustawioną na wartość 0,75"></img> </p>
	 
	 </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineBitmapStyle()" target="">lineBitmapStyle()</a><br/><a href="../geom/Matrix.html#createGradientBox()" target="">flash.geom.Matrix.createGradientBox()</a><br/><a href="GradientType.html" target="">flash.display.GradientType</a><br/><a href="SpreadMethod.html" target="">flash.display.SpreadMethod</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje rysowanie prostokąta oraz okręgu, w których zastosowany jest gradient obrysu od czerwonego do zielonego do niebieskiego.
 
 <p>Metoda <code>createGradientBox()</code> z klasy <code>Matrix</code> jest wykorzystywana do definiowania pola gradientu na szerokość 200 i wysokość 40. Grubość linii jest ustawiona na 5 pikseli. Grubość obrysu musi zostać zdefiniowana dla metody <code>lineGradientStyle()</code>. Gradient jest ustawiony na liniowy. Kolory dla gradientu są ustawione na: czerwony, zielony i niebieski. Przezroczystość (wartość alpha) dla kolorów jest ustawiona na 1 (nieprzezroczysty). Dystrybucja gradientu jest równa, gdzie kolory są próbkowane na 100% przy wartości 0 (po lewej stronie okna pola gradientu), 128 (środek pola) oraz 255 (po prawej stronie pola). Szerokość prostokąta opasa cały zakres gradientu, natomiast okrąg opasa 50% od środka zakresu.</p>  
 
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.Shape;
    import flash.geom.Matrix; 
    import flash.display.GradientType;
    
    public class Graphics_lineGradientStyleExample extends Sprite
    {
        public function Graphics_lineGradientStyleExample()
        {
            var myShape:Shape = new Shape();
            var gradientBoxMatrix:Matrix = new Matrix();
  
            gradientBoxMatrix.createGradientBox(200, 40, 0, 0, 0);  
            
            myShape.graphics.lineStyle(5);
  
            myShape.graphics.lineGradientStyle(GradientType.LINEAR, [0xFF0000,
            0x00FF00, 0x0000FF], [1, 1, 1], [0, 128, 255], gradientBoxMatrix);
            
            myShape.graphics.drawRect(0, 0, 200, 40);
            myShape.graphics.drawCircle(100, 120, 50);  
             
            this.addChild(myShape);
    
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##"><a name="lineShaderStyle()" id="lineShaderStyle()"></a><a name="lineShaderStyle(flash.display.Shader,flash.geom.Matrix)" id="lineShaderStyle(flash.display.Shader,flash.geom.Matrix)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lineShaderStyle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lineShaderStyle(shader:<a href="Shader.html">Shader</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5</td></tr></table><p></p><p></p><p>
	 Określa moduł cieniujący, jaki będzie używany dla obrysu podczas rysowania linii. 
     
     <p>Styl linii modułu cieniującego będzie używany dla kolejnych wywołań metod Graphics, takich jak <code>lineTo()</code> lub <code>drawCircle()</code>. Styl linii będzie obowiązywał do czasu wywołania metod <code>lineStyle()</code> lub <code>lineGradientStyle()</code>, albo ponownie metody <code>lineBitmapStyle()</code> z innymi parametrami. </p>
     
     <p>Metodę <code>lineShaderStyle()</code> można wywołać w trakcie rysowania ścieżki w celu określenia innych stylów dla różnych segmentów linii w ścieżce. </p>
     
     <p>Aby aktywować obrys, należy wywołać metodę <code>lineStyle()</code> przed wywołaniem metody <code>lineShaderStyle()</code> &mdash; w przeciwnym wypadku styl linii będzie następujący: <code>undefined</code>.</p>
     
     <p>Wywołania metody <code>clear()</code> powodują ponowne ustawienie stylu linii: <code>undefined</code>.
     </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">shader</span>:<a href="Shader.html">Shader</a></code> &mdash; Moduł cieniujący, jaki będzie używany dla obrysu.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Opcjonalna macierz transformacji zdefiniowana przez klasę flash.geom.Matrix. Macierz może być używana w celu skalowania lub innego manipulowania bitmapą przed zastosowaniem jej do stylu linii.
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineStyle()" target="">lineStyle()</a><br/><a href="Graphics.html#lineBitmapStyle()" target="">lineBitmapStyle()</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a></div></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="lineStyle()" id="lineStyle()"></a><a name="lineStyle(Number,uint,Number,Boolean,String,String,String,Number)" id="lineStyle(Number,uint,Number,Boolean,String,String,String,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lineStyle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lineStyle(thickness:<a href="../../Number.html">Number</a> = NaN, color:<a href="../../uint.html">uint</a> = 0, alpha:<a href="../../Number.html">Number</a> = 1.0, pixelHinting:<a href="../../Boolean.html">Boolean</a> = false, scaleMode:<a href="../../String.html">String</a> = "normal", caps:<a href="../../String.html">String</a> = null, joints:<a href="../../String.html">String</a> = null, miterLimit:<a href="../../Number.html">Number</a> = 3):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Określa styl linii, jaki będzie używany dla kolejnych wywołań metod Graphics, takich jak <code>lineTo()</code> lub <code>drawCircle()</code>. Styl linii będzie obowiązywał do czasu wywołania metody <code>lineGradientStyle()</code>, metody<code>lineBitmapStyle()</code> lub metody <code>lineStyle()</code> z innymi parametrami. 
     
     <p>Metodę <code>lineStyle()</code> można wywołać w trakcie rysowania ścieżki w celu określenia innych stylów dla różnych segmentów linii w ścieżce.</p> 
	 
	 <p><b>Uwaga: </b> Wywołania metody <code>clear()</code> ustawiają styl linii na z powrotem na wartość <code>undefined</code>.</p>
	 
	 <p><b>Uwaga: </b>Program Flash Lite 4 obsługuje jedynie trzy pierwsze parametry (<code>thickness</code>, <code>color</code> oraz <code>alpha</code>).</p>
     
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">thickness</span>:<a href="../../Number.html">Number</a></code> (default = <code>NaN</code>)<code></code> &mdash; Wartość całkowita wskazująca grubość linii w punktach; wartości prawidłowe należą do zakresu od 0 do 255. W przypadku braku określenia liczby, lub gdy parametr nie jest zdefiniowany, wówczas linia nie jest rysowana. Jeżeli wartość mniejsza niż 0 jest przekazywana, wówczas wartość domyślna wynosi 0. Wartość 0 wskazuje grubość cienkiej linii; grubość maksymalna wynosi 255. Jeżeli wartość większa niż 255 jest przekazywana, wówczas wartość domyślna wynosi 255. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Wartość szesnastkowa koloru linii; na przykład: czerwony to 0xFF0000, niebieski to 0x0000FF itd. Jeżeli wartość nie jest wskazana, wówczas wartość domyślna to 0x000000 (czarny). Opcjonalnie.
	 
 	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; Wartość wskazująca wartość alpha koloru linii; wartości prawidłowe należą do zakresu od 0 do 1. Jeżeli wartość nie jest wskazana, wówczas wartość domyślna to 1 (jednolita). Jeżeli wartość wynosi mniej niż 0, wówczas wartość domyślna wynosi 0. Jeżeli wartość wynosi więcej niż 1, wówczas wartość domyślna wynosi 1. 
	 
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">pixelHinting</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; (Brak obsługi w programie Flash Lite 4) Wartość typu Boolean określająca, czy obrysy są przyciągane do pełnych pikseli. Ma to wpływ na położenie kotwic krzywej oraz sam rozmiar linii obrysu. Gdy właściwość <code>pixelHinting</code> ma wartość <code>true</code>, szerokości linii są dopasowywane do pełnych wielokrotności pikseli. Przy właściwości <code>pixelHinting</code> ustawionej na wartość <code>false</code> mogą pojawić się przerwy na krzywych lub liniach prostych. Na przykład poniższe ilustracje przedstawiają sposób, w jaki program Flash Player lub środowisko AIR renderuje dwa zaokrąglone prostokąty, które są identyczne, ale parametr <code>pixelHinting</code> używany w metodzie <code>lineStyle()</code> jest ustawiony inaczej (obrazy zostały wyskalowane o 200%, w celu uwypuklenia różnic):
	 
	 <p><img src="../../images/lineStyle_pixelHinting.jpg" alt="właściwość pixelHinting ustawiona na wartość false oraz wartość true"></img></p>
	 
	 <p>Jeżeli wartość nie jest podana, wówczas przy rysowaniu linii nie jest stosowane przyciąganie do pikseli.</p>
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">scaleMode</span>:<a href="../../String.html">String</a></code> (default = "<code>normal</code>")<code></code> &mdash; (Brak obsługi w programie Flash Lite 4) Wartość z klasy LineScaleMode określająca używany tryb skalowania:
	 
	 <ul><li>
	 <code>LineScaleMode.NORMAL</code>&mdash;Zawsze będzie skalowana grubość linii gdy obiekt jest skalowany (domyślnie).
	 </li><li>
	 <code>LineScaleMode.NONE</code>&mdash;Nigdy nie będzie skalowana grubość linii.
	 </li><li>
	 <code>LineScaleMode.VERTICAL</code>&mdash;Nie będzie skalowana grubość linii, gdy obiekt jest skalowany <i>wyłącznie</i> pionowo. Można na przykład przeanalizować poniższe okręgi narysowane linią o grubości jednego piksela i w każdym przypadku z parametrem <code>scaleMode</code> ustawionym na wartość <code>LineScaleMode.VERTICAL</code>. Okrąg po lewej stronie jest skalowany wyłącznie pionowo, zaś okrąg po prawej stronie jest skalowany zarówno pionowo jak i poziomo:
	 
     <p><img src="../../images/LineScaleMode_VERTICAL.jpg" alt="Okrąg wyskalowany w pionie oraz okrąg wyskalowany w pionie i w poziomie."></img></p>
	 
	 </li><li>
	 <code>LineScaleMode.HORIZONTAL</code>&mdash;Nie będzie skalowana grubość linii, gdy obiekt jest skalowany <i>wyłącznie</i> poziomo. Przykładowo biorąc pod uwagę poniższe okręgi narysowane linią o grubości jednego piksela i w każdym przypadku z parametrem <code>scaleMode</code> ustawionym na wartość <code>LineScaleMode.HORIZONTAL</code>. Okrąg po lewej stronie jest skalowany wyłącznie poziomo, zaś okrąg po prawej stronie jest skalowany zarówno pionowo jak i poziomo:
	 
     <p><img src="../../images/LineScaleMode_HORIZONTAL.jpg" alt="Okrąg wyskalowany w poziomie oraz okrąg wyskalowany w pionie i w poziomie."></img></p>
	 
	 </li></ul>
	 
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">caps</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; (Brak obsługi w programie Flash Lite 4) Wartość z klasy CapsStyle określająca typ zakończeń linii. Wartości prawidłowe to: <code>CapsStyle.NONE</code>,<code>CapsStyle.ROUND</code> oraz <code>CapsStyle.SQUARE</code>. Jeżeli wartość nie jest wskazana, aplikacja Flash stosuje zakończenia zaokrąglone. 
	 <p>Na przykład poniższe ilustracje ukazują różne ustawienia właściwości <code>capsStyle</code>. Na ilustracji przedstawiono wygląd niebieskiej linii o grubości 30 (z zastosowaną właściwością <code>capsStyle</code>) dla poszczególnych ustawień oraz nałożoną czarną linię grubości 1 (względem której właściwość <code>capsStyle</code> nie jest stosowana):
	 </p>
	 <p><img src="../../images/linecap.jpg" alt="NONE, ROUND i SQUARE"></img></p>
	 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">joints</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; (Brak obsługi w programie Flash Lite 4) Wartość z klasy JointStyle określająca typ wyglądu połączenia stosowanego na połączeniach pod kątem. Wartości prawidłowe to: <code>JointStyle.BEVEL</code>, <code>JointStyle.MITER</code> i <code>JointStyle.ROUND</code>. Jeżeli wartość nie jest wskazana, aplikacja Flash stosuje połączenia zaokrąglone. 
	 
	 <p>Na przykład poniższe ilustracje ukazują różne ustawienia właściwości <code>joints</code>. Na ilustracji przedstawiono wygląd łamanej niebieskiej linii o grubości 30 (z zastosowaną właściwością <code>jointStyle</code>) dla poszczególnych ustawień oraz nałożoną czarną linię grubości 1(względem której właściwość <code>jointStyle</code> nie jest stosowana):
	 </p>
	 
     <p><img src="../../images/linejoin.jpg" alt="MITER, ROUND i BEVEL"></img></p>
	 
	 <p><b>Uwaga:</b> Dla właściwości <code>joints</code>ustawionej na wartość <code>JointStyle.MITER</code>, możliwe jest zastosowanie parametru <code>miterLimit</code> w celu ograniczenia długości ścięcia.</p>
 	 
	 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">miterLimit</span>:<a href="../../Number.html">Number</a></code> (default = <code>3</code>)<code></code> &mdash; (Brak obsługi w programie Flash Lite 4) Liczba określa ograniczenie, przy którym jest obcinane ścięcie. Wartości prawidłowe znajdują się w granicach od 1 do 255 (wartości poza tymi granicami są zaokrąglane do 1 lub 255). Wartość ta jest stosowana tylko w przypadku ustawienia właściwości <code>jointStyle</code> na wartość <code>"miter"</code>. Wartość <code>miterLimit</code> przedstawia długość na którą ścięcie może wystawać poza punkt, w którym linie spotykają się i tworzą połączenie. Wartość wyraża współczynnik <code>thickness</code> linii. Przykładowo z współczynnikiem <code>miterLimit</code> wartości 2.5 oraz właściwością <code>thickness</code> o wartości 10 pikseli, ścięcie jest ucinane na 25 pikselach. 
	 
	 <p>Można na przykład przeanalizować poniższe linie pod kątem, każdy narysowany przy właściwości <code>thickness</code> o wartości 20, ale przy właściwości<code>miterLimit</code> ustawionej na 1, 2 i 4. Nałożone zostały czarne linie odwołania, ukazujące punkty spotkania połączeń:</p>
	 
     <p><img src="../../images/miterLimit.jpg" alt="linie z właściwością miterLimit, ustawioną na wartość 1,2 i 4"></img></p>
	 
	 <p>Należy zauważyć, iż podana wartość właściwości <code>miterLimit</code> ma określony kąt maksymalny, przy którym ścięcie jest obcinane. Poniższa tabela przedstawia listę niektórych przykładów:</p>
	 
	 <table class="innertable" ><tr><th>wartość właściwości <code>miterLimit</code>:</th><th>Obcięciu ulegają kąty mniejsze niż:</th></tr><tr><td>1.414</td><td>90 stopni</td></tr><tr><td>2</td><td>60 stopni</td></tr><tr><td>4</td><td>30 stopni</td></tr><tr><td>8</td><td>15 stopni</td></tr></table>
	 
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Graphics.html#lineBitmapStyle()" target="">lineBitmapStyle()</a><br/><a href="Graphics.html#lineGradientStyle()" target="">lineGradientStyle()</a><br/><a href="LineScaleMode.html" target="">LineScaleMode</a><br/><a href="CapsStyle.html" target="">CapsStyle</a><br/><a href="JointStyle.html" target="">JointStyle</a></div><br/><span class="label"> Przykład </span><br/><span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span><br/>Proszę spojrzeć na przykłady metody <a href="Graphics.html#lineTo()" >lineTo()</a> lub <a href="Graphics.html#moveTo()" >moveTo()</a> w celu przyjrzenia się ilustracjom ukazującym sposób wykorzystania metody <code>getStyle()</code>. 
     
     </div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="lineTo()" id="lineTo()"></a><a name="lineTo(Number,Number)" id="lineTo(Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lineTo</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lineTo(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
	 Rysuje linię przy wykorzystaniu obecnego stylu linii z obecnej pozycji rysowania do (<code>x</code>, <code>y</code>); wówczas obecna pozycja rysowania jest ustawiana na (<code>x</code>,<code>y</code>). W przypadku, gdy obiekt wyświetlania w którym przeprowadzane jest rysowanie posiada zawartość, która została utworzona przy pomocy narzędzi rysowania aplikacji Flash, wówczas wywołania metody <code>lineTo()</code> są rysowane pod zawartością. W sytuacji gdy zostanie wywołana metoda <code>lineTo()</code> przed wywołaniami metody <code>moveTo()</code>, wówczas domyślną pozycją obecnego rysowania jest (<i>0, 0</i>). Jeżeli brakuje któregoś z parametrów, ta metoda kończy działanie niepowodzeniem, zaś obecna pozycja rysowania nie ulega zmianie.
	 
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób rysowania zniekształcenia trapezowego przy wykorzystaniu metody <code>lineTo()</code>, rozpoczynając na pikselach (100, 100).  
 <p>Grubość linii jest ustawiona na 10 pikseli, ustawiony kolor złoty i nieprzezroczysty, brak ustawień zakończeń linii (ponieważ wszystkie linie są połączone), zaś połączenie między liniami jest ustawione na wartość <code>MITER</code>, przy czym ograniczenie ścięcia wynosi 10, aby kąty były zaostrzone.</p>     
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.LineScaleMode;
    import flash.display.CapsStyle;
    import flash.display.JointStyle;
    import flash.display.Shape;


    public class Graphics_lineToExample extends Sprite {

        public function Graphics_lineToExample() {

            var trapezoid:Shape = new Shape();    

            trapezoid.graphics.lineStyle(10, 0xFFD700, 1, false, LineScaleMode.VERTICAL,
                               CapsStyle.NONE, JointStyle.MITER, 10);

            trapezoid.graphics.moveTo(100, 100);
 
            trapezoid.graphics.lineTo(120, 50);
            trapezoid.graphics.lineTo(200, 50);
            trapezoid.graphics.lineTo(220, 100);
            trapezoid.graphics.lineTo(100, 100); 

            this.addChild(trapezoid);
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##Lite::4##"><a name="moveTo()" id="moveTo()"></a><a name="moveTo(Number,Number)" id="moveTo(Number,Number)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>moveTo</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function moveTo(x:<a href="../../Number.html">Number</a>, y:<a href="../../Number.html">Number</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>AIR 1.0, Flash Player 9, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Przenosi obecną pozycję rysowania na: (<code>x</code>,<code>y</code>). Jeżeli brakuje któregoś z parametrów, ta metoda kończy działanie niepowodzeniem, zaś obecna pozycja rysowania nie ulega zmianie.
     
	 </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję poziomą względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../Number.html">Number</a></code> &mdash; Liczba wskazująca pozycję pionową względem punktu rejestracji nadrzędnego obiektu wyświetlanego (w pikselach).
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób rysowania linii przerywanej o grubości trzech pikseli przy zastosowaniu metod <code>moveTo()</code> oraz <code>lineTo()</code>.
 
 <p>Przy zastosowaniu metody <code>lineStyle()</code> grubość linii jest ustawiona na 3 piksele. Jest również ustawiona na brak skalowania. Ustawiony jest kolor czerwony z 25 procentowym kryciem. Właściwość <code>CapsStyle</code> jest ustawiona na kwadrat (domyślna wartość to okrąg).</p>
 
 <p>Ponieważ instancja <code>Graphics_moveToExample</code> należy do klasy <code>Sprite</code>, ma ona dostęp do wszystkich metod klasy Graphics. Metody klasy Graphics mogą być wykorzystywane do bezpośredniego rysowania na obiekcie Sprite <code>Graphic_moveToExample</code>. Przy czym brak ustawienia obiektu rysującego wektor w obiekcie <code>Shape</code> ogranicza możliwości ich zarządzania, przenoszenia lub zmieniania.</p>
 
<div class="listing"><pre>
package {
    import flash.display.Sprite;
    import flash.display.CapsStyle;
    import flash.display.LineScaleMode;

    public class Graphics_moveToExample extends Sprite
    {
        public function Graphics_moveToExample() {
            
            graphics.lineStyle(3, 0x990000, 0.25, false, 
                            LineScaleMode.NONE, CapsStyle.SQUARE);

            graphics.moveTo(10, 20);
            graphics.lineTo(20, 20);
            graphics.moveTo(30, 20);
            graphics.lineTo(50, 20);
            graphics.moveTo(60, 20);
            graphics.lineTo(80, 20);
            graphics.moveTo(90, 20);
            graphics.lineTo(110, 20);            
            graphics.moveTo(120, 20);
            graphics.lineTo(130, 20);           
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.6##AIR::3.6##"><a name="readGraphicsData()" id="readGraphicsData()"></a><a name="readGraphicsData(Boolean)" id="readGraphicsData(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>readGraphicsData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function readGraphicsData(recurse:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 11.6, AIR 3.6</td></tr></table><p></p><p></p><p>
	 Pobiera zawartość grafiki wektorowej obiektu Sprite lub Shape (opcjonalnie jego elementów potomnych). Wynikiem jest wektor obiektów IGraphicsData. Przed zapytaniem do obiektów ekranowych są stosowane przekształcenia, dzięki czemu wszystkie zwracane ścieżki znajdują się w tej samej przestrzeni współrzędnych. Współrzędne w wynikowym zestawie danych są podane względem stołu montażowego, a nie próbkowanego obiektu ekranowego.
	 
	 <p>Wynik zawiera obiekty następujących typów z wymienionymi ograniczeniami:</p>
	 
	 <ul><li>GraphicsSolidFill</li><li>GraphicsGradientFill
	    <ul><li>Metoda <code>readGraphicsData()</code> zwraca wszystkie właściwości wypełnienia gradientem.</li><li>Zwracana macierz jest zbliżona do macierzy wejściowej, ale nie jest taka sama.</li></ul>
	   </li><li>GraphicsEndFill</li><li>GraphicsBitmapFill
	     <ul><li>Zwracana macierz jest zbliżona do macierzy wejściowej, ale nie jest taka sama.</li><li>Właściwość <code>repeat</code> zawsze ma wartość true.</li><li>Właściwość <code>smooth</code> zawsze ma wartość false.</li></ul>
	   </li><li>GraphicsStroke
	     <ul><li>Jest obsługiwana właściwość <code>thickness</code>.</li><li>Właściwość <code>fill</code> obsługuje wartości GraphicsSolidFill, GraphicsGradientFill i GraphicsBitmapFill zgodnie z opisem powyżej.</li><li>Wszystkie pozostałe właściwości mają wartości domyślne.</li></ul>
	   </li><li>GraphicsPath
	     <ul><li>Są obsługiwane tylko polecenia MOVE_TO, CURVE_TO i LINE_TO.</li></ul>
	   </li></ul>
     
     <p>Wynik nie zawiera następujących elementów wizualnych i przekształceń, gdyż nie można ich odwzorować:</p>
     
     <ul><li>Maski</li><li>Tekst z wyjątkiem tekstu statycznego zdefiniowanego z opcją „Wygładź dla animacji”, który jest renderowany jako kształty wektorowe i zawarty w wyniku.</li><li>Wypełnienia z cieniowaniem</li><li>Tryby mieszania</li><li>Skalowanie z podziałem na obszary</li><li>Trójkąty (utworzone przy użyciu metody <code>drawTriangles()</code>)</li><li>Nieprzezroczyste tło</li><li>Ustawienia <code>scrollrect</code></li><li>Przekształcenia 2,5D</li><li>Niewidoczne obiekty (z właściwością <code>visible</code> o wartości <code>false</code>)</li></ul>
	 
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">recurse</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Określa, czy środowisko wykonawcze powinno sprawdzać potomne obiekty ekranowe bieżącego obiektu ekranowego. Wykonanie zapytania rekurencyjnego może trwać dłużej i wymagać dodatkowej pamięci. Zwracany jest pojedynczy, spłaszczony zestaw wyników bez podziału na obiekty ekranowe.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="IGraphicsData.html">IGraphicsData</a>&gt;</code> &mdash; Wektor obiektów IGraphicsData reprezentujących zawartość grafiki wektorowej powiązanego z nimi obiektu ekranowego.
     
	 </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="IGraphicsData.html" target="">Interfejs IGraphicsData</a><br/><a href="GraphicsSolidFill.html" target="">Klasa GraphicsSolidFille</a><br/><a href="GraphicsGradientFill.html" target="">Klasa GraphicsGradientFill</a><br/><a href="GraphicsEndFill.html" target="">Klasa GraphicsEndFill</a><br/><a href="GraphicsStroke.html" target="">Klasa GraphicsStroke</a><br/><a href="GraphicsBitmapFill.html" target="">Klasa GraphicsBitmapFill</a><br/><a href="GraphicsPath.html" target="">Klasa GraphicsPath</a><br/><a href="Graphics.html#drawGraphicsData()" target="">Metoda drawGraphicsData()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje pobieranie zawartości grafiki wektorowej obiektu ekranowego za pomocą metody <code>readGraphicsData()</code>. Następnie kod ponownie rysuje tę zawartość w innym obiekcie na stole montażowym, gdy użytkownik klika stół montażowy.
 <p>Choć oryginalna zawartość wektorowa jest rysowana przy użyciu metody <code>drawGraphicsData()</code>, dane uzyskane przy użyciu metody <code>readGraphicsData()</code> nie są dokładnie takie same jak dane przekazane do metody <code>drawGraphicsData()</code>. Dane wynikowe zawierają na przykład polecenia GraphicsSolidFill i GraphicsEndFill. Oryginalne dane grafiki tylko implikują użycie tych poleceń &mdash; nie zawierają ich bezpośrednio.</p>
<div class="listing"><pre>
package
{
    import flash.display.GraphicsPathCommand;
    import flash.display.IGraphicsData;
    import flash.display.Shape;
    import flash.display.Sprite;
    import flash.events.MouseEvent;
    
    public class ReadGraphicsDataExample extends Sprite
    {
        private var original:Shape;
        private var copy:Shape;
        
        public function ReadGraphicsDataExample()
        {
            original = new Shape();
            original.x = 50;
            original.y = 100;
            addChild(original);
            
            drawSquare();
            
            copy = new Shape();
            copy.x = 250;
            copy.y = 100;
            addChild(copy);
            
            stage.addEventListener(MouseEvent.CLICK, drawCopyOnClick);
        }
        
        private function drawCopyOnClick(event:MouseEvent):void
        {
            // reset
            copy.graphics.clear();
            
            // Sample the vector data. Move the original to 0,0
            // before sampling so that the coordinates match the 
            // relative coordinates of the original.
            var xPos:Number = original.x;
            var yPos:Number = original.y;
            original.x = 0;
            original.y = 0;
            var result:Vector.&lt;IGraphicsData&gt; = original.graphics.readGraphicsData(false);
            original.x = xPos;
            original.y = yPos;
            
            // re-draw
            copy.graphics.drawGraphicsData(result);
        }
        
        private function drawSquare():void
        {
            var squareCommands:Vector.&lt;int&gt; = new Vector.&lt;int&gt;(5, true);
            
            squareCommands[0] = GraphicsPathCommand.MOVE_TO;
            squareCommands[1] = GraphicsPathCommand.LINE_TO;
            squareCommands[2] = GraphicsPathCommand.LINE_TO;
            squareCommands[3] = GraphicsPathCommand.LINE_TO;
            
            var squareCoordinates:Vector.&lt;Number&gt; = new Vector.&lt;Number&gt;(8, true);
            squareCoordinates[0] = 0;
            squareCoordinates[1] = 0; 
            squareCoordinates[2] = 50; 
            squareCoordinates[3] = 0; 
            squareCoordinates[4] = 50; 
            squareCoordinates[5] = 50; 
            squareCoordinates[6] = 0; 
            squareCoordinates[7] = 50; 
            
            original.graphics.beginFill(0x003366);
            original.graphics.drawPath(squareCommands, squareCoordinates);
        }
    }
}
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Przykłady<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span></div><span id="pageFilter"><div class="exampleHeader">GraphicsExample.as</div><br/><div class="detailBody"> Poniższy przykład ilustruje sposób wykorzystania klasy GraphicsExample do narysowania okręgu, zaokrąglonego prostokąta oraz kwadratu. Zadanie to jest przeprowadzane poprzez wykorzystanie następujących kroków:
 <ol><li>Deklaruje właściwość <code>size</code> do późniejszego użytku przy określaniu rozmiaru każdej figury.</li><li>Należy zadeklarować właściwości w celu ustawienia tła na kolor pomarańczowy, barwę obramowania na kolor szary, rozmiar obramowania na 0 pikseli, promień kąta na 9 pikseli oraz ustawić przestrzeń pomiędzy krawędzią stołu montażowego i innych obiektów na 5 pikseli. </li><li>Należy wykorzystać właściwości zadeklarowane w poprzednich krokach wraz z wbudowanymi metodami klasy Graphics w celu narysowania okręgu, zaokrąglonego prostokąta oraz kwadratu na współrzędnych x = 0, y = 0.</li><li>Narysuj ponownie figury wzdłuż górnej części stołu montażowego, rozpoczynając na współrzędnych x = 5, y = 5, przy 5-pikselowej przerwie między figurami. </li></ol>
<div class="listing"><pre>

package {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
    import flash.display.Sprite;

    public class GraphicsExample extends Sprite {
        private var size:uint         = 80;
        private var bgColor:uint      = 0xFFCC00;
        private var borderColor:uint  = 0x666666;
        private var borderSize:uint   = 0;
        private var cornerRadius:uint = 9;
        private var gutter:uint       = 5;

        public function GraphicsExample() {
            doDrawCircle();
            doDrawRoundRect();
            doDrawRect();
            refreshLayout();
        }

        private function refreshLayout():void {
            var ln:uint = numChildren;
            var child:DisplayObject;
            var lastChild:DisplayObject = getChildAt(0);
            lastChild.x = gutter;
            lastChild.y = gutter;
            for (var i:uint = 1; i &lt; ln; i++) {
                child = getChildAt(i);
                child.x = gutter + lastChild.x + lastChild.width;
                child.y = gutter;
                lastChild = child;
            }
        }

        private function doDrawCircle():void {
            var child:Shape = new Shape();
            var halfSize:uint = Math.round(size / 2);
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawCircle(halfSize, halfSize, halfSize);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRoundRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRoundRect(0, 0, size, size, cornerRadius);
            child.graphics.endFill();
            addChild(child);
        }

        private function doDrawRect():void {
            var child:Shape = new Shape();
            child.graphics.beginFill(bgColor);
            child.graphics.lineStyle(borderSize, borderColor);
            child.graphics.drawRect(0, 0, size, size);
            child.graphics.endFill();
            addChild(child);
        }
    }
}
</pre></div></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:06 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/pl_PL/legalnotices/index.html">Informacje prawne</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Zasady prywatności online</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Dlaczego język angielski?</span>
				</div>
				<div class="white_content_body">
					<b>Treść dokumentacji języka ActionScript 3.0 wyświetlana w języku angielskim</b><br><br>
					Niektóre części dokumentacji języka ActionScript 3.0 nie są przetłumaczone na poszczególne języki. Gdy element nie jest przetłumaczony na dany język, jest wyświetlany tekst angielski. Na przykład opis klasy ga.controls.HelpBox nie jest przetłumaczony na żaden dodatkowy język. Z tego powodu polska wersja dokumentacji zawiera opis klasy ga.controls.HelpBox w języku angielskim.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:06 PM Z  -->
