<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="ActionScript&reg; 3.0 &mdash; dokumentacja dla platformy Adobe&reg; Flash&reg;  "><meta name="lang" content="pl-pl"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:9"><meta name="runtime" content="air"><meta name="runtimever" content="air:1.0$Lite:4"><meta name="product" content="flash player"><meta name="productver" content="flash player:9"><meta name="product" content="air"><meta name="productver" content="air:1.0$Lite:4"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="BitmapData,flash.display.BitmapData,height,rect,transparent,width,applyFilter,clone,colorTransform,compare,copyChannel,copyPixels,copyPixelsToByteArray,dispose,draw,drawWithQuality,encode,fillRect,floodFill,generateFilterRect,getColorBoundsRect,getPixel,getPixel32,getPixels,getVector,histogram,hitTest,lock,merge,noise,paletteMap,perlinNoise,pixelDissolve,scroll,setPixel,setPixel32,setPixels,setVector,threshold,unlock"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>BitmapData - Adobe ActionScript&reg; 3 (AS3 ) &mdash; dokumentacja interfejsu API</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "Środowiska wykonawcze";
			var productsLabel = "Produkty";
			var noneLabel = "Brak";
			var qsearchBoxLabel = "Wyszukiwanie";
			var qsearchText = "Nie znaleziono terminu.";
			var ajaxErrorMsg="Błąd wczytywania strony";
			var ajaxErrorTryMsg="Ponów próbę";
			var ajaxLoadingMsg="Wczytywanie nadal w toku";
			var cancelMsg = "Anuluj";
			var classesText = "Klasy";
			var strJiveReply = "To pytanie zamieszczono w odpowiedzi na następujący artykuł: "
			var showFilters = "Pokaż filtry";
			var hideFilters = "Ukryj filtry";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											ActionScript<sup>&reg;</sup> 3.0 &mdash; dokumentacja dla platformy Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup>  <br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> Strona główna </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="BitmapData.html#top" style="display:">Pokaż listę pakietów i klas</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="BitmapData.html#top" style="display:none">Ukryj listę pakietów i klas</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> Pakiety </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> Klasy </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> Nowości </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> Indeks </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> Dodatki </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">Dlaczego język angielski?</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/pl_PL/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>Filtry:</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">Pobieranie danych z serwera...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="BitmapData.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display&nbsp;</a><br>
								<h1 id="classProductName">BitmapData&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="BitmapData.html#propertySummary" style="display:none"> Właściwości </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> Właściwości </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="BitmapData.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> Konstruktor </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="BitmapData.html#methodSummary" style="display:none"> Metody </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="BitmapData.html#constantSummary" style="display:none"> Stałe globalne </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="BitmapData.html#eventSummary" style="display:none"> Zdarzenia </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="BitmapData.html#styleSummary" style="display:none"> Style </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="BitmapData.html#SkinPartSummary" style="display:none"> Części karnacji </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="BitmapData.html#SkinStateSummary" style="display:none"> Stany karnacji </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="BitmapData.html#effectSummary" style="display:none"> Efekty </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="BitmapData.html#constantSummary" style="display:none"> Stałe </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="BitmapData.html#methodSummary" style="display:none"> Funkcje globalne </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="BitmapData.html#methodSummary" style="display:none">Funkcje</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="BitmapData.html#interfaceSummary" style="display:none"> Interfejsy </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="BitmapData.html#classSummary" style="display:none"> Klasy </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="BitmapData.html#includeExamplesSummary" style="display:none"> Przykłady </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="BitmapData.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								Klasy
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">Pakiet</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display</a></td></tr><tr><td class="classHeaderTableLabel">Klasa</td><td class="classSignature">public  class  BitmapData</td></tr><tr><td class="classHeaderTableLabel">Dziedziczenie</td><td class="inheritanceList">BitmapData  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr><tr><td class="classHeaderTableLabel">Implementuje</td><td> <a href="IBitmapDrawable.html">IBitmapDrawable</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p></p>
 Klasa BitmapData umożliwia operacje na danych (pikselach) <span>obiektu Bitmap</span>. Możliwe jest wykorzystanie metod klasy BitmapData do tworzenia przezroczystych lub nieprzezroczystych obrazów bitmapowych o dowolnie określonych rozmiarach oraz manipulacja nimi na różne sposoby w trakcie wykonywania. <span> Możliwe jest również uzyskanie dostępu do właściwości BitmapData obrazu bitmapowego, który został załadowany za pomocą klasy <code>flash.display.Loader</code>.</span> 
 
               <p>Klasa ta pozwala na oddzielenie operacji renderowania bitmapy od wewnętrznych procedur odświeżania ekranu modułu Flash Player. Bezpośrednio manipulując obiektem BitmapData, można tworzyć złożone obrazy bez wprowadzania w każdej klatce narzutu czasowego wynikającego z ciągłego przerysowywania zawartości na podstawie danych wektorowych.</p>
 
               <p>Metody klasy BitmapData obsługują efekty, które nie są dostępne przez filtry udostępnione obiektom wyświetlanym innym niż bitmapy.</p>
 
               <p>Obiekt BitmapData zawiera tablicę pikseli. Dane te mogą reprezentować w pełni nieprzezroczystą bitmapę lub przezroczystą bitmapę zawierającą dane kanału alpha. Każdy z typów obiektów BitmapData jest przechowywany jako bufor 32-bitowych liczb całkowitych. Każda 32-bitowa liczba całkowita określa właściwości pojedynczego piksela bitmapy.</p>
 
               <p>Każda 32-bitowa liczba całkowita jest kombinacją czterech 8-bitowych wartości kanału (od 0 do 255), które opisują przezroczystość alpha oraz wartości koloru czerwonego, zielonego i niebieskiego (ARGB) piksela. (Dla wartości ARGB najbardziej znaczący bajt reprezentuje wartość kanału alpha a następnie koloru czerwonego, zielonego i niebieskiego).</p>
 
               <p>Te cztery kanały (alpha, czerwony, zielony, niebieski) są reprezentowane jako liczby przy wykorzystaniu ich w metodzie <code>BitmapData.copyChannel()</code> lub właściwościach <code>DisplacementMapFilter.componentX</code> oraz <code>DisplacementMapFilter.componentY</code>. Liczby te są reprezentowane przez następujące stałe w klasie BitmapDataChannel: </p>
 
               <ul>
                  <li>
                     <code>BitmapDataChannel.ALPHA</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.RED</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.GREEN</code>
                  </li>
                  <li>
                     <code>BitmapDataChannel.BLUE</code>
                  </li>
               </ul>
 
               <p>Możliwe jest dołączenie obiektów BitmapData do obiektu Bitmap poprzez wykorzystanie właściwości <code>bitmapData</code> obiektu Bitmap.</p>
 
               <p>Możliwe jest wykorzystanie obiektu BitmapData w celu wypełnienia obiektu Graphics poprzez zastosowanie metody <code>Graphics.beginBitmapFill()</code>.</p>
 
               <p>W środowisku wykonawczym AIR klasy DockIcon, Icon, InteractiveIcon i SystemTrayIcon zawierają właściwość <code>bitmaps</code> będącą tablicą obiektów BitmapData, które definiują obrazy bitmapowe ikony.</p>
 
               <p>W środowisku AIR 1.5 i programie Flash Player 10 maksymalna szerokość i wysokość obiektu BitmapData wynosi 8191, a łączna liczba pikseli nie może przekroczyć 16 777 215. (A zatem, jeśli obiekt BitmapData ma szerokość 8,191 pikseli, nie może być wyższy niż 2048 pikseli). W programie Flash Player 9 i wcześniejszych wersjach oraz w środowisku AIR 1.1 i wcześniejszych wersjach ograniczenie wysokości i szerokości wynosiło 2880 pikseli.</p>
 
               <p>W środowisku AIR 3 i programie Flash Player 11 usunięto ograniczenia obiektu BitmapData. Maksymalny rozmiar bitmapy zależy teraz od systemu operacyjnego.</p>
 
               <p>Wywołania do dowolnej metody lub właściwości obiektu BitmapData powodują zgłoszenie błędu ArgumentError jeżeli obiekt BitmapData jest nieprawidłowy (na przykład gdy jego właściwość <code>height == 0</code> i <code>width == 0</code>) lub został usunięty poprzez metodę dispose().  </p>
 
            <p></p><p><a href="BitmapData.html#includeExamplesSummary">Wyświetl przykłady</a></p><p><span class="classHeaderTableLabel">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="Bitmap.html#bitmapData" target="">flash.display.Bitmap.bitmapData</a><br/><a href="../desktop/DockIcon.html#bitmaps" target="">flash.desktop.DockIcon.bitmaps</a><br/><a href="Graphics.html#beginBitmapFill()" target="">flash.display.Graphics.beginBitmapFill()</a><br/><a href="../desktop/Icon.html#bitmaps" target="">flash.desktop.Icon.bitmaps</a><br/><a href="../desktop/InteractiveIcon.html#bitmaps" target="">flash.desktop.InteractiveIcon.bitmaps</a><br/><a href="Loader.html" target="">flash.display.Loader</a><br/><a href="../desktop/SystemTrayIcon.html#bitmaps" target="">flash.desktop.SystemTrayIcon.bitmaps</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Właściwości publiczne</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ukryj dziedziczone właściwości publiczne</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="BitmapData.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Pokaż dziedziczone właściwości publiczne</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">Właściwość</th><th>Zdefiniowane przez</th></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 Odwołanie do obiektu klasy lub funkcji konstruktora, dotyczące danej instancji obiektu.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#height" class="signatureLink">height</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[tylko do odczytu] 
     Wysokość obrazu bitmapowego w pikselach.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#rect" class="signatureLink">rect</a> : <a href="../geom/Rectangle.html">Rectangle</a><div class="summaryTableDescription">[tylko do odczytu] 
     Prostokąt definiujący wymiary i położenie obrazu bitmapowego.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#transparent" class="signatureLink">transparent</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[tylko do odczytu] 
     Określa, czy obraz bitmapowy obsługuje przezroczystość poszczególnych pikseli.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="BitmapData.html#width" class="signatureLink">width</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[tylko do odczytu] 
     Szerokość obrazu bitmapowego w pikselach.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">Metody publiczne </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> Ukryj dziedziczone metody publiczne</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="BitmapData.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> Pokaż dziedziczone metody publiczne</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">Metoda</th><th>Zdefiniowane przez</th></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#BitmapData()" class="signatureLink">BitmapData</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</div><div class="summaryTableDescription">
     Tworzy obiekt BitmapData o określonej wysokości i szerokości.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#applyFilter()" class="signatureLink">applyFilter</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Pobiera obraz źródłowy i filtr, a następnie generuje obraz filtrowany.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#clone()" class="signatureLink">clone</a>():<a href="BitmapData.html">BitmapData</a></div><div class="summaryTableDescription">
     Zwraca nowy obiekt BitmapData, który jest klonem oryginalnego wystąpienia z dokładną kopią zawartej bitmapy.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#colorTransform()" class="signatureLink">colorTransform</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Dopasowuje wartości kolorów w określonym obszarze obrazu bitmapowego za pomocą obiektu ColorTransform.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#compare()" class="signatureLink">compare</a>(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
     
     Porównuje dwa obiekty BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyChannel()" class="signatureLink">copyChannel</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Przenosi dane z jednego kanału innego obiektu BitmapData lub bieżącego obiektu BitmapData na kanał w bieżącym obiekcie BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixels()" class="signatureLink">copyPixels</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Zapewnia szybką procedurę do manipulowania pikselami między różnymi obrazami, bez rozciągania, obrotu ani efektów kolorystycznych.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.4##AIR::3.4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#copyPixelsToByteArray()" class="signatureLink">copyPixelsToByteArray</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Wypełnia tablicę bajtów na podstawie prostokątnego obszaru pikseli.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#dispose()" class="signatureLink">dispose</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Zwalnia pamięć używaną do przechowywania danego obiektu typu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#draw()" class="signatureLink">draw</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Rysuje obiekt wyświetlany source na obrazie bitmapowym za pomocą wektorowego mechanizmu renderującego środowiska wykonawczego Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#drawWithQuality()" class="signatureLink">drawWithQuality</a>(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Rysuje obiekt wyświetlany source na obrazie bitmapowym za pomocą wektorowego mechanizmu renderującego środowiska wykonawczego Flash.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::11.3##AIR::3.3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#encode()" class="signatureLink">encode</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Kompresuje ten obiekt BitmapData przy użyciu wybranego algorytmu kompresji i zwraca nowy obiekt ByteArray.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#fillRect()" class="signatureLink">fillRect</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Wypełnia obszar prostokątny pikselami o określonym kolorze ARGB.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#floodFill()" class="signatureLink">floodFill</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Przeprowadza operację wypełniania jednolitego, zaczynając od punktu na współrzędnych (x, y) i wypełniając wybranym kolorem.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#generateFilterRect()" class="signatureLink">generateFilterRect</a>(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Określa prostokąt docelowy, na który ma wpływ wywołanie metody applyFilter(), jeżeli jest podany obiekt BitmapData, prostokąt źródłowy oraz obiekt filtra.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getColorBoundsRect()" class="signatureLink">getColorBoundsRect</a>(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></div><div class="summaryTableDescription">
     Określa obszar prostokątny, który ma albo w pełni otoczyć wszystkie piksele o określonym kolorze (jeśli parametr findColor ma wartość true), albo w pełni otoczyć wszystkie piksele w innych kolorach (jeśli parametr findColor ma wartość false).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel()" class="signatureLink">getPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Zwraca liczbę całkowitą, która reprezentuje wartość RGB piksela z obiektu BitmapData w określonym punkcie (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixel32()" class="signatureLink">getPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Zwraca wartość koloru ARGB, która zawiera dane kanału alfa i dane RGB.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getPixels()" class="signatureLink">getPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></div><div class="summaryTableDescription">
     Generuje tablicę bajtów na podstawie prostokątnego obszaru pikseli.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#getVector()" class="signatureLink">getVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</div><div class="summaryTableDescription">
     Generuje tablicę wektorów na podstawie prostokątnego obszaru pikseli.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy dla obiektu zdefiniowano określoną właściwość.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#histogram()" class="signatureLink">histogram</a>(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</div><div class="summaryTableDescription">
     Oblicza histogram 256 wartości binarnych obiektu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#hitTest()" class="signatureLink">hitTest</a>(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
     Uaktywnia wykrywanie pikseli między obrazem bitmapowym a punktem, prostokątem lub innym obrazem bitmapowym.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy instancja klasy Object należy do łańcucha prototypów obiektu określonego jako parametr.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#lock()" class="signatureLink">lock</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Blokuje obraz, co powoduje, że wszelkie obiekty odwołujące się do obiektu BitmapData, np. obiekty Bitmap, nie są aktualizowane w odpowiedzi na zmiany obiektu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#merge()" class="signatureLink">merge</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Wykonuje mieszanie poszczególnych kanałów z obrazu źródłowego do obrazu docelowego.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#noise()" class="signatureLink">noise</a>(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Wypełnia obraz pikselami stanowiącymi losowy szum.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#paletteMap()" class="signatureLink">paletteMap</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ponownie odwzorowuje wartości kanałów kolorów w obrazie zawierającym maksymalnie cztery tablice dotyczące kolorów - po jednej na każdy kanał.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#perlinNoise()" class="signatureLink">perlinNoise</a>(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Generuje obraz szumu Perlina.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#pixelDissolve()" class="signatureLink">pixelDissolve</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></div><div class="summaryTableDescription">
     Przeprowadza operację rozpuszczania na poziomie pikseli - albo z obrazu źródłowego do obrazu docelowego, albo przy użyciu jednego obrazu.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 Wskazuje, czy określona właściwość istnieje i jest przeliczalna.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#scroll()" class="signatureLink">scroll</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Przewija obraz o pewną liczbę pikseli (x, y).</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel()" class="signatureLink">setPixel</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ustawia pojedynczy piksel obiektu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixel32()" class="signatureLink">setPixel32</a>(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ustawia wartości koloru i przezroczystości alfa jednego piksela w obiekcie typu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setPixels()" class="signatureLink">setPixels</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Konwertuje tablicę bajtów na prostokątny obszar pikseli.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Ustawia dostępność właściwości dynamicznej używanej w pętlach.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::10##AIR::1.5##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#setVector()" class="signatureLink">setVector</a>(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Przekształca obiekt Vector w prostokątny region danych pikselowych.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#threshold()" class="signatureLink">threshold</a>(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></div><div class="summaryTableDescription">
     Testuje wartości pikseli obrazu ze względu na określony próg i określa nowe wartości kolorów pikseli zweryfikowanych pozytywnie.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Zwraca ciąg reprezentujący obiekt &mdash; sformatowany zgodnie z konwencjami właściwymi dla ustawień regionalnych.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 Zwraca ciąg reprezentujący określony obiekt.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::9##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="BitmapData.html#unlock()" class="signatureLink">unlock</a>(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     Odblokowuje obraz, co powoduje, że wszelkie obiekty odwołujące się do obiektu BitmapData, np. obiekty Bitmap, są aktualizowane w odpowiedzi na zmiany obiektu BitmapData.</div></td><td class="summaryTableOwnerCol">BitmapData</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 Zwraca pierwotną wartość dla określonego obiektu.</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">Szczegół właściwości</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="height" id="height"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>height</h3></td><td class="detailHeaderType">właściwość</td></tr></table><div class="detailBody"><code>height:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[tylko do odczytu] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Wysokość obrazu bitmapowego w pikselach.
     
     </p><br/><br/><span class="label"> Implementacja </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get height():<a href="../../int.html">int</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="rect" id="rect"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>rect</h3></td><td class="detailHeaderType">właściwość</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>rect:<a href="../geom/Rectangle.html">Rectangle</a></code>&nbsp;&nbsp;[tylko do odczytu] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Prostokąt definiujący wymiary i położenie obrazu bitmapowego. Góra i lewa strona prostokąta mają wartość 0; szerokość i wysokość są równe szerokości i wysokości obiektu BitmapData.
     
     </p><br/><br/><span class="label"> Implementacja </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get rect():<a href="../geom/Rectangle.html">Rectangle</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="transparent" id="transparent"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>transparent</h3></td><td class="detailHeaderType">właściwość</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>transparent:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[tylko do odczytu] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Określa, czy obraz bitmapowy obsługuje przezroczystość poszczególnych pikseli. Możliwe jest ustawienie tej wartości tylko w przypadku konstruowania obiektu BitmapData przez podanie wartości <code>true</code> dla parametru <code>transparent</code> konstruktora. Następnie, po utworzeniu obiektu BitmapData, możliwe jest sprawdzenie obsługi przezroczystości na poziomie poszczególnych pikseli. W tym celu należy sprawdzić, czy właściwość <code>transparent</code> ma wartość <code>true</code>.
     
     
     </p><br/><br/><span class="label"> Implementacja </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get transparent():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="width" id="width"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>width</h3></td><td class="detailHeaderType">właściwość</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>width:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[tylko do odczytu] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Szerokość obrazu bitmapowego w pikselach.
     
     </p><br/><br/><span class="label"> Implementacja </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get width():<a href="../../int.html">int</a></code><br/></div></span><a name="constructorDetail" id="constructorDetail"></a><div class="detailSectionHeader">Konstruktor Szczegół</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="BitmapData()" id="BitmapData()"></a><a name="BitmapData(int,int,Boolean,uint)" id="BitmapData(int,int,Boolean,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>BitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">Konstruktor</td></tr></table><div class="detailBody"><code>public function BitmapData(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, transparent:<a href="../../Boolean.html">Boolean</a> = true, fillColor:<a href="../../uint.html">uint</a> = 0xFFFFFFFF)</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p>
     Tworzy obiekt BitmapData o określonej wysokości i szerokości. W przypadku określenia wartości parametru <code>fillColor</code> każdy piksel bitmapy zostanie ustawiony na ten kolor.
     
     <p>Domyślnie bitmapa jest tworzona jako przezroczysta, chyba że zostanie podana wartość <code>false</code> dla parametru <code>transparent</code>. Po utworzeniu nieprzezroczystej bitmapy nie jest możliwa zmiana jej na bitmapę przezroczystą. Każdy piksel na bitmapie nieprzezroczystej wykorzystuje tylko 24 bity informacji kanałów kolorów. Po zdefiniowaniu bitmapy jako przezroczystej każdy piksel wykorzystuje 32 bity informacji kanałów kolorów, włącznie z kanałem przezroczystości alpha.</p>
     
     <p>W środowisku AIR 1.5 i programie Flash Player 10 maksymalna szerokość i wysokość obiektu BitmapData wynosi 8191, a łączna liczba pikseli nie może przekroczyć 16 777 215. (A zatem, jeśli obiekt BitmapData ma szerokość 8,191 pikseli, nie może być wyższy niż 2048 pikseli). W programie Flash Player 9 lub nowszym i środowisku AIR 1.1 lub nowszym obowiązuje ograniczenie do 2880 pikseli wysokości i szerokości. Przy określeniu wartości szerokości lub wysokości większej niż 2880 nowa instancja nie zostanie utworzona.</p>
     
     </p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; Szerokość obrazu bitmapowego w pikselach.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; Wysokość obrazu bitmapowego w pikselach.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transparent</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Określa, czy obraz bitmapowy obsługuje przezroczystość z dokładnością do pojedynczych pikseli. Właściwość ma wartość domyślną <code>true</code> (przezroczyste). W celu utworzenia bitmapy w pełni przezroczystej należy ustawić parametr <code>transparent</code> na wartość <code>true</code> oraz parametr <code>fillColor</code> na wartość 0x00000000 (lub na 0). Ustawienie właściwości <code>transparent</code> na wartość <code>false</code> może spowodować niewielkie podwyższenie wydajności renderowania. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; 32-bitowa wartość koloru ARGB, która jest stosowana do wypełnienia obszaru obrazu bitmapowego. Właściwość ma wartość domyślną 0xFFFFFFFF (jednolity kolor biały).
     
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; szerokość i/lub wysokość przekracza wymiary maksymalne.
     
     </td></tr></table></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">Szczegół metody</div><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="applyFilter()" id="applyFilter()"></a><a name="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)" id="applyFilter(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>applyFilter</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td></tr></table><div class="detailBody"><code> public function applyFilter(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Pobiera obraz źródłowy i filtr, a następnie generuje obraz filtrowany.
     
     <p>Ta metoda opiera się na zachowaniu wbudowanych obiektów filtra, które określa prostokąt docelowy, na który ma wpływ prostokąt źródła wprowadzania.</p>
     
     <p>Po zastosowaniu filtra obraz wynikowy może być większy niż obraz wejściowy. Na przykład przy użyciu klasy BlurFilter w celu rozmycia prostokąta źródłowego o współrzędnych (50, 50,100,100) oraz punkcie docelowym (10, 10), obszar który ulega zmianie w obrazie docelowym jest większy niż (10, 10, 60, 60) ze względu na rozmycie. Dzieje się to wewnętrznie w trakcie wywołania metody <code>applyFilter()</code>.</p>
     
     <p>Jeżeli parametr<code>sourceRect</code> parametru <code>sourceBitmapData</code> jest obszarem wewnętrznym, jak na przykład (50, 50, 100, 100) w obrazie wielkości 200 x 200, wówczas filtr wykorzystuje piksele spoza parametru <code>sourceRect</code> w celu wygenerowania prostokąta docelowego.</p>
     
     <p>Jeżeli obiekt BitmapData oraz obiekt określony jako parametr <code>sourceBitmapData</code> są tym samym obiektem, wówczas aplikacja wykorzystuje tymczasową kopię obiektu w celu przeprowadzenia filtrowania. Najlepiej jest nie dopuszczać do takiej sytuacji.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do użycia. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnej instancji BitmapData. 

     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt wewnątrz obrazu docelowego (obecna instancja BitmapData) odpowiadający górnemu lewemu narożnikowi prostokąta. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Obiekt filtra wykorzystywany do przeprowadzenia operacji filtrowania. Każdy typ filtra ma pewne wymagania, przedstawione poniżej:
     
     <ul><li><b>BlurFilter</b> &mdash; Ten filtr może wykorzystywać obrazy źródłowe i docelowe, które są nieprzezroczyste lub przezroczyste. Jeżeli formaty obrazów nie zgadzają się, wówczas kopia obrazu źródłowego utworzona w trakcie filtrowania odpowiada formatowi obrazu docelowego.</li><li><b>BevelFilter, DropShadowFilter, GlowFilter</b> &mdash; Obraz docelowy tych filtrów musi być przezroczysty. Wywoływanie filtrów DropShadowFilter i GlowFilter tworzy obraz zawierający dane kanału alpha dla cienia i poświaty. Nie tworzy to cienia na obrazie docelowym. W przypadku zastosowania tych filtrów względem nieprzezroczystego obrazu docelowego zgłaszany jest wyjątek.</li><li><b>ConvolutionFilter</b> &mdash; Ten filtr może wykorzystywać obrazy źródłowe i docelowe, które są nieprzezroczyste lub przezroczyste.</li><li><b>ColorMatrixFilter</b> &mdash; Ten filtr może wykorzystywać obrazy źródłowe i docelowe, które są nieprzezroczyste lub przezroczyste.</li><li><b>DisplacementMapFilter</b> &mdash; Ten filtr może wykorzystywać obrazy źródłowe i docelowe, które są nieprzezroczyste lub przezroczyste, jednakże formaty obu tych obrazów muszą być identyczne.</li></ul>
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect, destPoint oraz filter mają wartość null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../errors/IllegalOperationError.html">IllegalOperationError</a> </code> &mdash; Przezroczystość obiektów BitmapData jest niekompatybilna z operacją filtrowania.
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../filters/BevelFilter.html" target="">flash.filters.BevelFilter</a><br/><a href="../filters/BlurFilter.html" target="">flash.filters.BlurFilter</a><br/><a href="../filters/ColorMatrixFilter.html" target="">flash.filters.ColorMatrixFilter</a><br/><a href="../filters/ConvolutionFilter.html" target="">flash.filters.ConvolutionFilter</a><br/><a href="../filters/DisplacementMapFilter.html" target="">flash.filters.DisplacementMapFilter</a><br/><a href="../filters/DropShadowFilter.html" target="">flash.filters.DropShadowFilter</a><br/><a href="../filters/GlowFilter.html" target="">flash.filters.GlowFilter</a><br/><a href="DisplayObject.html#filters" target="">flash.display.DisplayObject.filters</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób, w jaki można zastosować filtr rozmycia względem instancji BitmapData: 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();
bmd.applyFilter(bmd, rect, pt, filter);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="clone()" id="clone()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clone</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function clone():<a href="BitmapData.html">BitmapData</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zwraca nowy obiekt BitmapData, który jest klonem oryginalnej instancji z dokładną kopią zawartej bitmapy.
     
     </p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="BitmapData.html">BitmapData</a></code> &mdash; Nowy obiekt BitmapData jest identyczny względem oryginału.
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje jak można sklonować instancję BitmapData oraz przedstawia, jak w przypadku modyfikacji sklonowanej instancji BitmapData oryginał pozostaje bez zmian:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(100, 80, false, 0x00000000);
var bmd2:BitmapData = bmd1.clone();

bmd1.setPixel32(1, 1, 0xFFFFFFFF);

trace(bmd1.getPixel32(1, 1).toString(16)); // ffffffff
trace(bmd2.getPixel32(1, 1).toString(16)); // ff000000

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);

var bm2:Bitmap = new Bitmap(bmd2);
bm2.x = 110;
this.addChild(bm2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="colorTransform()" id="colorTransform()"></a><a name="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)" id="colorTransform(flash.geom.Rectangle,flash.geom.ColorTransform)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>colorTransform</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function colorTransform(rect:<a href="../geom/Rectangle.html">Rectangle</a>, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Dopasowuje wartości kolorów w określonym obszarze obrazu bitmapowego poprzez wykorzystanie obiektu <code>ColorTransform</code>. Jeżeli prostokąt pasuje pod względem granic do obrazu bitmapowego, wówczas ta metoda transformuje wartości kolorów dla całego obrazu.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obiekt Rectangle definiujący obszar, w którym obiekt ColorTransform ma być zastosowany.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> &mdash; Obiekt ColorTransform opisujący wartości transformacji kolorów do zastosowania.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości rect i colorTransform mają wartość null.
      
      </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób, w jaki można zastosować transformację kolorów do lewej połowy (prostokąta) obiektu BitmapData: 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.ColorTransform;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFF0000);

var cTransform:ColorTransform = new ColorTransform();
cTransform.alphaMultiplier = 0.5
var rect:Rectangle = new Rectangle(0, 0, 40, 30);
bmd.colorTransform(rect, cTransform);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="compare()" id="compare()"></a><a name="compare(flash.display.BitmapData)" id="compare(flash.display.BitmapData)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>compare</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function compare(otherBitmapData:<a href="BitmapData.html">BitmapData</a>):<a href="../../Object.html">Object</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     
     Porównuje dwa obiekty BitmapData. Jeżeli dwa obiekty BitmapData mają te same wymiary (szerokość i wysokość), wówczas metoda zwraca nowy obiekt BitmapData, w którym każdy piksel jest "różnicą" pomiędzy pikselami dwóch obiektów źródłowych:
     
     <ul><li>Jeżeli oba piksele są równe, piksel różnicy ma wartość 0x00000000. </li><li>Jeżeli oba piksele mają różne wartości RGB (pomijając wartość alpha), wówczas piksel różnicy ma wartość 0xRRGGBB, gdzie RR/GG/BB są indywidualnymi wartościami różnicy między kanałami koloru czerwonego, zielonego i niebieskiego (wartość pikseli w obiekcie źródłowym minus wartość pikseli w obiekcie <code>otherBitmapData</code>). Różnice dotyczące kanału alpha są w tym przypadku pomijane. </li><li>Jeżeli tylko wartość kanału alpha się różni, wówczas wartość pikseli wynosi 0x<i>ZZ</i>FFFFF, gdzie <i>ZZ</i> jest różnicą wartości alpha (wartość alpha w obiekcie źródłowym minus wartość alpha w obiekcie <code>otherBitmapData</code>).</li></ul>
     
     <p>Można na przykład przeanalizować poniższe dwa obiekty BitmapData:</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFF8800);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCCC6600);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel(0,0).toString(16); // 0x332200
     </pre></div>
     
     
     
     <p><b>Uwaga:</b> Kolory wykorzystane do wypełnienia dwóch obiektów BitmapData mają nieco inne wartości RGB (0xFF0000 i 0xFFAA00). Wynikiem metody <code>compare()</code> jest nowy obiekt BitmapData, gdzie każdy piksel wykazuje różnicę w wartościach RGB między dwoma bitmapami.</p>
     
     <p>Biorąc pod uwagę poniższe dwa obiekty BitmapData, w których kolory RGB są takie same, ale różne są wartości alpha: </p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
     var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
     var diffBmpData:BitmapData = bmd1.compare(bmd2) as BitmapData;
     trace ("0x" + diffBmpData.getPixel32(0,0).toString(16); // 0x33ffffff
     </pre></div>
     
     
     
     <p>Wynikiem metody <code>compare()</code> jest nowy obiekt BitmapData, gdzie każdy piksel wykazuje różnicę w wartościach właściwości alpha między dwoma bitmapami.</p>
     
     <p>Jeżeli obiekty BitmapData są swoimi odpowiednikami (ta sama szerokość i wysokość oraz identyczne wartości pikseli), wówczas metoda zwraca liczbę 0.</p>
     
     <p>Jeżeli szerokości obiektów BitmapData nie są równe, wówczas metoda zwraca liczbę -3. </p>
     
     <p>Jeżeli wysokości obiektów BitmapData nie są równe, ale szerokości są takie same, wówczas metoda zwraca liczbę -4.</p>
     
     <p>Poniższy przykład ilustruje porównanie dwóch obiektów Bitmap o różnych szerokościach (50 i 60):</p>
     
     <div class="listing"><pre>
     var bmd1:BitmapData = new BitmapData(100, 50, false, 0xFFFF0000);
     var bmd2:BitmapData = new BitmapData(100, 60, false, 0xFFFFAA00);
     trace(bmd1.compare(bmd2)); // -4
     </pre></div>
     
     
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">otherBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Obiekt BitmapData do porównania ze źródłowym obiektem BitmapData. 
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Object.html">Object</a></code> &mdash; Jeżeli dwa obiekty BitmapData mają te same wymiary (szerokość i wysokość), wówczas metoda zwraca nowy obiekt BitmapData, który posiada różnicę między tymi obiektami (zob. dyskusja główna). Jeżeli obiekty BitmapData są swoimi odpowiednikami, wówczas metoda zwraca liczbę 0. Jeżeli szerokości obiektów BitmapData nie są równe, wówczas metoda zwraca liczbę -3. Jeżeli wysokości obiektów BitmapData nie są równe, wówczas metoda zwraca liczbę -4. 
     
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość otherBitmapData ma wartość null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje wartość pikseli obiektu BitmapData, która wynika z porównania dwóch obiektów BitmapData o tych samych wymiarach:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd1:BitmapData = new BitmapData(50, 50, true, 0xFFFFAA00);
var bmd2:BitmapData = new BitmapData(50, 50, true, 0xCCFFAA00);
var diffBmpData:BitmapData = BitmapData(bmd1.compare(bmd2));
var diffValue:String = diffBmpData.getPixel32(1, 1).toString(16);
trace (diffValue); // 33ffffff

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 60;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyChannel()" id="copyChannel()"></a><a name="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)" id="copyChannel(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyChannel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyChannel(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, sourceChannel:<a href="../../uint.html">uint</a>, destChannel:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Przenosi dane z jednego kanału innego obiektu BitmapData lub bieżącego obiektu BitmapData na kanał w bieżącym obiekcie BitmapData. Wszelkie dane z innych kanałów w obiekcie docelowym BitmapData są zachowane.
     
     <p>Źródłowe wartości kanałów oraz docelowe wartości kanałów mogą mieć następujące wartości: </p>
     <ul><li><code>BitmapDataChannel.RED</code></li><li><code>BitmapDataChannel.GREEN</code></li><li><code>BitmapDataChannel.BLUE</code></li><li><code>BitmapDataChannel.ALPHA</code></li></ul>

     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do wykorzystania. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnego obiektu BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Źródłowy obiekt Rectangle. W celu skopiowania wyłącznie danych kanałów lub mniejszego obszaru wewnątrz bitmapy należy określić prostokąt źródłowy, który jest mniejszy niż całkowity rozmiar obiektu BitmapData.  
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Docelowy obiekt Point reprezentujący górny lewy narożnik obszaru prostokątnego, gdzie umieszczane są nowe dane kanałów. W celu skopiowania wyłącznie danych kanałów z jednego obszaru do drugiego w obrazie docelowym należy określić punkt o współrzędnych innych niż (0,0).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Kanał źródłowy. Należy zastosować wartość z klasy BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destChannel</span>:<a href="../../uint.html">uint</a></code> &mdash; Kanał docelowy. Należy wykorzystać wartość z klasy BitmapDataChannel (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>).
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect lub destPoint mają wartość null.
      
      </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób kopiowania kanału koloru czerwonego obiektu BitmapData do jego kanału koloru niebieskiego w obszarze pikseli wielkości 20 x 20: 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00FF0000);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd.copyChannel(bmd, rect, pt, BitmapDataChannel.RED, BitmapDataChannel.BLUE);

var bm:Bitmap = new Bitmap(bmd);
this.addChild(bm);    
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="copyPixels()" id="copyPixels()"></a><a name="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)" id="copyPixels(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,flash.display.BitmapData,flash.geom.Point,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixels(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, alphaBitmapData:<a href="BitmapData.html">BitmapData</a> = null, alphaPoint:<a href="../geom/Point.html">Point</a> = null, mergeAlpha:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zapewnia szybką procedurę do manipulowania pikselami między różnymi obrazami, bez rozciągania, obrotu ani efektów kolorystycznych. Ta metoda kopiuje prostokątny obszar obrazu źródłowego do obszaru prostokątnego o tym samym rozmiarze w punkcie docelowym obiektu BitmapData. 
     
     <p>W przypadku zawarcia parametrów <code>alphaBitmap</code> oraz <code>alphaPoint</code> możliwe jest wykorzystanie drugorzędnego obrazu jako źródła właściwości alpha dla obrazu źródłowego. Jeżeli obraz źródłowy posiada dane alpha, wówczas oba zestawy tych danych są wykorzystywane do składania pikseli z obrazu źródłowego do obrazu docelowego. Parametr <code>alphaPoint</code> jest punktem w obrazie alpha, który odpowiada górnemu lewemu narożnikowi prostokąta źródłowego. Wszelkie piksele znajdujące się poza przecięciem obrazu źródłowego i obrazu alpha nie są kopiowane do obrazu docelowego.</p>
     
     <p>Właściwość <code>mergeAlpha</code> kontroluje, czy kanał alpha jest lub nie jest wykorzystywany przy kopiowaniu jednego przezroczystego obrazu na drugi. W celu skopiowania pikseli z danymi kanału alpha należy ustawić właściwość <code>mergeAlpha</code> na wartość <code>true</code>. Domyślnie właściwość <code>mergeAlpha</code> ma wartość <code>false</code>.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy, z którego będą kopiowane piksele. Obrazem źródłowym może być inna instancja BitmapData lub może się on odwoływać do obecnej instancji BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do użycia jako dane do wprowadzenia.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt docelowy reprezentujący górny lewy narożnik obszaru prostokątnego, gdzie umieszczane są nowe dane kanałów.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> (default = <code>null</code>)<code></code> &mdash; Drugorzędny obiekt źródłowy parametru alpha obiektu BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Punkt w obiekcie źródłowym parametru alpha obiektu BitmapData odpowiadający górnemu lewemu narożnikowi parametru <code>sourceRect</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mergeAlpha</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; W celu wykorzystania kanału alpha należy ustawić wartość <code>true</code>. W celu skopiowania pikseli bez kanału alpha należy ustawić wartość <code>false</code>.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect oraz destPoint mają wartość null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób kopiowania pikseli z regionu wielkości 20 x 20 pikseli jednego obiektu BitmapData do drugiego.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(40, 40, false, 0x000000FF);
var bmd2:BitmapData = new BitmapData(80, 40, false, 0x0000CC44);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(10, 10);
bmd2.copyPixels(bmd1, rect, pt);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 50;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.4##AIR::3.4##"><a name="copyPixelsToByteArray()" id="copyPixelsToByteArray()"></a><a name="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)" id="copyPixelsToByteArray(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>copyPixelsToByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function copyPixelsToByteArray(rect:<a href="../geom/Rectangle.html">Rectangle</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 11.4, AIR 3.4</td></tr></table><p></p><p></p><p>
     Wypełnia tablicę bajtów na podstawie prostokątnego obszaru pikseli. Ta metoda zapisuje w tablicy bajtów liczbę całkowitą bez znaku (32-bitową niepomnożoną wartość pikseli) dla każdego piksela, rozpoczynając od indeksu <code>position</code> obiektu ByteArray. Jeśli jest to niezbędne, rozmiar tablicy bajtów zostaje zwiększony do liczby bajtów wymaganej w celu zapisania wszystkich danych pikseli.
           
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obszar prostokątny w obecnym obiekcie BitmapData.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Docelowy obiekt ByteArray.
     
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Gdy argument <code>rect</code> ma wartość <code>null</code> lub argument <code>data</code> ma wartość <code>null</code>.
     
	 </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="dispose()" id="dispose()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zwalnia pamięć używaną do przechowywania danego obiektu typu BitmapData. 
     
     <p>W przypadku wywołania metody <code>dispose()</code> na obrazie, jego szerokość i wysokość zostają ustawione na 0. Wszelkie kolejne wywołania do metod lub właściwości tej instancji BitmapData zakończą się niepowodzeniem oraz zgłoszone zostaną wyjątki. </p>
     <p>Metoda <code>BitmapData.dispose()</code> niezwłocznie zwalnia pamięć zajętą przez faktyczne dane bitmapowe (jedna bitmapa może zajmować maksymalnie 64 MB pamięci). Po użyciu metody <code>BitmapData.dispose()</code> obiekt BitmapData nie może być już używany, środowisko wykonawcze Flash wygeneruje wyjątek przy próbie wywołania funkcji tego obiektu. Jednak metoda <code>BitmapData.dispose()</code> nie porządkuje pamięci po obiekcie BitmapData (pozostawiając około 128 bajtów); pamięć zajęta przez obiekt BitmapData jest zwalniana w momencie usunięcia tego obiektu przez proces porządkowania pamięci.</p>
     
     </p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../system/System.html#gc()" target="">flash.system.System.gc()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje wynik wywołania metody obiektu BitmapData po wywołaniu metody <code>dispose()</code> (zgłaszany jest wyjątek):
<div class="listing"><pre>
import flash.display.BitmapData;

var myBitmapData:BitmapData = new BitmapData(100, 80, false, 0x000000FF);
trace(myBitmapData.getPixel(1, 1)); // 255 == 0xFF

myBitmapData.dispose();
try {
    trace(myBitmapData.getPixel(1, 1));
} catch (error:Error) {
    trace(error); // ArgumentError
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="draw()" id="draw()"></a><a name="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)" id="draw(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>draw</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function draw(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Rysuje obiekt wyświetlany <code>source</code> na obrazie bitmapowym za pomocą wektorowego mechanizmu renderującego środowiska wykonawczego Flash. Możliwe jest określenie parametrów <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> oraz docelowego parametru <code>clipRect</code> w celu kontrolowania wydajności renderowania. Opcjonalnie możliwe jest określenie, czy bitmapa powinna być wygładzana w trakcie skalowania (jest to możliwe tylko, gdy obiektem źródłowym jest obiekt BitmapData). 
     
     <p><b>Uwaga:</b> Metoda <code>drawWithQuality()</code> działa analogicznie do metody <code>draw()</code>, ale zamiast określać jakość renderowania grafiki wektorowej na podstawie właściwości <code>Stage.quality</code>, umożliwia podanie przy wywołaniu parametru <code>quality</code><code></code>.</p>
      
     <p>Ta metoda odpowiada bezpośrednio za sposób, w jaki obiekty są rysowane przy pomocy mechanizmu renderującego wektory standardowe dla obiektów w interfejsie narzędzi autoryzacyjnych.</p>
     
     <p>Źródłowy obiekt wyświetlany nie wykorzystuje żadnych zastosowanych transformacji dla tego wywołania. Jest on traktowany jakby istniał w bibliotece lub pliku, bez transformacji macierzy, transformacji kolorów czy trybu mieszania. W celu narysowania obiektu wyświetlanego (jak na przykład klip filmowy) przy wykorzystaniu jego własnych właściwości transformacji, możliwe jest skopiowanie jego obiektu właściwości <code>transform</code> do właściwości <code>transform</code> obiektu Bitmap korzystającego z obiektu BitmapData.</p>
     
     <p>Ta metoda jest obsługiwana przy użyciu protokołu RTMP w <span>programie Flash Player 9.0.115.0 i nowszych wersjach oraz w </span>środowisku Adobe AIR. Istnieje możliwość sterowania dostępem do strumieni na serwerze z oprogramowaniem Flash Media Server za pomocą skryptu po stronie serwera. Więcej informacji na ten temat zawierają opisy właściwości <code>Client.audioSampleAccess</code> oraz <code>Client.videoSampleAccess</code> w publikacji <a href="http://www.adobe.com/go/learn_flash_ss_as_pl" target="external"><i>Dokumentacja języka ActionScript po stronie serwera dla programu Flash Media Server</i></a>.</p>
     
     <p>Jeśli obiekt źródłowy oraz (w przypadku obiektu Sprite lub MovieClip) wszystkie jego obiekty podrzędne nie pochodzą z tej samej domeny, co treść wywołująca, lub nie należą do treści udostępnionej dla treści wywołującej za pomocą metody <code>Security.allowDomain()</code>, wywołanie metody <code>draw()</code> spowoduje wygenerowanie wyjątku SecurityError. To ograniczenie nie ma zastosowania do zawartości AIR w obszarze izolowanym aplikacji.</p>
     
     <p>Obowiązują także ograniczenia w wykorzystaniu załadowanego obrazu bitmapowego jako obiektu <code>source</code>. Wywołanie metody <code>draw()</code> kończy się powodzeniem, jeśli załadowany obraz pochodzi z tej samej domeny, co treść wywołująca. Ponadto międzydomenowy plik zasad na serwerze obrazu może nadać uprawnienia domenie treści SWF wywołującej metodę <code>draw()</code>. W tym przypadku należy ustawić właściwość <code>checkPolicyFile</code> obiektu LoaderContext i użyć tego obiektu jako parametru <code>context</code> w wywołaniu metody <code>load()</code> obiektu Loader wykorzystywanego do załadowania obrazu. Te ograniczenia nie ma zastosowania do treści AIR w obszarze izolowanym zabezpieczeń aplikacji.</p>
     
     <p>W systemie Windows metoda <code>draw()</code> nie umożliwia przechwytywania treści SWF osadzonej w stronie HTML <span>w obiekcie HTMLLoader w środowisku Adobe AIR</span>.</p>
     
     <p>Metoda <code>draw()</code> nie umożliwia przechwytywania treści PDF <span>w środowisku Adobe AIR</span>. Nie umożliwia także przechwytywania treści SWF osadzonej w kodzie HTML, gdy atrybut <code>wmode</code> jest ustawiony <code>"window"</code> (<span>w środowisku Adobe AIR</span>).</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Obiekt wyświetlany lub obiekt BitmapData konieczny przy rysowaniu obiektu BitmapData. (Klasy DisplayObject oraz BitmapData implementują interfejs IBitmapDrawable). 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt Matrix jest wykorzystywany w celu skalowania, obracania oraz translacji współrzędnych bitmapy. Jeżeli nie jest konieczne zastosowanie matrycy transformacji względem obrazu, wówczas należy ustawić ten parametr na wartość matrycy tożsamości, utworzonej przy pomocy domyślnego konstruktora <code>new Matrix()</code> lub podać wartość <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt ColorTransform wykorzystywany przy dopasowywaniu wartości kolorów bitmapy. Przy braku dostarczanego obiektu kolory obrazu bitmapowego nie są transformowane. Jeżeli konieczne jest podanie tego parametru, ale nie ma potrzeby transformacji obrazu należy ustawić ten parametr na obiekt ColorTransform utworzony przy pomocy domyślnego konstruktora <code>new ColorTransform()</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Wartość ciągu znaków z klasy flash.display.BlendMode, określający tryb mieszania do zastosowania w wynikowej bitmapie. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt Rectangle definiujący obszar obiektu źródłowego do narysowania. W przypadku gdy ta wartość nie została dostarczona, nie dochodzi do przycinania i rysowany jest cały obiekt źródłowy.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Wartość typu Boolean określająca, czy obiekt jest wygładzany w trakcie skalowania lub obracania ze względu na skalowanie lub obracanie określone w parametrze <code>matrix</code>. Parametr <code>smoothing</code> jest stosowany tylko w sytuacji, gdy parametr <code>source</code> jest obiektem BitmapData. W przypadku ustawienia parametru <code>smoothing</code> na wartość <code>false</code> obracany lub skalowany obraz BitmapData może pojawić się pikselizacja lub poszarpanie. Na przykład poniższe dwa obrazy wykorzystują ten sam obiekt BitmapData dla parametru <code>source</code>, jednakże parametr <code>smoothing</code> jest ustawiony na wartość <code>true</code>w przypadku obiektu po lewej stronie oraz na wartość <code>false</code> w przypadku obiektu po prawej stronie.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Dwa obrazy: po lewej stronie - z wygładzaniem, po prawej stronie - bez wygładzania"></img></p>
     
     <p>Rysowanie bitmapy z parametrem <code>smoothing</code> ustawionym na wartość <code>true</code> zajmuje więcej czasu, niż w przypadku parametru <code>smoothing</code> ustawionego na wartość <code>false</code>.</p>
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Parametr <code>source</code> nie jest obiektem BitmapData ani DisplayObject. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Obiekt <code>source</code> oraz (w przypadku obiektu Sprite lub MovieClip) wszystkie jego obiekty podrzędne nie pochodzą z tej samej domeny co obiekt wywołujący lub nie należą do treści dostępnej dla obiektu wywołującego poprzez wywołanie metody <code>Security.allowDomain()</code>. To ograniczenie nie ma zastosowania do treści AIR w obszarze izolowanym zabezpieczeń aplikacji.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Źródło ma wartość null lub nie jest prawidłowym obiektem IBitmapDrawable. 
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#drawWithQuality()" target="">flash.display.BitmapData.drawWithQuality()</a><br/><a href="Stage.html#quality" target="">flash.display.Stage.quality</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób, w jaki można narysować obiekt TextField w obiekcie BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.draw(tf);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="drawWithQuality()" id="drawWithQuality()"></a><a name="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)" id="drawWithQuality(flash.display.IBitmapDrawable,flash.geom.Matrix,flash.geom.ColorTransform,String,flash.geom.Rectangle,Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawWithQuality</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawWithQuality(source:<a href="IBitmapDrawable.html">IBitmapDrawable</a>, matrix:<a href="../geom/Matrix.html">Matrix</a> = null, colorTransform:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a> = null, blendMode:<a href="../../String.html">String</a> = null, clipRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, smoothing:<a href="../../Boolean.html">Boolean</a> = false, quality:<a href="../../String.html">String</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Rysuje obiekt wyświetlany <code>source</code> na obrazie bitmapowym za pomocą wektorowego mechanizmu renderującego środowiska wykonawczego Flash. Możliwe jest określenie parametrów <code>matrix</code>, <code>colorTransform</code>, <code>blendMode</code> oraz docelowego parametru <code>clipRect</code> w celu kontrolowania wydajności renderowania. Opcjonalnie możliwe jest określenie, czy bitmapa powinna być wygładzana w trakcie skalowania (jest to możliwe tylko, gdy obiektem źródłowym jest obiekt BitmapData). 
     
     <p><b>Uwaga:</b> Metoda <code>drawWithQuality()</code> działa analogicznie do metody <code>draw()</code>, ale zamiast określać jakość renderowania grafiki wektorowej na podstawie właściwości <code>Stage.quality</code>, umożliwia podanie przy wywołaniu parametru <code>quality</code><code></code>.</p>
      
     <p>Ta metoda odpowiada bezpośrednio za sposób, w jaki obiekty są rysowane przy pomocy mechanizmu renderującego wektory standardowe dla obiektów w interfejsie narzędzi autoryzacyjnych.</p>
     
     <p>Źródłowy obiekt wyświetlany nie wykorzystuje żadnych zastosowanych transformacji dla tego wywołania. Jest on traktowany jakby istniał w bibliotece lub pliku, bez transformacji macierzy, transformacji kolorów czy trybu mieszania. W celu narysowania obiektu wyświetlanego (jak na przykład klip filmowy) przy wykorzystaniu jego własnych właściwości transformacji, możliwe jest skopiowanie jego obiektu właściwości <code>transform</code> do właściwości <code>transform</code> obiektu Bitmap korzystającego z obiektu BitmapData.</p>
     
     <p>Ta metoda jest obsługiwana przy użyciu protokołu RTMP w <span>programie Flash Player 9.0.115.0 i nowszych wersjach oraz w </span>środowisku Adobe AIR. Istnieje możliwość sterowania dostępem do strumieni na serwerze z oprogramowaniem Flash Media Server za pomocą skryptu po stronie serwera. Więcej informacji na ten temat zawierają opisy właściwości <code>Client.audioSampleAccess</code> i <code>Client.videoSampleAccess</code> znajdujące się na stronie <a href="http://www.adobe.com/go/documentation_pl" target="external"><i>Dokumentacja języka ActionScript po stronie serwera dla programu Flash Media Server</i></a>.</p>
     
     <p>Jeśli obiekt źródłowy oraz (w przypadku obiektu Sprite lub MovieClip) wszystkie jego obiekty podrzędne nie pochodzą z tej samej domeny co element wywołujący albo nie należą do zawartości udostępnionej dla elementu wywołującego za pomocą metody <code>Security.allowDomain()</code>, wywołanie metody <code>drawWithQuality()</code> powoduje wygenerowanie wyjątku SecurityError. To ograniczenie nie ma zastosowania do zawartości AIR w obszarze izolowanym aplikacji.</p>
     
     <p>Obowiązują także ograniczenia w wykorzystaniu załadowanego obrazu bitmapowego jako obiektu <code>source</code>. Wywołanie metody <code>drawWithQuality()</code> kończy się powodzeniem, jeśli wczytany obraz pochodzi z tej samej domeny co element wywołujący. Ponadto plik zasad międzydomenowych na serwerze obrazu może nadać uprawnienia domenie zawartości SWF wywołującej metodę <code>drawWithQuality()</code>. W tym przypadku należy ustawić właściwość <code>checkPolicyFile</code> obiektu LoaderContext i użyć tego obiektu jako parametru <code>context</code> w wywołaniu metody <code>load()</code> obiektu Loader wykorzystywanego do załadowania obrazu. Te ograniczenia nie ma zastosowania do treści AIR w obszarze izolowanym zabezpieczeń aplikacji.</p>
     
     <p>W systemie Windows metoda <code>drawWithQuality()</code> nie umożliwia przechwytywania zawartości SWF osadzonej na stronie HTML <span>w obiekcie HTMLLoader w środowisku Adobe AIR</span>.</p>
     
     <p>Metoda <code>drawWithQuality()</code> nie umożliwia przechwytywania zawartości PDF <span>w środowisku Adobe AIR</span>. Nie umożliwia także przechwytywania treści SWF osadzonej w kodzie HTML, gdy atrybut <code>wmode</code> jest ustawiony <code>"window"</code> (<span>w środowisku Adobe AIR</span>).</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">source</span>:<a href="IBitmapDrawable.html">IBitmapDrawable</a></code> &mdash; Obiekt wyświetlany lub obiekt BitmapData konieczny przy rysowaniu obiektu BitmapData. (Klasy DisplayObject oraz BitmapData implementują interfejs IBitmapDrawable). 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix.html">Matrix</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt Matrix jest wykorzystywany w celu skalowania, obracania oraz translacji współrzędnych bitmapy. Jeżeli nie jest konieczne zastosowanie matrycy transformacji względem obrazu, wówczas należy ustawić ten parametr na wartość matrycy tożsamości, utworzonej przy pomocy domyślnego konstruktora <code>new Matrix()</code> lub podać wartość <code>null</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorTransform</span>:<a href="../geom/ColorTransform.html">flash.geom:ColorTransform</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt ColorTransform wykorzystywany przy dopasowywaniu wartości kolorów bitmapy. Przy braku dostarczanego obiektu kolory obrazu bitmapowego nie są transformowane. Jeżeli konieczne jest podanie tego parametru, ale nie ma potrzeby transformacji obrazu należy ustawić ten parametr na obiekt ColorTransform utworzony przy pomocy domyślnego konstruktora <code>new ColorTransform()</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blendMode</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Wartość ciągu znaków z klasy flash.display.BlendMode, określający tryb mieszania do zastosowania w wynikowej bitmapie. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">clipRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Obiekt Rectangle definiujący obszar obiektu źródłowego do narysowania. W przypadku gdy ta wartość nie została dostarczona, nie dochodzi do przycinania i rysowany jest cały obiekt źródłowy.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">smoothing</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Wartość typu Boolean określająca, czy obiekt jest wygładzany w trakcie skalowania lub obracania ze względu na skalowanie lub obracanie określone w parametrze <code>matrix</code>. Parametr <code>smoothing</code> jest stosowany tylko w sytuacji, gdy parametr <code>source</code> jest obiektem BitmapData. W przypadku ustawienia parametru <code>smoothing</code> na wartość <code>false</code> obracany lub skalowany obraz BitmapData może pojawić się pikselizacja lub poszarpanie. Na przykład poniższe dwa obrazy wykorzystują ten sam obiekt BitmapData dla parametru <code>source</code>, jednakże parametr <code>smoothing</code> jest ustawiony na wartość <code>true</code>w przypadku obiektu po lewej stronie oraz na wartość <code>false</code> w przypadku obiektu po prawej stronie.
     
     <p><img src="../../images/bitmapData_draw_smoothing.jpg" alt="Dwa obrazy: po lewej stronie - z wygładzaniem, po prawej stronie - bez wygładzania"></img></p>
     
     <p>Rysowanie bitmapy z parametrem <code>smoothing</code> ustawionym na wartość <code>true</code> zajmuje więcej czasu, niż w przypadku parametru <code>smoothing</code> ustawionego na wartość <code>false</code>.</p>
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">quality</span>:<a href="../../String.html">String</a></code> (default = <code>null</code>)<code></code> &mdash; Dowolna z wartości klasy StageQuality. Określa jakość wygładzania używanego podczas rysowania grafiki wektorowej. 
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Parametr <code>source</code> nie jest obiektem BitmapData ani DisplayObject. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../SecurityError.html">SecurityError</a> </code> &mdash; Obiekt <code>source</code> oraz (w przypadku obiektu Sprite lub MovieClip) wszystkie jego obiekty podrzędne nie pochodzą z tej samej domeny co obiekt wywołujący lub nie należą do treści dostępnej dla obiektu wywołującego poprzez wywołanie metody <code>Security.allowDomain()</code>. To ograniczenie nie ma zastosowania do treści AIR w obszarze izolowanym zabezpieczeń aplikacji.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Źródło ma wartość null lub nie jest prawidłowym obiektem IBitmapDrawable. 
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#draw()" target="">flash.display.BitmapData.draw()</a><br/><a href="StageQuality.html" target="">flash.display.StageQuality</a><br/><a href="BlendMode.html" target="">flash.display.BlendMode</a><br/><a href="../geom/ColorTransform.html" target="">flash.geom.ColorTransform</a><br/><a href="../geom/Matrix.html" target="">flash.geom.Matrix</a><br/><a href="../system/JPEGLoaderContext.html" target="">flash.system.JPEGLoaderContext</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób, w jaki można narysować obiekt TextField w obiekcie BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.text.TextField;

var tf:TextField = new TextField();
tf.text = "bitmap text";

var myBitmapData:BitmapData = new BitmapData(80, 20);
myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW);
var bmp:Bitmap = new Bitmap(myBitmapData);
this.addChild(bmp);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.3##AIR::3.3##"><a name="encode()" id="encode()"></a><a name="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)" id="encode(flash.geom.Rectangle,Object,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>encode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function encode(rect:<a href="../geom/Rectangle.html">Rectangle</a>, compressor:<a href="../../Object.html">Object</a>, byteArray:<a href="../utils/ByteArray.html">ByteArray</a> = null):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 11.3, AIR 3.3</td></tr></table><p></p><p></p><p>
     Kompresuje ten obiekt BitmapData przy użyciu wybranego algorytmu kompresji i zwraca nowy obiekt ByteArray. Opcjonalnie zapisuje dane wynikowe w podanym obiekcie ByteArray. Argument <code>compressor</code> określa algorytm kodowania. Może mieć wartość PNGEncoderOptions, JPEGEncoderOptions lub JPEGXREncoderOptions.
     
     <p>Poniższy przykładowy kod kompresuje obiekt BitmapData przy użyciu parametru JPEGEncoderOptions:</p>
     
     <pre>
     // Compress a BitmapData object as a JPEG file.
     var bitmapData:BitmapData = new BitmapData(640,480,false,0x00FF00);
     var byteArray:ByteArray = new ByteArray();
     bitmapData.encode(new Rectangle(0,0,640,480), new flash.display.JPEGEncoderOptions(), byteArray); </pre>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obszar obiektu BitmapData do skompresowania.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compressor</span>:<a href="../../Object.html">Object</a></code> &mdash; Kompresor, który ma zostać użyty. Prawidłowe wartości: <code>flash.display.PNGEncoderOptions</code>, <code>flash.display.JPEGEncoderOptions</code> i <code>flash.display.JPEGXREncoderOptions</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> (default = <code>null</code>)<code></code> &mdash; Wyjściowy obiekt ByteArray do przechowywania zakodowanego obrazu.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Obiekt ByteArray zawierający zakodowany obraz.
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="JPEGEncoderOptions.html" target="">flash.display.JPEGEncoderOptions</a><br/><a href="JPEGXREncoderOptions.html" target="">flash.display.JPEGXREncoderOptions</a><br/><a href="PNGEncoderOptions.html" target="">flash.display.PNGEncoderOptions</a></div></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="fillRect()" id="fillRect()"></a><a name="fillRect(flash.geom.Rectangle,uint)" id="fillRect(flash.geom.Rectangle,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>fillRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function fillRect(rect:<a href="../geom/Rectangle.html">Rectangle</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Wypełnia obszar prostokątny pikselami o określonym kolorze ARGB.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokątny obszar do wypełnienia.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość koloru ARGB, który wypełnia obszar. Kolory ARGB są często określane w formacie szesnastkowym; na przykład 0xFF336699.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość rect ma wartość null.
      
      </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../geom/Rectangle.html" target="">flash.geom.Rectangle</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób, w jaki można wypełnić obszar obiektu BitmapData kolorem niebieskim:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x0000FF);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="floodFill()" id="floodFill()"></a><a name="floodFill(int,int,uint)" id="floodFill(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>floodFill</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function floodFill(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Przeprowadza operację wypełniania jednolitego, zaczynając od punktu na współrzędnych (<i>x</i>, <i>y</i>) i wypełniając wybranym kolorem. Metoda <code>floodFill()</code> jest podobna do narzędzia wiadra z farbą, wykorzystywanego w różnych programach graficznych. Kolorem jest kolor ARGB zawierający informacje dotyczące wartości parametru alpha.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Współrzędna <i>x</i> obrazu.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Współrzędna <i>y</i> obrazu.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Kolor ARGB wykorzystany do wypełniania.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Następujący przykład ilustruje sposób wypełniania obszaru obiektu BitmapData &mdash; obszaru wokół piksela zdefiniowanego przez punkt <code>(10, 10)</code> &mdash; w taki sposób, że wszystkie kolory zgodne z kolorem w tym punkcie przyjmują kolor czerwony.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var myBitmapData:BitmapData = new BitmapData(40, 40, false, 0x0000FF00);

var rect:Rectangle = new Rectangle(0, 0, 20, 20);
myBitmapData.fillRect(rect, 0x000000FF);
rect = new Rectangle(15, 15, 25, 25);
myBitmapData.fillRect(rect, 0x000000FF);

myBitmapData.floodFill(10, 10, 0x00FF0000);

var bm:Bitmap = new Bitmap(myBitmapData);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="generateFilterRect()" id="generateFilterRect()"></a><a name="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)" id="generateFilterRect(flash.geom.Rectangle,flash.filters.BitmapFilter)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>generateFilterRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function generateFilterRect(sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, filter:<a href="../filters/BitmapFilter.html">BitmapFilter</a>):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Określa prostokąt docelowy, na który ma wpływ wywołanie metody <code>applyFilter()</code>, jeżeli jest podany obiekt BitmapData, prostokąt źródłowy oraz obiekt filtra. 
     
     <p>Na przykład filtr rozmycia ma wpływ na obszar większy niż rozmiar oryginalnego obrazu. Obraz wielkości 100 x 200 pikseli filtrowany przez domyślną instancję BlurFilter, gdzie <code>blurX = blurY = 4</code> generuje prostokąt docelowy o współrzędnych <code>(-2, -2, 104, 204)</code>. Metoda <code>generateFilterRect()</code> pozwala na wczesne poznanie rozmiaru prostokąta docelowego, aby możliwe było określenie rozmiaru obrazu docelowego przed przeprowadzaniem operacji filtrowania. </p>
     
     <p>Niektóre filtry przycinają prostokąt docelowy w oparciu o rozmiar obrazu źródłowego. Na przykład wewnętrzna właściwość <code>DropShadow</code> nie generuje wyniku większego niż jego obraz źródłowy. W przypadku tego API obiekt BitmapData jest wykorzystywany jako granice źródłowe a nie jako parametr źródłowy <code>rect</code>.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../filters/BitmapFilter.html">BitmapFilter</a></code> &mdash; Obiekt filtra wykorzystywany do obliczenia prostokąta docelowego.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt docelowy obliczony przy użyciu obrazu, parametru <code>sourceRect</code> oraz filtra.
     
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość sourceRect lub filtr ma wartość null.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób wykorzystania metody <code>generateFilterRect()</code> w celu określenia obszaru prostokątnego, który zostanie zajęty przez obiekt po zastosowaniu filtra rozmycia. Rezultaty metody <code>generateFilterRect()</code> są generowane przez funkcję <code>trace()</code>:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.filters.BlurFilter;

var bmd:BitmapData = new BitmapData(80, 30, false, 0xFFCC00);
var rect:Rectangle = new Rectangle(10, 10, 40, 10);
bmd.fillRect(rect, 0xFF0000);

var pt:Point = new Point(10, 10);
var filter:BlurFilter = new BlurFilter();

trace(bmd.generateFilterRect(rect, filter));
// (x=8, y=8, w=44, h=14)

bmd.applyFilter(bmd, rect, pt, filter);
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div> Należy zauważyć, iż metoda <code>generateFilterRect()</code> nie stosuje filtra. W celu aplikacji filtra należy wywołać metodę <code>applyFilter()</code>. 
</div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getColorBoundsRect()" id="getColorBoundsRect()"></a><a name="getColorBoundsRect(uint,uint,Boolean)" id="getColorBoundsRect(uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getColorBoundsRect</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getColorBoundsRect(mask:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a>, findColor:<a href="../../Boolean.html">Boolean</a> = true):<a href="../geom/Rectangle.html">Rectangle</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Określa obszar prostokątny, który albo w pełni pokrywa wszelkie piksele określonego koloru wewnątrz obrazu bitmapowego (jeżeli parametr <code>findColor</code> jest ustawiony na wartość <code>true</code>), lub w pełni pokrywa wszelkie piksele, które nie zawierają określonego koloru (jeżeli parametr <code>findColor</code> jest ustawiony na wartość <code>false</code>). 
     
     <p>Przykładowo, jeżeli konieczne jest określenie prostokąta posiadanego obrazu źródłowego, który zawiera kanał alpha inny niż zero, należy przekazać <code>(mask: 0xFF000000, kolor: 0x00000000</code> jako parametry. Jeżeli parametr <code>findColor</code> jest ustawiony na wartość<code>true</code>, wówczas w całym obrazie poszukiwane są piksele, których parametr <code>(value & mask) == color</code> (gdzie właściwość <code>value</code> jest wartością koloru pikseli). Jeżeli parametr <code>findColor</code> jest ustawiony na wartość <code>false</code>, wówczas w całym obrazie poszukiwane są granice pikseli, których właściwość <code>(value & mask) != color</code> (gdzie właściwość <code>value</code> jest wartością koloru pikseli). W celu określenia białej przestrzeni wokół obrazu należy podać parametry <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code> w celu odnalezienia granic pikseli innych niż białe.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość szesnastkowa określająca bity koloru ARGB do wzięcia pod uwagę. Wartość koloru jest połączona z tą wartością szesnastkową przy użyciu operatora <code>&</code> (bitowe "I").
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość szesnastkowa, określająca kolor ARGB w celu dopasowania (jeżeli właściwość <code>findColor</code> jest ustawiona na wartość <code>true</code>) lub <i>niedopasowania</i> (jeżeli właściwość <code>findColor</code> jest ustawiona na wartość <code>false</code>).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">findColor</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; Jeżeli wartość wynosi <code>true</code>, wówczas zwracane są granice wartości koloru w obrazie. Jeżeli wartość wynosi <code>false</code>, wówczas zwracane są granice gdzie nie ma koloru na obrazie.  
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obszar obrazu o określonym kolorze. 
     
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData z kolorem czerwonym w górnej połowie swoich pikseli. Następnie ukazane jest wywołanie metody <code>getColorBoundsRect()</code> w celu określenia prostokąta, w którym piksele mają kolor czerwony (0xFF0000), a potem wywołanie tej samej metody w celu określenia prostokąta, w którym piksele nie mają koloru czerwonego (poprzez ustawienie parametru <code>findColor</code> na wartość <code>false</code>:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFFFFFF);
var rect:Rectangle = new Rectangle(0, 0, 80, 20);
bmd.fillRect(rect, 0xFF0000);

var maskColor:uint = 0xFFFFFF; 
var color:uint = 0xFF0000;  
var redBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, true);
trace(redBounds); // (x=0, y=0, w=80, h=20)

var notRedBounds:Rectangle = bmd.getColorBoundsRect(maskColor, color, false);
trace(notRedBounds); // (x=0, y=20, w=80, h=20)

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel()" id="getPixel()"></a><a name="getPixel(int,int)" id="getPixel(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zwraca liczbę całkowitą, która reprezentuje wartość RGB piksela z obiektu BitmapData w określonym punkcie (<i>x</i>, <i>y</i>). Metoda <code>getPixel()</code> zwraca nieprzemnożoną wartość piksela. Nie jest zwracana informacja dotycząca wartości parametru alpha.
     
     <p>Wszystkie piksele obiektu BitmapData są przechowywane jako wstępnie przemnożone wartości kolorów. Wartość wstępnie przemnożona koloru jest wartością kanałów koloru czerwonego, zielonego i niebieskiego przemnożoną przez wartość alpha. Na przykład jeżeli wartość alhpa wynosi 0, wówczas wartości kanałów RGB również wynoszą 0, niezależnie od ich wartości nieprzemnożonych. Tego rodzaju utrata danych może spowodować problemy w trakcie wykonywania operacji. Wszystkie metody BitmapData pobierają i zwracają wartości nieprzemnożone. Reprezentacja pikseli wewnętrznych jest konwertowana z wartości wstępnie przemnożonych do wartości nieprzemnożonych przed zwróceniem jako wartość. W trakcie operacji ustawiania wartość piksela jest wstępnie przemnażana przed ustawieniem surowego piksela obrazu.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>x</i> piksela.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>y</i> piksela.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Liczba reprezentująca wartość RGB piksela. Jeżeli współrzędne (<i>x</i>, <i>y</i>) znajdują się poza granicami obrazu, metoda zwraca wartość 0. 
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData wypełnionego kolorem czerwonym, a następnie wykorzystanie metody <code>getPixel()</code> w celu określenia wartości koloru w górnym-lewym pikselu:
<div class="listing"><pre>
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, false, 0xFF0000);

var pixelValue:uint = bmd.getPixel(0, 0);
trace(pixelValue.toString(16)); // ff0000;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixel32()" id="getPixel32()"></a><a name="getPixel32(int,int)" id="getPixel32(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Zwraca wartość koloru ARGB, która zawiera dane kanału alfa i dane RGB. Ta metoda jest podobna do metody <code>getPixel()</code>, która zwraca kolor RGB bez wartości kanału alpha.
     
     <p>Wszystkie piksele obiektu BitmapData są przechowywane jako wstępnie przemnożone wartości kolorów. Wartość wstępnie przemnożona koloru jest wartością kanałów koloru czerwonego, zielonego i niebieskiego przemnożoną przez wartość alpha. Na przykład jeżeli wartość alhpa wynosi 0, wówczas wartości kanałów RGB również wynoszą 0, niezależnie od ich wartości nieprzemnożonych. Tego rodzaju utrata danych może spowodować problemy w trakcie wykonywania operacji. Wszystkie metody BitmapData pobierają i zwracają wartości nieprzemnożone. Reprezentacja pikseli wewnętrznych jest konwertowana z wartości wstępnie przemnożonych do wartości nieprzemnożonych przed zwróceniem jako wartość. W trakcie operacji ustawiania wartość piksela jest wstępnie przemnażana przed ustawieniem surowego piksela obrazu.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>x</i> piksela.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>y</i> piksela.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Liczba reprezentująca wartość RGB piksela. Jeżeli współrzędne (<i>x</i>, <i>y</i>) znajdują się poza granicami obrazu, metoda zwraca wartość 0.
     
     </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData wypełnionego kolorem, a następnie wykorzystanie metody <code>getPixel32()</code> w celu określenia wartości koloru w górnym-lewym pikselu, a potem określenia wartości szesnastkowych dla każdego składnika koloru (alpha, czerwony, zielony i niebieski):
<div class="listing"><pre>

import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 40, true, 0xFF44AACC);

var pixelValue:uint = bmd.getPixel32(0, 0);
var alphaValue:uint = pixelValue &gt;&gt; 24 & 0xFF;
var red:uint = pixelValue &gt;&gt; 16 & 0xFF;
var green:uint = pixelValue &gt;&gt; 8 & 0xFF;
var blue:uint = pixelValue & 0xFF;

trace(alphaValue.toString(16)); // ff
trace(red.toString(16)); // 44
trace(green.toString(16)); // aa
trace(blue.toString(16)); // cc
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="getPixels()" id="getPixels()"></a><a name="getPixels(flash.geom.Rectangle)" id="getPixels(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../utils/ByteArray.html">ByteArray</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Generuje tablicę bajtów na podstawie prostokątnego obszaru pikseli. Zapisuje liczbę całkowitą bez znaku (32-bitową wartość nieprzemnożoną pikseli) dla każdego piksela w tablicy bajtów.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obszar prostokątny w obecnym obiekcie BitmapData.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Obiekt ByteArray reprezentujący piksele w danym obiekcie Rectangle.
     
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość rect ma wartość null.
      
      </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html" target="">flash.utils.ByteArray</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData wypełnionego losową liczbą pikseli szumu, a następnie zastosowanie metody <code>getPixels()</code> w celu wypełnienia obiektu ByteArray wartościami pikseli obiektu BitmapData.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.utils.ByteArray;

var bmd:BitmapData = new BitmapData(80, 40, true);
var seed:int = int(Math.random() * int.MAX_VALUE);
bmd.noise(seed);

var bounds:Rectangle = new Rectangle(0, 0, bmd.width, bmd.height);
var pixels:ByteArray = bmd.getPixels(bounds);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="getVector()" id="getVector()"></a><a name="getVector(flash.geom.Rectangle)" id="getVector(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>getVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function getVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Generuje tablicę wektorów na podstawie prostokątnego obszaru pikseli. Zwraca obiekt Vector zawierający liczby całkowite bez znaku (32-bitowe nieprzemnożone wartości pikseli) dla określonego prostokąta.
     
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Obszar prostokątny w obecnym obiekcie BitmapData.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Obiekt Vector reprezentujący dany obiekt Rectangle.
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość rect ma wartość null.
      
      </td></tr></table></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="histogram()" id="histogram()"></a><a name="histogram(flash.geom.Rectangle)" id="histogram(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>histogram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function histogram(hRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Oblicza histogram 256 wartości binarnych obiektu BitmapData. Metoda zwraca obiekt Vector zawierający cztery obiekty Vector.Instancje &lt;Number> (cztery obiekty Vector, które zawierają obiekty Number). Cztery instancje Vector reprezentują w kolejności składnik czerwony, zielony, niebieski i kanał alfa. Każda instancja Vector zawiera 256 wartości, które reprezentują liczbę wystąpień dla pojedynczej wartości składnika (z zakresu od 0 do 255).
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">hRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Obszar obiektu BitmapData do wykorzystania.
      
      </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Vector.html">Vector</a>.&lt;<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;&gt;</code></td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="hitTest()" id="hitTest()"></a><a name="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)" id="hitTest(flash.geom.Point,uint,Object,flash.geom.Point,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>hitTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function hitTest(firstPoint:<a href="../geom/Point.html">Point</a>, firstAlphaThreshold:<a href="../../uint.html">uint</a>, secondObject:<a href="../../Object.html">Object</a>, secondBitmapDataPoint:<a href="../geom/Point.html">Point</a> = null, secondAlphaThreshold:<a href="../../uint.html">uint</a> = 1):<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Uaktywnia wykrywanie pikseli między obrazem bitmapowym a punktem, prostokątem lub innym obrazem bitmapowym. Do wykrycia dochodzi, gdy punkt lub prostokąt pokrywa piksel nieprzezroczysty lub dwa nachodzące na siebie nieprzezroczyste piksele. Rozciąganie, obracanie oraz żadne inne transformacje żadnego z obiektów nie są brane pod uwagę przy przeprowadzaniu testu trafień. 
     
     <p>Jeżeli obraz jest nieprzezroczysty, wówczas jest uznawany w tej metodzie za prostokąt w pełni nieprzezroczysty. Oba obrazy muszą być przezroczyste przy przeprowadzaniu testowania trafień na poziomie pikseli przy rozważaniu przezroczystości. Przy testowaniu dwóch obrazów przezroczystych, progowe parametry alpha kontrolują które wartości kanału alpha (z zakresu od 0 do 255) są uważane za nieprzezroczyste.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">firstPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash;  Położenie górnego lewego narożnika obrazu BitmapData w dowolnym układzie współrzędnych. Ten sam układ współrzędnych jest wykorzystywany przy definiowaniu parametru <code>secondBitmapPoint</code>.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Najmniejsza wartość kanału alpha jest traktowana jako wartość nieprzezroczystości dla tego testu trafień.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondObject</span>:<a href="../../Object.html">Object</a></code> &mdash; Obiekt Rectangle, Point, Bitmap lub BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondBitmapDataPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code> &mdash; Punkt definiujący położenie pikseli w drugim obiekcie BitmapData. Należy wykorzystać ten parametr, tylko w przypadku gdy wartością właściwości <code>secondObject</code> jest obiekt BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">secondAlphaThreshold</span>:<a href="../../uint.html">uint</a></code> (default = <code>1</code>)<code></code> &mdash; Najmniejsza wartość kanału alpha jest traktowana jako wartość nieprzezroczystości w drugim obiekcie BitmapData. Należy wykorzystać ten parametr, tylko w przypadku gdy wartością właściwości <code>secondObject</code> jest obiekt BitmapData oraz oba obiekty BitmapData są przezroczyste.
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Boolean.html">Boolean</a></code> &mdash; Wartość <code>true</code> przy wystąpieniu trafienia; wartość <code>false</code> w innym przypadku.
        
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Parametr <code>secondObject</code> nie jest obiektem Point, Rectangle, Bitmap lub BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość firstPoint ma wartość null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData, który jest nieprzezroczysty tylko w prostokątnym obszarze o współrzędnych (20, 20, 40, 40) oraz wywołanie metody <code>hitTest()</code> z obiektem Point jako obiekt <code>secondObject</code>. Przy pierwszym wywołaniu obiekt Point definiuje górny lewy narożnik obiektu BitmapData, który nie jest nieprzezroczysty, zaś w drugim wywołaniu obiekt Point definiuje centrum obiektu BitmapData, które jest nieprzezroczysty.
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(80, 80, true, 0x00000000);
var rect:Rectangle = new Rectangle(20, 20, 40, 40);
bmd1.fillRect(rect, 0xFF0000FF);

var pt1:Point = new Point(1, 1);
trace(bmd1.hitTest(pt1, 0xFF, pt1)); // false
var pt2:Point = new Point(40, 40);
trace(bmd1.hitTest(pt1, 0xFF, pt2)); // true
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="lock()" id="lock()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>lock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function lock():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Blokuje obraz, co powoduje, że wszelkie obiekty odwołujące się do obiektu BitmapData, np. obiekty Bitmap, nie są aktualizowane w odpowiedzi na zmiany obiektu BitmapData. W celu podwyższenia wydajności należy stosować tą metodę wraz z metodą <code>unlock()</code> przed i po wielokrotnych wywołaniach do metody <code>setPixel()</code> i <code>setPixel32()</code>.
     
     </p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody">  Poniższy przykład ilustruje tworzenie obiektu BitmapData w oparciu o właściwość <code>bitmapData</code> obiektu Bitmap <code>picture</code>. Następnie wywoływana jest metoda <code>lock()</code> przed wywołaniem skomplikowanej funkcji własnej <code>complexTransformation()</code>, która modyfikuje obiekt BItmapData. (Obiekt <code>picture</code> oraz funkcja <code>complexTransformation()</code> nie są zdefiniowane w tym przykładzie.) Nawet w przypadku gdy funkcja <code>complexTransformation()</code> aktualizuje właściwość <code>bitmapData</code> obiektu <code>picture</code>, zmiany nie są odzwierciedlone do momentu wywołania metody <code>unlock()</code> obiektu <code>bitmapData</code>.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="merge()" id="merge()"></a><a name="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)" id="merge(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,uint,uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>merge</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function merge(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redMultiplier:<a href="../../uint.html">uint</a>, greenMultiplier:<a href="../../uint.html">uint</a>, blueMultiplier:<a href="../../uint.html">uint</a>, alphaMultiplier:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Wykonuje mieszanie poszczególnych kanałów z obrazu źródłowego do obrazu docelowego. Dla każdego kanału i każdego piksela nowa wartość jest obliczana na podstawie wartości kanałów pikseli źródłowych i docelowych. Przykładowo w kanale koloru czerwonego, nowa wartość jest obliczana w następujący sposób (gdzie właściwość <code>redSrc</code> jest wartością kanału koloru czerwonego w obrazie źródłowym, zaś właściwość <code>redDest</code> jest wartością kanału czerwonego na odpowiadającym pikselu obrazu docelowego): 
     <p>
     <code> nowy redDest = [(redSrc * redMultiplier) + (redDest * (256 - redMultiplier))] / 256; </code>
     </p>
     
     <p>Wartości właściwości <code>redMultiplier</code>, <code>greenMultiplier</code>, <code>blueMultiplier</code> oraz <code>alphaMultiplier</code> są przelicznikami wykorzystywanymi względem każdego kanału kolorów. Należy zastosować wartość szesnastkową w graniach od <code>0</code> do <code>0x100</code> (256), gdzie <code>0</code> określa pełną wartość ze źródła wykorzystaną końcowo, <code>0x100</code> określa wykorzystanie pełnej wartości ze źródła, zaś liczby pomiędzy określają wykorzystanie mieszania (jak na przykład <code>0x80</code> dla wartości 50%).</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do wykorzystania. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnego obiektu BitmapData. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt wewnątrz obrazu docelowego (obecna instancja BitmapData) odpowiadający górnemu lewemu narożnikowi prostokąta. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość w jednostkach szesnastkowych, przez którą przemnażana jest wartość kanału koloru czerwonego. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość w jednostkach szesnastkowych, przez którą przemnażana jest wartość kanału koloru zielonego. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość w jednostkach szesnastkowych, przez którą przemnażana jest wartość kanału koloru niebieskiego.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaMultiplier</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość w jednostkach szesnastkowych, przez którą przemnażana jest wartość przezroczystości alpha.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect lub destPoint mają wartość null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie dwóch obiektów BitmapData. Oba obiekty mają wymiary 100 x 80 pikseli. Pierwszy z nich jest wypełniony kolorem zielonym a drugi kolorem czerwonym. Kod wywołuje metodę <code>merge()</code>, powodując scalenie pikseli drugiego obiektu BitmapData z pikselami pierwszego obiektu BitmapData, ale tylko w określonym obszarze prostokątnym. 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var bmd1:BitmapData = new BitmapData(100, 80, true, 0xFF00FF00);
var bmd2:BitmapData = new BitmapData(100, 80, true, 0xFFFF0000);
var rect:Rectangle = new Rectangle(0, 0, 20, 20);
var pt:Point = new Point(20, 20);
var mult:uint = 0x80; // 50% 
bmd1.merge(bmd2, rect, pt, mult, mult, mult, mult);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="noise()" id="noise()"></a><a name="noise(int,uint,uint,uint,Boolean)" id="noise(int,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>noise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function noise(randomSeed:<a href="../../int.html">int</a>, low:<a href="../../uint.html">uint</a> = 0, high:<a href="../../uint.html">uint</a> = 255, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Wypełnia obraz pikselami stanowiącymi losowy szum.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Wartość początkowa generatora liczb pseudolosowych do wykorzystania. Przy zachowaniu tych samych wartości wszystkich innych parametrów możliwe jest generowanie różnych wyników pseudolosowych poprzez zmienianie wartości początkowej generatora liczb pseudolosowych. Funkcja szumu jest funkcją odwzorowującą, a nie prawdziwą funkcją losową, zatem dla tej samej wartości początkowej generatora liczb pseudolosowych zwraca zawsze te same wyniki.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">low</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Najniższa wartość możliwa do wygenerowania dla każdego kanału (od 0 do 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">high</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; Najwyższa wartość możliwa do wygenerowania dla każdego kanału (od 0 do 255). 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash; Liczba, która może być kombinacją każdej z czterech wartości kanałów kolorów (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>). Możliwe jest wykorzystanie operatora logicznego LUB (<code>|</code>) w celu połączenia wartości kanałów. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Wartość Boolean. Jeżeli wartość <code>true</code>, wówczas tworzony jest obraz w skali szarości poprzez ustawienie wszystkich kanałów kolorów na tę samą wartość. Ustawienie tego parametru na wartość <code>true</code> nie ma wpływu na wybór kanału alpha. 
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapDataChannel.html#RED" target="">flash.display.BitmapDataChannel.RED</a><br/><a href="BitmapDataChannel.html#BLUE" target="">flash.display.BitmapDataChannel.BLUE</a><br/><a href="BitmapDataChannel.html#GREEN" target="">flash.display.BitmapDataChannel.GREEN</a><br/><a href="BitmapDataChannel.html#ALPHA" target="">flash.display.BitmapDataChannel.ALPHA</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie dwóch obiektów BitmapData oraz wywołanie metody <code>noise()</code> względem obu. Przy tej operacji parametr <code>grayscale</code> jest ustawiony na wartość <code>false</code> przy wywołaniu metody <code>noise()</code> względem pierwszego obiektu, oraz ustawiony na wartość <code>true</code> przy wywołaniu metody <code>noise()</code> względem drugiego.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;

var bmd1:BitmapData = new BitmapData(80, 80);
var bmd2:BitmapData = new BitmapData(80, 80);

var seed:int = int(Math.random() * int.MAX_VALUE);
bmd1.noise(seed, 0, 0xFF, BitmapDataChannel.RED, false);
bmd2.noise(seed, 0, 0xFF, BitmapDataChannel.RED, true);

var bm1:Bitmap = new Bitmap(bmd1);
this.addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
this.addChild(bm2);
bm2.x = 90;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="paletteMap()" id="paletteMap()"></a><a name="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)" id="paletteMap(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,Array,Array,Array,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>paletteMap</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function paletteMap(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, redArray:<a href="../../Array.html">Array</a> = null, greenArray:<a href="../../Array.html">Array</a> = null, blueArray:<a href="../../Array.html">Array</a> = null, alphaArray:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ponownie odwzorowuje wartości kanałów kolorów w obrazie zawierającym maksymalnie cztery tablice dotyczące kolorów &mdash; po jednej na każdy kanał. 
     
     <p>Środowisko wykonawcze Flash realizuje poniższe kroki w celu generowania obrazu wynikowego:</p>
     
     <ol><li>Po obliczeniu wartości koloru czerwonego, niebieskiego oraz wartości alpha są dodawane razem przy zastosowaniu standardowej arytmetyki 32-bitowych liczb całkowitych. </li><li>Wartości kanałów kolorów czerwonego, zielonego, niebieskiego oraz wartość alpha są wyodrębniane do oddzielnych wartości z zakresu 0 do 255. Te wartości są wykorzystywane przy wyszukiwaniu nowych wartości kolorów w odpowiedniej tablicy: <code>redArray</code>, <code>greenArray</code>, <code>blueArray</code> oraz <code>alphaArray</code>. Każda z tych tablic powinna zawierać 256 wartości. </li><li>Po pobraniu wszystkich czterech nowych wartości kanałów, są one łączone w standardową wartość ARGB, która będzie zastosowana względem pikseli.</li></ol>
     
     <p>Efekty międzykanałowe są obsługiwane przez tą metodę. Każda tablica wejścia może zawierać pełne 32-bitowe wartości i nie dochodzi do przesuwania gdy wartości są dodawane do siebie. Ta procedura nie obsługuje ściśnięcia poszczególnych kanałów. </p>
     
     <p>Jeżeli nie została wybrana tablica dla kanału, wówczas kanał koloru jest kopiowany z obrazu źródłowego do obrazu docelowego. </p>
     
     <p>Możliwe jest wykorzystanie tej metody do realizacji szerokiej gamy efektów, jak na przykład ogólnego odwzorowywania palety (pobieranie jednego kanału i jego konwersja do obrazu z zafałszowanymi kolorami). Możliwe jest również wykorzystanie tej metody w celu zastosowania różnych zaawansowanych algorytmów manipulacji kolorami, jak na przykład korekcja gamma, krzywe, poziomy oraz kwantyfikacja.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do wykorzystania. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnej instancji BitmapData. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt wewnątrz obrazu docelowego (obecny obiekt BitmapData) odpowiadający górnemu lewemu narożnikowi prostokąta źródłowego. 
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">redArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Jeżeli właściwość <code>redArray</code> nie ma wartości <code>null</code>, wówczas <code>red = redArray[source red value] else red = source rect value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">greenArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Jeżeli właściwość <code>greenArray</code> nie ma wartości <code>null</code>, wówczas <code>green = greenArray[source green value] else green = source green value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blueArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Jeżeli właściwość <code>blueArray</code> nie ma wartości <code>null</code>, wówczas <code>blue = blueArray[source blue value] else blue = source blue value</code>.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alphaArray</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Jeżeli właściwość <code>alphaArray</code> nie ma wartości <code>null</code>, wówczas <code>alpha = alphaArray[source alpha value] else alpha = source alpha value</code>.
     
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect lub destPoint mają wartość null.
      
      </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie zielonego obiektu BitmapData z czerwonym położonym centralnie kwadratem, a następnie wykorzystanie metody <code>paletteMap()</code> w celu zamiany kolorów czerwonego i zielonego na dolnej prostokątnej połowie obiektu BitmapData:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;
import flash.geom.Point;

var myBitmapData:BitmapData = new BitmapData(80, 80, false, 0x00FF0000);
myBitmapData.fillRect(new Rectangle(20, 20, 40, 40), 0x0000FF00);

var redArray:Array = new Array(256);
var greenArray:Array = new Array(256);

for(var i:uint = 0; i &lt; 255; i++) {
    redArray[i] = 0x00000000;
    greenArray[i] = 0x00000000;
}

redArray[0xFF] = 0x0000FF00;
greenArray[0xFF] = 0x00FF0000;

var bottomHalf:Rectangle = new Rectangle(0, 0, 100, 40);
var pt:Point = new Point(0, 0);
myBitmapData.paletteMap(myBitmapData, bottomHalf, pt, redArray, greenArray);

var bm1:Bitmap = new Bitmap(myBitmapData);
addChild(bm1);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="perlinNoise()" id="perlinNoise()"></a><a name="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)" id="perlinNoise(Number,Number,uint,int,Boolean,Boolean,uint,Boolean,Array)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>perlinNoise</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function perlinNoise(baseX:<a href="../../Number.html">Number</a>, baseY:<a href="../../Number.html">Number</a>, numOctaves:<a href="../../uint.html">uint</a>, randomSeed:<a href="../../int.html">int</a>, stitch:<a href="../../Boolean.html">Boolean</a>, fractalNoise:<a href="../../Boolean.html">Boolean</a>, channelOptions:<a href="../../uint.html">uint</a> = 7, grayScale:<a href="../../Boolean.html">Boolean</a> = false, offsets:<a href="../../Array.html">Array</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Generuje obraz szumu Perlina.
     
     <p>Algorytm generacji szumu Perlina interpoluje oraz łączy indywidualne funkcje szumu losowego (zwane oktawami) w pojedynczą funkcję tworzącą bardziej naturalny szum losowy. Tak jak w przypadku oktaw muzycznych, każda funkcja oktawy ma podwójną częstotliwość poprzedniej. Szum Perlina został opisany jako „suma fraktali szumu", ponieważ łączy on wiele zestawów danych szumu o różnych stopniach uszczegółowienia.</p>
     
     <p>Możliwe jest wykorzystanie funkcji szumu Perlina w celu symulacji zjawisk naturalnych i krajobrazów, jak na przykład struktura drewna, chmury oraz stoki górskie. W większości przypadków efekt wyjściowy funkcji szumu Perlina nie jest wyświetlana bezpośrednio, lecz wykorzystywana do udoskonalenia obrazów oraz nadania im pseudo-losowych wariacji.</p>
     
     <p>Proste funkcje cyfrowego szumu losowego często generują obrazy o ostrych, kontrastujących punktach. Tego typu ostry kontrast nie jest często spotykany w naturze. Algorytm szumu Perlina miesza wiele funkcji szumu, które operują na różnych stopniach szczegółowości. Algorytm powoduje mniejsze wariacje wśród wartości pikseli sąsiadujących.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">baseX</span>:<a href="../../Number.html">Number</a></code> &mdash; Częstotliwość do wykorzystania w kierunku <i>x</i>. Przykładowo w celu wygenerowania szumu, który jest określony dla obrazu o wielkości 64 x 128, należy podać wartość 64 dla parametru <code>baseX</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">baseY</span>:<a href="../../Number.html">Number</a></code> &mdash; Częstotliwość do wykorzystania w kierunku <i>y</i>. Przykładowo w celu wygenerowania szumu, który jest określony dla obrazu o wielkości 64 x 128, należy podać wartość 128 dla parametru <code>baseY</code>. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numOctaves</span>:<a href="../../uint.html">uint</a></code> &mdash; Liczba oktaw lub indywidualnych funkcji szumu do połączenia w celu wygenerowania tego szumu. Większa liczba oktaw tworzy obrazy o wyższych detalach. Większa liczba oktaw wymaga również dłuższego czasu przetwarzania.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> &mdash; Wartość początkowa generatora liczb pseudolosowych do wykorzystania. Przy zachowaniu tych samych wartości wszystkich innych parametrów możliwe jest generowanie różnych wyników pseudolosowych poprzez zmienianie wartości początkowej generatora liczb pseudolosowych. Funkcja szumu Perlina jest funkcją odwzorowującą, a nie prawdziwą funkcją losową, zatem dla tej samej wartości początkowej generatora liczb pseudolosowych zwraca zawsze te same wyniki.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stitch</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Wartość Boolean. Jeżeli wartość <code>true</code>, wówczas metoda próbuje wygładzić krawędzie przejścia obrazu, w celu utworzenia bezproblemowych tekstur dla wzorów powtarzających się do wypełnienia bitmapy.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fractalNoise</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; Wartość Boolean. Jeżeli wartość <code>true</code>, wówczas metoda generuje szum fraktalny; w innym przypadku generuje turbulencję. Obraz zawierający turbulencję ma widoczne przerwy w gradiencie, co powoduje tworzenie lepszych efektów wizualnych obiektów o ostrych kształtach, jak na przykład płomienie i fale oceanu. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">channelOptions</span>:<a href="../../uint.html">uint</a></code> (default = <code>7</code>)<code></code> &mdash;  Liczba, która może być kombinacją każdej z czterech wartości kanałów kolorów (<code>BitmapDataChannel.RED</code>, <code>BitmapDataChannel.BLUE</code>, <code>BitmapDataChannel.GREEN</code>, <code>BitmapDataChannel.ALPHA</code>). Możliwe jest wykorzystanie operatora logicznego LUB (<code>|</code>) w celu połączenia wartości kanałów.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">grayScale</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Wartość Boolean. Jeżeli wartość <code>true</code>, wówczas tworzony jest obraz w skali szarości poprzez ustawienie wszystkich kanałów kolorów na tę samą wartość. Ustawienie tego parametru na wartość <code>true</code> nie ma wpływu na wartość kanału alpha.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">offsets</span>:<a href="../../Array.html">Array</a></code> (default = <code>null</code>)<code></code> &mdash; Tablica punktów odpowiadających przesunięciom <i>x</i> i <i>y</i> dla każdej oktawy. Poprzez manipulację wartości przesunięcia możliwe jest płynne przewijanie warstw obrazu perlinNoise. Każdy punkt tablicy przesunięć wpływa na określoną funkcję szumu oktawy.
     
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje tworzenie obiektu BitmapData o rozmiarach 200 x 200 pikseli, który wywołuje metodę <code>perlinNoise()</code> w celu wygenerowania efektów akwareli koloru czerwonego i niebieskiego:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(200, 200, false, 0x00CCCCCC);

var seed:Number = Math.floor(Math.random() * 10);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd.perlinNoise(100, 80, 6, seed, false, true, channels, false, null);

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="pixelDissolve()" id="pixelDissolve()"></a><a name="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)" id="pixelDissolve(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>pixelDissolve</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function pixelDissolve(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, randomSeed:<a href="../../int.html">int</a> = 0, numPixels:<a href="../../int.html">int</a> = 0, fillColor:<a href="../../uint.html">uint</a> = 0):<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Przeprowadza operację rozpuszczania na poziomie pikseli - albo z obrazu źródłowego do obrazu docelowego, albo przy użyciu jednego obrazu. Środowisko wykonawcze Flash wykorzystuje wartość <code>randomSeed</code> w celu wygenerowania operacji losowego rozpuszczania pikseli. Wartość zwrotna funkcji musi zostać podana w kolejnych wywołaniach w celu kontynuowania operacji rozpuszczania pikseli aż do zakończenia.
     
     <p>Jeżeli obraz źródłowy nie równa się obrazowi docelowemu, wówczas piksele są kopiowane ze źródła do celu przez wykorzystanie wszelkich właściwości. Proces ten pozwala na rozpuszczanie z pustego obrazu do obrazu w całości zapełnionego.</p>
     
     <p>Jeżeli obrazy źródłowy i docelowy są takie same, wówczas piksele są wypełniane zgodnie z parametrem <code>color</code>. Proces ten pozwala na rozpuszczanie z dala od obrazu w całości zapełnionego. W tym trybie docelowy parametr <code>point</code> jest ignorowany.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do wykorzystania. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnej instancji BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt wewnątrz obrazu docelowego (obecna instancja BitmapData) odpowiadający górnemu lewemu narożnikowi prostokąta. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">randomSeed</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Wartość początkowa generatora liczb pseudolosowych używana do rozpoczęcia rozpuszczania na poziomie pikseli. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numPixels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; Domyślna wartość to 1/30 obszaru źródłowego (szerokość x wysokość).
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">fillColor</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Wartość koloru ARGB wykorzystywana do wypełnienia pikseli, których wartość źródłowa jest równa docelowej. 
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../int.html">int</a></code> &mdash; Nowa wartość początkowa generatora liczb pseudolosowych do wykorzystania w kolejnych wywołaniach.
     
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect lub destPoint mają wartość null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwość numPixels ma wartość ujemną.
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje zastosowanie metody <code>pixelDissolve()</code> w celu konwersji szarego obiektu BitmapData na kolor czerwony poprzez rozpuszczanie 40 pikseli w danym momencie, do czasu zmiany kolorów przez wszystkie piksele:
<div class="listing"><pre>
import flash.display.BitmapData;
import flash.display.Bitmap;
import flash.geom.Point;
import flash.geom.Rectangle;
import flash.utils.Timer;
import flash.events.TimerEvent;

var bmd:BitmapData = new BitmapData(100, 80, false, 0x00CCCCCC);
var bitmap:Bitmap = new Bitmap(bmd);
addChild(bitmap);

var tim:Timer = new Timer(20);
tim.start();
tim.addEventListener(TimerEvent.TIMER, timerHandler);
 
function timerHandler(event:TimerEvent):void {
    var randomNum:Number = Math.floor(Math.random() * int.MAX_VALUE);
    dissolve(randomNum);
}

function dissolve(randomNum:Number):void {
    var rect:Rectangle = bmd.rect;
    var pt:Point = new Point(0, 0);
    var numberOfPixels:uint = 100;
    var red:uint = 0x00FF0000;
    bmd.pixelDissolve(bmd, rect, pt, randomNum, numberOfPixels, red);
    var grayRegion:Rectangle = bmd.getColorBoundsRect(0xFFFFFFFF, 0x00CCCCCC, true);
    if(grayRegion.width == 0 && grayRegion.height == 0 ) {
        tim.stop();
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="scroll()" id="scroll()"></a><a name="scroll(int,int)" id="scroll(int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>scroll</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function scroll(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Przewija obraz o określoną ilość (<i>x</i>, <i>y</i>) pikseli. Obszary krawędzi poza polem przewijania są pozostawione bez zmian.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Stopień przewinięcia w poziomie.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Stopień przewinięcia w pionie.
     
     </td></tr></table></p><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje efekt przewijania obiektu danych Bitmap o 40 pikseli w prawą stronę.
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.geom.Rectangle;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);
var rect:Rectangle = new Rectangle(0, 0, 40, 40);
bmd.fillRect(rect, 0xFFFF0000);
            
var bm:Bitmap = new Bitmap(bmd);
addChild(bm);

trace (bmd.getPixel32(50, 20).toString(16)); // ffcccccccc

bmd.scroll(30, 0); 

trace (bmd.getPixel32(50, 20).toString(16)); // ffff0000
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel()" id="setPixel()"></a><a name="setPixel(int,int,uint)" id="setPixel(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ustawia pojedynczy piksel obiektu BitmapData. Obecna wartość kanału alpha pikseli obrazu jest zachowana w trakcie tej operacji. Parametr wartości RGB koloru jest traktowany jako wartość nieprzemnożona koloru.
     
     <p><b>Uwaga:</b> W celu podwyższenia wydajności w trakcie wielokrotnego korzystania z metod <code>setPixel()</code> i <code>setPixel32()</code> pomocne jest wywołanie metody <code>lock()</code> przed wywołaniem metody <code>setPixel()</code> i <code>setPixel32()</code> oraz wywołanie <code>unlock()</code> po dokonaniu zmian piksela. Proces ten zapobiega aktualizacji obiektów odwołujących się do instancji BitmapData zanim nie zostanie zakończone wprowadzanie zmian piksela. </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>x</i> piksela, którego wartości ulegają zmianie.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>y</i> piksela, którego wartości ulegają zmianie.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Wynikowy kolor RGB pikseli. 
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#getPixel()" target="">getPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób wykorzystania klasy <code>setPixel()</code> w celu narysowania czerwonej linii w obiekcie BitmapData: 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, false, 0xCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0xFF0000;
    bmd.setPixel(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixel32()" id="setPixel32()"></a><a name="setPixel32(int,int,uint)" id="setPixel32(int,int,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixel32</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixel32(x:<a href="../../int.html">int</a>, y:<a href="../../int.html">int</a>, color:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Ustawia wartości koloru i przezroczystości alfa jednego piksela w obiekcie typu BitmapData. Metoda ta jest podobna do metody <code>setPixel()</code>; główną różnicą jest fakt, iż metoda <code>setPixel32()</code> pobiera wartość ARGB koloru, która zawiera informację dotyczącą kanału alpha.
     
     <p>Wszystkie piksele obiektu BitmapData są przechowywane jako wstępnie przemnożone wartości kolorów. Wartość wstępnie przemnożona koloru jest wartością kanałów koloru czerwonego, zielonego i niebieskiego przemnożoną przez wartość alpha. Na przykład jeżeli wartość alhpa wynosi 0, wówczas wartości kanałów RGB również wynoszą 0, niezależnie od ich wartości nieprzemnożonych. Tego rodzaju utrata danych może spowodować problemy w trakcie wykonywania operacji. Wszystkie metody BitmapData pobierają i zwracają wartości nieprzemnożone. Reprezentacja pikseli wewnętrznych jest konwertowana z wartości wstępnie przemnożonych do wartości nieprzemnożonych przed zwróceniem jako wartość. W trakcie operacji ustawiania wartość piksela jest wstępnie przemnażana przed ustawieniem surowego piksela obrazu.</p>
     
     <p><b>Uwaga:</b> W celu podwyższenia wydajności w trakcie wielokrotnego korzystania z metod <code>setPixel()</code> i <code>setPixel32()</code> pomocne jest wywołanie metody <code>lock()</code> przed wywołaniem metody <code>setPixel()</code> i <code>setPixel32()</code> oraz wywołanie <code>unlock()</code> po dokonaniu zmian piksela. Proces ten zapobiega aktualizacji obiektów odwołujących się do instancji BitmapData zanim nie zostanie zakończone wprowadzanie zmian piksela. </p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">x</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>x</i> piksela, którego wartości ulegają zmianie.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">y</span>:<a href="../../int.html">int</a></code> &mdash; Położenie <i>y</i> piksela, którego wartości ulegają zmianie.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> &mdash; Wynikowy kolor RGB pikseli Jeżeli bitmapa jest nieprzezroczysta, wówczas sekcja przezroczystości alpha wartości koloru jest pomijana.
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#getPixel32()" target="">getPixel32()</a><br/><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#unlock()" target="">unlock()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje sposób wykorzystania klasy <code>setPixel32()</code> w celu narysowania przezroczystej (alpha == 0x60) czerwonej linii w obiekcie BitmapData: 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;

var bmd:BitmapData = new BitmapData(80, 80, true, 0xFFCCCCCC);

for (var i:uint = 0; i &lt; 80; i++) {
    var red:uint = 0x60FF0000;
    bmd.setPixel32(i, 40, red);
}

var bm:Bitmap = new Bitmap(bmd);
addChild(bm);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##Lite::4##"><a name="setPixels()" id="setPixels()"></a><a name="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)" id="setPixels(flash.geom.Rectangle,flash.utils.ByteArray)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setPixels</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setPixels(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputByteArray:<a href="../utils/ByteArray.html">ByteArray</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Konwertuje tablicę bajtów na prostokątny obszar pikseli. Dla każdego piksela metoda <code>ByteArray.readUnsignedInt()</code> jest wywoływana, zaś zwrócona wartość jest zapisana w pikselu. Jeżeli tablica bajtów kończy się przed zapisaniem całego prostokąta, wówczas funkcja jest zwracana. Dane w tablicy bajtów powinny być 32-bitowymi wartościami ARGB pikseli. Wyszukiwanie nie jest przeprowadzane na tablicy bajtów przed lub po odczytaniu pikseli.  
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Określa prostokątny obszar obiektu BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputByteArray</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; Obiekt ByteArray składa się z 32-bitowych nieprzemnożonych wartości pikseli do wykorzystania w obszarze prostokątnym.
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../errors/EOFError.html">EOFError</a> </code> &mdash; Obiekt <code>inputByteArray</code> nie zawiera dość danych do wypełnienia prostokąta <code>rect</code>. Metoda wypełnia maksymalną możliwą ilość pikseli przed zgłoszeniem wyjątku.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości rect lub inputByteArray mają wartość null.
      
      </td></tr></table><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="../utils/ByteArray.html#readUnsignedInt()" target="">flash.utils.ByteArray.readUnsignedInt()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> W poniższych przykładach zilustrowane jest wykorzystanie metod <code>getPixels()</code> oraz <code>setPixels()</code> w celu skopiowania pikseli z jednego obiektu BitmapData do drugiego:
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.utils.ByteArray;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(100, 100, true, 0xFFCCCCCC);
var bmd2:BitmapData = new BitmapData(100, 100, true, 0xFFFF0000);

var rect:Rectangle = new Rectangle(0, 0, 100, 100);
var bytes:ByteArray = bmd1.getPixels(rect);

bytes.position = 0;
bmd2.setPixels(rect, bytes);

var bm1:Bitmap = new Bitmap(bmd1);
addChild(bm1);
var bm2:Bitmap = new Bitmap(bmd2);
addChild(bm2);
bm2.x = 110;
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::10##AIR::1.5##Lite::4##"><a name="setVector()" id="setVector()"></a><a name="setVector(flash.geom.Rectangle,Vector$uint)" id="setVector(flash.geom.Rectangle,Vector$uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVector(rect:<a href="../geom/Rectangle.html">Rectangle</a>, inputVector:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 10, AIR 1.5, Flash Lite 4</td></tr></table><p></p><p></p><p>
     Przekształca obiekt Vector w prostokątny region danych pikselowych. Dla każdego piksela odczytywany jest element tablicy Vector, który następnie zapisywany jest do piksela w obiekcie BitmapData. Dane w tablicy Vector powinny być 32-bitowymi wartościami ARGB pikseli. 
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Określa prostokątny obszar obiektu BitmapData.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">inputVector</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../uint.html">uint</a>&gt;</code> &mdash; Obiekt Vector składa się z 32-bitowych nieprzemnożonych wartości pikseli do wykorzystania w obszarze prostokątnym.  
     
     </td></tr></table></p><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; Tablica Vector jest zbyt mała, by pomieścić wszystkie odczytane dane pikseli.
     </td></tr></table></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="threshold()" id="threshold()"></a><a name="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)" id="threshold(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point,String,uint,uint,uint,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>threshold</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function threshold(sourceBitmapData:<a href="BitmapData.html">BitmapData</a>, sourceRect:<a href="../geom/Rectangle.html">Rectangle</a>, destPoint:<a href="../geom/Point.html">Point</a>, operation:<a href="../../String.html">String</a>, threshold:<a href="../../uint.html">uint</a>, color:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xFFFFFFFF, copySource:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../uint.html">uint</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Testuje wartości pikseli obrazu ze względu na określony próg i określa nowe wartości kolorów pikseli zweryfikowanych pozytywnie. Poprzez zastosowanie metody <code>threshold()</code> możliwe jest izolowanie oraz zamiana zakresów kolorów w obrazie oraz przeprowadzenie innych operacji logicznych na pikselach obrazu. 
     
     <p>Logika testów metody <code>threshold()</code> przedstawia się następująco:</p> 
     
     <ol><li>Jeżeli <code>((pixelValue & maska) operacja (próg & maska))</code>, wówczas piksel jest ustawiany zgodnie z właściwością <code>color</code>;</li><li>W innym przypadku, gdy <code>copySource == true</code>, wówczas piksel jest ustawiany na odpowiadającą wartość pikseli z właściwości <code>sourceBitmap</code>.</li></ol>
     
     <p>Parametr <code>operation</code> określa operatora porównania do wykorzystania w teście progowym. Przykładowo, zastosowanie operatora "==" jako parametru <code>operation</code> możliwa jest izolacja określonej wartości koloru na obrazie. Również poprzez wykorzystanie parametru <code>{operation: "&lt;", mask: 0xFF000000, threshold: 0x7F000000, color: 0x00000000}</code> możliwe jest ustawienie wszystkich pikseli docelowych na pełną przezroczystość w przypadku, gdy wartość alpha pikseli obrazu źródłowego wynosi mniej niż 0x7F. Można wykorzystać tą technikę przy przejściach animowanych i innych efektach.</p>
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceBitmapData</span>:<a href="BitmapData.html">BitmapData</a></code> &mdash; Wejściowy obraz bitmapowy do użycia. Obrazem źródłowym może być inny obiekt BitmapData lub może się on odwoływać do obecnej instancji BitmapData. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">sourceRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; Prostokąt definiujący obszar obrazu źródłowego do wykorzystania jako materiał do wprowadzenia.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> &mdash; Punkt wewnątrz obrazu docelowego (obecna instancja BitmapData) odpowiadający górnemu lewemu narożnikowi prostokąta. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">operation</span>:<a href="../../String.html">String</a></code> &mdash; Jeden z następujących operatorów, podany jako obiekt String: "&lt;", "&lt;=", ">", ">=", "==", "!="
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">threshold</span>:<a href="../../uint.html">uint</a></code> &mdash; Wartość, względem której testowany jest każdy piksel w celu ustalenia, czy spełniony bądź przekroczony został próg.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">color</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; Wartość koloru, na którą piksel został ustawiony po pomyślnej weryfikacji testu progowego. Wartość domyślna to 0x00000000.
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xFFFFFFFF</code>)<code></code> &mdash; Maska do wykorzystania w celu izolacji składników koloru. 
     
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">copySource</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; Jeżeli wartość <code>true</code>, wówczas wartości pikseli z obrazu źródłowego są kopiowane do docelowego, gdy test progowy zakończy się niepowodzeniem. Jeżeli wartość <code>false</code>, wówczas obraz źródłowy nie jest kopiowany, gdy test progowy zakończy się niepowodzeniem. 
     
     </td></tr></table></p><p></p><span class="label">Zwraca</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../uint.html">uint</a></code> &mdash; Liczba zmienionych pikseli.
     </td></tr></table><br/><span class="label">Zgłasza</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Właściwości sourceBitmapData, sourceRect, destPoint lub operation mają wartość null.
     </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; Ciąg znaków operacji nie jest prawidłową operacją. 
      
     </td></tr></table><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody"> Poniższy przykład ilustruje zastosowanie metody <code>perlinNoise()</code> w celu dodania niebiesko-czerwonego wzoru do jednego obiektu BitmapData, a następnie wykorzystanie metody <code>threshold()</code> w celu skopiowania tych pikseli z pierwszego obiektu BitmapData to drugiego, z zastąpieniem pikseli o wartości koloru czerwonego większej niż 0x80 (50%) pikselami ustawionymi na przezroczysty kolor czerwony (0x20FF0000): 
<div class="listing"><pre>

import flash.display.Bitmap;
import flash.display.BitmapData;
import flash.display.BitmapDataChannel;
import flash.geom.Point;
import flash.geom.Rectangle;

var bmd1:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);

var seed:int = int(Math.random() * int.MAX_VALUE);
var channels:uint = BitmapDataChannel.RED | BitmapDataChannel.BLUE;
bmd1.perlinNoise(100, 80, 12, seed, false, true, channels, false, null);

var bitmap1:Bitmap = new Bitmap(bmd1);
addChild(bitmap1);

var bmd2:BitmapData = new BitmapData(200, 200, true, 0xFFCCCCCC);
var pt:Point = new Point(0, 0);
var rect:Rectangle = new Rectangle(0, 0, 200, 200);
var threshold:uint =  0x00800000; 
var color:uint = 0x20FF0000;
var maskColor:uint = 0x00FF0000;
bmd2.threshold(bmd1, rect, pt, "&gt;", threshold, color, maskColor, true);

var bitmap2:Bitmap = new Bitmap(bmd2);
bitmap2.x = bitmap1.x + bitmap1.width + 10;
addChild(bitmap2);
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::9##AIR::1.0##"><a name="unlock()" id="unlock()"></a><a name="unlock(flash.geom.Rectangle)" id="unlock(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>unlock</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">metoda</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function unlock(changeRect:<a href="../geom/Rectangle.html">Rectangle</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersja języka:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>Wersje środowiska wykonawczego:&nbsp;</b></td><td>Flash Player 9, AIR 1.0</td></tr></table><p></p><p></p><p>
     Odblokowuje obraz, co powoduje, że wszelkie obiekty odwołujące się do obiektu BitmapData, np. obiekty Bitmap, są aktualizowane w odpowiedzi na zmiany obiektu BitmapData. W celu podwyższenia wydajności należy stosować tą metodę wraz z metodą <code>lock()</code> przed i po wielokrotnych wywołaniach do metody <code>setPixel()</code> i <code>setPixel32()</code>.
     
     </p><p><span class="label"> Parametry </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">changeRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code> &mdash; Zmieniony obszar obiektu BitmapData. Jeżeli nie jest zdefiniowana wartość dla tego parametru, wówczas cały obszar obiektu BitmapData jest uznany za zmieniony. Ten parametr wymaga aplikacji Flash Player w wersji 9.0.115.0 lub nowszej.
     
     </td></tr></table></p><p><span class="label">Powiązane elementy interfejsu API</span></p><div class="seeAlso"><a href="BitmapData.html#lock()" target="">lock()</a><br/><a href="BitmapData.html#setPixel()" target="">setPixel()</a><br/><a href="BitmapData.html#setPixel32()" target="">setPixel32()</a></div><span id="pageFilter"><br/><span class="label"> Przykład &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span>)
            </span><br/><br/><div class="detailBody">  Poniższy przykład ilustruje tworzenie obiektu BitmapData w oparciu o właściwość <code>bitmapData</code> obiektu Bitmap <code>picture</code>. Następnie wywoływana jest metoda <code>lock()</code> przed wywołaniem skomplikowanej funkcji własnej <code>complexTransformation()</code>, która modyfikuje obiekt BItmapData. (Obiekt <code>picture</code> oraz funkcja <code>complexTransformation()</code> nie są zdefiniowane w tym przykładzie.) Nawet w przypadku gdy funkcja <code>complexTransformation()</code> aktualizuje właściwość <code>bitmapData</code> obiektu <code>picture</code>, zmiany nie są odzwierciedlone do momentu wywołania metody <code>unlock()</code> obiektu <code>bitmapData</code>.
<div class="listing"><pre>
import flash.display.BitmapData;

var bitmapData:BitmapData = picture.bitmapData;
bitmapData.lock();
bitmapData = complexTransformation(bitmapData);
bitmapData.unlock();
picture.bitmapData = bitmapData;
</pre></div></div></span></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">Przykłady<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_pl"> Sposób korzystania z tego przykładu </a></span></div><span id="pageFilter"><div class="exampleHeader">BitmapDataExample.as</div><br/><div class="detailBody"> Poniższy przykład ilustruje wykorzystanie klasy BitmapDataExample w celu załadowania obrazu Image.gif do obiektu DisplayObject w domyślnym położeniu (0, 0). Kopia obrazu Image.gif jest wówczas umieszczana na prawo od oryginału, w którym zastosowano nowe kolory wobec pikseli, które zostały zweryfikowane pozytywnie przy użyciu metody <code>threshold()</code>. Zadanie to jest przeprowadzane poprzez wykonanie następujących kroków:
 <ol><li>Tworzona jest właściwość <code>url</code>, która jest miejscem położenia oraz nazwą pliku obrazu. </li><li>Konstruktor klas tworzy obiekt Loader, który z kolei tworzy instancję detektora zdarzeń, zaś ten jest wywoływany gdy metoda <code>completeHandler()</code> zakończy manipulację obrazu.</li><li>Obiekt URLRequest <code>request</code> jest następnie przekazywany do metody <code>loader.load()</code>, który ładuje obraz poprzez wykorzystanie obiektu wyświetlania.</li><li>Obraz jest wówczas umieszczany na liście wyświetlania, która wyświetla obraz na ekranie na współrzędnych <i>x = 0, y = 0</i>.</li><li>Metoda <code>completeHandler()</code> przeprowadza wówczas następujące zadania. 
     <ul><li>Tworzy drugi obiekt Loader, wraz z obiektem Bitmap, który jest inicjalizowany przy pomocy obiektu Loader. </li><li>Tworzy dugi obiekt Bitmap <code>duplicate</code>, który z kolei wywołuje metodę <code>duplicateImage()</code>, tworzącą duplikat oryginalnego obrazu. </li><li>Tworzy obiekt BitmapData, który jest powiązany z obiektem <code>duplicate</code> obiektu BitmapData. </li><li>Tworzy nowy obiekt Rectangle inicjalizowany z tymi samymi współrzędnymi, szerokością i wysokością jak obraz oryginalny.</li><li>Tworzy nowy obiekt Point, którego współrzędne domyślne to <i>x = 0, y = 0</i>.</li><li>Tworzy następujące zmienne:
         <ul><li><code>operation</code> &mdash; Stosuje nowy kolor, gdy wartość progowa jest większa lub równa oryginałowi.</li><li><code>threshold</code> &mdash; Wartość, wobec której każdy piksel jest porównywany (w tym przykładzie jest ustawiona na kolor jasnoszary z wartością alpha 0xCC). </li><li><code>color</code> &mdash; kolor, na który zostaną ustawione piksele spełniające warunek progowy; w tym wypadku jest to jednolity kolor żółty.</li><li><code>mask</code> &mdash; Kolor dokładnie przeciwny (przezroczysty kolor niebieski). </li><li><code>copySource</code> &mdash; Ustawiona na wartość <code>false</code> wskazuje, iż wartości pikseli nie są kopiowane w przypadku, gdy wartość progowa nie zostanie zweryfikowana pozytywnie. Ta wartość nie ma znaczenia, ponieważ obraz jest zduplikowany i wyłącznie piksele które zostały pozytywnie zweryfikowane w teście progowym są zmieniane.</li></ul></li><li>Wywołuje metodę <code>threshold()</code> wykorzystując powyższe zmienne. Końcowe równanie progowe wygląda następująco: <code>jeżeli (obecna wartość pikseli & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) wówczas ustaw wartość pikseli na 0xFFFFFF00</code>. </li></ul></li></ol>
 <p> <b>Uwagi:</b>
 <ul><li>Plik SWF musi być skompilowany z zabezpieczeniem odtwarzania lokalnego ustawionym na tylko do pliki dostępne lokalnie.
 </li><li>Dla zilustrowania tego przykładu konieczne jest umieszczenie pliku o nazwie Image.gif w tym samym katalogu, w którym znajduje się plik SWF.
 </li><li>Zalecane jest wykorzystanie obrazu o szerokości do 80 pikseli. </li></ul>
 </p>
<div class="listing"><pre>

package {
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Loader;
    import flash.display.Sprite;
    import flash.events.*;
    import flash.geom.Point;
    import flash.geom.Rectangle;
    import flash.net.URLRequest;

    public class BitmapDataExample extends Sprite {
        private var url:String = "Image.gif";
        private var size:uint = 80;

        public function BitmapDataExample() {
            configureAssets();
        }

        private function configureAssets():void {
            var loader:Loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);

            var request:URLRequest = new URLRequest(url);
            loader.x = size * numChildren;
            loader.load(request);
            addChild(loader);
        }

        private function duplicateImage(original:Bitmap):Bitmap {
            var image:Bitmap = new Bitmap(original.bitmapData.clone());
            image.x = size * numChildren;
            addChild(image);
            return image;
        }

        private function completeHandler(event:Event):void {
            var loader:Loader = Loader(event.target.loader);
            var image:Bitmap = Bitmap(loader.content);

            var duplicate:Bitmap = duplicateImage(image);
            var bitmapData:BitmapData = duplicate.bitmapData;
            var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height);
            var destPoint:Point = new Point();
            var operation:String = "&gt;=";
            var threshold:uint = 0xCCCCCCCC;
            var color:uint = 0xFFFFFF00;
            var mask:uint = 0x000000FF;
            var copySource:Boolean = true;

            bitmapData.threshold(bitmapData,
                                 sourceRect,
                                 destPoint,
                                 operation,
                                 threshold,
                                 color,
                                 mask,
                                 copySource);
        }
        
        private function ioErrorHandler(event:IOErrorEvent):void {
            trace("Unable to load image: " + url);
        }
    }
}
</pre></div></div></span><span id="pageFilter"><div class="exampleHeader">BitmapDataExample2.as</div><br/><div class="detailBody"></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,false,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:06 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/pl_PL/legalnotices/index.html">Informacje prawne</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">Zasady prywatności online</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">Dlaczego język angielski?</span>
				</div>
				<div class="white_content_body">
					<b>Treść dokumentacji języka ActionScript 3.0 wyświetlana w języku angielskim</b><br><br>
					Niektóre części dokumentacji języka ActionScript 3.0 nie są przetłumaczone na poszczególne języki. Gdy element nie jest przetłumaczony na dany język, jest wyświetlany tekst angielski. Na przykład opis klasy ga.controls.HelpBox nie jest przetłumaczony na żaden dodatkowy język. Z tego powodu polska wersja dokumentacji zawiera opis klasy ga.controls.HelpBox w języku angielskim.
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 12:06 PM Z  -->
