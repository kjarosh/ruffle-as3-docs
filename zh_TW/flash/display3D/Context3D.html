<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN">
			<!-- saved from url=(0014)about:internet -->
			<html>
	<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=9"><meta name="book" content="適用於 Adobe&reg; Flash&reg; Platform 的 ActionScript&reg; 3.0 參考"><meta name="lang" content="zh-tw"><meta name="runtime" content="flash player"><meta name="runtimever" content="flash player:11"><meta name="runtime" content="air"><meta name="runtimever" content="air:3"><meta name="product" content="flash player"><meta name="productver" content="flash player:11"><meta name="product" content="air"><meta name="productver" content="air:3"><link rel="stylesheet" href="../../style.css" type="text/css" media="screen"><link rel="stylesheet" href="../../print.css" type="text/css" media="print"><link rel="stylesheet" href="../../override.css" type="text/css"><link rel="stylesheet" href="../../asfilter.css" type="text/css"><link rel="stylesheet" href="../../ion.css" type="text/css"><meta name="keywords" content="Context3D,flash.display3D.Context3D,backBufferHeight,backBufferWidth,driverInfo,enableErrorChecking,maxBackBufferHeight,maxBackBufferWidth,profile,supportsVideoTexture,totalGPUMemory,clear,configureBackBuffer,createCubeTexture,createIndexBuffer,createProgram,createRectangleTexture,createTexture,createVertexBuffer,createVertexBufferForInstances,createVideoTexture,dispose,drawToBitmapData,drawTriangles,drawTrianglesInstanced,present,setBlendFactors,setColorMask,setCulling,setDepthTest,setFillMode,setProgram,setProgramConstantsFromByteArray,setProgramConstantsFromMatrix,setProgramConstantsFromVector,setRenderToBackBuffer,setRenderToTexture,setSamplerStateAt,setScissorRectangle,setStencilActions,setStencilReferenceValue,setTextureAt,setVertexBufferAt"><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" src="../../AC_OETags.js" type="text/javascript"></script><title>Context3D - Adobe ActionScript&reg; 3 (AS3  ) API 參考</title>
		<link rel="stylesheet" href="../../filter-style.css" type="text/css">
		<link href="http://community.adobe.com/help/badge/v3/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link href="http://community.adobe.com/help/badge/ionBadge.css" rel="stylesheet" type="text/css" media="screen">
		<link rel="stylesheet" href="../../filter_new.css" type="text/css">
			
		<script src="../../jquery.js" type="text/javascript"></script>
		<script src="../../s_chl_code.js" type="text/javascript"></script>
		<script src="../../jquery.zclip.js" type="text/javascript"></script>
		<script src="../../jquery.ba-hashchange.js" type="text/javascript"></script>
		<script src="../../cookies.js" type="text/javascript"></script>
		<script src="../../asdoc.js" type="text/javascript"></script>
		<script src="../../iscroll.js" type="text/javascript"></script>
		<script src="../../AC_OETags.js" type="text/javascript"></script>
		<script src="../../omniture_asdocs.js" type="text/javascript"></script>
		<script type="text/javascript">
		
			var runtimesLabel = "執行階段";
			var productsLabel = "產品";
			var noneLabel = "無";
			var qsearchBoxLabel = "快速搜尋";
			var qsearchText = "找不到字詞";
			var ajaxErrorMsg="載入頁面時發生錯誤";
			var ajaxErrorTryMsg="再試一次";
			var ajaxLoadingMsg="仍在載入";
			var cancelMsg = "取消";
			var classesText = "類別";
			var strJiveReply = "張貼此問題是為回應下列文章： "
			var showFilters = "顯示篩選";
			var hideFilters = "隱藏篩選";
			
		
			var baseRef = "../../";
			var buildType = 'filter';
			var alreadyrunflag=0; //flag to indicate whether target function has already been run
			var terms_HELPCFG = "PlatformASLR.helpcfg";
			
			$(document).ready(function(){
				init2();
			});
			
		
		</script>
		<!--oss:off-->
		
<!-- ********************************** -->
<!-- START: ForeSee survey code in: /ssi/globalheader.ssi -->

<script type="text/javascript">
<!-- 
// Enable the survey for only English, German and Japanese
var agt=navigator.userAgent.toLowerCase();
if ( agt.indexOf("community help client") == -1 ){
    if ( document.location.href.indexOf("/en_US/") != -1 ){
        showSurvey();
//    }else if (document.location.href.indexOf("/de_DE/") != -1){
//         var locale="de";
//         showSurvey();
    }else if (document.location.href.indexOf("/ja_JP/") != -1 ){
         var locale="ja";
         showSurvey();
    }	
}

function showSurvey(){
	//document.write('<script type="text/javascript" src="/js/foresee/foresee-trigger.js"><\/scr'+'ipt>');
    // DO NOTHING
}

// -->
</script>

<!-- END: ForeSee survey code -->
<!-- ******************************** -->


	</head>
	<body>
		<a name="top"></a>
		
		<table class="titleTable" cellpadding="0" cellspacing="0">
			<tr>
				<td>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr>
							<td>
								<table class="titleTable" cellpadding="0" cellspacing="0">
									<tr>
										<td class="titleTableTitleION" align="left" nowrap="true">
											適用於 Adobe<sup>&reg;</sup> Flash<sup>&reg;</sup> Platform 的 ActionScript<sup>&reg;</sup> 3.0 參考<br>
											<span class="titleTableTopNavION">
												<span id="homelink">
													<a target="_self" href="../../index.html"> 首頁 </a>&nbsp;|&nbsp;
												</span>
												<span id="TocLink">
													<a target="_self" id="showtoc" onClick="showHideTOC(true)" href="Context3D.html#top" style="display:">顯示套件和類別清單</a><a target="_self" id="hidetoc" onClick="showHideTOC(false)" href="Context3D.html#top" style="display:none">隱藏套件和類別清單</a>&nbsp;|&nbsp;
												</span>
												<a target="_self" href="../../package-summary.html"> 套件 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../class-summary.html"> 類別 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../whatsnew.html"> 新增內容 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../all-index-Symbols.html"> 索引 </a>&nbsp;|&nbsp;
												<a target="_self" href="../../appendixes.html"> 附錄 </a>
												<span id="whyEnglish">&nbsp;|&nbsp;
													<a href="javascript:void(0)" onclick="document.getElementById('light').style.display='block';document.getElementById('fade').style.display='block'">為什麼顯示英文？</a>
												</span><br>
											</span>	
										</td>
										<td class="titleTableSearchION" align="right" nowrap="true">
											<span id="gsa" class="gsa">
												<form class="searchForm" method="get" action="https://help.adobe.com/zh_TW/FlashPlatform/reference/actionscript/3/search.html" onSubmit="searchfunctionsubmit('../../')"><input class="searchinput" id="search-livedocs" name="search_text" value="" title="" type="text"><input type="button" name="action" value="" class="searchbutton" onClick="searchfunctionsubmit('../../')"></form>
											</span>
										</td>
									</tr>
								</table>
							</td>
							<td class="titleTableLogo" align="right" rowspan="3"><div class="sprite logoION" alt="Adobe Logo" title="Adobe Logo"></div></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					<div id="filter_panel_float">
						<script language="javascript" type="text/javascript" src="../../help.js"></script>
						<script language="javascript" type="text/javascript" src="../../asfilter.js"></script>
						<script language="javascript" type="text/javascript" src="../../filter_new.js"></script>
						<div id="filter_panel_nf">
							<table class="filterTable" width="100%">
								<tr>
									<td>篩選：</td>
									<td width="5%" id="runtimefilter"></td>
									<td id="runtimes" align="left" style=" white-space:normal">從伺服器擷取資料...</td>
								</tr>
								<tr>
									<td></td>
									<td id="productfilter" valign="top"></td>
									<td id="products" width="85%" style="white-space:normal">從伺服器擷取資料...</td>
								</tr>
							</table>
						</div>
					</div>
				</td>
			</tr>
			<tr>
				<td>
					<center>
						<a href="Context3D.html#"><span id="filterImg" class="filterImg_hide" alt="Hide Filters" title="Hide Filters" onclick="showHideFilters();">
							<font id="filterImgText">
							</font>
						</span></a>
					</center>
					<table class="titleTable" cellpadding="0" cellspacing="0">
						<tr class="titleTableRow2">
							<td class="titleTableSubTitle" id="subTitle" align="left" colspan="2">
								<a href="package-detail.html" id="packageName" style="font-size:11px;">flash.display3D&nbsp;</a><br>
								<h1 id="classProductName">Context3D&nbsp; - AS3 </h1>
							</td>
							<td class="titleTableSubNav" id="subNav" align="right">
								<a id="propertiesLink" href="Context3D.html#propertySummary" style="display:none"> 屬性 </a>
								<span id="propertiesBar" style="display:none"> | </span>
								<a id="packagePropertiesLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('propertySummary');" style="display:none"> 屬性 </a>
								<span id="packagePropertiesBar" style="display:none"> | </span>
								<a id="constructorLink" href="Context3D.html#top" onClick="javascript:titleBar_gotoClassFrameAnchor('constructorSummary');" style="display:none"> 建構函式 </a>
								<span id="constructorBar" style="display:none"> | </span>
								<a id="methodsLink" href="Context3D.html#methodSummary" style="display:none"> 方法 </a>
								<span id="methodsBar" style="display:none"> | </span>
								<a id="packageConstantsLink" href="Context3D.html#constantSummary" style="display:none"> 全域常數 </a>
								<span id="packageConstantsBar" style="display:none"> | </span>
								<a id="eventsLink" href="Context3D.html#eventSummary" style="display:none"> 事件 </a>
								<span id="eventsBar" style="display:none"> | </span>
								<a id="stylesLink" href="Context3D.html#styleSummary" style="display:none"> 樣式 </a>
								<span id="stylesBar" style="display:none"> | </span>
								<a id="SkinPartLink" href="Context3D.html#SkinPartSummary" style="display:none"> 外觀部件 </a>
								<span id="SkinPartBar" style="display:none"> | </span>
								<a id="SkinStateLink" href="Context3D.html#SkinStateSummary" style="display:none"> 外觀狀態 </a>
								<span id="SkinStateBar" style="display:none"> | </span>
								<a id="effectsLink" href="Context3D.html#effectSummary" style="display:none"> 特效 </a>
								<span id="effectsBar" style="display:none"> | </span>
								<a id="constantsLink" href="Context3D.html#constantSummary" style="display:none"> 常數 </a>
								<span id="constantsBar" style="display:none"> | </span>
								<a id="packageFunctionsLink" href="Context3D.html#methodSummary" style="display:none"> 全域函數 </a>
								<span id="packageFunctionsBar" style="display:none"> | </span>
								<a id="packageMethodFunctionsLink" href="Context3D.html#methodSummary" style="display:none">函數</a>
								<span id="packageMethodFunctionsBar" style="display:none"> | </span>
								<a id="interfacesLink" href="Context3D.html#interfaceSummary" style="display:none"> 介面 </a>
								<span id="interfacesBar" style="display:none"> | </span>
								<a id="classesLink" href="Context3D.html#classSummary" style="display:none"> 類別 </a>
								<span id="classesBar" style="display:none"> | </span>
								<a id="examplesLink" href="Context3D.html#includeExamplesSummary" style="display:none"> 範例 </a>
							</td>
						</tr>
						<tr class="titleTableRow3">
							<td colspan="4"></td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
		<div class="maincontainer" id="maincontainer" style="display:none">
			<div class="mainleft" id="toc">
				<div id="packagelist" class="packagelist"></div>
				<div class="h_splitter" id="h_splitter" onMouseDown="h_splitterMouseDown(event, this);" onMouseUp="h_splitterMouseUp(event);" onMouseMove="h_splitterMouseMove(event);"></div>
				<div id="classlist" class="classlist">
					<div id="classlistWrapper">
						<h4 id="classlisth4">
							<a id="cls_name" href="Context3D.html" target="_self" onclick="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" oncontextmenu="this.href=baseRef + 'class-summary.html';saveClassListScrollTop();" style="color:black">
								類別
							</a>
							<span id="cls_searchspan" style="display:none">
								<input type="text" id="cls_searchbox" onfocus="clsSearchBoxOnFocus();" onblur="clsSearchBoxOnBlur()" onkeyup="clsSearchOnKeyUp();">
								<span id="cls_clear_search" class="search_inactive" onclick="clsClearSearchButton()">x</span>
							</span>
						</h4>
						<div id="classlistoutline" class="classlistoutline"></div>
					</div>
				</div>
			</div>
			<div class="splitter" id="splitter" onMouseDown="splitterMouseDown(event, this);" onMouseUp="splitterMouseUp(event);" onMouseMove="splitterMouseMove(event);">
			</div>
			<!--oss:on--><div class="mainright" id="content">
				<div class="content"><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><table class="classHeaderTable" cellpadding="0" cellspacing="0"><tr><td class="classHeaderTableLabel">套件</td><td><a href="package-detail.html" onclick="javascript:loadClassListFrame('class-list.html')">flash.display3D</a></td></tr><tr><td class="classHeaderTableLabel">類別</td><td class="classSignature">public final   class  Context3D</td></tr><tr><td class="classHeaderTableLabel">繼承</td><td class="inheritanceList">Context3D  <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../events/EventDispatcher.html">EventDispatcher</a> <img src="../../images/inherit-arrow.gif" title="Inheritance" alt="Inheritance" class="inheritArrow"> <a href="../../Object.html">Object</a></td></tr></table><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p></p>
     Context3D 類別會提供用於顯示以幾何圖形定義之圖像的內容。
     
     <p>顯示內容包括繪製表面及其關聯的資源和狀態。如果可以，顯示內容會使用硬體圖像處理單元 (GPU)。否則，顯示內容會使用軟體 (如果平台不支援透過 Context3D 顯示，則 Stage 物件的 <code>stage3Ds</code> 屬性會包含空白清單)。</p>
     
               <p>Context3D 顯示內容是可程式化的管線，與 OpenGL ES 2 非常類似，但它是抽象的，因此與各種硬體和 GPU 介面相容。雖然專為 3D 圖像而設計，但是顯示管線不會將顯示視為三維。因此，您可以提供適當的頂點和像素片段程式，藉此建立 2D 輸出器。在 3D 和 2D 情況中，唯一支援的幾何基本圖形為三角形。</p>
     
               <p>透過呼叫 Stage3D 物件的 <code>requestContext3D()</code> 方法，取得 Context3D 類別的實體。每個舞台都有有限數目的 Context3D 物件；<code>Stage.stage3Ds</code> 清單中的每個 Stage3D 各有一個。當建立內容時，Stage3D 物件會傳送 <code>context3DCreate</code> 事件。顯示內容可以隨時移除再重新建立，例如，另一個使用 GPU 的應用程式取得焦點時。您的程式碼應預期會收到多個 <code>context3DCreate</code> 事件。請使用關聯 Stage3D 實體的 <code>x</code> 和 <code>y</code> 屬性，將顯示區域放置在舞台上。</p>  
     
     
     
     
               <p>若要顯示一個場景 (在取得 Context3D 物件之後)，通常會執行下列步驟：</p>
               <ol>
                  <li>呼叫 <code>configureBackBuffer()</code> 來設定主要顯示緩衝屬性。</li>
                  <li>建立並初始化您的顯示資源，包括：
      <ul>
                        <li>定義場景幾何的頂點和索引緩衝區</li>
                        <li>用於顯示場景的頂點和像素程式 (著色器)</li>
                        <li>紋理</li>
                     </ul>
                  </li>
                  <li>顯示影格：
      <ul>
                        <li>適時為場景中的物件或物件集合設定顯示狀態。</li>
                        <li>呼叫 <code>drawTriangles()</code> 方法來顯示一組三角形。</li>
                        <li>變更下一個物件群組的顯示狀態。</li>
                        <li>呼叫 <code>drawTriangles()</code> 來繪製定義物件的三角形。</li>
                        <li>重複執行，直到完整顯示場景為止。</li>
                        <li>呼叫 <code>present()</code> 方法，讓顯示的場景在舞台上顯示。</li>
                     </ul>
                  </li>
               </ol>
     
               <p>顯示時會套用下列限制：</p>
               <p>資源限制：
      <table class="innertable" ><tr><th>資源</th><th>允許的數目</th><th>記憶體總數</th></tr><tr><td>
                                 <code>頂點緩衝區</code>
                              </td><td>4096</td><td>256 MB</td></tr><tr><td>
                                 <code>索引緩衝區</code>
                              </td><td>4096</td><td>128 MB</td></tr><tr><td>
                                 <code>程式</code>
                              </td><td>4096</td><td>16 MB</td></tr><tr><td>
                                 <code>紋理</code>
                              </td><td>4096</td><td>128 MB</td></tr><tr><td>
                                 <code>立方體紋理</code>
                              </td><td>4096</td><td>256 MB</td></tr></table>
               </p>
               <p>AGAL 限制：每個程式各有 200 個 opcode。</p>
     
               <p>繪製呼叫限制：每個 <code>present()</code> 呼叫有 32,768 個 <code>drawTriangles()</code> 呼叫。</p>
               <p>下列限制會套用至紋理：</p>
               <p>AIR 32 位元的紋理限制:
      <table class="innertable" ><tr><th>紋理</th><th>大小上限</th><th>總計 GPU 記憶體</th></tr><tr><td>
                                 <code>一般紋理 (在延伸的基線之下)</code>
                              </td><td>2048x2048</td><td>512 MB</td></tr><tr><td>
                                 <code>一般紋理 (延伸的基線以及以上)</code>
                              </td><td>4096x4096</td><td>512 MB</td></tr><tr><td>
                                 <code>矩形紋理 (在延伸的基線之下)</code>
                              </td><td>2048x2048</td><td>512 MB</td></tr><tr><td>
                                 <code>矩形紋理 (延伸的基線以及以上)</code>
                              </td><td>4096x4096</td><td>512 MB</td></tr><tr><td>
                                 <code>立方體紋理</code>
                              </td><td>1024x1024</td><td>256 MB</td></tr></table>
	              </p> 
	              <p>AIR 64 位元的紋理限制 (桌上型電腦)：
      <table class="innertable" ><tr><th>紋理</th><th>大小上限</th><th>總計 GPU 記憶體</th></tr><tr><td>
                                 <code>一般紋理 (在延伸的基線之下)</code>
                              </td><td>2048x2048</td><td>512 MB</td></tr><tr><td>
                                 <code>一般紋理 (基線延伸到標準)</code>
                              </td><td>4096x4096</td><td>512 MB</td></tr><tr><td>
                                 <code>一般紋理 (延伸的標準以及以上)</code>
                              </td><td>4096x4096</td><td>2048 MB</td></tr><tr><td>
                                 <code>矩形紋理 (在延伸的基線之下)</code>
                              </td><td>2048x2048</td><td>512 MB</td></tr><tr><td>
                                 <code>矩形紋理 (基線延伸到標準)</code>
                              </td><td>4096x4096</td><td>512 MB</td></tr><tr><td>
                                 <code>矩形紋理 (延伸的標準以及以上)</code>
                              </td><td>4096x4096</td><td>2048 MB</td></tr><tr><td>
                                 <code>立方體紋理</code>
                              </td><td>1024x1024</td><td>256 MB</td></tr></table>
	              </p>
               <p>512 MB 是紋理的絕對限制，其中包括 MIP 映射所需的紋理記憶體。然而，立方體紋理的記憶體限制為 256 MB。</p>
     
               <p>您無法搭配 Context3D 建構函式建立 Context3D 物件。它是建構及做為 Stage3D 實體的屬性使用。Context3D 類別可以在桌上型電腦和行動裝置平台上使用，而且兩者皆在 Flash Player 和 AIR 中執行。</p>
         
            <p></p><p><a href="Context3D.html#includeExamplesSummary">檢視範例</a></p><p><span class="classHeaderTableLabel">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a><br/><a href="Context3DClearMask.html" target="">Context3DClearMask</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DProgramType.html" target="">Context3DProgramType</a><br/><a href="Context3DRenderMode.html" target="">Context3DRenderMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="textures/CubeTexture.html" target="">flash.display3D.textures.CubeTexture</a><br/><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a><br/><a href="../geom/Matrix3D.html" target="">flash.geom.Matrix3D</a><br/><a href="Program3D.html" target="">Program3D</a><br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a><br/><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a></div><br/><hr></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="propertySummary" id="propertySummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">公用屬性</div><div class="showHideLinks"><div id="hideInheritedProperty" class="hideInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(false,'Property');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 隱藏繼承公用屬性</a></div><div id="showInheritedProperty" class="showInheritedProperty"><a class="showHideLink" href="Context3D.html#propertySummary" onclick="javascript:setInheritedVisible(true,'Property');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 顯示繼承公用屬性</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableProperty"><tr><th>&nbsp;</th><th colspan="2">屬性</th><th>定義自</th></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferHeight" class="signatureLink">backBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[唯讀]  
        指定背景緩衝區的高度，成功呼叫 configureBackBuffer() 方法即可加以變更。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#backBufferWidth" class="signatureLink">backBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription">[唯讀]  
        指定背景緩衝區的寬度，成功呼叫 configureBackBuffer() 方法即可加以變更。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedProperty" runtime="Flash::9##Lite::4##AIR::1.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><a href="../../Object.html#constructor" class="signatureLink">constructor</a> : <a href="../../Object.html">Object</a><div class="summaryTableDescription">
	 類別物件的參照或是特定物件實體的建構函數。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#driverInfo" class="signatureLink">driverInfo</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[唯讀]  
         此顯示內容使用的圖形庫驅動程式類型。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#enableErrorChecking" class="signatureLink">enableErrorChecking</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription"> 
         指定是否要將輸出器遇到的錯誤回報給應用程式。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferHeight" class="signatureLink">maxBackBufferHeight</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        指定背景緩衝區的最大高度。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::15##AIR::15##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#maxBackBufferWidth" class="signatureLink">maxBackBufferWidth</a> : <a href="../../int.html">int</a><div class="summaryTableDescription"> 
        指定背景緩衝區的最大寬度。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::12##AIR::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#profile" class="signatureLink">profile</a> : <a href="../../String.html">String</a><div class="summaryTableDescription">[唯讀] 
		這個 Context3D 物件所使用的功能支援描述檔。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#supportsVideoTexture" class="signatureLink">supportsVideoTexture</a> : <a href="../../Boolean.html">Boolean</a><div class="summaryTableDescription">[靜態] [唯讀] 
          指出 Context3D 是否支援視訊紋理。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::21##AIR::21##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><a href="Context3D.html#totalGPUMemory" class="signatureLink">totalGPUMemory</a> : <a href="../../Number.html">Number</a><div class="summaryTableDescription">[唯讀]  
         傳回應用程式的 Stage3D 資料結構所配置的 GPU 記憶體總數。每當建立 GPU 資源物件時，所使用的記憶體都會儲存在 Context3D 中。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="methodSummary" id="methodSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">公用方法 </div><div class="showHideLinks"><div id="hideInheritedMethod" class="hideInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(false,'Method');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 隱藏繼承公用方法</a></div><div id="showInheritedMethod" class="showInheritedMethod"><a class="showHideLink" href="Context3D.html#methodSummary" onclick="javascript:setInheritedVisible(true,'Method');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 顯示繼承公用方法</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable " id="summaryTableMethod"><tr><th>&nbsp;</th><th colspan="2">方法</th><th>定義自</th></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#addEventListener()" class="signatureLink">addEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false, priority:<a href="../../int.html">int</a> = 0, useWeakReference:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	會在 EventDispatcher 物件註冊事件偵聽程式，以便讓偵聽程式收到事件的通知。</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#clear()" class="signatureLink">clear</a>(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         清除與此 Context3D 物件相關聯的顏色、深度和模板緩衝區，然後以指定的值填入那些緩衝區。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#configureBackBuffer()" class="signatureLink">configureBackBuffer</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定顯示緩衝區的檢視區域尺寸和其它屬性。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createCubeTexture()" class="signatureLink">createCubeTexture</a>(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></div><div class="summaryTableDescription">
         建立 CubeTexture 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createIndexBuffer()" class="signatureLink">createIndexBuffer</a>(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></div><div class="summaryTableDescription">
         建立 IndexBuffer3D 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createProgram()" class="signatureLink">createProgram</a>():<a href="Program3D.html">Program3D</a></div><div class="summaryTableDescription">
         建立 Program3D 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.8##AIR::3.8##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createRectangleTexture()" class="signatureLink">createRectangleTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></div><div class="summaryTableDescription">
         建立 Rectangle Texture 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createTexture()" class="signatureLink">createTexture</a>(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></div><div class="summaryTableDescription">
         建立 Texture 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVertexBuffer()" class="signatureLink">createVertexBuffer</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         建立 VertexBuffer3D 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#createVertexBufferForInstances()" class="signatureLink">createVertexBufferForInstances</a>(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></div><div class="summaryTableDescription">
         建立適用於實體資料的 VertexBuffer3D 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::17.0##Flash::18.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#createVideoTexture()" class="signatureLink">createVideoTexture</a>():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></div><div class="summaryTableDescription">
         建立 VideoTexture 物件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#dispatchEvent()" class="signatureLink">dispatchEvent</a>(event:<a href="../events/Event.html">Event</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	會將事件傳送到事件流程。</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#dispose()" class="signatureLink">dispose</a>(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         釋放與此 Context3D 關聯的所有資源和內部儲存空間。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawToBitmapData()" class="signatureLink">drawToBitmapData</a>(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         繪製目前顯示緩衝區的點陣圖。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#drawTriangles()" class="signatureLink">drawTriangles</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         請使用此 Context3D 物件的目前緩衝區和狀態來顯示指定的三角形。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::20.0##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#drawTrianglesInstanced()" class="signatureLink">drawTrianglesInstanced</a>(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         請使用此 Context3D 物件的目前緩衝區和狀態來顯示指定的實體化三角形。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#hasEventListener()" class="signatureLink">hasEventListener</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	會檢查 EventDispatcher 物件是否有對特定的事件類型註冊偵聽程式。</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#hasOwnProperty()" class="signatureLink">hasOwnProperty</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出物件是否有已定義的指定屬性。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#isPrototypeOf()" class="signatureLink">isPrototypeOf</a>(theClass:<a href="../../Object.html">Object</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出 Object 類別的實體是否位於指定為參數的物件原型鏈中。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#present()" class="signatureLink">present</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         顯示背景顯示緩衝區。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#propertyIsEnumerable()" class="signatureLink">propertyIsEnumerable</a>(name:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	 指出指定的屬性是否存在，以及是否可列舉。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#removeEventListener()" class="signatureLink">removeEventListener</a>(type:<a href="../../String.html">String</a>, listener:<a href="../../Function.html">Function</a>, useCapture:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
	會從 EventDispatcher 物件移除偵聽程式。</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setBlendFactors()" class="signatureLink">setBlendFactors</a>(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         指定用於將繪製作業的輸出顏色與現有顏色混合的係數。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setColorMask()" class="signatureLink">setColorMask</a>(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定將顏色寫入顯示緩衝區時所用的遮色片。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setCulling()" class="signatureLink">setCulling</a>(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定三角形剔除模式。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setDepthTest()" class="signatureLink">setDepthTest</a>(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定用於深度測試的比較類型。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="AIR::16##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;<a href="Context3D.html#setFillMode()" class="signatureLink">setFillMode</a>(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
		設定用於顯示的填色模式。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgram()" class="signatureLink">setProgram</a>(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定頂點和片段著色器程式，以供後續顯示使用。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.1##AIR::3.1##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromByteArray()" class="signatureLink">setProgramConstantsFromByteArray</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         使用 ByteArray 中儲存的值，設定著色器程式所使用的常數。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromMatrix()" class="signatureLink">setProgramConstantsFromMatrix</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         使用 Matrix3D 中儲存的值，設定著色器程式所使用的常數。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setProgramConstantsFromVector()" class="signatureLink">setProgramConstantsFromVector</a>(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定著色器程式的常數輸入。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#setPropertyIsEnumerable()" class="signatureLink">setPropertyIsEnumerable</a>(name:<a href="../../String.html">String</a>, isEnum:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
     為迴圈作業設定動態屬性的可用性。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToBackBuffer()" class="signatureLink">setRenderToBackBuffer</a>():<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定背景顯示緩衝區做為顯示目標。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setRenderToTexture()" class="signatureLink">setRenderToTexture</a>(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定指定的紋理做為顯示目標。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11.6##AIR::3.6##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setSamplerStateAt()" class="signatureLink">setSamplerStateAt</a>(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         手動覆寫紋理取樣程式狀態。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setScissorRectangle()" class="signatureLink">setScissorRectangle</a>(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定剪刀矩形，這是繪製遮色片類型。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilActions()" class="signatureLink">setStencilActions</a>(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         設定模板模式和作業。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setStencilReferenceValue()" class="signatureLink">setStencilReferenceValue</a>(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription"> 
         設定用於模板測試的模板比較值。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setTextureAt()" class="signatureLink">setTextureAt</a>(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         指定要用於片段程式之紋理輸出暫存器的紋理。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="" runtime="Flash::11##AIR::3##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol">&nbsp;</td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="Context3D.html#setVertexBufferAt()" class="signatureLink">setVertexBufferAt</a>(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></div><div class="summaryTableDescription">
         指定對應至單一頂點著色器程式輸入的頂點資料組件。</div></td><td class="summaryTableOwnerCol">Context3D</td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toLocaleString()" class="signatureLink">toLocaleString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 傳回代表此物件的字串，根據地區特定慣例進行格式化。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#toString()" class="signatureLink">toString</a>():<a href="../../String.html">String</a></div><div class="summaryTableDescription">
	 會傳回指定之物件的字串形式。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##AIR::1.0##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../../Object.html#valueOf()" class="signatureLink">valueOf</a>():<a href="../../Object.html">Object</a></div><div class="summaryTableDescription">
	 會傳回指定之物件的基本值。</div></td><td class="summaryTableOwnerCol"><a href="../../Object.html">Object</a></td></tr><tr class="hideInheritedMethod" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#willTrigger()" class="signatureLink">willTrigger</a>(type:<a href="../../String.html">String</a>):<a href="../../Boolean.html">Boolean</a></div><div class="summaryTableDescription">
	檢查此 EventDispatcher 物件是否已註冊事件偵聽程式，或者此物件的任何祖系已為特定事件類型註冊事件偵聽程式。</div></td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><a xmlns:xd="http://www.pnp-software.com/XSLTdoc" name="eventSummary" id="eventSummary"></a><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="summarySection"><div class="summaryTableTitle">事件</div><div class="showHideLinks"><a href="http://help.adobe.com/en_US/Flex/4.6/UsingSDK/WS2db454920e96a9e51e63e3d11c0bf69084-7ee9.html" target="_blank">按一下以瞭解事件的詳細資訊</a></div><div class="showHideLinks"><div id="hideInheritedEvent" class="hideInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(false,'Event');"><img class="showHideLinkImage" src="../../images/expanded.gif"> 隱藏繼承事件</a></div><div id="showInheritedEvent" class="showInheritedEvent"><a class="showHideLink" href="Context3D.html#eventSummary" onclick="javascript:setInheritedVisible(true,'Event');"><img class="showHideLinkImage" src="../../images/collapsed.gif"> 顯示繼承事件</a></div></div><table cellspacing="0" cellpadding="3" class="summaryTable hideInheritedEvent" id="summaryTableEvent"><tr><th>&nbsp;</th><th colspan="2">事件</th><th> 摘要 </th><th>定義自</th></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:activate" class="signatureLink">activate</a></div></td><td class="summaryTableDescription summaryTableCol">[廣播事件] 當 Flash Player 或 AIR 應用程式取得作業系統焦點並成為作用中時傳送。</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr><tr class="hideInheritedEvent" runtime="Flash::9##Lite::4##"><td class="summaryTablePaddingCol">&nbsp;</td><td class="summaryTableInheritanceCol"><img src="../../images/inheritedSummary.gif" alt="Inherited" title="Inherited" class="inheritedSummaryImage"></td><td class="summaryTableSignatureCol"><div class="summarySignature"><a href="../events/EventDispatcher.html#event:deactivate" class="signatureLink">deactivate</a></div></td><td class="summaryTableDescription summaryTableCol">[廣播事件] 當 Flash Player 或 AIR 應用程式失去作業系統焦點並成為非作用中時傳送。</td><td class="summaryTableOwnerCol"><a href="../events/EventDispatcher.html">EventDispatcher</a></td></tr></table></div><script xmlns:xd="http://www.pnp-software.com/XSLTdoc" language="javascript" type="text/javascript"><!--                      
                      showHideInherited();                      
                      --></script><div xmlns:xd="http://www.pnp-software.com/XSLTdoc" class="MainContent"><div class="detailSectionHeader">屬性詳細資訊</div><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferHeight" id="backBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferHeight</h3></td><td class="detailHeaderType">屬性</td></tr></table><div class="detailBody"><code>backBufferHeight:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        指定背景緩衝區的高度，成功呼叫 <code>configureBackBuffer()</code> 方法即可加以變更。在最後一次成功呼叫 <code>configureBackBuffer()</code> 方法中，如果 <code>wantsBestResolutionOnBrowserZoom</code> 設定為 <code>true</code>，則瀏覽器縮放係數變更時可能會修改高度。透過為瀏覽器縮放變更事件註冊事件偵聽程式，即可偵測高度的變更。
        
        </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferHeight():<a href="../../int.html">int</a></code><br/><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="backBufferWidth" id="backBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>backBufferWidth</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>backBufferWidth:<a href="../../int.html">int</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        指定背景緩衝區的寬度，成功呼叫 <code>configureBackBuffer()</code> 方法即可加以變更。在最後一次成功呼叫 <code>configureBackBuffer()</code> 方法中，如果 <code>wantsBestResolutionOnBrowserZoom</code> 設定為 <code>true</code>，則瀏覽器縮放係數變更時可能會修改寬度。透過為瀏覽器縮放變更事件註冊事件偵聽程式，即可偵測寬度的變更。
		
		</p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get backBufferWidth():<a href="../../int.html">int</a></code><br/><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#configureBackBuffer" target="">configureBackBuffer</a><br/><a href="../events/Event.html#BROWSER_ZOOM_CHANGE" target="">flash.events.Event.BROWSER_ZOOM_CHANGE</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="driverInfo" id="driverInfo"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>driverInfo</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>driverInfo:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         此顯示內容使用的圖形庫驅動程式類型。指出要使用 DirectX 驅動程式或是使用 OpenGL 驅動程式來顯示。同時指出硬體顯示是否失敗。如果硬體顯示失敗，則 Flash Player 會為 Stage3D 使用軟體顯示，並且 <code>driverInfo</code> 會包含下列其中一個值：
         <ul><li>「Software Hw_disabled=userDisabled」：未選取 Adobe Flash Player「設定 UI」中的「啟用硬體加速」核取方塊。</li><li>「Software Hw_disabled=oldDriver」：硬體圖形驅動程式發生已知問題。更新圖形驅動程式或許可以修正這個問題。</li><li>「Software Hw_disabled=unavailable」：硬體圖形驅動程式發生已知問題，或者硬體圖形初始化失敗。</li><li>「Software Hw_disabled=explicit」：內容已明確透過 requestContext3D 要求軟體顯示。</li><li>「Software Hw_disabled=domainMemory」：內容使用 domainMemory，但後者需要授權才能與 Stage3D 硬體顯示搭配使用。請造訪 <a href="http://www.adobe.com/go/fpl" target="_new">adobe.com/go/fpl_tw</a>。</li></ul>
         
         </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get driverInfo():<a href="../../String.html">String</a></code><br/></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="propertyDetail" id="propertyDetail"></a><a name="enableErrorChecking" id="enableErrorChecking"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>enableErrorChecking</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>enableErrorChecking:<a href="../../Boolean.html">Boolean</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         指定是否要將輸出器遇到的錯誤回報給應用程式。
          
         <p>當 <code>enableErrorChecking</code> 為 <code>true</code> 時，<code>clear()</code> 和 <code>drawTriangles()</code> 方法是同步的，並且可以擲回錯誤。當 <code>enableErrorChecking</code> 為 <code>false</code> 時，預設值、<code>clear()</code> 和 <code>drawTriangles()</code> 方法是非同步的，而且不會報告錯誤。啟用錯誤檢查功能會降低顯示效能。請只在除錯時啟用錯誤檢查功能。</p>
         
         </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get enableErrorChecking():<a href="../../Boolean.html">Boolean</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set enableErrorChecking(value:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><br/><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a></div></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferHeight" id="maxBackBufferHeight"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferHeight</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferHeight:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        指定背景緩衝區的最大高度。初始值是平台的系統限制。屬性可以設定為小於或等於但不大於系統限制的值。屬性可以設定為大於或等於但不小於最小限制的值。未設定背景緩衝區時，最小限制為常數值 32。設定背景緩衝區之後，最小限制會是最後一次成功呼叫 <code>configureBackBuffer()</code> 方法中的高度參數值。
        
        </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferHeight():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferHeight(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::15##AIR::15##"><a name="propertyDetail" id="propertyDetail"></a><a name="maxBackBufferWidth" id="maxBackBufferWidth"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>maxBackBufferWidth</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>maxBackBufferWidth:<a href="../../int.html">int</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 15, AIR 15</td></tr></table><p></p><p></p><p> 
        指定背景緩衝區的最大寬度。初始值是平台的系統限制。屬性可以設定為小於或等於但不大於系統限制的值。屬性可以設定為大於或等於但不小於最小限制的值。未設定背景緩衝區時，最小限制為常數值 32。設定背景緩衝區之後，最小限制會是最後一次成功呼叫 <code>configureBackBuffer()</code> 方法中的寬度參數值。
		
        </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get maxBackBufferWidth():<a href="../../int.html">int</a></code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function set maxBackBufferWidth(value:<a href="../../int.html">int</a>):<a href="../../specialTypes.html#void">void</a></code><br/></div></span><span id="pageFilter" runtime="Flash::12##AIR::4##"><a name="propertyDetail" id="propertyDetail"></a><a name="profile" id="profile"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>profile</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>profile:<a href="../../String.html">String</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 12, AIR 4</td></tr></table><p></p><p></p><p>
		這個 Context3D 物件所使用的功能支援描述檔。
		</p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get profile():<a href="../../String.html">String</a></code><br/><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DProfile.html" target="">Context3DProfile</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="propertyDetail" id="propertyDetail"></a><a name="supportsVideoTexture" id="supportsVideoTexture"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>supportsVideoTexture</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>supportsVideoTexture:<a href="../../Boolean.html">Boolean</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
          指出 Context3D 是否支援視訊紋理。
         
          </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public static function get supportsVideoTexture():<a href="../../Boolean.html">Boolean</a></code><br/></div></span><span id="pageFilter" runtime="Flash::21##AIR::21##"><a name="propertyDetail" id="propertyDetail"></a><a name="totalGPUMemory" id="totalGPUMemory"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>totalGPUMemory</h3></td><td class="detailHeaderType">屬性</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code>totalGPUMemory:<a href="../../Number.html">Number</a></code>&nbsp;&nbsp;[唯讀] <p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 21, AIR 21</td></tr></table><p></p><p></p><p> 
         <p>傳回應用程式的 Stage3D 資料結構所配置的 GPU 記憶體總數。</p>
		 <p>每當建立 GPU 資源物件時，所使用的記憶體都會儲存在 Context3D 中。這個記憶體包括索引緩衝區、頂點緩衝區，以及透過這個 Context3D 所建立的紋理 (不包括視訊紋理) 和程式。</p>
		 <p>API <code>totalGPUMemory</code> 會傳回上述資源為使用者所耗用的記憶體總數。傳回的預設值為 0。傳回的 GPU 記憶體總數以位元組計算。資訊僅以行動裝置上的直接模式，以及桌上型電腦上的直接模式和 GPU 模式提供 (在桌上型電腦上，使用 <code>&lt;renderMode&gt;gpu&lt;/renderMode&gt;</code> 將會回復至 <code>&lt;renderMode&gt;direct&lt;/renderMode&gt;</code>)。 </p>
		 
         當 SWF 版本為 32 以上版本時，可以使用這個 API。
         
         
         </p><br/><br/><span class="label"> 實作 </span><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;public function get totalGPUMemory():<a href="../../Number.html">Number</a></code><br/></div></span><a name="methodDetail" id="methodDetail"></a><div class="detailSectionHeader">方法詳細資訊</div><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="clear()" id="clear()"></a><a name="clear(Number,Number,Number,Number,Number,uint,uint)" id="clear(Number,Number,Number,Number,Number,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>clear</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td></tr></table><div class="detailBody"><code> public function clear(red:<a href="../../Number.html">Number</a> = 0.0, green:<a href="../../Number.html">Number</a> = 0.0, blue:<a href="../../Number.html">Number</a> = 0.0, alpha:<a href="../../Number.html">Number</a> = 1.0, depth:<a href="../../Number.html">Number</a> = 1.0, stencil:<a href="../../uint.html">uint</a> = 0, mask:<a href="../../uint.html">uint</a> = 0xffffffff):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         清除與此 Context3D 物件相關聯的顏色、深度和模板緩衝區，然後以指定的值填入那些緩衝區。
         
         <p>設定 <code>mask</code> 參數，以指定要清除的緩衝區。使用 Context3DClearMask 類別中定義的常數可設定 <code>mask</code> 參數。使用位元 OR 運算子「|」，可以將多個緩衝區加入遮色片 (或使用 <code>Context3DClearMask.ALL</code>)。當顯示到背景緩衝區時，<code>configureBackBuffer()</code> 方法必須在任何 <code>clear()</code> 呼叫之前呼叫。</p>
         
         <p><b>注意：</b>如果您指定允許的範圍以外的參數值，Numeric 參數值就會以無訊息方式緊縮為範圍零到一。同樣地，如果 <code>stencil</code> 大於 0xff，就設定為 0xff。 </p> 
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 要清除顏色緩衝區之顏色的紅色組件，範圍為零到一。         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 要清除顏色緩衝區之顏色的綠色組件，範圍為零到一。  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Number.html">Number</a></code> (default = <code>0.0</code>)<code></code> &mdash; 要清除顏色緩衝區之顏色的藍色組件，範圍為零到一。  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; 要清除顏色緩衝區之顏色的 Alpha 組件，範圍為零到一。Alpha 組件非使用於混合。會直接將其寫入緩衝區 Alpha。        
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">depth</span>:<a href="../../Number.html">Number</a></code> (default = <code>1.0</code>)<code></code> &mdash; 要清除深度緩衝區的值，範圍為零到一。  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">stencil</span>:<a href="../../uint.html">uint</a></code> (default = <code>0</code>)<code></code> &mdash; 要清除模板緩衝區的 8 位元值，範圍為 0x00 到 0xff。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mask</span>:<a href="../../uint.html">uint</a></code> (default = <code>0xffffffff</code>)<code></code> &mdash; 指定要清除的緩衝區。
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DClearMask.html" target="">Context3DClearMask</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="configureBackBuffer()" id="configureBackBuffer()"></a><a name="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)" id="configureBackBuffer(int,int,int,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>configureBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function configureBackBuffer(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, antiAlias:<a href="../../int.html">int</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = true, wantsBestResolution:<a href="../../Boolean.html">Boolean</a> = false, wantsBestResolutionOnBrowserZoom:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定顯示緩衝區的檢視區域尺寸和其它屬性。
         
         <p>顯示經過雙重緩衝。呼叫 <code>present()</code> 方法時，背景緩衝區會替換為可見的前景緩衝區。緩衝區的大小下限為 32x32 像素。背景緩衝區的大小上限會依裝置功能而有所限制，並且也可以由使用者透過屬性 <code>maxBackBufferWidth</code> 和 <code>maxBackBufferHeight</code> 加以設定。設定緩衝區作業很慢。請避免在一般顯示作業期間變更緩衝區大小或屬性。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 緩衝區的寬度 (以像素為單位)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 緩衝區的高度 (以像素為單位)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> &mdash; 指定所要求消除鋸齒品質的整數值。使用消除鋸齒時，值會關聯至子樣本的數目。雖然相對效能衝擊取決於特定的顯示硬體，但是若要使用更多子樣本，還是必須執行更多計算。消除鋸齒類型以及是否執行消除鋸齒，完全取決於裝置和顯示模式。軟體顯示內容完全不支援消除鋸齒。
         
         <table class="+ topic/table adobe-d/adobetable " ><tr><td>0</td><td>不消除鋸齒</td></tr><tr><td>2</td><td>最小消除鋸齒</td></tr><tr><td>4</td><td>高品質消除鋸齒</td></tr><tr><td>16</td><td>極佳品質消除鋸齒</td></tr></table>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code> &mdash; <code>false</code> 指出不建立深度或模板緩衝區，<code>true</code> 將建立深度和模板緩衝區。若是以 SWF 版本 15 或更新版本編譯的 AIR 3.2 或更新版本應用程式，如果應用程式描述器檔案中的 <code>renderMode</code> 元素是 <code>direct</code>，則應用程式描述器檔案中的 <code>depthAndStencil</code> 元素必須具有與這個引數相同的值。根據預設，<code>depthAndStencil</code> 元素的值是 <code>false</code>。
		 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolution</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code> 表示，如果裝置支援 HiDPI 螢幕，將會嘗試配置相較於寬度和高度參數所標示更大的背景緩衝區。由於這會增加更多像素，並且可能會改變著色器作業的結果，因此，預設是關閉的。請使用 Stage.contentsScaleFactor 判斷原生背景緩衝區放大了多少。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wantsBestResolutionOnBrowserZoom</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; <code>true</code> 表示背景緩衝區的大小應依瀏覽器縮放係數增加的比例而增加。這個值的設定在多個瀏覽器縮放間具有持續性。參數的預設值是 <code>false</code>。設定 <code>maxBackBufferWidth</code> 和 <code>maxBackBufferHeight</code> 屬性可以限制背景緩衝區大小的增加。使用 <code>backBufferWidth</code> 和 <code>backBufferHeight</code> 即可判斷背景緩衝區的目前大小。
		 
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 輸入大小錯誤：width 或 height 參數小於允許的背景緩衝區大小下限，或大於允許的背景緩衝區大小上限。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3709：應用程式描述器中的 <code>depthAndStencil</code> 旗標必須符合傳遞至 Context3D 物件之 <code>configureBackBuffer()</code> 的 <code>enableDepthAndStencil</code> Boolean。
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createCubeTexture()" id="createCubeTexture()"></a><a name="createCubeTexture(int,String,Boolean,int)" id="createCubeTexture(int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createCubeTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createCubeTexture(size:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         建立 CubeTexture 物件。
         
         <p>使用 CubeTexture 物件可以將立方體紋理點陣圖上傳到顯示內容，也可以在顯示期間參考立方體紋理。一個立方體紋理包含六個相等大小的矩形紋理，這些紋理在立方體拓撲中排列，並可用來說明環境對應。</p>
           
         <p>您無法搭配 CubeTexture 建構函式建立 CubeTexture 物件；請改用這個方法。建立 CubeTexture 物件之後，請使用 CubeTexture <code>uploadFromBitmapData()</code>、<code>uploadFromByteArray()</code> 或 <code>uploadCompressedTextureFromByteArray()</code> 方法上傳紋理點陣圖資料。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">size</span>:<a href="../../int.html">int</a></code> &mdash; 以紋理為單位表示的紋理邊緣長度。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 列舉清單的紋理格式。
         <p> 紋理壓縮可讓您以壓縮格式直接將紋理影像儲存在 GPU 上，以便節省 GPU 記憶體和記憶體頻寬。一般來說，壓縮的紋理是以使用 Texture.uploadCompressedTextureFromByteArray 方法的壓縮格式離線壓縮後上傳到 GPU。桌面平台上的 Flash Player 11.4 和 AIR 3.4 已為執行階段紋理壓縮新增支援，在特定情況下，例如顯示向量圖像中的動態紋理時，此壓縮會很有用。請注意，行動平台目前並未提供這項功能，因此，將改為擲回 ArgumentError (紋理格式不相符)。若要使用執行階段紋理壓縮，請執行下列步驟：1. 呼叫 Context3D.createCubeTexture() 方法、以格式參數傳遞 flash.display3D.Context3DTextureFormat.COMPRESSED 或 flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA，藉此建立紋理物件。2. 使用 createCubeTexture() 所傳回的 flash.display3D.textures.Texture 實體，呼叫 flash.display3D.textures.CubeTexture.uploadFromBitmapData() 或 flash.display3D.textures.CubeTexture.uploadFromByteArray()，以一個步驟上傳並壓縮紋理。
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 如果紋理可能當做顯示目標使用，則設為 <code>true</code>。         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 必須在影像顯示之前載入的 MIP 對應層級。「紋理串流」能優先載入並顯示最小的 MIP 層級，然後以漸進方式一邊載入紋理一邊顯示品質較高的影像。使用者可以一邊在應用程式中檢視品質較低的影像，一邊載入品質較高的影像。
         <p>根據預設，streamingLevels 為 0，這表示 MIP 對應中最高品質的影像必須在影像顯示之前載入。這個參數是 Flash Player 11.3 及 AIR 3.3 中新增的參數。使用預設值會維持 Flash Player 及 AIR 先前版本的行為。 
         </p>
         <p>將 <code>streamingLevels</code> 設定成介於 1 和 MIP 對應中影像數目之間的值，則可啟用紋理串流。舉例來說，您的 MIP 對應包含具有最高品質 64x64 像素的主要影像。MIP 對應中較低品質的影像為 32x32、16x16、8x8、4x4、2x2 和 1x1 像素，總共 7 個影像或 7 個層級。層級 0 是最高品質的影像。這個屬性的最大值為 log2(min(width,height))。因此，以 64x64 像素的主要影像來說，<code>streamingLevels</code> 的最大值為 7。將這個屬性設定為 3，即可在 8x8 像素影像載入後顯示影像。</p>
         
         <p><b>注意：</b>將這個屬性設定為大於 0 的值可能會影響記憶體用量和效能。 </p>
         
         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/CubeTexture.html">flash.display3D.textures:CubeTexture</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多 Texture 物件，或是超過配置給紋理的記憶體數量。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 未實作深度紋理：嘗試建立深度紋理。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理大小為零：<code>size</code> 參數不大於零。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理非 2 的倍數：<code>size</code> 參數不是 2 的倍數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理太大：<code>size</code> 參數大於 1024。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理建立失敗：無法利用顯示內容建立 CubeTexture 物件 (但沒有其原因的相關資訊)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 無效的串流層級：<code>streamingLevels</code> 大於或等於 log2(size)。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createIndexBuffer()" id="createIndexBuffer()"></a><a name="createIndexBuffer(int,String)" id="createIndexBuffer(int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createIndexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createIndexBuffer(numIndices:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="IndexBuffer3D.html">IndexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         建立 IndexBuffer3D 物件。
         
         <p>使用 IndexBuffer3D 物件可以將一組三角形索引上傳到顯示內容，並且參考該索引進行顯示。索引緩衝區中的每個索引會參考頂點緩衝區中的對應頂點。透過每組三個索引，可識別出三角形。將 IndexBuffer3D 物件傳遞到 <code>drawTriangles()</code> 方法，即可顯示索引緩衝區中定義的一或多個三角形。</p>
         
         <p>您無法搭配 IndexBuffer3D 類別建構函式建立 IndexBuffer3D 物件；請改用這個方法。建立 IndexBuffer3D 物件之後，請使用 IndexBuffer3D <code>uploadFromVector()</code> 或 <code>uploadFromByteArray()</code> 方法上傳索引。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numIndices</span>:<a href="../../int.html">int</a></code> &mdash; 要在緩衝區中儲存的頂點數目。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 預期的緩衝區使用量。使用 <code>Context3DBufferUsage</code> 中定義的其中一個常數。當您設定正確時，硬體驅動程式可以達到適當的最佳化。這個參數僅在 Flash 12/AIR 4 之後的版本中提供。
 
         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="IndexBuffer3D.html">IndexBuffer3D</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多索引緩衝區，或是超過配置給索引緩衝區的記憶體數量。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區太大：<code>numIndices</code> 大於或等於 0xf0000。 
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="IndexBuffer3D.html" target="">IndexBuffer3D</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createProgram()" id="createProgram()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createProgram():<a href="Program3D.html">Program3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         建立 Program3D 物件。
         
         <p>使用 Program3D 物件可以將著色器程式上傳到顯示內容，也可以在顯示期間參考上傳的程式。Program3D 物件會儲存兩個程式，分別為頂點程式和片段程式 (又稱為像素程式)。將以二進位著色器組合語言編寫這些程式。</p>
         
         <p>您無法搭配 Program3D 建構函式建立 Program3D 物件；請改用這個方法。建立 Program3D 物件之後，請使用 Program3D <code>upload()</code> 方法上傳程式。</p>
         
         </p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="Program3D.html">Program3D</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 程式數目超過 4096 個，或者記憶體總數超過 16MB (使用 <code>dispose</code> 可釋放 Program3D 資源)。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Program3D.html" target="">Program3D</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 此範例說明如何建立、上傳及啟用顯示內容的一組頂點與像素程式。請注意，<code>renderContext</code> 物件是 Context3D 類別的實體。範例中的程式是使用 Adobe Graphics Assembly Language (AGAL) 所撰寫。 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.8##AIR::3.8##"><a name="createRectangleTexture()" id="createRectangleTexture()"></a><a name="createRectangleTexture(int,int,String,Boolean)" id="createRectangleTexture(int,int,String,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createRectangleTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createRectangleTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>):<a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.8, AIR 3.8</td></tr></table><p></p><p></p><p>
         建立 Rectangle Texture 物件。
         
         <p>使用 RectangleTexture 物件可以將紋理點陣圖上傳到顯示內容，也可以在顯示期間參考紋理。</p>
         
         <p>您無法搭配 RectangleTexture 建構函式建立 RectangleTexture 物件；請改用這個方法。建立 RectangleTexture 物件之後，請使用 Texture <code>uploadFromBitmapData()</code> 或 <code>uploadFromByteArray()</code> 方法上傳紋理點陣圖。</p>
         
         <p>請注意，會以符合 Flash <code>BitmapData</code> 格式的封裝 BGRA 格式來儲存 32 位元整數紋理。浮點數紋理使用慣用的 RGBA 格式。 </p>
         
         <p> 矩形紋理不同於一般 2D 紋理，因為它的寬度和高度不一定要是 2 的次方。此外，矩形紋理不包含 MIP 對應。在顯示紋理時，矩形紋理是最有用的。如果矩形紋理與使用 MIP 對應篩選或重複換行的取樣程式搭配使用，drawTriangles 呼叫將會失敗。此外，矩形紋理也不允許使用串流。矩形紋理支援的紋理格式為 BGRA、BGR_PACKED、BGRA_PACKED。矩形紋理不支援壓縮的紋理格式。
         </p>
                 
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 以紋理為單位表示的紋理寬度。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 以紋理為單位表示的紋理高度。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 列舉清單的紋理格式。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 如果紋理可能當做顯示目標使用，則設為 <code>true</code>。                 
                                   
         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/RectangleTexture.html">flash.display3D.textures:RectangleTexture</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多 Texture 物件，或是超過配置給紋理的記憶體數量。         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理大小為零：<code>width</code> 或 <code>height</code> 參數兩者均不大於零。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理太大：<code>width</code> 或 <code>height</code> 參數大於 2048。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理建立失敗：無法利用顯示內容建立 Texture 物件 (但沒有其原因的相關資訊)。  
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 需要基線描述檔或更高版本：矩形紋理是以基線限制描述檔建立的。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createTexture()" id="createTexture()"></a><a name="createTexture(int,int,String,Boolean,int)" id="createTexture(int,int,String,Boolean,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createTexture(width:<a href="../../int.html">int</a>, height:<a href="../../int.html">int</a>, format:<a href="../../String.html">String</a>, optimizeForRenderToTexture:<a href="../../Boolean.html">Boolean</a>, streamingLevels:<a href="../../int.html">int</a> = 0):<a href="textures/Texture.html">flash.display3D.textures:Texture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         建立 Texture 物件。
         
         <p>使用 Texture 物件可以將紋理點陣圖上傳到顯示內容，也可以在顯示期間參考紋理。</p>
         
         <p>您無法搭配 Texture 建構函式建立 Texture 物件；請改用這個方法。建立 Texture 物件之後，請使用 Texture <code>uploadFromBitmapData()</code>、<code>uploadFromByteArray()</code> 或 <code>uploadCompressedTextureFromByteArray()</code> 方法上傳紋理點陣圖。</p>
         
         <p>請注意，會以符合 Flash <code>BitmapData</code> 格式的封裝 BGRA 格式來儲存 32 位元整數紋理。浮點數紋理使用慣用的 RGBA 格式。 </p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">width</span>:<a href="../../int.html">int</a></code> &mdash; 以紋理為單位表示的紋理寬度。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">height</span>:<a href="../../int.html">int</a></code> &mdash; 以紋理為單位表示的紋理高度。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> &mdash; Context3DTextureFormat 列舉清單的紋理格式。
         <p> 紋理壓縮可讓您以壓縮格式直接將紋理影像儲存在 GPU 上，以便節省 GPU 記憶體和記憶體頻寬。一般來說，壓縮的紋理是以使用 Texture.uploadCompressedTextureFromByteArray 方法的壓縮格式離線壓縮後上傳到 GPU。桌面平台上的 Flash Player 11.4 和 AIR 3.4 已為執行階段紋理壓縮新增支援，在特定情況下，例如顯示向量圖像中的動態紋理時，此壓縮會很有用。請注意，行動平台目前並未提供這項功能，因此，將改為擲回 ArgumentError (紋理格式不相符)。若要使用執行階段紋理壓縮，請執行下列步驟：1. 呼叫 Context3D.createTexture() 方法、以格式參數傳遞 flash.display3D.Context3DTextureFormat.COMPRESSED 或 flash.display3D.Context3DTextureFormat.COMPRESSED_ALPHA，藉此建立紋理物件。2. 使用 createTexture() 所傳回的 flash.display3D.textures.Texture 實體，呼叫 flash.display3D.textures.Texture.uploadFromBitmapData() 或 flash.display3D.textures.Texture.uploadFromByteArray()，以一個步驟上傳並壓縮紋理。
         </p>
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">optimizeForRenderToTexture</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 如果紋理可能當做顯示目標使用，則設為 <code>true</code>。         
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">streamingLevels</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 必須在影像顯示之前載入的 MIP 對應層級。「紋理串流」能優先載入並顯示最小的 MIP 層級，然後以漸進方式一邊載入紋理一邊顯示品質較高的影像。使用者可以一邊在應用程式中檢視品質較低的影像，一邊載入品質較高的影像。
         <p>根據預設，streamingLevels 為 0，這表示 MIP 對應中最高品質的影像必須在影像顯示之前載入。這個參數是 Flash Player 11.3 及 AIR 3.3 中新增的參數。使用預設值會維持 Flash Player 及 AIR 先前版本的行為。 
         </p>
         <p>將 <code>streamingLevels</code> 設定成介於 1 和 MIP 對應中影像數目之間的值，則可啟用紋理串流。舉例來說，您的 MIP 對應包含具有最高品質 64x64 像素的主要影像。MIP 對應中較低品質的影像為 32x32、16x16、8x8、4x4、2x2 和 1x1 像素，總共 7 個影像或 7 個層級。層級 0 是最高品質的影像。這個屬性的最大值為 log2(min(width,height))。因此，以 64x64 像素的主要影像來說，<code>streamingLevels</code> 的最大值為 7。將這個屬性設定為 3，即可在 8x8 像素影像載入後顯示影像。</p>
         
         <p><b>注意：</b>將這個屬性設定為大於 0 的值可能會影響記憶體用量和效能。 </p>
         
         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/Texture.html">flash.display3D.textures:Texture</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多 Texture 物件，或是超過配置給紋理的記憶體數量。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 未實作深度紋理：嘗試建立深度紋理。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理大小為零：<code>width</code> 或 <code>height</code> 參數兩者均不大於零。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理非 2 的倍數：<code>width</code> 與 <code>height</code> 參數不是 2 的倍數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 紋理太大：<code>width</code> 或 <code>height</code> 參數大於基線的 2048 和基線限制描述檔，或者 <code>width</code> 或 <code>height</code> 參數大於延伸以上的描述檔基線的 4096。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理建立失敗：無法利用顯示內容建立 Texture 物件 (但沒有其原因的相關資訊)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 無效的串流層級：<code>streamingLevels</code> 大於或等於 log2(min(width,height))。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DTextureFormat.html" target="">Context3DTextureFormat</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="createVertexBuffer()" id="createVertexBuffer()"></a><a name="createVertexBuffer(int,int,String)" id="createVertexBuffer(int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVertexBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBuffer(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         建立 VertexBuffer3D 物件。
         
         <p>使用 VertexBuffer3D 物件可以將一組頂點資料上傳到顯示內容。頂點緩衝區包含要在場景幾何中顯示每個點時所需的資料。與每個頂點關聯的資料屬性通常包含位置、顏色和紋理座標，並且可當做頂點著色器程式的輸入。使用 <code>setVertexBufferAt()</code> 方法可以識別對應至其中一個頂點程式輸入的資料值。每個頂點最多可以指定 64 個 32 位元值。</p>
         
         <p>您無法搭配 VertexBuffer3D 建構函式建立 VertexBuffer3D 物件；請改用這個方法。建立 VertexBuffer3D 物件之後，請使用 VertexBuffer3D <code>uploadFromVector()</code> 或 <code>uploadFromByteArray()</code> 方法上傳頂點資料。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; 要在緩衝區中儲存的頂點數目。單一緩衝區中的頂點數上限為 65535。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; 每一個頂點相關的 32 位元 (4 位元組) 資料值數目。每個頂點的 32 位元資料元素數目為 64 (或 256 位元組)。請注意，一個頂點著色器程式任何時間都只能存取 8 個屬性暫存器。使用 <code>SetVertextBufferAt()</code> 可選取頂點緩衝區內的屬性。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 預期的緩衝區使用量。使用 <code>Context3DBufferUsage</code> 中定義的其中一個常數。當您設定正確時，硬體驅動程式可以達到適當的最佳化。這個參數僅在 Flash 12/AIR 4 之後的版本中提供

         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多頂點緩衝區，或是超過配置給頂點緩衝區的記憶體數量。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區太大：<code>numVertices</code> 大於 0x10000 或 <code>data32PerVertex</code> 大於 64。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區大小為零：<code>numVertices</code> 為零，或是 <code>data32PerVertex</code> 為零。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區建立失敗：無法利用顯示內容建立 VertexBuffer3D 物件 (但沒有其原因的其他相關資訊)。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例說明如何建立和載入頂點資料緩衝區。在此範例中，緩衝區的每個頂點都包含兩種資料類型：位置 (例如 x、y、z) 與顏色 (例如 RGB 組件)。建立頂點緩衝區之後，此範例會呼叫 <code>setVertexBufferAt()</code> 方法，指定將前三個資料點傳遞給頂點程式，做為 va0 的 3 個浮點值，並傳遞次三個資料點做為 va1。頂點程式 (也稱為頂點屬性暫存器) 最多可有 8 個輸入，定義如下。
<div class="listing"><pre>
const dataPerVertex:int = 6;
var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
    [
      // x, y, z    r, g, b format
         0, 0, 0,   1, 1, 1,
        -1, 1, 0,   0, 0,.5,
         1, 1, 0,   0, 0, 1,
         1,-1, 0,  .5, 0, 0,
        -1,-1, 0,   1, 0, 0
    ]
);
var vertexes:VertexBuffer3D = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
//Identify vertex data inputs for vertex program
renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va0 as the position data
renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //Defines shader input va1 as the color data
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="createVertexBufferForInstances()" id="createVertexBufferForInstances()"></a><a name="createVertexBufferForInstances(int,int,int,String)" id="createVertexBufferForInstances(int,int,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;createVertexBufferForInstances</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVertexBufferForInstances(numVertices:<a href="../../int.html">int</a>, data32PerVertex:<a href="../../int.html">int</a>, instancesPerElement:<a href="../../int.html">int</a>, bufferUsage:<a href="../../String.html">String</a> = "staticDraw"):<a href="VertexBuffer3D.html">VertexBuffer3D</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         建立適用於實體資料的 VertexBuffer3D 物件。
         
         <p>使用 VertexBuffer3D 物件可以將一組實體資料上傳到顯示內容。頂點緩衝區包含要在場景幾何中顯示每個實體時所需的資料。含有實體資料的頂點緩衝區提供實體的所有頂點都適用的特質，並且可當做頂點著色器程式的輸入。使用 <code>setVertexBufferAt()</code> 方法可以識別對應至其中一個頂點程式輸入的資料值。每個頂點緩衝區的元素最多可以指定 64 個 32 位元值。</p>
         
         <p>您無法搭配 VertexBuffer3D 建構函式建立 VertexBuffer3D 物件；請改用這個方法。建立 VertexBuffer3D 物件之後，請使用 VertexBuffer3D <code>uploadFromVector()</code> 或 <code>uploadFromByteArray()</code> 方法上傳頂點資料。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">numVertices</span>:<a href="../../int.html">int</a></code> &mdash; 要在緩衝區中儲存的元素數目。單一緩衝區中的元素數上限為 65535。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data32PerVertex</span>:<a href="../../int.html">int</a></code> &mdash; 每一個元素相關的 32 位元 (4 位元組) 資料值數目。每個頂點的 32 位元資料元素數目為 64 (或 256 位元組)。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">instancesPerElement</span>:<a href="../../int.html">int</a></code> &mdash; 將使用頂點緩衝區其中一個元素的實體數目。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferUsage</span>:<a href="../../String.html">String</a></code> (default = "<code>staticDraw</code>")<code></code> &mdash; 預期的緩衝區使用量。使用 <code>Context3DBufferUsage</code> 中定義的其中一個常數。當您設定正確時，硬體驅動程式可以達到適當的最佳化。這個參數僅在 Flash 12/AIR 4 之後的版本中提供
         
         </td></tr></table></p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="VertexBuffer3D.html">VertexBuffer3D</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多頂點緩衝區，或是超過配置給頂點緩衝區的記憶體數量。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區太大：<code>numVertices</code> 大於 0x10000 或 <code>data32PerVertex</code> 大於 64。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區大小為零：<code>numVertices</code> 為零，或是 <code>data32PerVertex</code> 為零。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 緩衝區建立失敗：無法利用顯示內容建立 VertexBuffer3D 物件 (但沒有其原因的其他相關資訊)。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 需要標準延伸描述檔或以上版本：當要求的描述檔版本低於標準延伸描述檔時，呼叫這個方法。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的 Instances Per Element：instancesPerElement 未大於零。
         
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="VertexBuffer3D.html" target="">VertexBuffer3D</a><br/><a href="Context3D.html#setVertexBufferAt()" target="">setVertexBufferAt()</a></div></div></span><span id="pageFilter" runtime="AIR::17.0##Flash::18.0##"><a name="createVideoTexture()" id="createVideoTexture()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>createVideoTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function createVideoTexture():<a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 17.0, Flash Player 18.0</td></tr></table><p></p><p></p><p>
         建立 VideoTexture 物件。
         
         <p>使用 VideoTexture 物件能以紋理形式從 NetStream 或 Camera 物件取得視訊影格，並且將視訊影格上傳到顯示內容。</p>
         
         <p>無法使用 VideoTexture 建構函式建立 VideoTexture 物件；請改用這個方法。建立 VideoTexture 物件之後，請附加 NetStream 物件或 Camera 物件，透過 VideoTexture <code>attachNetStream()</code> 或 <code>attachCamera()</code> 方法取得視訊影格。</p>
         
         <p>請注意，如果系統不支援這個功能，這個方法就會傳回 null。 </p>
         
         <p> VideoTexture 未包含 MIP 對應。如果 VideoTexture 與使用 MIP 對應篩選或重複換行的取樣程式搭配使用，drawTriangles 呼叫將會失敗。VideoTexture 會被著色器視為 BGRA 紋理。<b>如果以軟體顯示模式要求 Context3D，則嘗試初始化 VideoTexture 物件將會失敗。</b> 
         </p>
         
         <p> 每個 Context3D 實體最多有 4 個 VideoTexture 物件可以使用。在行動裝置版本上，由於平台限制，支援的 VideoTexture 物件實際數目可能少於 4 個。 </p>
                                   
         </p><p></p><span class="label">傳回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="textures/VideoTexture.html">flash.display3D.textures:VideoTexture</a></code></td></tr></table><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 超過資源限制：建立太多 Texture 物件，或是超過配置給紋理的記憶體數量。         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理建立失敗：無法利用顯示內容建立 Texture 物件 (但沒有其原因的相關資訊)。  
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="dispose()" id="dispose()"></a><a name="dispose(Boolean)" id="dispose(Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>dispose</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function dispose(recreate:<a href="../../Boolean.html">Boolean</a> = true):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         釋放與此 Context3D 關聯的所有資源和內部儲存空間。
          
         <p>透過此 Context3D 建立的所有索引緩衝區、頂點緩衝區、紋理和程式的處理方式，與個別在其上呼叫 <code>dispose()</code> 予以處理是相同的。此外，Context3D 本身將釋放所有暫存緩衝區和背景緩衝區予以處理。如果您呼叫 dispose() 之後呼叫 configureBackBuffer()、clear()、drawTriangles()、createCubeTexture()、createTexture()、createProgram()、createIndexBuffer()、createVertexBuffer() 或 drawToBitmapData()，則執行階段會擲出例外。</p>                   
         
         <p><b>警告</b>：當關聯的 Stage3D 物件上仍有一個所設定之 Events.CONTEXT3D_CREATE 的事件偵聽程式時，若呼叫 Context3D 上的 dispose()，則 dispose() 呼叫會模擬裝置損失。它會在 Stage3D 上建立新的 Context3D，並再次發出 Events.CONTEXT3D_CREATE 事件。如果這不是所需的行為，請先移除 Stage3D 物件中的事件偵聽程式，然後再呼叫 dispose()，或者將 recreate 參數設定為 false。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">recreate</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>true</code>)<code></code></td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso">Stage3D<br/><a href="../display/Stage3D.html" target="">flash.display.Stage3D</a></div></div></span><span id="pageFilter" runtime="AIR::3##"><a name="drawToBitmapData()" id="drawToBitmapData()"></a><a name="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)" id="drawToBitmapData(flash.display.BitmapData,flash.geom.Rectangle,flash.geom.Point)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawToBitmapData</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawToBitmapData(destination:<a href="../display/BitmapData.html">BitmapData</a>, srcRect:<a href="../geom/Rectangle.html">Rectangle</a> = null, destPoint:<a href="../geom/Point.html">Point</a> = null):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 3</td></tr></table><p></p><p></p><p>
         繪製目前顯示緩衝區的點陣圖。
         
         <p>背景顯示緩衝區的目前內容會複製到 BitmapData 物件。這項作業可能執行得很慢，可能需要花上一些時間。請小心使用。請注意，這個函數不會複製前景顯示緩衝區 (舞台上顯示的緩衝區)，而是要繪製到的緩衝區。若要在顯示的影像出現在舞台時加以擷取，請在呼叫 <code>present()</code> 之前，先立即呼叫 <code>drawToBitmapData()</code>。</p>
         
		 
         <p>從 AIR 25 開始，API <code>drawToBitmapData()</code> 中引進兩個新參數。這個 API 現在接受三個參數。第一個是現有參數 <code>destination:BitmapData</code>。第二個參數是 <code>srcRect:Rectangle</code>，這是 stage3D 上的目標矩形。第三個參數是 <code>destPoint:Point</code>，這是目的地點陣圖上的座標。參數 srcRect 和 destPoint 為選用，分別預設為 (0,0,bitmapWidth,bitmapHeight) 和 (0,0)。</p>
         
         <p>繪製影像時，影像不會縮放為點陣圖的大小。相反地，內容將符合目的地點陣圖的大小。</p>
         
         <p>Flash BitmapData 物件會儲存已經乘以 Alpha 組件的顏色。例如，如果像素的「純」RGB 顏色組件為 (0x0A, 0x12, 0xBB)，而 Alpha 組件為 0x7F (.5)，則像素會以 RGBA 值儲存在 BitmapData 物件中：(0x05, 0x09, 0x5D, 0x7F)。您可以設定混合係數，使顯示至緩衝區的顏色乘以 Alpha 或是在片段著色器中執行此作業。顯示內容不會驗證顏色是否以預先相乘的格式來儲存。 </p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">destination</span>:<a href="../display/BitmapData.html">BitmapData</a></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">srcRect</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> (default = <code>null</code>)<code></code></td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destPoint</span>:<a href="../geom/Point.html">Point</a></code> (default = <code>null</code>)<code></code></td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3802：參數 <code>destPoint:Point</code> 或 <code>srcRect:Rectangle</code> 位於點陣圖/stage3D 座標界限之外，或者非數值 (NaN) 值傳遞做為輸入。
		 
         </td></tr></table><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例會在一般顯示緩衝區與 BitmapData 物件顯示兩個三角形。BitmapData 物件是使用新增至一般顯示清單的 Bitmap 物件來顯示。陰影濾鏡適用於點陣圖顯示。 
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Bitmap;
    import flash.display.BitmapData;
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.filters.DropShadowFilter;
    
    public class Context3D_drawToBitmapData extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var bitmap:Bitmap;
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawToBitmapData()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 0;
            stage3D.y = 0;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            var renderedBitmapData:BitmapData = new BitmapData( viewWidth, viewHeight, true );
            renderContext.drawToBitmapData( renderedBitmapData );
            
            renderContext.present();
            
            //Add to stage
            bitmap = new Bitmap( renderedBitmapData );
            this.addChild( bitmap );
            bitmap.x = 55;
            bitmap.y = 25;
            bitmap.filters = [new DropShadowFilter( 8, 235, .4 )];
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="drawTriangles()" id="drawTriangles()"></a><a name="drawTriangles(flash.display3D.IndexBuffer3D,int,int)" id="drawTriangles(flash.display3D.IndexBuffer3D,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>drawTriangles</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTriangles(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         請使用此 Context3D 物件的目前緩衝區和狀態來顯示指定的三角形。
         
         <p>就每個三角形而言，三角形頂點會經過頂點著色器程式的處理，而三角形表面則經由像素著色器程式處理。來自像素程式之輸出色彩的每一像素會根據視模板作業、深度測試、來源和目的地 Alpha 以及目前混合模式，繪製到顯示目標。顯示目的地可以是主要顯示緩衝區或紋理。</p>
         
         <p>如果啟用剔除功能 (透過使用 <code>setCulling()</code> 方法)，則會在執行像素程式之前捨棄場景中的三角形。如果啟用模板和深度測試，則會捨棄像素程式中的輸出像素，而不會更新顯示目的地。此外，像素程式可以決定不要輸出像素的顏色。</p>
         
         <p>在您呼叫 <code>present()</code> 方法之前，顯示的三角形不會出現在檢視區域中。在每個 <code>present()</code> 呼叫之後，必須在第一個 <code>drawTriangles()</code> 呼叫之前呼叫 <code>clear()</code> 方法，否則顯示會失敗。</p>

         <p>當 <code>enableErrorChecking</code> 為 <code>false</code> 時，此函數會立即傳回而不等候結果，並且只有在此 COntext3D 實體已加以處理或是有太多繪製呼叫時，才會擲回例外。如果顯示內容狀態無效，則顯示會無訊息失敗。當 <code>enableErrorChecking</code> 屬性為 <code>true</code> 時，此函數會在繪製三角形之後傳回，並針對任何繪製錯誤或無效的內容狀態擲回例外。</p> 
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; 一組頂點索引，這些索引參考要顯示的頂點。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 選取顯示的第一個頂點索引的索引。預設為 0。   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 要顯示的三角形數目。每一個三角形耗用三個索引。傳遞 -1 可在索引緩衝區中繪製所有三角形。預設為 -1。  
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 如果在 <code>present()</code> 的呼叫之間呼叫此方法太多次。呼叫的最大次數為 32,768 次。 
         
         <p>下列錯誤只會在 <code>enableErrorChecking</code> 屬性為 <code>true</code> 時擲回：</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 繪製前必須先清除：自最後一次 <code>present()</code> 呼叫以來不曾清除過緩衝區。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 未設定有效的 Program3D 物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 未設定有效的索引緩衝區：未設定 IndexBuffer3D 物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 參數的例行性檢查失敗：要繪製的三角形數目或 <code>firstIndex</code> 超過允許的值。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 這個緩衝區中沒有足夠的索引：緩衝區中沒有足夠的索引，無法定義要繪製的三角形數目。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結紋理同時繫結至顯示：顯示目標是紋理，而該紋理已指定給目前片段程式的紋理輸入。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結無效的紋理：指定無效的紋理做為目前片段程式的輸入。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 取樣程式格式不符合紋理格式：指定做為目前片段程式輸入的紋理，具有與為取樣程式暫存器所指定不同的格式。例如，將 2D 紋理指定給立方體紋理取樣程式。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結未定義的紋理：目前片段程式存取尚未設定 (使用 <code>setTextureAt()</code>) 的紋理暫存器。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 相同紋理需要相同取樣程式參數：如果紋理用於一個以上的取樣程式暫存器，則所有取樣程式都必須具有相同的設定。例如，您無法將一個取樣程式設定為 clamp，另一個設定為圍繞。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理已繫結但未使用：紋理已設定為著色器輸入，但未使用過。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流不在使用中：頂點緩衝區已指定至頂點屬性輸入，但頂點程式不會參考對應的暫存器。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流無效：指定給頂點程式輸入的 VertexBuffer3D 物件不是有效的物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 串流沒有足夠的頂點：提供資料以供繪製指定之三角形的頂點緩衝區沒有足夠的資料。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 串流頂點偏移值超出範圍：<code>setVertexBufferAt()</code> 呼叫中指定的偏移值是負數或超過緩衝區結尾。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流已讀取但未設定：目前頂點程式所使用的頂點屬性未設定 (使用 <code>setVertexBufferAt()</code>)。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列類別會在舞台的 Stage3D 檢視區域繪製兩個三角形。這兩個三角形共用一個頂點，其位於原點 (0,0,0)。
 
 <p>三角形是使用頂點緩衝區和索引緩衝區來定義。頂點緩衝區包含每個三角形頂點的位置和顏色資訊。索引緩衝區包含頂點緩衝區的索引。三個索引定義一個三角形。例如，由頂點緩衝區中前三個點所組成的三角形，在索引緩衝區中列示為 0,1,2。</p>
 
 <p>在這個簡單範例中，不會執行 3D 變形。只有標準化檢視區域 (2x2x1 單位體積) 內的物件才會顯示，且所定義的三角形座標必須位在此區域內。不過，在顯示典型的 3D 場景時，請使用透視或正視投影，將要顯示的物件從「世界」座標系統投影至此檢視區域。</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_drawTriangles extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_drawTriangles()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   0, 0,.5,
                     1, 1, 0,   0, 0, 1,
                     1,-1, 0,  .5, 0, 0,
                    -1,-1, 0,   1, 0, 0
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Clear required before first drawTriangles() call
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 2 triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="AIR::20.0##"><a name="drawTrianglesInstanced()" id="drawTrianglesInstanced()"></a><a name="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)" id="drawTrianglesInstanced(flash.display3D.IndexBuffer3D,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;drawTrianglesInstanced</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function drawTrianglesInstanced(indexBuffer:<a href="IndexBuffer3D.html">IndexBuffer3D</a>, numInstances:<a href="../../int.html">int</a>, firstIndex:<a href="../../int.html">int</a> = 0, numTriangles:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 20.0</td></tr></table><p></p><p></p><p>
         請使用此 Context3D 物件的目前緩衝區和狀態來顯示指定的實體化三角形。
         
         <p>就每一個實體的每個三角形而言，三角形頂點會經過頂點著色器程式的處理，而三角形表面則經由像素著色器程式處理。來自像素程式之輸出色彩的每一像素會根據視模板作業、深度測試、來源和目的地 Alpha 以及目前混合模式，繪製到顯示目標。顯示目的地可以是主要顯示緩衝區或紋理。</p>
         
         <p>如果啟用剔除功能 (透過使用 <code>setCulling()</code> 方法)，則會在執行像素程式之前捨棄場景中的三角形。如果啟用模板和深度測試，則會捨棄像素程式中的輸出像素，而不會更新顯示目的地。此外，像素程式可以決定不要輸出像素的顏色。</p>
         
         <p>在您呼叫 <code>present()</code> 方法之前，顯示的實體化三角形不會出現在檢視區域中。在每個 <code>present()</code> 呼叫之後，必須在第一個 <code>drawTrianglesInstanced()</code> 呼叫之前呼叫 <code>clear()</code> 方法，否則顯示會失敗。</p>

         <p>當 <code>enableErrorChecking</code> 為 <code>false</code> 時，此函數會立即傳回而不等候結果，並且只有在此 COntext3D 實體已加以處理或是有太多繪製呼叫時，才會擲回例外。如果顯示內容狀態無效，則顯示會無訊息失敗。當 <code>enableErrorChecking</code> 屬性為 <code>true</code> 時，此函數會在繪製三角形之後傳回，並針對任何繪製錯誤或無效的內容狀態擲回例外。</p>
		 
		 <p>如果實體化緩衝區以 <code>SetVertexAt()</code> 不當地排序，這個方法可能會擲回例外。以 Direct 3D 9 為例，所要繪製的實體的已編製索引幾何資料和數目，必須永遠以 <code>SetStreamSourceFreq()</code> API 在串流零中設定。</p>
		 
		 <p>這表示，以 <code>SetVertexBufferAt()</code> 作為頂點著色器程式的輸入時，使用 <code>CreateVertexBufferForInstance()</code> 建立的頂點緩衝區不應設為最小索引號碼。使用 <code>CreateVertexBuffer()</code> 所產生之頂點緩衝區的索引號碼，必須設為小於 <code>CreateVertexBufferForInstance()</code> 的索引號碼。一般來說，幾何資料必須放在具有 <code>SetVertexBufferAt()</code> 的每個實體資料前。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">indexBuffer</span>:<a href="IndexBuffer3D.html">IndexBuffer3D</a></code> &mdash; 一組頂點索引，這些索引參考要顯示的頂點。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numInstances</span>:<a href="../../int.html">int</a></code> &mdash; 要顯示的實體數目。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 選取顯示的第一個頂點索引的索引。預設為 0。   
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numTriangles</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 要顯示的三角形數目。每一個三角形耗用三個索引。傳遞 -1 可在索引緩衝區中繪製所有三角形。預設為 -1。  
		 
		 </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 如果在 <code>present()</code> 的呼叫之間呼叫此方法太多次。呼叫的最大次數為 32,768 次。 
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 需要標準延伸描述檔或以上版本：當要求的描述檔版本低於標準延伸描述檔時，呼叫這個方法。
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 以負數 numInstance 呼叫了這個方法。
         
         <p>下列錯誤只會在 <code>enableErrorChecking</code> 屬性為 <code>true</code> 時擲回：</p>
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 繪製前必須先清除：自最後一次 <code>present()</code> 呼叫以來不曾清除過緩衝區。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 未設定有效的 Program3D 物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 未設定有效的索引緩衝區：未設定 IndexBuffer3D 物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 參數的例行性檢查失敗：要繪製的三角形數目或 <code>firstIndex</code> 超過允許的值。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 這個緩衝區中沒有足夠的索引：緩衝區中沒有足夠的索引，無法定義要繪製的三角形數目。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結紋理同時繫結至顯示：顯示目標是紋理，而該紋理已指定給目前片段程式的紋理輸入。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結無效的紋理：指定無效的紋理做為目前片段程式的輸入。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 取樣程式格式不符合紋理格式：指定做為目前片段程式輸入的紋理，具有與為取樣程式暫存器所指定不同的格式。例如，將 2D 紋理指定給立方體紋理取樣程式。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 樣本繫結未定義的紋理：目前片段程式存取尚未設定 (使用 <code>setTextureAt()</code>) 的紋理暫存器。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 相同紋理需要相同取樣程式參數：如果紋理用於一個以上的取樣程式暫存器，則所有取樣程式都必須具有相同的設定。例如，您無法將一個取樣程式設定為 clamp，另一個設定為圍繞。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 紋理已繫結但未使用：紋理已設定為著色器輸入，但未使用過。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流不在使用中：頂點緩衝區已指定至頂點屬性輸入，但頂點程式不會參考對應的暫存器。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流無效：指定給頂點程式輸入的 VertexBuffer3D 物件不是有效的物件。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 串流沒有足夠的頂點：提供資料以供繪製指定之三角形的頂點緩衝區沒有足夠的資料。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 串流頂點偏移值超出範圍：<code>setVertexBufferAt()</code> 呼叫中指定的偏移值是負數或超過緩衝區結尾。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 串流已讀取但未設定：目前頂點程式所使用的頂點屬性未設定 (使用 <code>setVertexBufferAt()</code>)。
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 頂點緩衝區串流沒有足夠的元素可供實體使用：頂點緩衝區串流沒有足夠的元素可供一些實體使用。
		 
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 實體的頂點緩衝區串流不當設定為最小索引屬性暫存器：使用 <code>CreateVertexBuffer()</code> 所產生之頂點緩衝區的索引號碼，大於使用 <code>CreateVertexBufferForInstance()</code> 所產生之頂點緩衝區的索引號碼。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#enableErrorChecking" target="">enableErrorChecking</a><br/><a href="VertexBuffer3D.html#upload()" target="">VertexBuffer3D.upload()</a><br/><a href="IndexBuffer3D.html#upload()" target="">IndexBuffer3D.upload()</a><br/><a href="textures/Texture.html" target="">flash.display3D.textures.Texture</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列類別會使用以單一繪製呼叫 (而非多個繪製呼叫) 進行實體化繪製的功能，繪製三個三角形。
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstancedDrawing extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstancedDrawing()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //The vertex shader code runs for every vertex of each instance.
            //The vertex buffers uploaded for instance data (va1,va2) are used when the vertex shader for that particular instance is being executed.
            code += "add vt0, va0, va2\n";
            code += "mov op, vt0\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span><span id="pageFilter"><br/><div class="detailBody"> 下列類別會使用以單一繪製呼叫 (而非多個繪製呼叫) 進行實體化繪製的功能，繪製三個三角形。
<div class="listing"><pre>
package
{
    import com.adobe.utils.v3.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.utils.ByteArray;
    
    public class Context3D_HelloInstanceIdRegister extends Sprite
    {
        private var W:int;
        private var H:int;
        
        private var renderContext:Context3D;
        private var program:Program3D;
        private var vertexBuffer:VertexBuffer3D;
        private var instanceBufferColor:VertexBuffer3D;
        private var instanceBufferTranslation:VertexBuffer3D;
        private var indexBuffer:IndexBuffer3D;
        private var m:Matrix3D;
        private var vertexShader:ByteArray;
        private var fragmentShader:ByteArray;
        
        public function Context3D_HelloInstanceIdRegister()
        {
            if (hasEventListener(Event.ADDED_TO_STAGE))
                removeEventListener(Event.ADDED_TO_STAGE, init);
            W = stage.stageWidth;
            H = stage.stageHeight;
            stage.scaleMode = StageScaleMode.NO_SCALE;
            stage.align = StageAlign.TOP_LEFT;
            stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, contextCreated);
            //We need to request context3D in standard extended profile as instanced drawing requires standard extended profile.
            stage.stage3Ds[0].requestContext3D("auto","standardExtended");            
            
        }
        
        //Note: &lt;code&gt;context3DCreate&lt;/code&gt; event can happen at any time. For example, when the hardware resources are taken up by another process.
        private function contextCreated( event:Event ):void
        {
            var t:Stage3D = event.target as Stage3D;
            renderContext = t.context3D;
            trace( "3D driver: " + renderContext.driverInfo );
            setupScene();
        }
        
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true;
            renderContext.configureBackBuffer( W, H, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //create vertex buffer for geometry information of the instances (same geometry of the instances)
            vertexBuffer = renderContext.createVertexBuffer(3, 3);
            
            //The color and translation information varies across the instances. Use &lt;code&gt;createVertexBufferForInstances&lt;/code&gt; for color and translation information.
            //the intancesPerElement parameter used is 1 which means that each instance will use unique element of the instances buffer
            //if the intancesPerElement is 3 then sets of 3 instances will use the same element of the instances buffer
            instanceBufferColor = renderContext.createVertexBufferForInstances(4,3,1);
            instanceBufferTranslation = renderContext.createVertexBufferForInstances(4,3,1);
            //create index buffer for the triangle
            indexBuffer = renderContext.createIndexBuffer(3);
            
            //create and compile program
            program = renderContext.createProgram();
            //Note : for instance id support , use the latest AgalMiniAssembler from github - https://github.com/adobe-flash/graphicscorelib/blob/master/src/com/adobe/utils/v3/AGALMiniAssembler.as
            var assembler:AGALMiniAssembler = new AGALMiniAssembler();
            
            // VERTEX SHADER
            var code:String = "";
            //the vertex shader code will run for every vertex of every instance , 
            //the vertex buffers uploaded for instance data (va1,va2) will be used when vertex shader for that particular instance is being executed 
            //the vertex shader code below indexes the program constants matrix using iid.x. iid is a new register introduced in vertex shader for instanced drawing
            //it is a read only register , iid.x gives the current instance id whose shader is being executed
            code += "add vt0, va0, va2\n";
            code += "mul vt1, vt0, vc[iid.x]\n"
            code += "mov op, vt1\n";
            code += "mov v0, va1\n";
            
            vertexShader = assembler.assemble(Context3DProgramType.VERTEX, code, 3);
            
            //FRAGMENT SHADER
            code = "mov oc, v0\n"; 
            
            // Compile the agal code into bytecode using agalminiassembler
            fragmentShader = assembler.assemble(Context3DProgramType.FRAGMENT, code, 3);
            
            //upload program to gpu
            program.upload(vertexShader, fragmentShader);
            
            //geometry data for the instances
            var vertexData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0,     // - 1st vertex x,y,z
                0, 0.3, 1,         // - 2nd vertex x,y,z 
                0.3, -0.3, 0    // - 3rd vertex x,y,z
            ]);
            
            //per instance color data
            var instanceColorData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 0.0, 0.0,     // - 1st instance r,g,b
                0.0, 1.0, 0.0,  // - 2nd instance r,g,b
                1.0, 1.0, 1.0,    // - 3rd instance r,g,b
                0.7, 0.0, 1.0   // - 4th instance r,g,b
            ]);
            //per instance translation data
            var instanceTranslationData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                -0.3, -0.3, 0.0,     // - 1st instance x,y,z
                0.3, 0.3, 0.0,         // - 2nd instance x,y,z
                -0.3, 0.3, 0.0,        // - 3rd instance x,y,z
                0.3, -0.3, 0.0      // - 4th instance x,y,z
            ]);
            
            vertexBuffer.uploadFromVector(vertexData, 0, 3);
            instanceBufferColor.uploadFromVector(instanceColorData, 0, 4);
            indexBuffer.uploadFromVector(Vector.&lt;uint&gt;([0, 1, 2]), 0, 3);
            instanceBufferTranslation.uploadFromVector(instanceTranslationData, 0, 4);
            
            //pass data to program
            renderContext.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(1, instanceBufferColor, 0, Context3DVertexBufferFormat.FLOAT_3);
            renderContext.setVertexBufferAt(2, instanceBufferTranslation, 0, Context3DVertexBufferFormat.FLOAT_3);
            
            //set active program
            renderContext.setProgram(program);
            renderContext.enableErrorChecking = true;
            addEventListener(Event.ENTER_FRAME, render);
            
        }
        
        private function render( event:Event ):void
        {
            renderContext.clear(0.3, 0.2, 1, 1); // Clear the backbuffer by filling it with the given color
            var instanceScalingData:Vector.&lt;Number&gt;=Vector.&lt;Number&gt;([
                1.0, 1.0, 1.0, 1.0,     // - 1st instance x,y,z,w
                1.4, 1.4, 1.4, 1.0,        // - 2nd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0,        // - 3rd instance x,y,z,w
                0.6, 0.6, 0.6, 1.0
            ]);
            var m:Matrix3D = new Matrix3D();
            m.copyRawDataFrom(instanceScalingData);
            renderContext.setProgramConstantsFromMatrix("vertex",0,m,false);
            
            //Draw three instances of the same geometry but with varying instance data specified using &lt;code&gt;vertexBufferForInstances&lt;/code&gt;.
            renderContext.drawTrianglesInstanced(indexBuffer,4);
            renderContext.present(); // render the backbuffer on screen.
        }    
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="present()" id="present()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>present</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function present():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         顯示背景顯示緩衝區。 
         
         <p>呼叫 <code>present()</code> 方法會使自最後一次可見的 <code>present()</code> 呼叫以來的所有顯示作業產生結果，並且啟動新的顯示循環。呼叫 <code>present</code> 之後，您必須先呼叫 <code>clear()</code> 再進行其他 <code>drawTriangles()</code> 呼叫。否則，這個函數會交替清除黃色和綠色的顯示緩衝區，或者如果 <code>enableErrorChecking</code> 已設定為 <code>true</code>，則會擲回例外。</p>
         
         <p>呼叫 <code>present()</code> 也會重設顯示目標，就如同呼叫 <code>setRenderToBackBuffer()</code>。 </p>  
         
         </p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 繪製前必須先清除：自上一次呼叫 <code>present()</code> 以來不曾呼叫過 <code>clear()</code> (不允許兩個連續 <code>present()</code> 呼叫未在彼此間呼叫 <code>clear()</code>)。
         
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 3768：在背景執行期間不會使用 <code>Stage3D</code> API。
         
         </td></tr></table></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setBlendFactors()" id="setBlendFactors()"></a><a name="setBlendFactors(String,String)" id="setBlendFactors(String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setBlendFactors</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setBlendFactors(sourceFactor:<a href="../../String.html">String</a>, destinationFactor:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         指定用於將繪製作業的輸出顏色與現有顏色混合的係數。
         
         <p>像素著色器程式的輸出 (來源) 顏色會根據下列公式，與該像素位置的現有 (目標) 顏色相結合：</p> 
         <p><code>result color = (source color * sourceFactor) + (destination color * destinationFactor)</code></p>
         <p>該像素的目標顏色是顯示緩衝區中的目前顏色。因此，這是最近 <code>clear()</code> 呼叫和任何中介 <code>drawTriangles()</code> 呼叫的結果。 </p>
          
         <p>使用 <code>setBlendFactors()</code> 可以設定來源顏色和目標顏色相加之前先相乘所用的係數。預設混合係數是 <code>sourceFactor = Context3DBlendFactor.ONE</code> 和 <code>destinationFactor = Context3DBlendFactor.ZERO</code>，結果來源顏色會覆寫目標顏色 (換句話說，兩個顏色沒有產生混合)。若是一般 Alpha 混合，請使用 <code>sourceFactor = Context3DBlendFactor.SOURCE_ALPHA</code> 和 <code>destinationFactor = Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA</code>。 
         </p>
         
         <p>使用 Context3DBlendFactor 類別中定義的常數可以設定這個函數的參數。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sourceFactor</span>:<a href="../../String.html">String</a></code> &mdash; 要乘以來源顏色的係數。預設為 <code>Context3DBlendFactor.ONE</code>。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">destinationFactor</span>:<a href="../../String.html">String</a></code> &mdash; 要乘以目標顏色的係數。預設為 <code>Context3DBlendFactor.ZERO</code>。
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉：<code>sourceFactor</code> 或 <code>destinationFactor</code> 不是其中一個可辨識的值的時候，這些值是在 Context3DBlendFactor 類別中定義。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DBlendFactor.html" target="">Context3DBlendFactor</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列類別說明各種不同的混合係數。此範例會在顯示緩衝區繪製四種不同顏色的矩形。這組矩形便是混合「目標」。接下來，設定來源與目標混合模式，並繪製一個較大的矩形，也就是混合「來源」。請使用按鍵「1」與「2」來循環切換來源混合模式。使用按鍵「3」與「4」來循環切換目標混合模式。
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.ui.Keyboard;
    
    public class Context3D_setBlendMode extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var sourceFactor:int = 6;
        private var destinationFactor:int = 4;
        private var blendFactors:Array = [Context3DBlendFactor.DESTINATION_ALPHA,
                                          Context3DBlendFactor.DESTINATION_COLOR,
                                          Context3DBlendFactor.ONE,
                                          Context3DBlendFactor.ONE_MINUS_DESTINATION_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA,
                                          Context3DBlendFactor.ONE_MINUS_SOURCE_COLOR,
                                          Context3DBlendFactor.SOURCE_ALPHA,
                                          Context3DBlendFactor.SOURCE_COLOR,
                                          Context3DBlendFactor.ZERO];
            
        public function Context3D_setBlendMode()
        {
            this.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyHandler );
            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3,
                                                            6, 4, 5,
                                                            5, 7, 6,
                                                            10, 8, 9,
                                                            9, 11, 10,
                                                            12, 15, 14,
                                                            12, 13, 15,
                                                            16, 17, 19,
                                                            16, 19, 18
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 7;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format
                    -1, 1, 0,   1, 1, 1, .5,
                     0, 1, 0,   1, 1, 1, .5,
                    -1, 0, 0,   1, 1, 1, .5,
                     0, 0, 0,   1, 1, 1, .5,
                     
                     0, 1, 0,  .8,.8,.8, .6,
                     1, 1, 0,  .8,.8,.8, .6,
                     0, 0, 0,  .8,.8,.8, .6,
                     1, 0, 0,  .8,.8,.8, .6,
                     
                    -1, 0, 0,   1, 0, 0, .5,
                     0, 0, 0,   0, 1, 0, .5,
                    -1,-1, 0,   0, 0, 1, .5,
                     0,-1, 0,   1, 0, 1, .5,
                     
                     0, 0, 0,   0, 0, 0, .5,
                     1, 0, 0,   0, 0, 0, .5,
                     0,-1, 0,   0, 0, 0, .5,
                     1,-1, 0,   0, 0, 0, .5,
                     
                   -.8,.8, 0,  .6,.4,.2,.4,
                    .8,.8, 0,  .6,.4,.2,.4,
                  -.8,-.8, 0,  .6,.4,.2,.4,
                   .8,-.8, 0,  .6,.4,.2,.4
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_4 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear( 1, 1, 1, 1 );
            //Draw the back triangles
            renderContext.setBlendFactors( Context3DBlendFactor.ONE, Context3DBlendFactor.ZERO ); //No blending
            renderContext.drawTriangles( indexList, 0, 8 );

            //Set blend
            renderContext.setBlendFactors( blendFactors[sourceFactor], blendFactors[destinationFactor] );
            
            //Draw the front triangles
            renderContext.drawTriangles( indexList, 24, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
        
        private function keyHandler( event:KeyboardEvent ):void
        {
            switch ( event.keyCode )
            {
                case Keyboard.NUMBER_1:
                    if( --sourceFactor &lt; 0 ) sourceFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_2:
                    if( ++sourceFactor &gt; blendFactors.length - 1) sourceFactor = 0;
                    break;
                case Keyboard.NUMBER_3:
                    if( --destinationFactor &lt; 0 ) destinationFactor = blendFactors.length - 1; 
                    break;
                case Keyboard.NUMBER_4:
                    if( ++destinationFactor &gt; blendFactors.length - 1) destinationFactor = 0;
                    break;
            }
            trace( "Source blend factor: " + blendFactors[sourceFactor] + ", destination blend factor: " + blendFactors[destinationFactor] );
            render();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setColorMask()" id="setColorMask()"></a><a name="setColorMask(Boolean,Boolean,Boolean,Boolean)" id="setColorMask(Boolean,Boolean,Boolean,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setColorMask</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setColorMask(red:<a href="../../Boolean.html">Boolean</a>, green:<a href="../../Boolean.html">Boolean</a>, blue:<a href="../../Boolean.html">Boolean</a>, alpha:<a href="../../Boolean.html">Boolean</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定將顏色寫入顯示緩衝區時所用的遮色片。
         
         <p>將顏色寫入顯示緩衝區時，只會更新對應顏色遮色片參數為 <code>true</code> 的顏色組件。例如，如果您呼叫 <code>setColorMask( true, false, false, false )</code>，在您再次變更顏色遮色片之前，只有顏色的紅色組件會寫入緩衝區。顏色遮色片不會影響 <code>clear()</code> 方法的行為。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">red</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 設定 <code>false</code> 可防止變更紅色色版。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">green</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 設定 <code>false</code> 可防止變更綠色色版。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">blue</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 設定 <code>false</code> 可防止變更藍色色版。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">alpha</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 設定 <code>false</code> 可防止變更 Alpha 色版。
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列範例說明設定顏色遮色片的效果。此範例會描繪兩個顏色相同的三角形。上方的三角形是在設定遮色片之前描繪，因而顯示為白色。下方的三角形是在遮住紅色色版以外的所有色版之後描繪。因為只能更新紅色色版，所以白色三角形會顯示為紅色。
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    
    public class Context3D_setColorMask extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3D_setColorMask()
        {
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 0, 1, 2, 0, 3, 4 ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b format
                     0, 0, 0,   1, 1, 1,
                    -1, 1, 0,   1, 1, 1,
                     1, 1, 0,   1, 1, 1,
                     1,-1, 0,   1, 1, 1,
                    -1,-1, 0,   1, 1, 1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            renderContext.clear( .3,.3,.3,1 );
            renderContext.drawTriangles( indexList, 0, 1 ); //Top triangle draws all colors, so is white
            renderContext.setColorMask( true, false, false, false ); //Mask all but red channel            
            renderContext.drawTriangles( indexList, 3, 1 ); //Bottom triangle only updates red
            
            //Show the frame
            renderContext.present();
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setCulling()" id="setCulling()"></a><a name="setCulling(String)" id="setCulling(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setCulling</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setCulling(triangleFaceToCull:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定三角形剔除模式。
         
         <p>可根據其相對於檢視平面的方向，從顯示管線中的早期場景中排除三角形。正確地從要剔除的模型外部檢視，一致地指定頂點順序 (順時針或逆時針)。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFaceToCull</span>:<a href="../../String.html">String</a></code> &mdash; 剔除模式。使用 Context3DTriangleFace 類別中定義的其中一個常數。
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉錯誤：<code>triangleFaceToCull</code> 不是 Context3DTriangleFace 類別中定義的其中一個值。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setDepthTest()" id="setDepthTest()"></a><a name="setDepthTest(Boolean,String)" id="setDepthTest(Boolean,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setDepthTest</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setDepthTest(depthMask:<a href="../../Boolean.html">Boolean</a>, passCompareMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定用於深度測試的比較類型。
         
         <p>像素著色器程式中的來源像素輸出深度會與深度緩衝區中的目前值相比較。如果比較評估為 <code>false</code>，則會捨棄來源像素。如果為 <code>true</code>，則來源像素會進行顯示管線中的下一個步驟，即模板測試。此外，只要 <code>depthMask</code> 參數設定為 <code>true</code>，深度緩衝區還會以來源像素的深度進行更新。</p>
         
         <p>設定用來比較來源和目的地像素的深度值之測試。當比較為 true 時，來源像素將與目的地像素複合。comparison 運算子將依照該順序，做為來源與目的地像素值之間的 infix 運算子予以套用。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">depthMask</span>:<a href="../../Boolean.html">Boolean</a></code> &mdash; 若為 true，則從來源像素更新目的地深度值。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">passCompareMode</span>:<a href="../../String.html">String</a></code> &mdash; 深度比較測試作業。其中一個 Context3DCompareMode 值。
         
         </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a></div></div></span><span id="pageFilter" runtime="AIR::16##"><a name="setFillMode()" id="setFillMode()"></a><a name="setFillMode(String)" id="setFillMode(String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3><span class="sprite AirIcon12x12" alt="AIR-only" title="只能在 AIR 執行階段中使用">&nbsp;&nbsp;&nbsp;</span>&nbsp;setFillMode</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setFillMode(fillMode:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>AIR 16</td></tr></table><p></p><p></p><p> 
		設定用於顯示的填色模式。此介面只在 AIR 桌面中提供使用。
		
		</p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">fillMode</span>:<a href="../../String.html">String</a></code> &mdash; 如果值是 WIREFRAME，將會以線條組成的網格來顯示物件。如果值是 SOLID，將會以純色著色的多邊形來顯示物件。
		
		</td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DFillMode.html" target="">Context3DFillMode</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgram()" id="setProgram()"></a><a name="setProgram(flash.display3D.Program3D)" id="setProgram(flash.display3D.Program3D)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgram</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgram(program:<a href="Program3D.html">Program3D</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定頂點和片段著色器程式，以供後續顯示使用。
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">program</span>:<a href="Program3D.html">Program3D</a></code> &mdash; 代表要使用頂點和片段程的 Program3D 物件。 
         
         </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#drawTriangles()" target="">drawTriangles()</a><br/><a href="Program3D.html" target="">Program3D</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 此範例說明如何建立、上傳及啟用顯示內容的一組頂點與像素程式。請注意，<code>renderContext</code> 物件是 Context3D 類別的實體。範例中的程式是使用 Adobe Graphics Assembly Language (AGAL) 所撰寫。 
<div class="listing"><pre>
//A simple vertex program in AGAL
const VERTEX_SHADER:String =
    "m44 op, va0, vc0 \n" +    
    "mov v0, va1"; 

//A simple fragment (or pixel) program in AGAL        
const FRAGMENT_SHADER:String = "mov oc, v0";  

var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
var programPair:Program3D;

//Compile shaders
vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            

//Upload programs to render context
programPair = renderContext.createProgram();
programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
renderContext.setProgram( programPair );
            
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11.1##AIR::3.1##"><a name="setProgramConstantsFromByteArray()" id="setProgramConstantsFromByteArray()"></a><a name="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)" id="setProgramConstantsFromByteArray(String,int,int,flash.utils.ByteArray,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromByteArray</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromByteArray(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, numRegisters:<a href="../../int.html">int</a>, data:<a href="../utils/ByteArray.html">ByteArray</a>, byteArrayOffset:<a href="../../uint.html">uint</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.1, AIR 3.1</td></tr></table><p></p><p></p><p>
         使用 <code>ByteArray</code> 中儲存的值，設定著色器程式所使用的常數。 
         
         <p>設定可從頂點或片段程式中存取的常數。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; 其中一個 Context3DProgramType。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 要設定的第一個著色器程式常數的索引。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> &mdash; 要設定的暫存器數目。每個暫存器會讀取為四個浮點值。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../utils/ByteArray.html">ByteArray</a></code> &mdash; 來源 ByteArray 物件
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">byteArrayOffset</span>:<a href="../../uint.html">uint</a></code> &mdash; ByteArray 進行讀取時的偏移值
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; 當 <code>data</code> 為 null 時，則為 kNullPointerError。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 當嘗試設定的著色器常數的數目超過其上限時，則為 kConstantRegisterOutOfBounds。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 如果 <code>byteArrayOffset</code> 大於或等於 <code>data</code> 的長度，或 <code>data</code> 中的元素數目 - <code>byteArrayOffset</code> 小於 <code>numRegisters</code>*16，則會發生 kBadInputSize。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromMatrix()" id="setProgramConstantsFromMatrix()"></a><a name="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)" id="setProgramConstantsFromMatrix(String,int,flash.geom.Matrix3D,Boolean)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromMatrix</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromMatrix(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, matrix:<a href="../geom/Matrix3D.html">Matrix3D</a>, transposedMatrix:<a href="../../Boolean.html">Boolean</a> = false):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         使用 <code>Matrix3D</code> 中儲存的值，設定著色器程式所使用的常數。 
         
         <p>使用這個函數可將矩陣傳遞至著色器程式。函數會設定頂點或片段程式所使用的 4 個常數暫存器。矩陣已逐列指定給暫存器。第一個常數暫存器已指定矩陣的頂端列。您可以為頂點程式設定 128 個暫存器，為片段程式設定 28 個。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; 著色器程式類型，可能是 <code>Context3DProgramType.VERTEX</code> 或 <code>Context3DProgramType.FRAGMENT</code>。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 第一個要設定的常數暫存器索引。由於 Matrix3D 有 16 個值，因此，設定 4 個暫存器。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">matrix</span>:<a href="../geom/Matrix3D.html">Matrix3D</a></code> &mdash; 包含常數值的矩陣。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">transposedMatrix</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 若為 <code>true</code>，則依反方向將矩陣項目複製到暫存器。預設值是 <code>false</code>。
            
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Null 指標錯誤：<code>matrix</code> 為 null。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 常數暫存器超出範圍：嘗試設定超過著色器常數暫存器上限。
         
         </td></tr></table><p id="learnMore"><span class="label">詳細資訊</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_tw</a></div><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setProgramConstantsFromVector()" id="setProgramConstantsFromVector()"></a><a name="setProgramConstantsFromVector(String,int,Vector$Number,int)" id="setProgramConstantsFromVector(String,int,Vector$Number,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setProgramConstantsFromVector</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setProgramConstantsFromVector(programType:<a href="../../String.html">String</a>, firstRegister:<a href="../../int.html">int</a>, data:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;, numRegisters:<a href="../../int.html">int</a> = -1):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定著色器程式的常數輸入。
         
         <p>設定頂點或片段著色器程式存取的常數陣列。Program3D 中的常數集是在著色器程式中做為常數暫存器存取。每一個常數暫存器包含 4 個浮點數值 (x, y, z, w)。因此每個暫存器在 data 向量中需要 4 個項目。您可以針對頂點程式和片段程式設定的暫存器數目，取決於 <code>Context3DProfile</code>。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">programType</span>:<a href="../../String.html">String</a></code> &mdash; 著色器程式類型，可能是 <code>Context3DProgramType.VERTEX</code> 或 <code>Context3DProgramType.FRAGMENT</code>。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">firstRegister</span>:<a href="../../int.html">int</a></code> &mdash; 第一個要設定的常數暫存器索引。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">data</span>:<a href="../../Vector.html">Vector</a>.&lt;<a href="../../Number.html">Number</a>&gt;</code> &mdash; 浮點常數值。<code>data</code> 中至少必須有 <code>numRegisters</code> 4 個元素。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">numRegisters</span>:<a href="../../int.html">int</a></code> (default = <code>-1</code>)<code></code> &mdash; 要設定的常數數目。指定 -1 預設值，可設定足夠的暫存器來使用所有可用資料。
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../TypeError.html">TypeError</a> </code> &mdash; Null 指標錯誤：<code>data</code> 為 <code>null</code>。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 常數暫存器超出範圍：嘗試設定超過著色器常數暫存器上限。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 輸入大小錯誤：<code>data</code> 中的元素數目小於 <code>numRegisters</code>*4
         
         </td></tr></table><p id="learnMore"><span class="label">詳細資訊</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_tw</a></div><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DProgramType.html" target="">Context3DProgramType</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToBackBuffer()" id="setRenderToBackBuffer()"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToBackBuffer</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToBackBuffer():<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定背景顯示緩衝區做為顯示目標。後續呼叫 <code>drawTriangles()</code> 和 <code>clear()</code> 方法將導致背景緩衝區更新。在使用 <code>setRenderToTexture()</code> 方法之後，使用這個方法可恢復一般顯示。 
         
         
         </p></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setRenderToTexture()" id="setRenderToTexture()"></a><a name="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)" id="setRenderToTexture(flash.display3D.textures.TextureBase,Boolean,int,int,int)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setRenderToTexture</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setRenderToTexture(texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>, enableDepthAndStencil:<a href="../../Boolean.html">Boolean</a> = false, antiAlias:<a href="../../int.html">int</a> = 0, surfaceSelector:<a href="../../int.html">int</a> = 0, colorOutputIndex:<a href="../../int.html">int</a> = 0):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定指定的紋理做為顯示目標。  
         
         <p>後續呼叫 <code>drawTriangles()</code> 和 <code>clear()</code> 方法會更新指定的紋理，而非背景緩衝區。自動建立 Mip 映射。使用 <code>setRenderToBackBuffer()</code> 可恢復背景緩衝區的一般顯示。</p>
         
         <p>繪圖前不需執行任何清除動作。如果沒有清除作業，將會保留顯示內容。深度緩衝區和模板緩衝區也不會遭到清除。但是，第一次繪圖時會強制清除。呼叫 <code>present()</code> 會將目標重設為背景緩衝區。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; 要向其顯示的目標紋理。設定為 <code>null</code> 可恢復顯示至背景緩衝區 (<code>setRenderToBackBuffer()</code> 和 <code>present</code> 也會將目標重設為背景緩衝區)。       
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">enableDepthAndStencil</span>:<a href="../../Boolean.html">Boolean</a></code> (default = <code>false</code>)<code></code> &mdash; 如果為 <code>true</code>，則可以使用深度和模板測試。如果為 <code>false</code>，則會忽略後續繪製作業的所有深度和模板狀態。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">antiAlias</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 消除鋸齒品質。使用 0 可停用消除鋸齒；較高的值能改善消除鋸齒品質，但需要更多計算。此值目前被行動平台和軟體顯示內容忽略。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">surfaceSelector</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 指定要更新的紋理元素。Texture 物件有 1 個表面，因此，您必須指定預設值 0。CubeTexture 物件有 6 個表面，因此，您可以指定 0 到 5 的整數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">colorOutputIndex</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 輸出色彩暫存器。對於限制或基線模式，必須為 0。或者，請指定輸出色彩暫存器。 
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 因為 <code>surfaceSelector</code> 參數不符。2D 紋理的值必須是 0，而立方體對應的值必須是 0~5。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>texture</code> 並非衍生自 TextureBase 類別 (Texture 或 CubeTexture 類別)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; <code>colorOutputIndex</code> 必須是介於 0 和 3 之間的整數。
		 </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../ArgumentError.html">ArgumentError</a> </code> &mdash; 這個呼叫需要以標準描述檔或更高版本建立的 <code>Context3D</code>。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#clear()" target="">clear()</a><br/><a href="Context3D.html#configureBackBuffer()" target="">configureBackBuffer()</a><br/><a href="textures/CubeTexture.html#uploadFromByteArray()" target="">flash.display3D.textures.CubeTexture.uploadFromByteArray()</a></div></div></span><span id="pageFilter" runtime="Flash::11.6##AIR::3.6##"><a name="setSamplerStateAt()" id="setSamplerStateAt()"></a><a name="setSamplerStateAt(int,String,String,String)" id="setSamplerStateAt(int,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setSamplerStateAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setSamplerStateAt(sampler:<a href="../../int.html">int</a>, wrap:<a href="../../String.html">String</a>, filter:<a href="../../String.html">String</a>, mipfilter:<a href="../../String.html">String</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11.6, AIR 3.6</td></tr></table><p></p><p></p><p>
         手動覆寫紋理取樣程式狀態。
         
         <p>紋理取樣狀態通常是在呼叫 <code>setProgram</code> 時設定的。不過，您可以使用此函數覆寫紋理取樣程式狀態。如果您不希望程式變更取樣程式狀態，請在 AGAL 中設定 <code>ignoresamnpler</code> 位元並使用此函數。          
         </p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; 取樣程式 暫存器要使用的取樣程式。AGAL 中取樣程式暫存器的對應。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">wrap</span>:<a href="../../String.html">String</a></code> &mdash; 換行模式。已定義於 <code>Context3DWrapMode</code>。預設值為 repeat。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">filter</span>:<a href="../../String.html">String</a></code> &mdash; 紋理篩選模式。已定義於 <code>Context3DTextureFilter</code>。預設值為 nearest。 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">mipfilter</span>:<a href="../../String.html">String</a></code> &mdash; MIP 對應濾鏡。已定義於 <code>Context3DMipFilter</code>。預設值為 none。          
                  
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 取樣程式超出範圍
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 包裝、濾鏡、MIP 濾鏡列舉錯誤 
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 物件已處理：這個 Context3D 物件已經透過呼叫 <code>dispose()</code> 的方式處理，或是因為遺失基礎顯示硬體。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DWrapMode.html" target="">Context3DWrapMode</a><br/><a href="Context3DTextureFilter.html" target="">Context3DTextureFilter</a><br/><a href="Context3DMipFilter.html" target="">Context3DMipFilter</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setScissorRectangle()" id="setScissorRectangle()"></a><a name="setScissorRectangle(flash.geom.Rectangle)" id="setScissorRectangle(flash.geom.Rectangle)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setScissorRectangle</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setScissorRectangle(rectangle:<a href="../geom/Rectangle.html">Rectangle</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定剪刀矩形，這是繪製遮色片類型。輸出器只會繪製到剪刀矩形內的區域。剪斷不影響清除作業。 
         
         <p>傳遞 <code>null</code> 即可關閉剪斷。</p>     
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">rectangle</span>:<a href="../geom/Rectangle.html">Rectangle</a></code> &mdash; 要在其中繪製的矩形。以像素為單位指定矩形位置和尺寸。座標系統原點是在檢視區域的左上角，隨著正數值增加而往下及往右 (就像一般 Flash 顯示座標系統)。 
         
         </td></tr></table></p><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列類別會將兩個三角形繪製至舞台上的 640x480 像素檢視連接埠。這兩個三角形共用一個頂點，其位於原點 (0,0,0)。
 
 <p>三角形是使用頂點緩衝區和索引緩衝區來定義。頂點緩衝區包含每個三角形頂點的位置和顏色資訊。索引緩衝區包含頂點緩衝區的索引。三個索引定義一個三角形。例如，由頂點緩衝區中前三個點所組成的三角形，在索引緩衝區中列示為 0,1,2。</p>
 
 <p>在這個簡單範例中，不會執行 3D 變形。只會顯示標準檢視區域 (以原點為中心，體積為 2x2x2 的立方體) 內的物件。不過，在顯示典型的 3D 場景時，請使用透視或正視投影，將要顯示的物件投影至此檢視區域。</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_ScissorRectangle extends Sprite
    {
        public const viewWidth:Number = 640;
        public const viewHeight:Number = 480;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        private var scissorOn:Boolean = false;
        private var toggler:Timer = new Timer( 750 );
        
        public function Context3D_ScissorRectangle()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
            
            //Set up timer to turn scissoring on and off
            toggler.addEventListener( TimerEvent.TIMER, toggleScissor );
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3 , 2, 
                                                            0, 1, 3
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  // x, y, z    r, g, b, a format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            render();
            toggler.start();
        }
        
        private function render():void
        {
            //Clear required before first drawTriangles() call
            renderContext.clear();

            //Sciss a region excluding the outer 100 pixels of the viewport
            var scissor:Rectangle = new Rectangle( 100, 100, viewWidth - 200, viewHeight - 200 );
            if( scissorOn )    renderContext.setScissorRectangle( scissor ); //on
            else renderContext.setScissorRectangle( null ); //off

            //Draw the triangles
            renderContext.drawTriangles( indexList, 0, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function toggleScissor( event:Event ):void
        {
            scissorOn = !scissorOn;
            render();
        }
        
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilActions()" id="setStencilActions()"></a><a name="setStencilActions(String,String,String,String,String)" id="setStencilActions(String,String,String,String,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilActions</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilActions(triangleFace:<a href="../../String.html">String</a> = "frontAndBack", compareMode:<a href="../../String.html">String</a> = "always", actionOnBothPass:<a href="../../String.html">String</a> = "keep", actionOnDepthFail:<a href="../../String.html">String</a> = "keep", actionOnDepthPassStencilFail:<a href="../../String.html">String</a> = "keep"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         設定模板模式和作業。
         
         <p>一個 8 位元模板參考值可關聯每一個繪製呼叫。在顯示期間，可針對影格緩衝區先前的儲存值測試參考值。測試的結果可控制繪製動作，及是否或如何更新儲存的模板值。此外，深度測試控制是否執行模板測試。也可以使用失敗的深度測試，控制模板緩衝區上執行的動作。</p>
         
         <p>在像素處理管線中，將首先執行深度測試。如果深度測試失敗，可執行模板緩衝區更新動作，但不會進一步評估模板緩衝區值。如果通過深度測試，則執行模板測試。可依據模板測試的結果來執行替代動作。  </p>
         
         <p>模板參考值是使用 <code>setStencilReferenceValue()</code> 所設定。 </p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">triangleFace</span>:<a href="../../String.html">String</a></code> (default = "<code>frontAndBack</code>")<code></code> &mdash; 允許在模板作業中使用的三角形方向。其中一個 Context3DTriangleFace。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">compareMode</span>:<a href="../../String.html">String</a></code> (default = "<code>always</code>")<code></code> &mdash; test 運算子，可用來比較目前的模板參考值和目的地像素模板值。當 comparison 為 true 時將執行目的地像素顏色和深度更新。在下列動作參數中，將在要求時執行模板動作。comparison 運算子將依照該順序，做為目前與目的地像素值之間的 infix 運算子予以套用 (在 pseudocode 中：若為 <code>if stencilReference OPERATOR stencilBuffer then pass</code>)。使用 Context3DCompareMode 類別中定義的其中一個常數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnBothPass</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 當深度和模板比較通過時所採取的動作。使用 Context3DStencilAction 類別中定義的其中一個常數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 深度比較失敗時所採取的動作。使用 Context3DStencilAction 類別中定義的其中一個常數。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">actionOnDepthPassStencilFail</span>:<a href="../../String.html">String</a></code> (default = "<code>keep</code>")<code></code> &mdash; 深度比較通過且模板比較失敗時所採取的動作。使用 Context3DStencilAction 類別中定義的其中一個常數。
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉錯誤：<code>triangleFace</code> 不是 Context3DTriangleFace 類別中定義的其中一個值。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉錯誤：<code>compareMode</code> 不是 Context3DCompareMode 類別中定義的其中一個值。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉錯誤：<code>actionOnBothPass</code>、<code>actionOnDepthFail</code> 或 <code>actionOnDepthPassStencilFail</code> 不是 Context3DStencilAction 類別中定義的其中一個值。
         
         </td></tr></table><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DTriangleFace.html" target="">Context3DTriangleFace</a><br/><a href="Context3DCompareMode.html" target="">Context3DCompareMode</a><br/><a href="Context3DStencilAction.html" target="">Context3DStencilAction</a><br/><a href="Context3D.html#setStencilReferenceValue()" target="">setStencilReferenceValue()</a></div><span id="pageFilter"><br/><span class="label"> 範例 &nbsp;(
                <span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span>)
            </span><br/><br/><div class="detailBody"> 下列類別說明如何繪製模板並做為遮色片，用於後續繪製作業。這個範例會執行以下步驟：
 <ul><li>清除模板緩衝區並設為 0。</li><li>通過模板測試後，將模板動作設定為遞增。</li><li>將模板參考值設定為 0。</li><li>繪製三角形遮色片。因為已清除模板緩衝區並設為 0 且參考值為 0，所以不論在哪裡繪製三角形，都會通過模板測試。因此，在繪製三角形遮色片的位置，模板緩衝區會遞增為 1。</li><li>變更要保留的模板動作，以便讓後續繪製作業不會變更模板緩衝區。</li><li>繪製全螢幕的矩形 (多重顏色)。因為模板參考值仍為 0，所以在遮色區域進行模板測試會失敗。因此，可在遮色區域以外的位置繪製矩形。</li><li>將模板參考值變更為 1。</li><li>繪製另一個全螢幕的矩形 (紅色)。現在，若在遞增為 1 的遮色區域以外的位置進行模板測試都會失敗。因此，只會在遮色區域繪製矩形。</li></ul>
 <p>將滑鼠移至範例上方，即可依序查閱主要步驟。</p>
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DBlendFactor;
    import flash.display3D.Context3DCompareMode;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DStencilAction;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.Event;
    import flash.events.KeyboardEvent;
    import flash.events.MouseEvent;
    import flash.events.TimerEvent;
    import flash.geom.Rectangle;
    import flash.text.TextField;
    import flash.text.TextFormat;
    import flash.ui.Keyboard;
    import flash.utils.Timer;
    
    public class Context3D_Stencil extends Sprite
    {
        public const viewWidth:Number = 350;
        public const viewHeight:Number = 240;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private const VERTEX_SHADER:String =
            "mov op, va0    \n" +    //copy position to output 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
                
        public function Context3D_Stencil()
        {            
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );            
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );
        
            non3DSetup();
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
            renderContext = Stage3D( event.target ).context3D;
            trace( "3D driver: " + renderContext.driverInfo );

            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, true );
            
            //Create vertex index list for the triangles
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [  0, 3, 2, 
                                                            0, 1, 3,
                                                            4, 7, 6,
                                                            4, 5, 7,
                                                            8, 9, 10
                                                         ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                  //x, y, z  r,g,b format 
                   -1, 1, 0,  1,0,0,
                    1, 1, 0,  0,0,1,
                   -1,-1, 0,  0,1,0,
                    1,-1, 0,  1,0,1,

                   -1, 1, 0,  .5,0,0,
                    1, 1, 0,  .5,0,0,
                   -1,-1, 0,  .5,0,0,
                    1,-1, 0,  .5,0,0,
                    
                    0, .7,.1, 0,0,0,
                  -.7,-.7,.1, 0,0,0,
                   .7,-.7,.1, 0,0,0
                ]);
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            render();
        }
        private function render():void
        {
            //Clear, setting stencil to 0
            renderContext.clear( .3, .3, .3, 1, 1, 0 );
            
            //Draw stencil, incrementing the stencil buffer value
            renderContext.setStencilReferenceValue( 0 );
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.INCREMENT_SATURATE );            
            if( state &gt; 0 ) renderContext.drawTriangles( indexList, 12, 1 );

            //Change stencil action when stencil passes so stencil buffer is not changed
            renderContext.setStencilActions( Context3DTriangleFace.FRONT_AND_BACK, 
                Context3DCompareMode.EQUAL, Context3DStencilAction.KEEP );
            
            //Draw quad -- doesn't draw where stencil has already drawn
            if( state &gt; 1 ) renderContext.drawTriangles( indexList, 0, 2 );
            
            //Change the reference to 1 so this quad only draws into stenciled area
            renderContext.setStencilReferenceValue( 1 );
            if( state &gt; 2 ) renderContext.drawTriangles( indexList, 6, 2 );
            
            //Show the frame
            renderContext.present();
        }
        
        //The rest of the code is for the example UI and timer 
        private function doState( event:TimerEvent ):void
        {
            switch (state)
            {
                case 0:
                    description.text = "Draw triangle with stencil action == increment";
                    state = 1;
                    break;
                case 1:
                    description.text = "Draw the first plane where stencil == 0";
                    state = 2;
                    break;
                case 2:
                    description.text = "Draw second plane where stencil == 1";
                    state = 3;
                    break;
                case 3:
                    description.text = "Clear, setting stencil to 0";
                    state = 0;
                    break;

                default:
                    description.text = "";
                    state = 0;        
            }
            render();
        }

        private var state:int = 3;
        private var stateTimer:Timer = new Timer( 1250 );
        private var description:TextField = new TextField();
        
        private function non3DSetup():void
        {
            //Setup timer to animate the stages of drawing the scene
            stateTimer.addEventListener( TimerEvent.TIMER, doState );
            this.stage.addEventListener( MouseEvent.MOUSE_OVER, function(event:Event):void{stateTimer.start()} );
            this.stage.addEventListener( MouseEvent.MOUSE_OUT, function(event:Event):void{stateTimer.stop()} );
            
            description.height = 30;
            description.width = viewWidth;
            this.addChild( description );
            description.y = viewHeight + 15;
            description.defaultTextFormat = new TextFormat( null, 18, 0xffffff );
            description.text = "Mouse over to view.";
            
            //Allows mouse-over events
            var coverSprite:Sprite = new Sprite();
            coverSprite.graphics.beginFill( 0, .01 )
            coverSprite.graphics.lineTo( stage.stageWidth, 0 );
            coverSprite.graphics.lineTo( stage.stageWidth, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, stage.stageHeight );
            coverSprite.graphics.lineTo( 0, 0 );
            this.addChild( coverSprite );            
        }
    }
}
</pre></div></div></span></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setStencilReferenceValue()" id="setStencilReferenceValue()"></a><a name="setStencilReferenceValue(uint,uint,uint)" id="setStencilReferenceValue(uint,uint,uint)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setStencilReferenceValue</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setStencilReferenceValue(referenceValue:<a href="../../uint.html">uint</a>, readMask:<a href="../../uint.html">uint</a> = 255, writeMask:<a href="../../uint.html">uint</a> = 255):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p> 
         設定用於模板測試的模板比較值。 
         
         <p>僅使用參考值較低的 8 位元。模板緩衝區值的長度也是 8 位元。使用 <code>readMask</code> 和 <code>writeMask</code> 可以將模板緩衝區當做位元欄位使用。</p>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">referenceValue</span>:<a href="../../uint.html">uint</a></code> &mdash; 在參考值比較測試中使用的 8 位元參考值。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">readMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 在比較之前同時套用至目前模板緩衝區值和參考值的 8 位元遮色片。  
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">writeMask</span>:<a href="../../uint.html">uint</a></code> (default = <code>255</code>)<code></code> &mdash; 在更新模板緩衝區之前套用至參考值的 8 位元遮色片。
         
         </td></tr></table></p><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3D.html#setStencilActions()" target="">setStencilActions()</a></div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setTextureAt()" id="setTextureAt()"></a><a name="setTextureAt(int,flash.display3D.textures.TextureBase)" id="setTextureAt(int,flash.display3D.textures.TextureBase)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setTextureAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setTextureAt(sampler:<a href="../../int.html">int</a>, texture:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a>):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         指定要用於片段程式之紋理輸出暫存器的紋理。
         
         <p>片段程式可以從最多 8 個紋理物件中讀取資訊。使用這個函數，可將 Texture 或 CubeTexture 物件指定給片段程式所使用的其中一個取樣程式暫存器。 </p>
         
         <p><b>注意：</b>如果您要將作用中的片段程式 (使用 <code>setProgram</code>) 變更為使用較少紋理的著色器，請將未使用的暫存器設定為 <code>null</code>：</p>
         <div class="listing"><pre>
         setTextureAt( 7, null );
         </pre></div>
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">sampler</span>:<a href="../../int.html">int</a></code> &mdash; 取樣程式暫存器索引，值為 0 到 7。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">texture</span>:<a href="textures/TextureBase.html">flash.display3D.textures:TextureBase</a></code> &mdash; 可供使用的紋理物件，可能是 Texture 或 CubeTexture 實體。
         
         </td></tr></table></p><p id="learnMore"><span class="label">詳細資訊</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_tw</a></div><p><span class="label">相關 API 元素</span></p><div class="seeAlso">Texture<br/>CubeTexture</div></div></span><span id="pageFilter" runtime="Flash::11##AIR::3##"><a name="setVertexBufferAt()" id="setVertexBufferAt()"></a><a name="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)" id="setVertexBufferAt(int,flash.display3D.VertexBuffer3D,int,String)"></a><table class="detailHeader" cellpadding="0" cellspacing="0"><tr><td class="detailHeaderName"><h3>setVertexBufferAt</h3></td><td class="detailHeaderParens">()</td><td class="detailHeaderType">方法</td><td class="detailHeaderRule">&nbsp;</td></tr></table><div class="detailBody"><code> public function setVertexBufferAt(index:<a href="../../int.html">int</a>, buffer:<a href="VertexBuffer3D.html">VertexBuffer3D</a>, bufferOffset:<a href="../../int.html">int</a> = 0, format:<a href="../../String.html">String</a> = "float4"):<a href="../../specialTypes.html#void">void</a></code><p></p><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>語言版本:&nbsp;</b></td><td>ActionScript 3.0</td></tr></table><table cellpadding="0" cellspacing="0" border="0"><tr><td style="white-space:nowrap" valign="top"><b>執行階段版本:&nbsp;</b></td><td>Flash Player 11, AIR 3</td></tr></table><p></p><p></p><p>
         指定對應至單一頂點著色器程式輸入的頂點資料組件。
         
         <p>使用 <code>setVertexBufferAt</code> 方法，可識別 VertexBuffer3D 緩衝區中為每個頂點定義的哪些資料組件屬於頂點程式的哪些輸入。頂點程式的開發人員可決定每個頂點需要的資料量。資料從 1 或更多的 <code>VertexBuffer3D</code> 串流，對應至頂點著色器程式的屬性暫存器。</p>
         
         <p>頂點著色器耗用的資料之最小單位為 32 位元資料。至頂點串流的偏移量是以 32 位元的倍數指定。</p>
         
         例如，程式設計人員可能會使用下列資料定義每個頂點：
<pre>
position:  x    float32
           y    float32
           z    float32
color:     r    unsigned byte
           g    unsigned byte
           b    unsigned byte
           a    unsigned byte
</pre>            
         假設在一個名為 <code>buffer</code> 的 VertexBuffer3D 物件中定義頂點，則可使用下列程式碼將它指定給頂點著色器：
<pre>
setVertexBufferAt( 0, buffer, 0, Context3DVertexBufferFormat.FLOAT_3 );   // attribute #0 will contain the position information
setVertexBufferAt( 1, buffer, 3, Context3DVertexBufferFormat.BYTES_4 );    // attribute #1 will contain the color information
</pre>
         
         
         </p><p><span class="label"> 參數 </span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20px"></td><td><code><span class="label">index</span>:<a href="../../int.html">int</a></code> &mdash; 頂點著色器中屬性暫存器的索引 (0 到 7)。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">buffer</span>:<a href="VertexBuffer3D.html">VertexBuffer3D</a></code> &mdash; 包含要饋送至頂點著色器的來源頂點資料之緩衝區。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">bufferOffset</span>:<a href="../../int.html">int</a></code> (default = <code>0</code>)<code></code> &mdash; 單一頂點的資料開頭與開始讀取此屬性的偏移值。在上述範例中，位置資料的偏移值為 0，因為它是第一個屬性；顏色的偏移值為 3，因為顏色屬性遵循 3 個 32 位元位置值。偏移值以 32 位元為單位指定。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20px"></td><td><code><span class="label">format</span>:<a href="../../String.html">String</a></code> (default = "<code>float4</code>")<code></code> &mdash; Context3DVertexBufferFormat 類別的值，可指定這個屬性的資料類型。  
         
         </td></tr></table></p><br/><span class="label">擲回值</span><table cellpadding="0" cellspacing="0" border="0"><tr><td width="20"></td><td><code><a href="../../Error.html">Error</a> </code> &mdash; 無效的列舉：格式不是 Context3DVertexBufferFormat 類別中定義的其中一個值。
         </td></tr><tr><td class="paramSpacer">&nbsp;</td></tr><tr><td width="20"></td><td><code><a href="../../RangeError.html">RangeError</a> </code> &mdash; 屬性暫存器超出範圍：<code>index</code> 參數不在 0 到 7 的範圍 (著色器最多可以使用 8 個頂點屬性暫存器)。
         
         </td></tr></table><p id="learnMore"><span class="label">詳細資訊</span></p><div class="seeAlso"><a href="http://www.adobe.com/go/learn_as3_agal_bytecode_en" target="_blank">http://www.adobe.com/go/learn_as3_agal_bytecode_tw</a></div><p><span class="label">相關 API 元素</span></p><div class="seeAlso"><a href="Context3DVertexBufferFormat.html" target="">Context3DVertexBufferFormat</a><br/><a href="Program3D.html#upload()" target="">Program3D.upload()</a></div></div></span><a name="includeExamplesSummary" id="includeExamplesSummary"></a><div class="detailSectionHeader">範例<span class="usage"><a href="http://www.adobe.com/go/learn_as3_usingexamples_tw"> 如何使用本範例 </a></span></div><span id="pageFilter"><div class="exampleHeader">Context3DExample.as</div><br/><div class="detailBody"> 下列類別會使用透視投影繪製旋轉立方體。
<div class="listing"><pre>
package
{
    import com.adobe.utils.AGALMiniAssembler;
    import com.adobe.utils.PerspectiveMatrix3D;
    
    import flash.display.Sprite;
    import flash.display.Stage3D;
    import flash.display.StageAlign;
    import flash.display.StageScaleMode;
    import flash.display3D.Context3D;
    import flash.display3D.Context3DProgramType;
    import flash.display3D.Context3DRenderMode;
    import flash.display3D.Context3DTriangleFace;
    import flash.display3D.Context3DVertexBufferFormat;
    import flash.display3D.IndexBuffer3D;
    import flash.display3D.Program3D;
    import flash.display3D.VertexBuffer3D;
    import flash.events.ErrorEvent;
    import flash.events.Event;
    import flash.geom.Matrix3D;
    import flash.geom.Vector3D;
    
    public class Context3DExample extends Sprite
    {
        public const viewWidth:Number = 320;
        public const viewHeight:Number = 200;
        public const zNear:Number = 1;
        public const zFar:Number = 500;
        
        public const fov:Number = 45;
        
        private var stage3D:Stage3D;
        private var renderContext:Context3D;
        private var indexList:IndexBuffer3D;
        private var vertexes:VertexBuffer3D;
        
        private var projection:PerspectiveMatrix3D = new PerspectiveMatrix3D();
        private var model:Matrix3D = new Matrix3D();
        private var view:Matrix3D = new Matrix3D();
        private var finalTransform:Matrix3D = new Matrix3D();
        
        //For rotating the cube
        private const pivot:Vector3D = new Vector3D();
        
        private const VERTEX_SHADER:String =
            "m44 op, va0, vc0    \n" +    // 4x4 matrix transform 
            "mov v0, va1"; //copy color to varying variable v0
        
        private const FRAGMENT_SHADER:String = 
            "mov oc, v0"; //Set the output color to the value interpolated from the three triangle vertices 

        private var vertexAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var fragmentAssembly:AGALMiniAssembler = new AGALMiniAssembler();
        private var programPair:Program3D;
        
        public function Context3DExample()
        {
            this.stage.scaleMode = StageScaleMode.NO_SCALE;
            this.stage.align = StageAlign.TOP_LEFT;
            this.stage.nativeWindow.activate(); //AIR only
                         
            stage3D = this.stage.stage3Ds[0];
            stage3D.x = 10;
            stage3D.y = 10;

            //Add event listener before requesting the context
            stage3D.addEventListener( Event.CONTEXT3D_CREATE, contextCreated );
            stage3D.addEventListener( ErrorEvent.ERROR, contextCreationError );
            stage3D.requestContext3D( Context3DRenderMode.AUTO );
            
            //Compile shaders
            vertexAssembly.assemble( Context3DProgramType.VERTEX, VERTEX_SHADER, false );
            fragmentAssembly.assemble( Context3DProgramType.FRAGMENT, FRAGMENT_SHADER, false );            
        }
        
        //Note, context3DCreate event can happen at any time, such as when the hardware resources are taken by another process
        private function contextCreated( event:Event ):void
        {
                renderContext = Stage3D( event.target ).context3D;
                trace( "3D driver: " + renderContext.driverInfo );
                setupScene();
        }
        
        private function setupScene():void
        {
            renderContext.enableErrorChecking = true; //Can slow rendering - only turn on when developing/testing
            renderContext.configureBackBuffer( viewWidth, viewHeight, 2, false );
            renderContext.setCulling( Context3DTriangleFace.BACK );
            
            //Create vertex index list for the triangles forming a cube
            var triangles:Vector.&lt;uint&gt; = Vector.&lt;uint&gt;( [ 
                2,1,0, //front face
                3,2,0,
                4,7,5, //bottom face
                7,6,5,
                8,11,9, //back face
                9,11,10,
                12,15,13, //top face
                13,15,14,
                16,19,17, //left face
                17,19,18,
                20,23,21, //right face
                21,23,22
            ] );
            indexList = renderContext.createIndexBuffer( triangles.length );
            indexList.uploadFromVector( triangles, 0, triangles.length );
            
            //Create vertexes - cube faces do not share vertexes
            const dataPerVertex:int = 6;
            var vertexData:Vector.&lt;Number&gt; = Vector.&lt;Number&gt;(
                [
                    // x,y,z r,g,b format
                    0,0,0, 1,0,0, //front face
                    0,1,0, 1,0,0,
                    1,1,0, 1,0,0,
                    1,0,0, 1,0,0,
                    
                    0,0,0, 0,1,0, //bottom face
                    1,0,0, 0,1,0,
                    1,0,1, 0,1,0,
                    0,0,1, 0,1,0,
                    
                    0,0,1, 1,0,0, //back face
                    1,0,1, 1,0,0,
                    1,1,1, 1,0,0,
                    0,1,1, 1,0,0,
                    
                    0,1,1, 0,1,0, //top face
                    1,1,1, 0,1,0,
                    1,1,0, 0,1,0,
                    0,1,0, 0,1,0,
                    
                    0,1,1, 0,0,1, //left face
                    0,1,0, 0,0,1,
                    0,0,0, 0,0,1,
                    0,0,1, 0,0,1,
                    
                    1,1,0, 0,0,1, //right face
                    1,1,1, 0,0,1,
                    1,0,1, 0,0,1,
                    1,0,0, 0,0,1
                ]
            );
            vertexes = renderContext.createVertexBuffer( vertexData.length/dataPerVertex, dataPerVertex );
            vertexes.uploadFromVector( vertexData, 0, vertexData.length/dataPerVertex );
            
            //Identify vertex data inputs for vertex program
            renderContext.setVertexBufferAt( 0, vertexes, 0, Context3DVertexBufferFormat.FLOAT_3 ); //va0 is position
            renderContext.setVertexBufferAt( 1, vertexes, 3, Context3DVertexBufferFormat.FLOAT_3 ); //va1 is color
            
            //Upload programs to render context
            programPair = renderContext.createProgram();
            programPair.upload( vertexAssembly.agalcode, fragmentAssembly.agalcode );
            renderContext.setProgram( programPair );
            
            //Set up 3D transforms
            projection.perspectiveFieldOfViewRH( fov, viewWidth/viewHeight, zNear, zFar );            
            view.appendTranslation( 0, 0, -2 );    //Move view back
            model.appendTranslation( -.5, -.5, -.5 ); //center cube on origin
            this.stage.addEventListener( Event.ENTER_FRAME, render );
        }
        
        private function render( event:Event ):void
        {
            //Rotate model on each frame
            model.appendRotation( .5, Vector3D.Z_AXIS, pivot );
            model.appendRotation( .5, Vector3D.Y_AXIS, pivot );
            model.appendRotation( .5, Vector3D.X_AXIS, pivot );
            
            //Combine transforms
            finalTransform.identity();
            finalTransform.append( model );
            finalTransform.append( view );
            finalTransform.append( projection );
            
            //Pass the final transform to the vertex shader as program constant, vc0
            renderContext.setProgramConstantsFromMatrix( Context3DProgramType.VERTEX, 0, finalTransform, true );
            
            //Clear is required before drawTriangles on each frame
            renderContext.clear( .3,.3,.3 );
            
            //Draw the 12 triangles that make up the cube
            renderContext.drawTriangles( indexList, 0, 12 );
            
            //Show the frame
            renderContext.present();
        }
        
        private function contextCreationError( error:ErrorEvent ):void
        {
            trace( error.errorID + ": " + error.text );
        }
    }
}
</pre></div></div></span><br/><br/><hr><br/><script language="javascript" type="text/javascript" xml:space="preserve">                
                                            
        				
        <!--				
          				    				
          					
          if (!isEclipse() || window.name != ECLIPSE_FRAME_NAME) {titleBar_setSubTitle(""); titleBar_setSubNav(false,true,false,false,false,false,true,false,true,true,false,false,false,false,false,false);}				    
          				        				    
          				
        -->                
                                            
        			
      </script></div><p xmlns:xd="http://www.pnp-software.com/XSLTdoc"></p><center class="copyright"> &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:47 PM Z  </center></div>
				<div class="contentfooter"><div class="separator">&nbsp;</div><p id="creativecommons" class="creativecommons"><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="external"><span class="sprite CC">&nbsp;</span></a></p><p id="cpsPromo"><a href="http://www.adobe.com/community/publishing/download.html" target="_blank" class="sprite CC_promo"></a></p><a class="legal" target="external" href="http://help.adobe.com/zh_TW/legalnotices/index.html">法律聲明</a>&nbsp;|&nbsp;<a class="privacy" href="http://www.adobe.com/misc/privacy.html" target="external">線上隱私權政策</a></div>
			</div>
		</div>
		<div class="footer">
		</div>
		<div id="whyEnglishContent">
			<div id="light" class="white_content">
				<div class="white_content_title">
					<span style="float:right"><a href="javascript:void(0)" onclick="document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none'">[ X ]</a></span><span style="float:left">為什麼顯示英文？</span>
				</div>
				<div class="white_content_body">
					<b>「ActionScript 3.0 參考」的內容是以英文顯示</b><br><br>
					並非所有「ActionScript 3.0 參考」的內容都翻譯為所有語言。當語言元素未翻譯時，就會以英文顯示。例如，ga.controls.HelpBox 類別並沒有翻譯為任何語言。因此在參考的繁體中文版本中，ga.controls.HelpBox 類別就會以英文顯示。
				</div>
			</div>
			<div id="fade" class="black_overlay"></div>
		</div>
		
		
		<script src="http://community.adobe.com/help/badge/v3/ionLoader.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionSupport.js" type="text/javascript"></script>
		<script src="http://community.adobe.com/help/badge/v3/ionBadge.js" type="text/javascript"></script>
	</body>
</html><!-- &copy; 2015 Adobe Systems Incorporated. All rights reserved. <br/>Tue Jun 12 2018, 03:47 PM Z  -->
